#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\tmp\\x64-Debug\\RGBBinding\\Unity1.cpp"
#pragma message( "C:/Users/Thomas/Code/CubeWorldC++/source/Library/RGBBinding/Array.cpp" )
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.cpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdint"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#pragma once
#line 215 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 220 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 226 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 233 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#pragma once
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
        #line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
    #line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#pragma once
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#pragma region Input Buffer SAL 1 compatibility macros
#pragma endregion Input Buffer SAL 1 compatibility macros
#line 1555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 1586 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 1611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 1624 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 1663 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 1775 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 1878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2047 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
extern "C" {
#line 2367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2595 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2634 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2868 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2878 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2883 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2890 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2891 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2898 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2899 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2911 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 2945 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
}
#line 2969 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\concurrencysal.h"
#pragma once
extern "C" {
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\concurrencysal.h"
#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\concurrencysal.h"
#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\concurrencysal.h"
#line 352 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\concurrencysal.h"
}
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\concurrencysal.h"
#line 358 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\concurrencysal.h"
#line 2971 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\sal.h"
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#pragma once
#pragma pack(push, 8)
extern "C" {
#line 20 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
        typedef unsigned __int64  uintptr_t;
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
        typedef char* va_list;
    #line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#line 111 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
    void __cdecl __va_start(va_list* , ...);
#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
} 
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };
        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };
        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };
        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } 
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vadefs.h"
#pragma pack(pop)
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
__pragma(pack(push, 8)) extern "C" {
    #line 93 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
    #line 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
    #line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 135 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 165 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 173 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 174 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;
#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
    typedef bool  __vcrt_bool;
#line 198 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 231 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
    }
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
    #line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 279 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
    void __cdecl __security_init_cookie(void);
        void __cdecl __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(  uintptr_t _StackCookie);
    #line 290 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
extern uintptr_t __security_cookie;
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
} __pragma(pack(pop))
#line 303 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;
    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    typedef bool  __crt_bool;
#line 158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 241 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
     void __cdecl _invalid_parameter(
          wchar_t const*,
          wchar_t const*,
          wchar_t const*,
                unsigned int,
                uintptr_t
        );
#line 277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
 void __cdecl _invalid_parameter_noinfo(void);
 __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);
__declspec(noreturn)
 void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);
#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 329 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
        #line 427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 481 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 489 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;
typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;
typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;
typedef __crt_locale_pointers* _locale_t;
typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;
typedef _Mbstatet mbstate_t;
#line 542 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
        typedef __time64_t time_t;
    #line 553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    typedef size_t rsize_t;
#line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 1815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 2005 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
    #line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
#line 2007 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
} __pragma(pack(pop))
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
    #line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
    #line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
    #line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
        #line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
    #line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 63 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
    #line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\crtdefs.h"
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#pragma once
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 79 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 115 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 187 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 199 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 205 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 223 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 235 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 241 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 253 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 290 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 302 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 308 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 320 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 326 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 338 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 344 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 362 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 368 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 374 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 380 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 386 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 392 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 398 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 404 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 410 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 422 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 428 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 446 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 452 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 458 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 470 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 477 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 489 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 495 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 502 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 508 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 526 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 534 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 540 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 546 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 552 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 556 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 558 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 559 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xkeycheck.h"
#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 252 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 260 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 261 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 280 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 316 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 337 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 340 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 343 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 344 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 352 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 360 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 374 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 379 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 384 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 389 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 399 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 404 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 412 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 429 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 446 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 451 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 469 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 480 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 488 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 494 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 503 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 504 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 531 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 544 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 558 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 571 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 586 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 599 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 611 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 623 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 636 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 651 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 653 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 665 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 681 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 683 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 698 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 713 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 714 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 736 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 755 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 773 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 789 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 797 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 801 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 805 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 809 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 813 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 832 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 833 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 859 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 861 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 862 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals_core.h"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new_debug.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new.h"
#pragma once
extern "C++" {
#pragma pack(push, 8)
#pragma warning(push)
#pragma warning(disable: 4985) 
namespace std
{
    enum class align_val_t : size_t {};
}
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new.h"
    namespace std
    {
        struct nothrow_t {
            explicit nothrow_t() = default;
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new.h"
        };
            extern nothrow_t const nothrow;
        #line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new.h"
    }
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new.h"
__declspec(allocator) void* __cdecl operator new(
    size_t _Size
    );
__declspec(allocator) void* __cdecl operator new(
    size_t _Size,
    std::nothrow_t const&
    ) noexcept;
__declspec(allocator) void* __cdecl operator new[](
    size_t _Size
    );
__declspec(allocator) void* __cdecl operator new[](
    size_t _Size,
    std::nothrow_t const&
    ) noexcept;
void __cdecl operator delete(
    void* _Block
    ) noexcept;
void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) noexcept;
void __cdecl operator delete[](
    void* _Block
    ) noexcept;
void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) noexcept;
void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;
void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;
__declspec(allocator) void* __cdecl operator new(
    size_t           _Size,
    std::align_val_t _Al
    );
__declspec(allocator) void* __cdecl operator new(
    size_t                _Size,
    std::align_val_t      _Al,
    std::nothrow_t const&
    ) noexcept;
__declspec(allocator) void* __cdecl operator new[](
    size_t           _Size,
    std::align_val_t _Al
    );
__declspec(allocator) void* __cdecl operator new[](
    size_t                _Size,
    std::align_val_t      _Al,
    std::nothrow_t const&
    ) noexcept;
void __cdecl operator delete(
    void*            _Block,
    std::align_val_t _Al
    ) noexcept;
void __cdecl operator delete(
    void*                 _Block,
    std::align_val_t      _Al,
    std::nothrow_t const&
    ) noexcept;
void __cdecl operator delete[](
    void*            _Block,
    std::align_val_t _Al
    ) noexcept;
void __cdecl operator delete[](
    void*                 _Block,
    std::align_val_t      _Al,
    std::nothrow_t const&
    ) noexcept;
void __cdecl operator delete(
    void*            _Block,
    size_t           _Size,
    std::align_val_t _Al
    ) noexcept;
void __cdecl operator delete[](
    void*            _Block,
    size_t           _Size,
    std::align_val_t _Al
    ) noexcept;
#line 160 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new.h"
#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 
    inline void* __cdecl operator new(size_t _Size,   void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }
    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }
#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new.h"
    inline void* __cdecl operator new[](size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }
    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new.h"
#pragma warning(pop)
#pragma warning(pop)
#pragma pack(pop)
} 
#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new.h"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new_debug.h"
extern "C++" {
#pragma pack(push, 8)
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );
    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;
    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;
#line 53 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new_debug.h"
#pragma pack(pop)
} 
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_new_debug.h"
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
__pragma(pack(push, 8)) extern "C" {
typedef void* _HFILE; 
typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);
typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);
typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);
struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;
         int*  __cdecl __p__crtDbgFlag(void);
         long* __cdecl __p__crtBreakAlloc(void);
         _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);
         _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
              _CRT_ALLOC_HOOK _PfnNewHook
            );
         _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);
         _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
              _CRT_DUMP_CLIENT _PFnNewDump
            );
    #line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
     int __cdecl _CrtCheckMemory(void);
    typedef void (__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);
     void __cdecl _CrtDoForAllClientObjects(
          _CrtDoForAllClientObjectsCallback _Callback,
          void*                             _Context
        );
     int __cdecl _CrtDumpMemoryLeaks(void);
     int __cdecl _CrtIsMemoryBlock(
           void const*  _Block,
               unsigned int _Size,
          long*        _RequestNumber,
          char**       _FileName,
          int*         _LineNumber
        );
     int __cdecl _CrtIsValidHeapPointer(
          void const* _Pointer
        );
     int __cdecl _CrtIsValidPointer(
          void const*  _Pointer,
              unsigned int _Size,
              int          _ReadWrite
        );
     void __cdecl _CrtMemCheckpoint(
          _CrtMemState* _State
        );
     int __cdecl _CrtMemDifference(
          _CrtMemState*       _State,
           _CrtMemState const* _OldState,
           _CrtMemState const* _NewState
        );
     void __cdecl _CrtMemDumpAllObjectsSince(
          _CrtMemState const* _State
        );
     void __cdecl _CrtMemDumpStatistics(
          _CrtMemState const* _State
        );
     int __cdecl _CrtReportBlockType(
          void const* _Block
        );
     long __cdecl _CrtSetBreakAlloc(
          long _NewValue
        );
     int __cdecl _CrtSetDbgFlag(
          int _NewFlag
        );
#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
     void __cdecl _aligned_free_dbg(
            void* _Block
        );
     __declspec(allocator) void* __cdecl _aligned_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
          char const* _FileName,
                int         _LineNumber
        );
     size_t __cdecl _aligned_msize_dbg(
          void*  _Block,
                   size_t _Alignment,
                   size_t _Offset
        );
     __declspec(allocator) void* __cdecl _aligned_offset_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
                size_t      _Offset,
          char const* _FileName,
                int         _LineNumber
        );
     __declspec(allocator) void* __cdecl _aligned_offset_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );
     __declspec(allocator) void* __cdecl _aligned_offset_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );
     __declspec(allocator) void* __cdecl _aligned_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );
     __declspec(allocator) void* __cdecl _aligned_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );
     __declspec(allocator) void* __cdecl _calloc_dbg(
                size_t      _Count,
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );
     __declspec(allocator) void* __cdecl _expand_dbg(
          void*       _Block,
                   size_t      _Size,
                   int         _BlockUse,
             char const* _FileName,
                   int         _LineNumber
        );
     void __cdecl _free_dbg(
            void* _Block,
                                    int   _BlockUse
        );
     __declspec(allocator) void* __cdecl _malloc_dbg(
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );
     size_t __cdecl _msize_dbg(
          void* _Block,
                   int   _BlockUse
        );
     __declspec(allocator) void* __cdecl _realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );
     __declspec(allocator) void* __cdecl _recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );
     errno_t __cdecl _dupenv_s_dbg(
          char** _PBuffer,
                               size_t*     _PBufferSizeInBytes,
                                  char const* _VarName,
                                    int          _BlockType,
                              char const* _FileName,
                                    int          _LineNumber
        );
     __declspec(allocator) char* __cdecl _fullpath_dbg(
          char*       _FullPath,
                                    char const* _Path,
                                      size_t      _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );
     __declspec(allocator) char* __cdecl _getcwd_dbg(
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );
     __declspec(allocator) char* __cdecl _getdcwd_dbg(
                                      int         _Drive,
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );
     __declspec(allocator) char* __cdecl _strdup_dbg(
          char const* _String,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );
     __declspec(allocator) char* __cdecl _tempnam_dbg(
          char const* _DirName,
          char const* _FilePrefix,
                int         _BlockType,
          char const* _FileName,
                int         _LineNumber
        );
     __declspec(allocator) wchar_t* __cdecl _wcsdup_dbg(
          wchar_t const* _String,
                int            _BlockUse,
          char const*    _FileName,
                int            _LineNumber
        );
     errno_t __cdecl _wdupenv_s_dbg(
          wchar_t** _PBuffer,
                                 size_t*         _PBufferSizeInWords,
                                    wchar_t const* _VarName,
                                      int             _BlockType,
                                char const*    _FileName,
                                      int             _LineNumber
        );
     __declspec(allocator) wchar_t* __cdecl _wfullpath_dbg(
          wchar_t*       _FullPath,
                                    wchar_t const* _Path,
                                      size_t         _SizeInWords,
                                      int            _BlockType,
                                char const*    _FileName,
                                      int            _LineNumber
        );
     __declspec(allocator) wchar_t* __cdecl _wgetcwd_dbg(
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );
     __declspec(allocator) wchar_t* __cdecl _wgetdcwd_dbg(
                                      int         _Drive,
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );
     __declspec(allocator) wchar_t* __cdecl _wtempnam_dbg(
          wchar_t const* _DirName,
          wchar_t const* _FilePrefix,
                int            _BlockType,
          char const*    _FileName,
                int            _LineNumber
        );
#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
     int __cdecl _CrtDbgReport(
                int         _ReportType,
          char const* _FileName,
                int         _Linenumber,
          char const* _ModuleName,
          char const* _Format,
        ...);
     int __cdecl _CrtDbgReportW(
                int            _ReportType,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
        ...);
     int __cdecl _VCrtDbgReportA(
                int         _ReportType,
            void*       _ReturnAddress,
          char const* _FileName,
                int         _LineNumber,
          char const* _ModuleName,
          char const* _Format,
                   va_list     _ArgList
        );
     int __cdecl _VCrtDbgReportW(
                int            _ReportType,
            void*          _ReturnAddress,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
                   va_list        _ArgList
        );
     size_t __cdecl _CrtSetDebugFillThreshold(
          size_t _NewDebugFillThreshold
        );
     size_t __cdecl _CrtGetDebugFillThreshold(void);
     _HFILE __cdecl _CrtSetReportFile(
              int    _ReportType,
          _HFILE _ReportFile
        );
     int __cdecl _CrtSetReportMode(
          int _ReportType,
          int _ReportMode
        );
        extern long _crtAssertBusy;
         _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);
         _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
              _CRT_REPORT_HOOK _PFnNewHook
            );
         int __cdecl _CrtSetReportHook2(
                  int              _Mode,
              _CRT_REPORT_HOOK _PFnNewHook
            );
         int __cdecl _CrtSetReportHookW2(
                  int               _Mode,
              _CRT_REPORT_HOOKW _PFnNewHook
            );
    #line 684 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
    #line 737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
    #line 741 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
    #line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
#line 767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
#line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
} __pragma(pack(pop))
#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 116 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 117 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1900")
#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
#line 137 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 142 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MTd_StaticDebug")
#line 148 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 149 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 150 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#pragma once
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#pragma comment(lib, "libcpmt" "d" "")
#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\use_ansi.h"
#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 214 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 219 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 229 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 230 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 252 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 257 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 259 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 277 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 279 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 289 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 290 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 298 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 299 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
namespace std {
enum _Uninitialized { 
    _Noinit
};
class  _Lockit { 
public:
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
    __thiscall _Lockit(); 
    explicit __thiscall _Lockit(int); 
    __thiscall ~_Lockit() noexcept; 
#line 349 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
    static  void __cdecl _Lockit_ctor(int);
    static  void __cdecl _Lockit_dtor(int);
private:
    static  void __cdecl _Lockit_ctor(_Lockit*);
    static  void __cdecl _Lockit_ctor(_Lockit*, int);
    static  void __cdecl _Lockit_dtor(_Lockit*);
public:
     _Lockit(const _Lockit&) = delete;
    _Lockit&  operator=(const _Lockit&) = delete;
private:
    int _Locktype;
};
#line 438 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
class  _Init_locks { 
public:
#line 451 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
    __thiscall _Init_locks();
    __thiscall ~_Init_locks() noexcept;
#line 454 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
private:
    static  void __cdecl _Init_locks_ctor(_Init_locks*);
    static  void __cdecl _Init_locks_dtor(_Init_locks*);
};
#line 481 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 483 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 507 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
}
#line 509 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#pragma warning(pop)
#pragma pack(pop)
#line 519 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 520 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\yvals.h"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdint"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdint.h"
#pragma once
typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;
typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;
typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;
typedef long long          intmax_t;
typedef unsigned long long uintmax_t;
#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdint.h"
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdint.h"
#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdint.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdint"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
using :: int8_t;
using :: int16_t;
using :: int32_t;
using :: int64_t;
using :: uint8_t;
using :: uint16_t;
using :: uint32_t;
using :: uint64_t;
using :: int_least8_t;
using :: int_least16_t;
using :: int_least32_t;
using :: int_least64_t;
using :: uint_least8_t;
using :: uint_least16_t;
using :: uint_least32_t;
using :: uint_least64_t;
using :: int_fast8_t;
using :: int_fast16_t;
using :: int_fast32_t;
using :: int_fast64_t;
using :: uint_fast8_t;
using :: uint_fast16_t;
using :: uint_fast32_t;
using :: uint_fast64_t;
using :: intmax_t;
using :: intptr_t;
using :: uintmax_t;
using :: uintptr_t;
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdint"
}
#pragma warning(pop)
#pragma pack(pop)
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdint"
#line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdint"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdlib"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\math.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
#pragma warning(push)
#pragma warning(disable:4738) 
#pragma warning(disable:4820) 
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };
        struct _complex
        {
            double x, y; 
        };
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
    #line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
        extern double const _HUGE;
#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
void __cdecl _fperrraise(  int _Except);
   short __cdecl _dclass(  double _X);
   short __cdecl _ldclass(  long double _X);
   short __cdecl _fdclass(  float _X);
   int __cdecl _dsign(  double _X);
   int __cdecl _ldsign(  long double _X);
   int __cdecl _fdsign(  float _X);
   int __cdecl _dpcomp(  double _X,   double _Y);
   int __cdecl _ldpcomp(  long double _X,   long double _Y);
   int __cdecl _fdpcomp(  float _X,   float _Y);
   short __cdecl _dtest(  double* _Px);
   short __cdecl _ldtest(  long double* _Px);
   short __cdecl _fdtest(  float* _Px);
 short __cdecl _d_int(  double* _Px,   short _Xexp);
 short __cdecl _ld_int(  long double* _Px,   short _Xexp);
 short __cdecl _fd_int(  float* _Px,   short _Xexp);
 short __cdecl _dscale(  double* _Px,   long _Lexp);
 short __cdecl _ldscale(  long double* _Px,   long _Lexp);
 short __cdecl _fdscale(  float* _Px,   long _Lexp);
 short __cdecl _dunscale(  short* _Pex,   double* _Px);
 short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
 short __cdecl _fdunscale(  short* _Pex,   float* _Px);
   short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
   short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
   short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);
   short __cdecl _dnorm(  unsigned short* _Ps);
   short __cdecl _fdnorm(  unsigned short* _Ps);
   double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
   long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
   float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);
   double __cdecl _dlog(  double _X,   int _Baseflag);
   long double __cdecl _ldlog(  long double _X,   int _Baseflag);
   float __cdecl _fdlog(  float _X,   int _Baseflag);
   double __cdecl _dsin(  double _X,   unsigned int _Qoff);
   long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
   float __cdecl _fdsin(  float _X,   unsigned int _Qoff);
typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;
typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;
typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;
typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;
extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;
extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;
extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;
extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }
      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }
      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }
      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }
      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }
      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }
      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }
      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }
      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }
    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };
    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };
    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };
    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };
    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };
    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };
    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };
    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };
    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };
    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };
    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };
    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }
    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }
    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }
    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }
    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }
    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }
    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }
    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }
    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }
    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }
    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 461 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);
      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);
      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);
       double    __cdecl acosh(  double _X);
       double    __cdecl asinh(  double _X);
       double    __cdecl atanh(  double _X);
        double    __cdecl atof(  char const* _String);
        double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
       double    __cdecl _cabs(  struct _complex _Complex_value);
       double    __cdecl cbrt(  double _X);
       double    __cdecl ceil(  double _X);
       double    __cdecl _chgsign(  double _X);
       double    __cdecl copysign(  double _Number,   double _Sign);
       double    __cdecl _copysign(  double _Number,   double _Sign);
       double    __cdecl erf(  double _X);
       double    __cdecl erfc(  double _X);
       double    __cdecl exp2(  double _X);
       double    __cdecl expm1(  double _X);
       double    __cdecl fdim(  double _X,   double _Y);
       double    __cdecl floor(  double _X);
       double    __cdecl fma(  double _X,   double _Y,   double _Z);
       double    __cdecl fmax(  double _X,   double _Y);
       double    __cdecl fmin(  double _X,   double _Y);
       double    __cdecl frexp(  double _X,   int* _Y);
       double    __cdecl hypot(  double _X,   double _Y);
       double    __cdecl _hypot(  double _X,   double _Y);
       int       __cdecl ilogb(  double _X);
       double    __cdecl ldexp(  double _X,   int _Y);
       double    __cdecl lgamma(  double _X);
       long long __cdecl llrint(  double _X);
       long long __cdecl llround(  double _X);
       double    __cdecl log1p(  double _X);
       double    __cdecl log2(  double _X);
       double    __cdecl logb(  double _X);
       long      __cdecl lrint(  double _X);
       long      __cdecl lround(  double _X);
    int __cdecl _matherr(  struct _exception* _Except);
       double __cdecl modf(  double _X,   double* _Y);
       double __cdecl nan(  char const* _X);
       double __cdecl nearbyint(  double _X);
       double __cdecl nextafter(  double _X,   double _Y);
       double __cdecl nexttoward(  double _X,   long double _Y);
       double __cdecl remainder(  double _X,   double _Y);
       double __cdecl remquo(  double _X,   double _Y,   int* _Z);
       double __cdecl rint(  double _X);
       double __cdecl round(  double _X);
       double __cdecl scalbln(  double _X,   long _Y);
       double __cdecl scalbn(  double _X,   int _Y);
       double __cdecl tgamma(  double _X);
       double __cdecl trunc(  double _X);
       double __cdecl _j0(  double _X );
       double __cdecl _j1(  double _X );
       double __cdecl _jn(int _X,   double _Y);
       double __cdecl _y0(  double _X);
       double __cdecl _y1(  double _X);
       double __cdecl _yn(  int _X,   double _Y);
       float     __cdecl acoshf(  float _X);
       float     __cdecl asinhf(  float _X);
       float     __cdecl atanhf(  float _X);
       float     __cdecl cbrtf(  float _X);
       float     __cdecl _chgsignf(  float _X);
       float     __cdecl copysignf(  float _Number,   float _Sign);
       float     __cdecl _copysignf(  float _Number,   float _Sign);
       float     __cdecl erff(  float _X);
       float     __cdecl erfcf(  float _X);
       float     __cdecl expm1f(  float _X);
       float     __cdecl exp2f(  float _X);
       float     __cdecl fdimf(  float _X,   float _Y);
       float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
       float     __cdecl fmaxf(  float _X,   float _Y);
       float     __cdecl fminf(  float _X,   float _Y);
       float     __cdecl _hypotf(  float _X,   float _Y);
       int       __cdecl ilogbf(  float _X);
       float     __cdecl lgammaf(  float _X);
       long long __cdecl llrintf(  float _X);
       long long __cdecl llroundf(  float _X);
       float     __cdecl log1pf(  float _X);
       float     __cdecl log2f(  float _X);
       float     __cdecl logbf(  float _X);
       long      __cdecl lrintf(  float _X);
       long      __cdecl lroundf(  float _X);
       float     __cdecl nanf(  char const* _X);
       float     __cdecl nearbyintf(  float _X);
       float     __cdecl nextafterf(  float _X,   float _Y);
       float     __cdecl nexttowardf(  float _X,   long double _Y);
       float     __cdecl remainderf(  float _X,   float _Y);
       float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
       float     __cdecl rintf(  float _X);
       float     __cdecl roundf(  float _X);
       float     __cdecl scalblnf(  float _X,   long _Y);
       float     __cdecl scalbnf(  float _X,   int _Y);
       float     __cdecl tgammaf(  float _X);
       float     __cdecl truncf(  float _X);
#line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
           float __cdecl _logbf(  float _X);
           float __cdecl _nextafterf(  float _X,   float _Y);
           int   __cdecl _finitef(  float _X);
           int   __cdecl _isnanf(  float _X);
           int   __cdecl _fpclassf(  float _X);
           int   __cdecl _set_FMA3_enable(  int _Flag);
           int   __cdecl _get_FMA3_enable(void);
#line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
           float __cdecl acosf(  float _X);
           float __cdecl asinf(  float _X);
           float __cdecl atan2f(  float _Y,   float _X);
           float __cdecl atanf(  float _X);
           float __cdecl ceilf(  float _X);
           float __cdecl cosf(  float _X);
           float __cdecl coshf(  float _X);
           float __cdecl expf(  float _X);
#line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 669 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }
    #line 676 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
           float __cdecl floorf(  float _X);
           float __cdecl fmodf(  float _X,   float _Y);
#line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }
      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }
      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }
           float  __cdecl log10f(  float _X);
           float  __cdecl logf(  float _X);
           float  __cdecl modff(  float _X,   float *_Y);
           float  __cdecl powf(  float _X,   float _Y);
           float  __cdecl sinf(  float _X);
           float  __cdecl sinhf(  float _X);
           float  __cdecl sqrtf(  float _X);
           float  __cdecl tanf(  float _X);
           float  __cdecl tanhf(  float _X);
#line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
       long double __cdecl acoshl(  long double _X);
      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }
       long double __cdecl asinhl(  long double _X);
      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }
      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }
       long double __cdecl atanhl(  long double _X);
      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }
       long double __cdecl cbrtl(  long double _X);
      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }
      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }
       long double __cdecl copysignl(  long double _Number,   long double _Sign);
      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }
      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }
      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }
       long double __cdecl erfl(  long double _X);
       long double __cdecl erfcl(  long double _X);
      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }
       long double __cdecl exp2l(  long double _X);
       long double __cdecl expm1l(  long double _X);
      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }
       long double __cdecl fdiml(  long double _X,   long double _Y);
      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }
       long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
       long double __cdecl fmaxl(  long double _X,   long double _Y);
       long double __cdecl fminl(  long double _X,   long double _Y);
      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }
      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }
       int __cdecl ilogbl(  long double _X);
      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }
      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }
      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }
       long double __cdecl lgammal(  long double _X);
       long long __cdecl llrintl(  long double _X);
       long long __cdecl llroundl(  long double _X);
      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }
      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }
       long double __cdecl log1pl(  long double _X);
       long double __cdecl log2l(  long double _X);
       long double __cdecl logbl(  long double _X);
       long __cdecl lrintl(  long double _X);
       long __cdecl lroundl(  long double _X);
      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }
       long double __cdecl nanl(  char const* _X);
       long double __cdecl nearbyintl(  long double _X);
       long double __cdecl nextafterl(  long double _X,   long double _Y);
       long double __cdecl nexttowardl(  long double _X,   long double _Y);
      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }
       long double __cdecl remainderl(  long double _X,   long double _Y);
       long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
       long double __cdecl rintl(  long double _X);
       long double __cdecl roundl(  long double _X);
       long double __cdecl scalblnl(  long double _X,   long _Y);
       long double __cdecl scalbnl(  long double _X,   int _Y);
      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }
      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }
      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }
      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }
      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }
       long double __cdecl tgammal(  long double _X);
       long double __cdecl truncl(  long double _X);
#line 962 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
            extern double HUGE;
#line 980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))    double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))    double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))    double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))    double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))    double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))    double __cdecl yn(  int _X,   double _Y);
    #line 988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 990 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#pragma warning(pop)
} __pragma(pack(pop))
#line 996 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\math.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdlib"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_malloc.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_malloc.h"
 __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );
  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
       size_t _Count,
       size_t _Size
    );
 int __cdecl _callnewh(
      size_t _Size
    );
 __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
       size_t _Size
    );
void __cdecl _free_base(
        void* _Block
    );
void __cdecl free(
        void* _Block
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );
 __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
       size_t _Size
    );
size_t __cdecl _msize_base(
      void* _Block
    );
size_t __cdecl _msize(
      void* _Block
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );
 __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
              size_t _Size
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size
    );
void __cdecl _aligned_free(
        void* _Block
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
       size_t _Size,
                         size_t _Alignment
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
       size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );
size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment
    );
 __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment
    );
#line 225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_malloc.h"
} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }
    using ::std::nullptr_t;
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
     int* __cdecl _errno(void);
     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
 extern unsigned long  __cdecl __threadid(void);
 extern uintptr_t __cdecl __threadhandle(void);
} __pragma(pack(pop))
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
__pragma(pack(push, 8)) extern "C" {
    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);
     void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );
     void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );
#line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
 void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );
 void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );
 void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );
 void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );
 void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );
 void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
     void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
     void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
} __pragma(pack(pop))
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
     errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );
    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
     errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );
    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
     errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );
    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
     double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );
     double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );
     long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );
     long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );
     long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );
     long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );
     unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );
     unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );
     unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );
     unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );
     long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );
     long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );
     float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );
     float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );
     double __cdecl _wtof(
          wchar_t const* _String
        );
     double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );
     int __cdecl _wtoi(
          wchar_t const* _String
        );
     int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );
     long __cdecl _wtol(
          wchar_t const* _String
        );
     long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );
     long long __cdecl _wtoll(
          wchar_t const* _String
        );
     long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );
     errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );
     errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );
     __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );
     __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );
     __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );
     __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );
     unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );
     unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );
     __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );
     errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );
    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(pop)
     void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );
     errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );
    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
         errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );
          __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
         wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );
         errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );
        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
         int __cdecl _wputenv(
              wchar_t const* _EnvString
            );
         errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );
         errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );
        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
         int __cdecl _wsystem(
              wchar_t const* _Command
            );
#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
} __pragma(pack(pop))
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits.h"
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits.h"
    #line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits.h"
#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits.h"
} __pragma(pack(pop))
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__pragma(pack(push, 8)) extern "C" {
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );
     __declspec(noreturn) void __cdecl exit(  int _Code);
     __declspec(noreturn) void __cdecl _exit(  int _Code);
     __declspec(noreturn) void __cdecl _Exit(  int _Code);
     __declspec(noreturn) void __cdecl quick_exit(  int _Code);
     __declspec(noreturn) void __cdecl abort(void);
#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );
    typedef int (__cdecl* _onexit_t)(void);
#line 78 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
int __cdecl at_quick_exit(void (__cdecl*)(void));
    typedef void (__cdecl* _purecall_handler)(void);
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );
     _purecall_handler __cdecl _get_purecall_handler(void);
     _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );
     _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
     _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );
     _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
  int __cdecl _set_error_mode(  int _Mode);
     int* __cdecl _errno(void);
     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);
     unsigned long* __cdecl __doserrno(void);
     errno_t __cdecl _set_doserrno(  unsigned long _Value);
     errno_t __cdecl _get_doserrno(  unsigned long * _Value);
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);
     void __cdecl perror(  char const* _ErrMsg);
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  int*      __cdecl __p__fmode  (void);
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 errno_t __cdecl _get_pgmptr (  char**    _Value);
 errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);
 errno_t __cdecl _set_fmode  (               int       _Mode );
 errno_t __cdecl _get_fmode  (              int*      _PMode);
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;
typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;
typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;
  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);
  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);
   div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
   ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
   lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);
#pragma warning (push)
#pragma warning (disable:6540)
unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );
unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );
unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );
unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );
#pragma warning (pop)
 void __cdecl srand(  unsigned int _Seed);
   int __cdecl rand(void);
#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }
    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }
    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }
    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
typedef struct
{
    double x;
} _CRT_DOUBLE;
typedef struct
{
    float f;
} _CRT_FLOAT;
typedef struct
{
    long double x;
} _LONGDOUBLE;
#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)
                      double    __cdecl atof   (  char const* _String);
    int       __cdecl atoi   (  char const* _String);
                      long      __cdecl atol   (  char const* _String);
                      long long __cdecl atoll  (  char const* _String);
                      __int64   __cdecl _atoi64(  char const* _String);
   double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
   int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
   long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
   long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
   __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);
   int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
   int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
   int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);
 int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );
 int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );
 int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );
 float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );
 float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );
 double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );
 double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );
 long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );
 long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );
 long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );
 long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );
 long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );
 long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );
 unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );
 unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );
 unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );
 unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );
 __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );
 __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );
 unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );
 unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );
 errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );
extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(pop)
 errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(pop)
 errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );
 errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );
 errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );
 errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );
extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );
 errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );
extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );
#line 836 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
    #line 838 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
    #line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
     int __cdecl ___mb_cur_max_func(void);
     int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );
 int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );
 size_t __cdecl _mbstrlen(
      char const* _String
    );
 size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );
 size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );
 size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );
 int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );
 int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );
 errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 952 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 961 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );
     errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );
#line 989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);
 errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1014 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1021 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1049 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );
 errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1097 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(pop)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );
 errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
 errno_t __cdecl getenv_s(
                                 size_t*     _RequiredCount,
      char*       _Buffer,
                                  rsize_t     _BufferCount,
                                char const* _VarName
    );
#line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 int*       __cdecl __p___argc (void);
 char***    __cdecl __p___argv (void);
 wchar_t*** __cdecl __p___wargv(void);
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
 char***    __cdecl __p__environ (void);
 wchar_t*** __cdecl __p__wenviron(void);
#line 1171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 1181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl getenv(
          char const* _VarName
        );
    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
     errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );
#line 1217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
     int __cdecl system(
          char const* _Command
        );
    #pragma warning (push)
    #pragma warning (disable:6540)
     int __cdecl _putenv(
          char const* _EnvString
        );
     errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );
    #pragma warning (pop)
     errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );
    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1260 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
     void __cdecl _seterrormode(
          int _Mode
        );
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
     void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
     void __cdecl _sleep(
          unsigned long _Duration
        );
#line 1279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
    #pragma warning(push)
    #pragma warning(disable: 4141) 
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
     void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
     int __cdecl putenv(
          char const* _EnvString
        );
    #pragma warning(pop)
    _onexit_t __cdecl onexit(  _onexit_t _Func);
#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
} __pragma(pack(pop))
#line 1368 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdlib"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
  inline double abs(  double _Xx) noexcept {
    return :: fabs(_Xx);
}
  inline float abs(  float _Xx) noexcept {
    return :: fabsf(_Xx);
}
  inline long double abs(  long double _Xx) noexcept {
    return :: fabsl(_Xx);
}
namespace std {
using :: size_t;
using :: div_t;
using :: ldiv_t;
using :: abort;
using :: abs;
using :: atexit;
using :: atof;
using :: atoi;
using :: atol;
using :: bsearch;
using :: calloc;
using :: div;
using :: exit;
using :: free;
using :: labs;
using :: ldiv;
using :: malloc;
using :: mblen;
using :: mbstowcs;
using :: mbtowc;
using :: qsort;
using :: rand;
using :: realloc;
using :: srand;
using :: strtod;
using :: strtol;
using :: strtoul;
using :: wcstombs;
using :: wctomb;
using :: lldiv_t;
using :: getenv;
using :: system;
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdlib"
using :: atoll;
using :: llabs;
using :: lldiv;
using :: strtof;
using :: strtold;
using :: strtoll;
using :: strtoull;
using :: _Exit;
using :: at_quick_exit;
using :: quick_exit;
}
#pragma warning(pop)
#pragma pack(pop)
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdlib"
#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdlib"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cfloat"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
        #line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
    #line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
#line 212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
 unsigned int __cdecl _clearfp(void);
#pragma warning(push)
#pragma warning(disable: 4141)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );
#pragma warning(pop)
 void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );
 errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );
 unsigned int __cdecl _statusfp(void);
 void __cdecl _fpreset(void);
 unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );
 int* __cdecl __fpecode(void);
 int __cdecl __fpe_flt_rounds(void);
   double __cdecl _copysign(  double _Number,   double _Sign);
   double __cdecl _chgsign(  double _X);
   double __cdecl _scalb(  double _X,   long _Y);
   double __cdecl _logb(  double _X);
   double __cdecl _nextafter(  double _X,   double _Y);
   int    __cdecl _finite(  double _X);
   int    __cdecl _isnan(  double _X);
   int    __cdecl _fpclass(  double _X);
       float __cdecl _scalbf(  float _X,   long _Y);
#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
     void __cdecl fpreset(void);
#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
} __pragma(pack(pop))
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cfloat"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cfloat"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\climits"
#pragma once
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\climits"
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\climits"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cwchar"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdio"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 22 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 58 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 70 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
    #line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__pragma(pack(push, 8)) extern "C" {
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
 FILE* __cdecl __acrt_iob_func(unsigned _Ix);
     wint_t __cdecl fgetwc(
          FILE* _Stream
        );
     wint_t __cdecl _fgetwchar(void);
     wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);
     wint_t __cdecl _fputwchar(
          wchar_t _Character
        );
     wint_t __cdecl getwc(
          FILE* _Stream
        );
     wint_t __cdecl getwchar(void);
     wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );
     int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );
     wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );
    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );
     wint_t __cdecl putwchar(
          wchar_t _Character
        );
     int __cdecl _putws(
          wchar_t const* _Buffer
        );
     wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );
     FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );
     errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );
     errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );
     FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );
     void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );
         FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );
    #line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     int __cdecl _wremove(
          wchar_t const* _FileName
        );
     __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );
     errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );
    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );
     wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );
     wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );
     wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );
     wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 385 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 412 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 457 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 489 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
#line 537 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 548 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
#line 576 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
#line 611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 620 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 694 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 726 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
#line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
#line 769 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 773 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
#line 784 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 788 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 815 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
#line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 830 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
#line 842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 851 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
#line 879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 888 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
#line 936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
#line 973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 982 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 984 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
#line 1058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #pragma warning(push)
    #pragma warning(disable: 4793)
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #pragma warning(pop)
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
#line 1131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
#line 1160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
#line 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
#line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
#line 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
#line 1247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
#line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
#line 1285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
#line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
#line 1332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 1365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    #line 1369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 1413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
#line 1434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
#line 1453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1482 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #pragma warning(push)
    #pragma warning(disable:4793 4996)
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1496 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1503 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #pragma warning(pop)
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
#line 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
#line 1538 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 1549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1556 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
#line 1568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
#line 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
#line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1618 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
#line 1629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
#line 1650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
#line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1740 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 1749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
#line 1767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 1786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
#line 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        #pragma warning(push)
        #pragma warning(disable: 4141 4412 4793 4996 6054)
            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
                #pragma warning(suppress: 28719)
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }
            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                #pragma warning(suppress: 28719)
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }
            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }
            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }
        #line 1874 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        #pragma warning(pop)
    #line 1877 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#line 1884 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1918 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
#line 1929 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 1933 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
#line 1945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1951 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
#line 1964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 1968 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1978 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
#line 1991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
#line 2010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 2016 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
#line 2027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2036 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
#line 2046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2055 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
#line 2087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2096 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    #line 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
#line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
#line 2135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2149 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
#line 2161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
#line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
} __pragma(pack(pop))
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__pragma(pack(push, 8)) extern "C" {
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
typedef __int64 fpos_t;
     errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );
         errno_t __cdecl clearerr_s(
              FILE* _Stream
            );
         errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode
            );
         size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );
         errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );
         char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );
         errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );
         errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );
    #line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     void __cdecl clearerr(
          FILE* _Stream
        );
     int __cdecl fclose(
          FILE* _Stream
        );
     int __cdecl _fcloseall(void);
     FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );
     int __cdecl feof(
          FILE* _Stream
        );
     int __cdecl ferror(
          FILE* _Stream
        );
     int __cdecl fflush(
          FILE* _Stream
        );
     int __cdecl fgetc(
          FILE* _Stream
        );
     int __cdecl _fgetchar(void);
     int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );
     char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );
     int __cdecl _fileno(
          FILE* _Stream
        );
     int __cdecl _flushall(void);
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );
     int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );
     int __cdecl _fputchar(
          int _Character
        );
     int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );
     size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );
     FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );
     int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );
     int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );
     int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );
     long __cdecl ftell(
          FILE* _Stream
        );
     __int64 __cdecl _ftelli64(
          FILE* _Stream
        );
     size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );
     int __cdecl getc(
          FILE* _Stream
        );
     int __cdecl getchar(void);
     int __cdecl _getmaxstdio(void);
    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     int __cdecl _getw(
          FILE* _Stream
        );
     void __cdecl perror(
          char const* _ErrorMessage
        );
         int __cdecl _pclose(
              FILE* _Stream
            );
         FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );
    #line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );
     int __cdecl putchar(
          int _Character
        );
     int __cdecl puts(
          char const* _Buffer
        );
     int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );
     int __cdecl remove(
          char const* _FileName
        );
     int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );
     int __cdecl _unlink(
          char const* _FileName
        );
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
         int __cdecl unlink(
              char const* _FileName
            );
    #line 386 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     void __cdecl rewind(
          FILE* _Stream
        );
     int __cdecl _rmtmp(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );
     int __cdecl _setmaxstdio(
          int _Maximum
        );
     int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );
#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
     FILE* __cdecl tmpfile(void);
    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   char* __cdecl tmpnam(  char *_Buffer);
#line 445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(pop)
     int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );
     void __cdecl _lock_file(
          FILE* _Stream
        );
     void __cdecl _unlock_file(
          FILE* _Stream
        );
     int __cdecl _fclose_nolock(
          FILE* _Stream
        );
     int __cdecl _fflush_nolock(
          FILE* _Stream
        );
     int __cdecl _fgetc_nolock(
          FILE* _Stream
        );
     int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );
     size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );
     size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );
     int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );
     int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );
     long __cdecl _ftell_nolock(
          FILE* _Stream
        );
     __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );
     size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );
     int __cdecl _getc_nolock(
          FILE* _Stream
        );
     int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );
     int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );
#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     int* __cdecl __p__commode(void);
    #line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#line 601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
#line 656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 691 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
#line 704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
#line 718 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
#line 732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
#line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
#line 759 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 763 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
#line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 794 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
#line 803 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 807 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
#line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 844 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     int __cdecl _set_printf_count_output(
          int _Value
        );
     int __cdecl _get_printf_count_output(void);
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 869 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
#line 880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 889 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 910 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 928 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 937 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 946 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 963 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 972 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 981 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
#line 991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 1011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
#line 1028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
#line 1062 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1068 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
#line 1078 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 1082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
#line 1093 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1099 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
#line 1112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 1116 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
#line 1128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
#line 1141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 1145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
#line 1170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
#line 1186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
#line 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
#line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
#line 1263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
#line 1280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
#line 1298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1307 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
#line 1317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
#line 1389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
#line 1409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1416 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#line 1427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
#line 1439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
#line 1459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
#line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1484 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
#line 1519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1531 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 1533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
#line 1546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1554 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
#line 1566 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
#line 1584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
#line 1605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1618 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
#line 1633 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    #line 1637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 1648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
#line 1658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1666 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    #line 1679 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
#line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
#line 1706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
#line 1722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        return _Result < 0 ? -1 : _Result;
    }
    #line 1730 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
#line 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 1757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        #pragma warning(pop)
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
#line 1781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
        #pragma warning(pop)
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1795 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #pragma warning(push)
    #pragma warning(disable: 4996)
    #pragma warning(disable: 28719) 
    #pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1806 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #pragma warning(pop)
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
#line 1819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1850 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 1852 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1859 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
#line 1871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1900 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1926 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#line 1937 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
#line 1948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    #pragma warning(suppress:28719)    
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
#line 1969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    #pragma warning(suppress:28719)    
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1979 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 2000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2009 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
#line 2020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2029 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
#line 2042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2051 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
#line 2063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2072 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 2080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
#line 2106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
#line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
#line 2141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
#line 2175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
#line 2191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 2195 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
#line 2206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        #pragma warning(push)
        #pragma warning(disable:6530)
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
#line 2227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 2231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        #pragma warning(pop)
    #line 2242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
#line 2252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
#line 2270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
#line 2289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
#line 2309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            #pragma warning(push)
            #pragma warning(disable: 4996) 
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
            #pragma warning(pop)
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #line 2325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #pragma warning(push)
    #pragma warning(disable:6530)
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
#line 2339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
#line 2362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2375 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
#line 2387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
#line 2410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
    #pragma warning(pop)
#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#line 2445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
         char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );
#line 2455 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details."))  int   __cdecl fcloseall(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))     FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))   int   __cdecl fgetchar(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))     int   __cdecl fileno(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))   int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))   int   __cdecl fputchar(  int _Ch);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))       int   __cdecl getw(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))       int   __cdecl putw(  int _Ch,   FILE* _Stream);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))      int   __cdecl rmtmp(void);
    #line 2467 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#line 2468 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
} __pragma(pack(pop))
#line 2473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdio"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 
using :: FILE;
using :: _Mbstatet;
using :: size_t;
using :: fpos_t;
using :: FILE;
using :: clearerr;
using :: fclose;
using :: feof;
using :: ferror;
using :: fflush;
using :: fgetc;
using :: fgetpos;
using :: fgets;
using :: fopen;
using :: fprintf;
using :: fputc;
using :: fputs;
using :: fread;
using :: freopen;
using :: fscanf;
using :: fseek;
using :: fsetpos;
using :: ftell;
using :: fwrite;
using :: getc;
using :: getchar;
using :: perror;
using :: putc;
using :: putchar;
using :: printf;
using :: puts;
using :: remove;
using :: rename;
using :: rewind;
using :: scanf;
using :: setbuf;
using :: setvbuf;
using :: sprintf;
using :: sscanf;
using :: tmpfile;
using :: tmpnam;
using :: ungetc;
using :: vfprintf;
using :: vprintf;
using :: vsprintf;
using :: snprintf;
using :: vsnprintf;
using :: vfscanf;
using :: vscanf;
using :: vsscanf;
#pragma warning(pop)
}
#pragma warning(pop)
#pragma pack(pop)
#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdio"
#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstdio"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cwchar"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
     int* __cdecl _errno(void);
     errno_t __cdecl _set_errno(  int _Value);
     errno_t __cdecl _get_errno(  int* _Value);
     unsigned long* __cdecl __doserrno(void);
     errno_t __cdecl _set_doserrno(  unsigned long _Value);
     errno_t __cdecl _get_doserrno(  unsigned long * _Value);
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"
} __pragma(pack(pop))
#line 132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_string.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
 void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );
 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );
 char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );
 char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );
 char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );
 wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );
 wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );
 wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );
} __pragma(pack(pop))
#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_string.h"
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"
__pragma(pack(push, 8)) extern "C" {
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }
        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);
            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };
            return 22;
        }
#pragma warning(suppress:4996) 
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }
        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };
#pragma warning(suppress:4996) 
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }
#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"
} __pragma(pack(pop))
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
     errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );
    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
     int __cdecl _cputws(
          wchar_t const* _Buffer
        );
           wint_t __cdecl _getwch  (void);
           wint_t __cdecl _getwche (void);
      wint_t __cdecl _putwch  (  wchar_t _Character);
      wint_t __cdecl _ungetwch(  wint_t  _Character);
           wint_t __cdecl _getwch_nolock  (void);
           wint_t __cdecl _getwche_nolock (void);
      wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
      wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);
     int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
     int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)
#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)
#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 235 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
     int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )
#line 310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
    }
#line 317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )
#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 369 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)
#line 377 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)
#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
} __pragma(pack(pop))
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
    #line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
     const unsigned short* __cdecl __pctype_func(void);
     const wctype_t*       __cdecl __pwctype_func(void);
    #line 41 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
   int __cdecl iswalnum  (  wint_t _C);
   int __cdecl iswalpha  (  wint_t _C);
   int __cdecl iswascii  (  wint_t _C);
   int __cdecl iswblank  (  wint_t _C);
   int __cdecl iswcntrl  (  wint_t _C);
   int __cdecl iswdigit  (  wint_t _C);
   int __cdecl iswgraph  (  wint_t _C);
   int __cdecl iswlower  (  wint_t _C);
   int __cdecl iswprint  (  wint_t _C);
   int __cdecl iswpunct  (  wint_t _C);
   int __cdecl iswspace  (  wint_t _C);
   int __cdecl iswupper  (  wint_t _C);
   int __cdecl iswxdigit (  wint_t _C);
   int __cdecl __iswcsymf(  wint_t _C);
   int __cdecl __iswcsym (  wint_t _C);
   int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
   int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);
   wint_t __cdecl towupper(  wint_t _C);
   wint_t __cdecl towlower(  wint_t _C);
   int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);
   wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
   wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
   int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);
       int __cdecl isleadbyte(  int _C);
       int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details."))  int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
#line 196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
} __pragma(pack(pop))
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wdirect.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
 __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );
 __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );
 int __cdecl _wchdir(
      wchar_t const* _Path
    );
 int __cdecl _wmkdir(
      wchar_t const* _Path
    );
 int __cdecl _wrmdir(
      wchar_t const* _Path
    );
} __pragma(pack(pop))
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_share.h"
#pragma once
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_share.h"
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
__pragma(pack(push, 8)) extern "C" {
#pragma warning(push)
#pragma warning(disable:4820) 
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
typedef unsigned long _fsize_t;
struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};
struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};
struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};
struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
 int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );
 errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );
 int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );
 intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );
 int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );
 int __cdecl _wunlink(
      wchar_t const* _FileName
    );
 int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );
 errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
 intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );
 intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );
 intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );
 int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );
 int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );
 int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );
 errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );
 errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
#pragma warning(pop)
} __pragma(pack(pop))
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wprocess.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
         intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);
         intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);
         intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);
         intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);
         intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );
         intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );
         intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );
         intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );
         intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);
         intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);
         intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);
         intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);
         intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );
         intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );
         intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );
         intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );
         int __cdecl _wsystem(
              wchar_t const* _Command
            );
    #line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wprocess.h"
#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wprocess.h"
} __pragma(pack(pop))
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
     errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );
     errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );
     errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );
     errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );
     wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );
#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
 size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );
 size_t __cdecl wcslen(
      wchar_t const* _String
    );
#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );
#line 162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#line 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }
#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );
 size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
    #line 242 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 
    #pragma warning(disable: 28719 28726 28727) 
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }
#line 258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
    #pragma warning(pop)
#line 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );
 errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 294 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );
  errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
   int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );
   int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );
   int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );
   int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );
  errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );
  errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 375 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
  errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 392 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
 size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );
 size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );
 int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );
 int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );
 int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );
 int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );
 int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );
 int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );
 int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );
 int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );
extern "C++" {
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }
}
#line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#line 578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
     wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );
#line 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
     int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
     int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
     int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );
#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
} __pragma(pack(pop))
#line 650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );
 errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );
extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
 size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );
 size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );
 errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );
 errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
 errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
 errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
    #pragma warning(push)
    #pragma warning(disable: 4996)
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }
    #line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
    #pragma warning(pop)
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
} __pragma(pack(pop))
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
#pragma once
    typedef unsigned short _ino_t; 
        typedef _ino_t ino_t;
    #line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
    typedef unsigned int _dev_t; 
        typedef _dev_t dev_t;
    #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
    typedef long _off_t; 
        typedef _off_t off_t;
    #line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
__pragma(pack(push, 8)) extern "C" {
#pragma warning(push)
#pragma warning(disable: 4820) 
struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};
struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};
struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};
struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};
    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
 int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );
 int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );
 int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );
 int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );
 int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );
 int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );
 int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );
 int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );
 int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );
 int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );
 int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );
 int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );
        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }
    #line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
#pragma warning(pop)
} __pragma(pack(pop))
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
__pragma(pack(push, 8)) extern "C" {
typedef wchar_t _Wint_t;
     wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );
     _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );
     wint_t __cdecl btowc(
          int _Ch
        );
     size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );
     size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );
     errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );
    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
     errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );
    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
     errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );
    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
     int __cdecl wctob(
          wint_t _WCh
        );
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );
    #line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }
    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }
    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;
        return 0;
    }
    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;
        return 0;
    }
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }
    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }
        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }
    #line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
} __pragma(pack(pop))
#line 286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cwchar"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
using _Mbstatet = mbstate_t;
namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 
using :: _Mbstatet;
using :: mbstate_t;
using :: size_t;
using :: tm;
using :: wint_t;
using :: btowc;
using :: fgetwc;
using :: fgetws;
using :: fputwc;
using :: fputws;
using :: fwide;
using :: fwprintf;
using :: fwscanf;
using :: getwc;
using :: getwchar;
using :: mbrlen;
using :: mbrtowc;
using :: mbsrtowcs;
using :: mbsinit;
using :: putwc;
using :: putwchar;
using :: swprintf;
using :: swscanf;
using :: ungetwc;
using :: vfwprintf;
using :: vswprintf;
using :: vwprintf;
using :: wcrtomb;
using :: wprintf;
using :: wscanf;
using :: wcsrtombs;
using :: wcstol;
using :: wcscat;
using :: wcschr;
using :: wcscmp;
using :: wcscoll;
using :: wcscpy;
using :: wcscspn;
using :: wcslen;
using :: wcsncat;
using :: wcsncmp;
using :: wcsncpy;
using :: wcspbrk;
using :: wcsrchr;
using :: wcsspn;
using :: wcstod;
using :: wcstoul;
using :: wcsstr;
using :: wcstok;
using :: wcsxfrm;
using :: wctob;
using :: wmemchr;
using :: wmemcmp;
using :: wmemcpy;
using :: wmemmove;
using :: wmemset;
using :: wcsftime;
using :: vfwscanf;
using :: vswscanf;
using :: vwscanf;
using :: wcstof;
using :: wcstold;
using :: wcstoll;
using :: wcstoull;
#pragma warning(pop)
}
#pragma warning(pop)
#pragma pack(pop)
#line 102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cwchar"
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cwchar"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstddef"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtr1common"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Ty,
    _Ty _Val>
struct integral_constant { 
    static constexpr _Ty value = _Val;
    using value_type = _Ty;
    using type       = integral_constant;
    constexpr operator value_type() const noexcept { 
        return value;
    }
    [[nodiscard]] constexpr value_type operator()() const noexcept { 
        return value;
    }
};
template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;
using true_type  = bool_constant<true>;
using false_type = bool_constant<false>;
template <bool _Test,
    class _Ty = void>
struct enable_if { 
};
template <class _Ty>
struct enable_if<true, _Ty> { 
    using type = _Ty;
};
template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;
template <bool _Test, class _Ty1,
    class _Ty2>
struct conditional { 
    using type = _Ty2;
};
template <class _Ty1, class _Ty2>
struct conditional<true, _Ty1, _Ty2> { 
    using type = _Ty1;
};
template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;
template <class _Ty1,
    class _Ty2>
struct is_same : false_type { 
};
template <class _Ty1>
struct is_same<_Ty1, _Ty1> : true_type { 
};
template <class _Ty, class _Uty>
inline constexpr bool is_same_v = is_same<_Ty, _Uty>::value;
template <class _Ty>
struct remove_const { 
    using type = _Ty;
};
template <class _Ty>
struct remove_const<const _Ty> { 
    using type = _Ty;
};
template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;
template <class _Ty>
struct remove_volatile { 
    using type = _Ty;
};
template <class _Ty>
struct remove_volatile<volatile _Ty> { 
    using type = _Ty;
};
template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;
template <class _Ty>
struct remove_cv { 
    using type = _Ty;
};
template <class _Ty>
struct remove_cv<const _Ty> { 
    using type = _Ty;
};
template <class _Ty>
struct remove_cv<volatile _Ty> { 
    using type = _Ty;
};
template <class _Ty>
struct remove_cv<const volatile _Ty> { 
    using type = _Ty;
};
template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;
template <class _Ty>
struct _Is_integral : false_type { 
};
template <>
struct _Is_integral<bool> : true_type { 
};
template <>
struct _Is_integral<char> : true_type { 
};
template <>
struct _Is_integral<unsigned char> : true_type { 
};
template <>
struct _Is_integral<signed char> : true_type { 
};
template <>
struct _Is_integral<wchar_t> : true_type { 
};
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtr1common"
template <>
struct _Is_integral<char16_t> : true_type { 
};
template <>
struct _Is_integral<char32_t> : true_type { 
};
template <>
struct _Is_integral<unsigned short> : true_type { 
};
template <>
struct _Is_integral<short> : true_type { 
};
template <>
struct _Is_integral<unsigned int> : true_type { 
};
template <>
struct _Is_integral<int> : true_type { 
};
template <>
struct _Is_integral<unsigned long> : true_type { 
};
template <>
struct _Is_integral<long> : true_type { 
};
template <>
struct _Is_integral<unsigned long long> : true_type { 
};
template <>
struct _Is_integral<long long> : true_type { 
};
template <class _Ty>
struct is_integral : _Is_integral<remove_cv_t<_Ty>>::type { 
};
template <class _Ty>
inline constexpr bool is_integral_v = is_integral<_Ty>::value;
template <class _Ty>
struct _Is_floating_point : false_type { 
};
template <>
struct _Is_floating_point<float> : true_type { 
};
template <>
struct _Is_floating_point<double> : true_type { 
};
template <>
struct _Is_floating_point<long double> : true_type { 
};
template <class _Ty>
struct is_floating_point : _Is_floating_point<remove_cv_t<_Ty>>::type { 
};
template <class _Ty>
inline constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;
template <class _Ty>
struct is_arithmetic
    : bool_constant<is_integral_v<_Ty> || is_floating_point_v<_Ty>> { 
};
template <class _Ty>
inline constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;
template <class _Ty>
struct remove_reference { 
    using type = _Ty;
};
template <class _Ty>
struct remove_reference<_Ty&> { 
    using type = _Ty;
};
template <class _Ty>
struct remove_reference<_Ty&&> { 
    using type = _Ty;
};
template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;
template <class _Ty>
using _Remove_cvref_t = remove_cv_t<remove_reference_t<_Ty>>;
#line 275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtr1common"
}
#pragma warning(pop)
#pragma pack(pop)
#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtr1common"
#line 283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtr1common"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstddef"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
using :: ptrdiff_t;
using :: size_t;
using max_align_t = double; 
enum class byte : unsigned char {};
template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr byte operator<<(
    const byte _Arg, const _IntType _Shift) noexcept { 
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) << _Shift));
}
template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr byte operator>>(
    const byte _Arg, const _IntType _Shift) noexcept { 
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) >> _Shift));
}
[[nodiscard]] constexpr byte operator|(
    const byte _Left, const byte _Right) noexcept { 
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) | static_cast<unsigned int>(_Right)));
}
[[nodiscard]] constexpr byte operator&(
    const byte _Left, const byte _Right) noexcept { 
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) & static_cast<unsigned int>(_Right)));
}
[[nodiscard]] constexpr byte operator^(
    const byte _Left, const byte _Right) noexcept { 
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) ^ static_cast<unsigned int>(_Right)));
}
[[nodiscard]] constexpr byte operator~(const byte _Arg) noexcept { 
    return static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(_Arg)));
}
template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator<<=(byte& _Arg, const _IntType _Shift) noexcept { 
    return _Arg = _Arg << _Shift;
}
template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator>>=(byte& _Arg, const _IntType _Shift) noexcept { 
    return _Arg = _Arg >> _Shift;
}
constexpr byte& operator|=(byte& _Left, const byte _Right) noexcept { 
    return _Left = _Left | _Right;
}
constexpr byte& operator&=(byte& _Left, const byte _Right) noexcept { 
    return _Left = _Left & _Right;
}
constexpr byte& operator^=(byte& _Left, const byte _Right) noexcept { 
    return _Left = _Left ^ _Right;
}
template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr _IntType to_integer(const byte _Arg) noexcept { 
    return static_cast<_IntType>(_Arg);
}
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstddef"
}
using ::std:: max_align_t; 
#pragma warning(pop)
#pragma pack(pop)
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstddef"
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstddef"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\initializer_list"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Elem>
class initializer_list { 
public:
    using value_type      = _Elem;
    using reference       = const _Elem&;
    using const_reference = const _Elem&;
    using size_type       = size_t;
    using iterator       = const _Elem*;
    using const_iterator = const _Elem*;
    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) { 
    }
    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) { 
    }
    [[nodiscard]] constexpr const _Elem* begin() const noexcept { 
        return _First;
    }
    [[nodiscard]] constexpr const _Elem* end() const noexcept { 
        return _Last;
    }
    [[nodiscard]] constexpr size_t size() const noexcept { 
        return static_cast<size_t>(_Last - _First);
    }
private:
    const _Elem* _First;
    const _Elem* _Last;
};
template <class _Elem>
[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept { 
    return _Ilist.begin();
}
template <class _Elem>
[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept { 
    return _Ilist.end();
}
}
#pragma warning(pop)
#pragma pack(pop)
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\initializer_list"
#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\initializer_list"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class>
inline constexpr bool _Always_false = false;
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
template <class _Ty = void>
struct plus { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty result_type;
    constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const { 
        return _Left + _Right;
    }
};
template <class _Ty = void>
struct minus { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty result_type;
    constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const { 
        return _Left - _Right;
    }
};
template <class _Ty = void>
struct multiplies { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty result_type;
    constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const { 
        return _Left * _Right;
    }
};
template <class _Ty = void>
struct equal_to { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef bool result_type;
    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { 
        return _Left == _Right;
    }
};
template <class _Ty = void>
struct not_equal_to { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef bool result_type;
    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { 
        return _Left != _Right;
    }
};
template <class _Ty = void>
struct greater { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef bool result_type;
    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { 
        return _Left > _Right;
    }
};
template <class _Ty = void>
struct less { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef bool result_type;
    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { 
        return _Left < _Right;
    }
};
template <class _Ty = void>
struct greater_equal { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef bool result_type;
    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { 
        return _Left >= _Right;
    }
};
template <class _Ty = void>
struct less_equal { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef bool result_type;
    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const { 
        return _Left <= _Right;
    }
};
template <>
struct plus<void> { 
    using is_transparent = int;
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) 
        -> decltype(
            static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) { 
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }
};
template <>
struct minus<void> { 
    using is_transparent = int;
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) 
        -> decltype(
            static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) { 
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }
};
template <>
struct multiplies<void> { 
    using is_transparent = int;
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) 
        -> decltype(
            static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) { 
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }
};
template <>
struct equal_to<void> { 
    using is_transparent = int;
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) 
        -> decltype(
            static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) { 
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }
};
template <>
struct not_equal_to<void> { 
    using is_transparent = int;
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) 
        -> decltype(
            static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) { 
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }
};
template <>
struct greater<void> { 
    using is_transparent = int;
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) 
        -> decltype(
            static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) { 
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }
};
template <>
struct less<void> { 
    using is_transparent = int;
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) 
        -> decltype(
            static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) { 
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }
};
template <>
struct greater_equal<void> { 
    using is_transparent = int;
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) 
        -> decltype(
            static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) { 
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }
};
template <>
struct less_equal<void> { 
    using is_transparent = int;
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) 
        -> decltype(
            static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) { 
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }
};
template <class _Ty>
[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept { 
    return __builtin_addressof(_Val);
}
template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;
template <class _Ptrty>
inline auto _Unfancy(_Ptrty _Ptr) { 
    return ::std:: addressof(*_Ptr);
}
template <class _Ty>
inline _Ty* _Unfancy(_Ty* _Ptr) { 
    return _Ptr;
}
}
#line 307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 312 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 330 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 383 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 435 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#pragma warning(pop)
#pragma pack(pop)
#line 441 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 442 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstddef"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
enum float_denorm_style { 
    denorm_indeterminate = -1,
    denorm_absent        = 0,
    denorm_present       = 1
};
enum float_round_style { 
    round_indeterminate       = -1,
    round_toward_zero         = 0,
    round_to_nearest          = 1,
    round_toward_infinity     = 2,
    round_toward_neg_infinity = 3
};
struct _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss          = false;
    static constexpr bool has_infinity             = false;
    static constexpr bool has_quiet_NaN            = false;
    static constexpr bool has_signaling_NaN        = false;
    static constexpr bool is_bounded               = false;
    static constexpr bool is_exact                 = false;
    static constexpr bool is_iec559                = false;
    static constexpr bool is_integer               = false;
    static constexpr bool is_modulo                = false;
    static constexpr bool is_signed                = false;
    static constexpr bool is_specialized           = false;
    static constexpr bool tinyness_before          = false;
    static constexpr bool traps                    = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits                    = 0;
    static constexpr int digits10                  = 0;
    static constexpr int max_digits10              = 0;
    static constexpr int max_exponent              = 0;
    static constexpr int max_exponent10            = 0;
    static constexpr int min_exponent              = 0;
    static constexpr int min_exponent10            = 0;
    static constexpr int radix                     = 0;
};
template <class _Ty>
class numeric_limits : public _Num_base { 
public:
    [[nodiscard]] static constexpr _Ty(min)() noexcept { 
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty(max)() noexcept { 
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty lowest() noexcept { 
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty epsilon() noexcept { 
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty round_error() noexcept { 
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty denorm_min() noexcept { 
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty infinity() noexcept { 
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept { 
        return _Ty();
    }
    [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept { 
        return _Ty();
    }
};
template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> { 
};
template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> { 
};
template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> { 
};
struct _Num_int_base : _Num_base { 
    static constexpr bool is_bounded     = true;
    static constexpr bool is_exact       = true;
    static constexpr bool is_integer     = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix           = 2;
};
struct _Num_float_base : _Num_base { 
    static constexpr float_denorm_style has_denorm = denorm_present;
    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr bool is_bounded               = true;
    static constexpr bool is_iec559                = true;
    static constexpr bool is_signed                = true;
    static constexpr bool is_specialized           = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix                     = 2;
};
template <>
class numeric_limits<char> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr char(min)() noexcept { 
        return (-128);
    }
    [[nodiscard]] static constexpr char(max)() noexcept { 
        return 127;
    }
    [[nodiscard]] static constexpr char lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr char epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits     = 8 - ((-128) != 0);
    static constexpr int digits10   = 2;
};
template <>
class numeric_limits<wchar_t> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr wchar_t(min)() noexcept { 
        return 0x0000;
    }
    [[nodiscard]] static constexpr wchar_t(max)() noexcept { 
        return 0xffff;
    }
    [[nodiscard]] static constexpr wchar_t lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr wchar_t epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
template <>
class numeric_limits<bool> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr bool(min)() noexcept { 
        return false;
    }
    [[nodiscard]] static constexpr bool(max)() noexcept { 
        return true;
    }
    [[nodiscard]] static constexpr bool lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr bool epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr bool round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr bool denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr bool infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr bool quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr bool signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr int digits = 1;
};
template <>
class numeric_limits<signed char> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr signed char(min)() noexcept { 
        return (-128);
    }
    [[nodiscard]] static constexpr signed char(max)() noexcept { 
        return 127;
    }
    [[nodiscard]] static constexpr signed char lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr signed char epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr signed char round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr signed char denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr signed char infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr signed char quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr signed char signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_signed = true;
    static constexpr int digits     = 7;
    static constexpr int digits10   = 2;
};
template <>
class numeric_limits<unsigned char> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr unsigned char(min)() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char(max)() noexcept { 
        return 0xff;
    }
    [[nodiscard]] static constexpr unsigned char lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned char epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};
template <>
class numeric_limits<short> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr short(min)() noexcept { 
        return (-32768);
    }
    [[nodiscard]] static constexpr short(max)() noexcept { 
        return 32767;
    }
    [[nodiscard]] static constexpr short lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr short epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr short round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr short denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr short infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr short quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr short signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_signed = true;
    static constexpr int digits     = 15;
    static constexpr int digits10   = 4;
};
template <>
class numeric_limits<unsigned short> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr unsigned short(min)() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short(max)() noexcept { 
        return 0xffff;
    }
    [[nodiscard]] static constexpr unsigned short lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned short epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
#line 453 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits"
template <>
class numeric_limits<char16_t> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr char16_t(min)() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char16_t(max)() noexcept { 
        return 0xffff;
    }
    [[nodiscard]] static constexpr char16_t lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr char16_t epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char16_t round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char16_t denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char16_t infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
template <>
class numeric_limits<int> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr int(min)() noexcept { 
        return (-2147483647 - 1);
    }
    [[nodiscard]] static constexpr int(max)() noexcept { 
        return 2147483647;
    }
    [[nodiscard]] static constexpr int lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr int epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr int round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr int denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr int infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr int quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr int signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};
template <>
class numeric_limits<unsigned int> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr unsigned int(min)() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int(max)() noexcept { 
        return 0xffffffff;
    }
    [[nodiscard]] static constexpr unsigned int lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned int epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};
template <>
class numeric_limits<long> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr long(min)() noexcept { 
        return (-2147483647L - 1);
    }
    [[nodiscard]] static constexpr long(max)() noexcept { 
        return 2147483647L;
    }
    [[nodiscard]] static constexpr long lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr long epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long signaling_NaN() noexcept { 
        return 0;
    }
    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};
template <>
class numeric_limits<unsigned long> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr unsigned long(min)() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long(max)() noexcept { 
        return 0xffffffffUL;
    }
    [[nodiscard]] static constexpr unsigned long lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned long epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept { 
        return 0;
    }
    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};
template <>
class numeric_limits<char32_t> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr char32_t(min)() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char32_t(max)() noexcept { 
        return 0xffffffff;
    }
    [[nodiscard]] static constexpr char32_t lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr char32_t epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char32_t round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char32_t denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char32_t infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};
template <>
class numeric_limits<long long> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr long long(min)() noexcept { 
        return (-9223372036854775807i64 - 1);
    }
    [[nodiscard]] static constexpr long long(max)() noexcept { 
        return 9223372036854775807i64;
    }
    [[nodiscard]] static constexpr long long lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr long long epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long long round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long long denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long long infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long long quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr long long signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_signed = true;
    static constexpr int digits     = 63;
    static constexpr int digits10   = 18;
};
template <>
class numeric_limits<unsigned long long> : public _Num_int_base { 
public:
    [[nodiscard]] static constexpr unsigned long long(min)() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long(max)() noexcept { 
        return 0xffffffffffffffffui64;
    }
    [[nodiscard]] static constexpr unsigned long long lowest() noexcept { 
        return (min)();
    }
    [[nodiscard]] static constexpr unsigned long long epsilon() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long round_error() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long infinity() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept { 
        return 0;
    }
    [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept { 
        return 0;
    }
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 64;
    static constexpr int digits10   = 19;
};
template <>
class numeric_limits<float> : public _Num_float_base { 
public:
    [[nodiscard]] static constexpr float(min)() noexcept { 
        return 1.175494351e-38F;
    }
    [[nodiscard]] static constexpr float(max)() noexcept { 
        return 3.402823466e+38F;
    }
    [[nodiscard]] static constexpr float lowest() noexcept { 
        return -(max)();
    }
    [[nodiscard]] static constexpr float epsilon() noexcept { 
        return 1.192092896e-07F;
    }
    [[nodiscard]] static constexpr float round_error() noexcept { 
        return 0.5F;
    }
    [[nodiscard]] static constexpr float denorm_min() noexcept { 
        return 1.401298464e-45F;
    }
    [[nodiscard]] static constexpr float infinity() noexcept { 
        return __builtin_huge_valf();
    }
    [[nodiscard]] static constexpr float quiet_NaN() noexcept { 
        return __builtin_nanf("0");
    }
    [[nodiscard]] static constexpr float signaling_NaN() noexcept { 
        return __builtin_nansf("1");
    }
    static constexpr int digits         = 24;
    static constexpr int digits10       = 6;
    static constexpr int max_digits10   = 9;
    static constexpr int max_exponent   = 128;
    static constexpr int max_exponent10 = 38;
    static constexpr int min_exponent   = (-125);
    static constexpr int min_exponent10 = (-37);
};
template <>
class numeric_limits<double> : public _Num_float_base { 
public:
    [[nodiscard]] static constexpr double(min)() noexcept { 
        return 2.2250738585072014e-308;
    }
    [[nodiscard]] static constexpr double(max)() noexcept { 
        return 1.7976931348623158e+308;
    }
    [[nodiscard]] static constexpr double lowest() noexcept { 
        return -(max)();
    }
    [[nodiscard]] static constexpr double epsilon() noexcept { 
        return 2.2204460492503131e-016;
    }
    [[nodiscard]] static constexpr double round_error() noexcept { 
        return 0.5;
    }
    [[nodiscard]] static constexpr double denorm_min() noexcept { 
        return 4.9406564584124654e-324;
    }
    [[nodiscard]] static constexpr double infinity() noexcept { 
        return __builtin_huge_val();
    }
    [[nodiscard]] static constexpr double quiet_NaN() noexcept { 
        return __builtin_nan("0");
    }
    [[nodiscard]] static constexpr double signaling_NaN() noexcept { 
        return __builtin_nans("1");
    }
    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};
template <>
class numeric_limits<long double> : public _Num_float_base { 
public:
    [[nodiscard]] static constexpr long double(min)() noexcept { 
        return 2.2250738585072014e-308;
    }
    [[nodiscard]] static constexpr long double(max)() noexcept { 
        return 1.7976931348623158e+308;
    }
    [[nodiscard]] static constexpr long double lowest() noexcept { 
        return -(max)();
    }
    [[nodiscard]] static constexpr long double epsilon() noexcept { 
        return 2.2204460492503131e-016;
    }
    [[nodiscard]] static constexpr long double round_error() noexcept { 
        return 0.5L;
    }
    [[nodiscard]] static constexpr long double denorm_min() noexcept { 
        return 4.9406564584124654e-324;
    }
    [[nodiscard]] static constexpr long double infinity() noexcept { 
        return __builtin_huge_val();
    }
    [[nodiscard]] static constexpr long double quiet_NaN() noexcept { 
        return __builtin_nan("0");
    }
    [[nodiscard]] static constexpr long double signaling_NaN() noexcept { 
        return __builtin_nans("1");
    }
    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};
}
#pragma warning(pop)
#pragma pack(pop)
#line 968 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits"
#line 969 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\limits"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\new"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
#pragma warning(disable : 4180) 
namespace std {
template <class _Ty,
    _Ty... _Vals>
struct integer_sequence { 
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");
    using value_type = _Ty;
    [[nodiscard]] static constexpr size_t size() noexcept { 
        return sizeof...(_Vals);
    }
};
template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;
template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;
template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;
template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
template <bool _First_value, class _First,
    class... _Rest>
struct _Conjunction { 
    using type = _First;
};
template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { 
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};
template <class... _Traits>
struct conjunction : true_type { 
};
template <class _First, class... _Rest>
struct conjunction<_First, _Rest...>
    : _Conjunction<_First::value, _First, _Rest...>::type { 
};
template <class... _Traits>
inline constexpr bool conjunction_v = conjunction<_Traits...>::value;
template <bool _First_value, class _First,
    class... _Rest>
struct _Disjunction { 
    using type = _First;
};
template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { 
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};
template <class... _Traits>
struct disjunction : false_type { 
};
template <class _First, class... _Rest>
struct disjunction<_First, _Rest...>
    : _Disjunction<_First::value, _First, _Rest...>::type { 
};
template <class... _Traits>
inline constexpr bool disjunction_v = disjunction<_Traits...>::value;
template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> { 
};
template <class _Trait>
inline constexpr bool negation_v = negation<_Trait>::value;
template <class _Ty, class... _Types>
inline constexpr bool _Is_any_of_v = disjunction_v<is_same<_Ty, _Types>...>;
template <class... _Types>
struct _Arg_types { 
};
template <class _Ty1>
struct _Arg_types<_Ty1> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty1 argument_type;
};
template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty1 first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty2 second_argument_type;
};
template <class _Ty>
struct _Is_function { 
    using _Bool_type = false_type;
};
template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)   noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)   noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const  noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const  noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile  noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile  noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile  noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile  noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)  & noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)  & noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const & noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const & noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile & noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile & noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile & noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile & noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)  && noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...)  && noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const && noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const && noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile && noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) volatile && noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const volatile && noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };    template <class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall(_Types...) const volatile && noexcept> : _Arg_types<_Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };
template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) > { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) &> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) &&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const&&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile&&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile&&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) &noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) &&noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const&& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile&& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; }; template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile&& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; };
template <class _Ty>
struct is_function : _Is_function<_Ty>::_Bool_type { 
};
template <class _Ty>
inline constexpr bool is_function_v = is_function<_Ty>::value;
template <class _Ty>
struct _Is_memfunptr { 
    using _Bool_type = false_type;
};
template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };
template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&& noexcept> { using _Bool_type = true_type; [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };
template <class _Ty>
struct is_void : false_type { 
};
template <> struct is_void< void> : true_type { }; template <> struct is_void<const void> : true_type { }; template <> struct is_void<volatile void> : true_type { }; template <> struct is_void<const volatile void> : true_type { };
template <class _Ty>
inline constexpr bool is_void_v = is_void<_Ty>::value;
template <class... _Types>
using void_t = void;
template <class _Ty>
struct add_const { 
    using type = const _Ty;
};
template <class _Ty>
using add_const_t = typename add_const<_Ty>::type; 
template <class _Ty>
struct add_volatile { 
    using type = volatile _Ty;
};
template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type; 
template <class _Ty>
struct add_cv { 
    using type = const volatile _Ty;
};
template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type; 
template <class _Ty,
    class = void>
struct _Add_reference { 
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};
template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { 
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};
template <class _Ty>
struct add_lvalue_reference { 
    using type = typename _Add_reference<_Ty>::_Lvalue;
};
template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;
template <class _Ty>
struct add_rvalue_reference { 
    using type = typename _Add_reference<_Ty>::_Rvalue;
};
template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;
template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept;
template <class _Ty>
struct remove_extent { 
    using type = _Ty;
};
template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> { 
    using type = _Ty;
};
template <class _Ty>
struct remove_extent<_Ty[]> { 
    using type = _Ty;
};
template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;
template <class _Ty>
struct remove_all_extents { 
    using type = _Ty;
};
template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> { 
    using type = typename remove_all_extents<_Ty>::type;
};
template <class _Ty>
struct remove_all_extents<_Ty[]> { 
    using type = typename remove_all_extents<_Ty>::type;
};
template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;
template <class _Ty>
struct remove_pointer { 
    using type = _Ty;
};
template <class _Ty> struct remove_pointer<_Ty * > { using type = _Ty; }; template <class _Ty> struct remove_pointer<_Ty * const> { using type = _Ty; }; template <class _Ty> struct remove_pointer<_Ty * volatile> { using type = _Ty; }; template <class _Ty> struct remove_pointer<_Ty * const volatile> { using type = _Ty; };
template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;
template <class _Ty,
    class = void>
struct _Add_pointer { 
    using type = _Ty;
};
template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { 
    using type = remove_reference_t<_Ty>*;
};
template <class _Ty>
struct add_pointer { 
    using type = typename _Add_pointer<_Ty>::type;
};
template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;
template <class _Ty>
struct is_array : false_type { 
};
template <class _Ty, size_t _Nx>
struct is_array<_Ty[_Nx]> : true_type { 
};
template <class _Ty>
struct is_array<_Ty[]> : true_type { 
};
template <class _Ty>
inline constexpr bool is_array_v = is_array<_Ty>::value;
template <class _Ty>
struct is_lvalue_reference : false_type { 
};
template <class _Ty>
struct is_lvalue_reference<_Ty&> : true_type { 
};
template <class _Ty>
inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;
template <class _Ty>
struct is_rvalue_reference : false_type { 
};
template <class _Ty>
struct is_rvalue_reference<_Ty&&> : true_type { 
};
template <class _Ty>
inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;
template <class _Ty>
struct is_reference : false_type { 
};
template <class _Ty>
struct is_reference<_Ty&> : true_type { 
};
template <class _Ty>
struct is_reference<_Ty&&> : true_type { 
};
template <class _Ty>
inline constexpr bool is_reference_v = is_reference<_Ty>::value;
template <class _Ty,
    bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
struct _Is_member_object_pointer : false_type { 
};
template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
    : true_type { 
    using _Class_type = _Ty2;
};
template <class _Ty>
struct is_member_object_pointer
    : _Is_member_object_pointer<remove_cv_t<_Ty>>::type { 
};
template <class _Ty>
inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;
template <class _Ty>
struct is_member_function_pointer
    : _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type { 
};
template <class _Ty>
inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;
template <class _Ty>
struct is_pointer : false_type { 
};
template <class _Ty>
struct is_pointer<_Ty*> : true_type { 
};
template <class _Ty>
struct is_pointer<_Ty* const> : true_type { 
};
template <class _Ty>
struct is_pointer<_Ty* volatile> : true_type { 
};
template <class _Ty>
struct is_pointer<_Ty* const volatile> : true_type { 
};
template <class _Ty>
inline constexpr bool is_pointer_v = is_pointer<_Ty>::value;
template <class _Ty>
struct is_null_pointer : bool_constant<is_same_v<remove_cv_t<_Ty>, nullptr_t>> { 
};
template <class _Ty>
inline constexpr bool is_null_pointer_v = is_same_v<remove_cv_t<_Ty>, nullptr_t>;
template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_union_v = __is_union(_Ty);
template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_class_v = __is_class(_Ty);
template <class _Ty>
struct is_fundamental
    : bool_constant<is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>> { 
};
template <class _Ty>
inline constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;
template <class _Ty>
struct is_object
    : bool_constant<!is_function_v<_Ty> && !is_reference_v<_Ty> && !is_void_v<_Ty>> { 
};
template <class _Ty>
inline constexpr bool is_object_v = is_object<_Ty>::value;
template <class _From, class _To>
struct is_convertible
    : bool_constant<__is_convertible_to(_From, _To)> { 
};
template <class _From, class _To>
inline constexpr bool is_convertible_v = __is_convertible_to(_From, _To);
template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_enum_v = __is_enum(_Ty);
template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> { 
};
template <class _Ty>
inline constexpr bool is_compound_v = is_compound<_Ty>::value;
template <class _Ty>
struct is_member_pointer
    : bool_constant<is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>> { 
};
template <class _Ty>
inline constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;
template <class _Ty>
struct is_scalar
    : bool_constant<
          is_arithmetic_v<
              _Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>> {};
template <class _Ty>
inline constexpr bool is_scalar_v = is_scalar<_Ty>::value;
template <class _Ty>
struct is_const : false_type { 
};
template <class _Ty>
struct is_const<const _Ty> : true_type { 
};
template <class _Ty>
inline constexpr bool is_const_v = is_const<_Ty>::value;
template <class _Ty>
struct is_volatile : false_type { 
};
template <class _Ty>
struct is_volatile<volatile _Ty> : true_type { 
};
template <class _Ty>
inline constexpr bool is_volatile_v = is_volatile<_Ty>::value;
template <class _Ty>
struct is_pod : bool_constant<__is_pod(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_pod_v = __is_pod(_Ty);
template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_empty_v = __is_empty(_Ty);
template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);
template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_abstract_v = __is_abstract(_Ty);
template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_final_v = __is_final(_Ty);
template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);
template <class _Ty>
struct [[deprecated("warning STL4013: " "std::is_literal_type and std::is_literal_type_v are deprecated in C++17. " "You can define _SILENCE_CXX17_IS_LITERAL_TYPE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] is_literal_type
    : bool_constant<__is_literal_type(_Ty)> { 
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
[[deprecated("warning STL4013: " "std::is_literal_type and std::is_literal_type_v are deprecated in C++17. " "You can define _SILENCE_CXX17_IS_LITERAL_TYPE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] inline constexpr bool is_literal_type_v = __is_literal_type(_Ty);
#pragma warning(pop)
template <class _Ty>
struct is_trivial : bool_constant<__is_trivial(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_trivial_v = __is_trivial(_Ty);
template <class _Ty>
struct is_trivially_copyable
    : bool_constant<__is_trivially_copyable(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);
template <class _Ty>
struct has_virtual_destructor
    : bool_constant<__has_virtual_destructor(_Ty)> { 
};
template <class _Ty>
inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);
template <class _Ty>
struct has_unique_object_representations : bool_constant<__has_unique_object_representations(
                                               _Ty)> { 
};
template <class _Ty>
inline constexpr bool has_unique_object_representations_v = __has_unique_object_representations(_Ty);
template <class _Ty>
struct is_aggregate : bool_constant<__is_aggregate(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_aggregate_v = __is_aggregate(_Ty);
#line 676 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
template <class _Ty, class... _Args>
struct is_constructible
    : bool_constant<__is_constructible(_Ty, _Args...)> { 
};
template <class _Ty, class... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);
template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty,
                                   add_lvalue_reference_t<const _Ty>)> { 
};
template <class _Ty>
inline constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_default_constructible
    : bool_constant<__is_constructible(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_default_constructible_v = __is_constructible(_Ty);
template <class _Ty,
    class = void>
struct _Is_implicitly_default_constructible : false_type { 
};
template <class _Ty>
void _Implicitly_default_construct(const _Ty&);
template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>>
    : true_type { 
};
template <class _Ty>
struct is_move_constructible
    : bool_constant<__is_constructible(_Ty, _Ty)> { 
};
template <class _Ty>
inline constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);
template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> { 
};
template <class _To, class _From>
inline constexpr bool is_assignable_v = __is_assignable(_To, _From);
template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>,
          add_lvalue_reference_t<const _Ty>)> { 
};
template <class _Ty>
inline constexpr bool is_copy_assignable_v = __is_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
          add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {};
template <class _Ty>
inline constexpr bool _Is_copy_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
#line 763 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>,
                                _Ty)> { 
};
template <class _Ty>
inline constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);
template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {};
template <class _Ty>
inline constexpr bool _Is_move_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t<_Ty>, _Ty);
#line 788 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_destructible_v = __is_destructible(_Ty);
template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(
                                        _Ty, _Args...)> { 
};
template <class _Ty, class... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);
template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(
          _Ty, add_lvalue_reference_t<const _Ty>)> { 
};
template <class _Ty>
inline constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_trivially_default_constructible
    : bool_constant<__is_trivially_constructible(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);
template <class _Ty>
struct is_trivially_move_constructible
    : bool_constant<__is_trivially_constructible(_Ty, _Ty)> { 
};
template <class _Ty>
inline constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);
template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(
                                     _To, _From)> { 
};
template <class _To, class _From>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);
template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>,
          add_lvalue_reference_t<const _Ty>)> { 
};
template <class _Ty>
inline constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>,
                                          _Ty)> { 
};
template <class _Ty>
inline constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);
template <class _Ty>
struct is_trivially_destructible
    : bool_constant<__is_trivially_destructible(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);
template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(
                                      _Ty, _Args...)> { 
};
template <class _Ty, class... _Args>
inline constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);
template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(
          _Ty, add_lvalue_reference_t<const _Ty>)> { 
};
template <class _Ty>
inline constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(
    _Ty, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_nothrow_default_constructible
    : bool_constant<__is_nothrow_constructible(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);
template <class _Ty>
struct is_nothrow_move_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> { 
};
template <class _Ty>
inline constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);
template <class _To, class _From>
struct is_nothrow_assignable
    : bool_constant<__is_nothrow_assignable(_To, _From)> { 
};
template <class _To, class _From>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);
template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>,
          add_lvalue_reference_t<const _Ty>)> { 
};
template <class _Ty>
inline constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(
    add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>,
                                        _Ty)> { 
};
template <class _Ty>
inline constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);
template <class _Ty>
struct is_nothrow_destructible
    : bool_constant<__is_nothrow_destructible(_Ty)> { 
};
template <class _Ty>
inline constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);
#pragma warning(push)
#pragma warning(disable : 4296) 
template <class _Ty,
    bool = is_integral_v<_Ty>>
struct _Sign_base { 
    using _Uty      = remove_cv_t<_Ty>;
    using _Signed   = bool_constant<_Uty(-1) < _Uty(0)>;
    using _Unsigned = bool_constant<_Uty(0) < _Uty(-1)>;
};
#pragma warning(pop)
template <class _Ty>
struct _Sign_base<_Ty, false> { 
    using _Signed   = typename is_floating_point<_Ty>::type;
    using _Unsigned = false_type;
};
template <class _Ty>
struct is_signed : _Sign_base<_Ty>::_Signed { 
};
template <class _Ty>
inline constexpr bool is_signed_v = is_signed<_Ty>::value;
template <class _Ty>
struct is_unsigned : _Sign_base<_Ty>::_Unsigned { 
};
template <class _Ty>
inline constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;
template <class _Ty>
using _Is_nonbool_integral = bool_constant<is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>>;
template <class _Ty>
struct _Change_sign { 
    static_assert(_Is_nonbool_integral<_Ty>::value || is_enum_v<_Ty>,
        "make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
        "cv-qualified) integral type or enumeration but not a bool type.");
    using _Signed = conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, long,
        conditional_t<sizeof(_Ty) == 1, signed char,
            conditional_t<sizeof(_Ty) == 2, short, conditional_t<sizeof(_Ty) == 4, int, long long>>>>;
    using _Unsigned = conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, unsigned long,
        conditional_t<sizeof(_Ty) == 1, unsigned char,
            conditional_t<sizeof(_Ty) == 2, unsigned short,
                conditional_t<sizeof(_Ty) == 4, unsigned int, unsigned long long>>>>;
};
template <class _Ty>
struct _Change_sign<const _Ty> { 
    using _Signed   = const typename _Change_sign<_Ty>::_Signed;
    using _Unsigned = const typename _Change_sign<_Ty>::_Unsigned;
};
template <class _Ty>
struct _Change_sign<volatile _Ty> { 
    using _Signed   = volatile typename _Change_sign<_Ty>::_Signed;
    using _Unsigned = volatile typename _Change_sign<_Ty>::_Unsigned;
};
template <class _Ty>
struct _Change_sign<const volatile _Ty> { 
    using _Signed   = const volatile typename _Change_sign<_Ty>::_Signed;
    using _Unsigned = const volatile typename _Change_sign<_Ty>::_Unsigned;
};
template <class _Ty>
struct make_signed { 
    using type = typename _Change_sign<_Ty>::_Signed;
};
template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;
template <class _Ty>
struct make_unsigned { 
    using type = typename _Change_sign<_Ty>::_Unsigned;
};
template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;
template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { 
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}
template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> { 
};
template <class _Ty>
inline constexpr size_t alignment_of_v = alignof(_Ty);
template <class _Ty,
    size_t _Len>
union _Align_type { 
    _Ty _Val;
    char _Pad[_Len];
};
template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned;
template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> { 
    using type = _Align_type<_Ty, _Len>;
};
template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> { 
    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member type would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "Please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and "
        "that you actually want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conformant "
        "behavior.");
#line 1095 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
    using type = _Align_type<max_align_t, _Len>;
#line 1097 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
};
template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> { 
    using type = typename _Aligned<_Len, _Align, double, _Align <= alignof(double)>::type;
};
template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> { 
    using type = typename _Aligned<_Len, _Align, int, _Align <= alignof(int)>::type;
};
template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> { 
    using type = typename _Aligned<_Len, _Align, short, _Align <= alignof(short)>::type;
};
template <size_t _Len,
    size_t _Align = alignof(max_align_t)>
struct aligned_storage { 
    using type = typename _Aligned<_Len, _Align, char, _Align <= alignof(char)>::type;
};
template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
template <size_t... _Vals>
struct _Maximum;
template <>
struct _Maximum<> : integral_constant<size_t, 0> { 
};
template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> { 
};
template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First),
                                                 _Rest...>::type { 
};
template <size_t _Len,
    class... _Types>
struct aligned_union { 
    static constexpr size_t _Max_len        = _Maximum<_Len, sizeof(_Types)...>::value; 
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;
    using type                              = aligned_storage_t<_Max_len, alignment_value>;
};
template <size_t _Len, class... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
template <class _Ty>
struct underlying_type { 
    using type = __underlying_type(_Ty);
};
template <class _Ty>
using underlying_type_t = typename underlying_type<_Ty>::type;
template <class _Ty>
struct rank : integral_constant<size_t, 0> { 
};
template <class _Ty, size_t _Ix>
struct rank<_Ty[_Ix]> : integral_constant<size_t, rank<_Ty>::value + 1> { 
};
template <class _Ty>
struct rank<_Ty[]> : integral_constant<size_t, rank<_Ty>::value + 1> { 
};
template <class _Ty>
inline constexpr size_t rank_v = rank<_Ty>::value;
template <class _Ty, unsigned int _Nx>
struct _Extent : integral_constant<size_t, 0> { 
};
template <class _Ty, size_t _Ix>
struct _Extent<_Ty[_Ix], 0> : integral_constant<size_t, _Ix> { 
};
template <class _Ty, unsigned int _Nx, size_t _Ix>
struct _Extent<_Ty[_Ix], _Nx> : _Extent<_Ty, _Nx - 1> { 
};
template <class _Ty, unsigned int _Nx>
struct _Extent<_Ty[], _Nx> : _Extent<_Ty, _Nx - 1> { 
};
template <class _Ty, unsigned int _Nx = 0>
struct extent : _Extent<_Ty, _Nx> { 
};
template <class _Ty, unsigned int _Ix = 0>
inline constexpr size_t extent_v = extent<_Ty, _Ix>::value;
template <class _Base, class _Derived>
struct is_base_of
    : bool_constant<__is_base_of(_Base, _Derived)> { 
};
template <class _Base, class _Derived>
inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
template <class _Ty>
struct decay { 
    using _Ty1 = remove_reference_t<_Ty>;
    using type = conditional_t<is_array_v<_Ty1>, add_pointer_t<remove_extent_t<_Ty1>>,
        conditional_t<is_function_v<_Ty1>, add_pointer_t<_Ty1>, remove_cv_t<_Ty1>>>;
};
template <class _Ty>
using decay_t = typename decay<_Ty>::type;
template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper {};
template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>())>> {
    using type = decay_t<decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>())>;
};
template <class... _Ty>
struct common_type;
template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;
template <>
struct common_type<> {};
template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};
template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};
template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};
template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};
template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};
template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};
template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};
#line 1275 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
template <class _Ty>
struct _Identity { 
    using type = _Ty;
};
template <class _Ty>
using _Identity_t = typename _Identity<_Ty>::type;
template <class _Type, template <class...> class _Template>
inline constexpr bool _Is_specialization_v = false;
template <template <class...> class _Template, class... _Types>
inline constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;
template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};
template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(
    remove_reference_t<_Ty>& _Arg) noexcept { 
    return static_cast<_Ty&&>(_Arg);
}
template <class _Ty>
[[nodiscard]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept { 
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}
template <class _Ty>
[[nodiscard]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { 
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
template <class _Ty>
[[nodiscard]] constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&,
    _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept { 
    return ::std:: move(_Arg);
}
template <class _Ty>
class reference_wrapper;
struct _Invoker_pmf_object { template <class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)) { return (::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _Invoker_pmf_refwrap { template <class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>( _Args2)...)) { return (::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _Invoker_pmf_pointer { template <class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>( _Args2)...)) { return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _Invoker_pmd_object { template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd) { return ::std:: forward<_Ty1>(_Arg1).*_Pmd; } }; struct _Invoker_pmd_refwrap { template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)) -> decltype( ::std:: forward<_Ty1>(_Arg1).get().*_Pmd) { return ::std:: forward<_Ty1>(_Arg1).get().*_Pmd; } }; struct _Invoker_pmd_pointer { template <class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)) -> decltype( (*::std:: forward<_Ty1>(_Arg1)).*_Pmd) { return (*::std:: forward<_Ty1>(_Arg1)).*_Pmd; } }; struct _Invoker_functor { template <class _Callable, class... _Types> static inline auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(noexcept(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...))) -> decltype( ::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)) { return ::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...); } }; template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>, bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>, bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>> struct _Invoker1; template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false> : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _Invoker_pmf_object, conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap, _Invoker_pmf_pointer>> { }; template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true> : conditional_t< is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _Invoker_pmd_object, conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap, _Invoker_pmd_pointer>> { }; template <class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor { }; template <class _Callable, class... _Types> struct _Invoker; template <class _Callable> struct _Invoker<_Callable> : _Invoker_functor { }; template <class _Callable, class _Ty1, class... _Types2> struct _Invoker<_Callable, _Ty1, _Types2...> : _Invoker1<_Callable, _Ty1> { }; template <class _Callable, class... _Types> inline auto invoke(_Callable && _Obj, _Types && ... _Args) noexcept(noexcept(_Invoker < _Callable, _Types... > ::_Call(::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))) ->decltype(_Invoker < _Callable, _Types... > ::_Call(::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)) { return _Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...); }
struct _C__Invoker_pmf_object { template <class _Decayed, class _Ty1, class... _Types2> static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)( ::std:: forward<_Types2>(_Args2)...)) { return (::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _C__Invoker_pmf_refwrap { template <class _Decayed, class _Ty1, class... _Types2> static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>( _Args2)...)) { return (::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _C__Invoker_pmf_pointer { template <class _Decayed, class _Ty1, class... _Types2> static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>( _Args2)...)) { return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...); } }; struct _C__Invoker_pmd_object { template <class _Decayed, class _Ty1> static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd) { return ::std:: forward<_Ty1>(_Arg1).*_Pmd; } }; struct _C__Invoker_pmd_refwrap { template <class _Decayed, class _Ty1> static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)) -> decltype( ::std:: forward<_Ty1>(_Arg1).get().*_Pmd) { return ::std:: forward<_Ty1>(_Arg1).get().*_Pmd; } }; struct _C__Invoker_pmd_pointer { template <class _Decayed, class _Ty1> static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)) -> decltype( (*::std:: forward<_Ty1>(_Arg1)).*_Pmd) { return (*::std:: forward<_Ty1>(_Arg1)).*_Pmd; } }; struct _C__Invoker_functor { template <class _Callable, class... _Types> static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(noexcept(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...))) -> decltype( ::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)) { return ::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...); } }; template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>, bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>, bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>> struct _C__Invoker1; template <class _Callable, class _Ty1, class _Removed_cvref> struct _C__Invoker1<_Callable, _Ty1, _Removed_cvref, true, false> : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _C__Invoker_pmf_object, conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _C__Invoker_pmf_refwrap, _C__Invoker_pmf_pointer>> { }; template <class _Callable, class _Ty1, class _Removed_cvref> struct _C__Invoker1<_Callable, _Ty1, _Removed_cvref, false, true> : conditional_t< is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _C__Invoker_pmd_object, conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _C__Invoker_pmd_refwrap, _C__Invoker_pmd_pointer>> { }; template <class _Callable, class _Ty1, class _Removed_cvref> struct _C__Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _C__Invoker_functor { }; template <class _Callable, class... _Types> struct _C__Invoker; template <class _Callable> struct _C__Invoker<_Callable> : _C__Invoker_functor { }; template <class _Callable, class _Ty1, class... _Types2> struct _C__Invoker<_Callable, _Ty1, _Types2...> : _C__Invoker1<_Callable, _Ty1> { }; template <class _Callable, class... _Types> constexpr auto _C_invoke(_Callable && _Obj, _Types && ... _Args) noexcept(noexcept(_C__Invoker < _Callable, _Types... > ::_Call(::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))) ->decltype(_C__Invoker < _Callable, _Types... > ::_Call(::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)) { return _C__Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...); }
#line 1453 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
template <class _Rx,
    bool = is_void_v<_Rx>>
struct _Invoker_ret { 
};
struct _Unforced { 
};
template <class _Cv_void>
struct _Invoker_ret<_Cv_void, true> { 
    template <class... _Valtys>
    static void _Call(_Valtys&&... _Vals) { 
        ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
    }
};
template <class _Rx>
struct _Invoker_ret<_Rx, false> { 
    template <class... _Valtys>
    static _Rx _Call(_Valtys&&... _Vals) { 
        return ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
    }
};
template <>
struct _Invoker_ret<_Unforced, false> { 
    template <class... _Valtys>
    static auto _Call(_Valtys&&... _Vals)
        -> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...)) { 
        return ::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
    }
};
template <class _To>
void _Implicitly_convert_to(_To) noexcept;
template <class _From, class _To, bool = is_convertible_v<_From, _To>>
struct _Is_nothrow_convertible : bool_constant<noexcept(_Implicitly_convert_to<_To>( ::std:: declval<_From>()))> { 
#line 1496 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
};
template <class _From, class _To>
struct _Is_nothrow_convertible<_From, _To, false>
    : false_type { 
};
template <class _Void,
    class... _Types>
struct _Invoke_traits { 
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};
template <class... _Types>
struct _Invoke_traits<void_t<decltype(::std:: invoke(::std:: declval<_Types>()...))>,
    _Types...> { 
    using type                  = decltype(::std:: invoke(::std:: declval<_Types>()...));
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant<noexcept(::std:: invoke(::std:: declval<_Types>()...))>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, is_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<
        conjunction_v<_Is_nothrow_invocable, disjunction<is_void<_Rx>, _Is_nothrow_convertible<type, _Rx>>>>;
};
template <class _Fty>
struct [[deprecated("warning STL4014: " "std::result_of and std::result_of_t are deprecated in C++17. " "They are superseded by std::invoke_result and std::invoke_result_t. " "You can define _SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] result_of { 
    static_assert(_Always_false<_Fty>, "result_of<CallableType> is invalid; use "
                                       "result_of<CallableType(zero or more argument types)> instead.");
};
template <class _Callable, class... _Args> struct [[deprecated("warning STL4014: " "std::result_of and std::result_of_t are deprecated in C++17. " "They are superseded by std::invoke_result and std::invoke_result_t. " "You can define _SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] result_of<_Callable __cdecl(_Args...)> : _Invoke_traits<void, _Callable, _Args...> { };    template <class _Callable, class... _Args> struct [[deprecated("warning STL4014: " "std::result_of and std::result_of_t are deprecated in C++17. " "They are superseded by std::invoke_result and std::invoke_result_t. " "You can define _SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] result_of<_Callable __vectorcall(_Args...)> : _Invoke_traits<void, _Callable, _Args...> { };
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
using result_of_t [[deprecated("warning STL4014: " "std::result_of and std::result_of_t are deprecated in C++17. " "They are superseded by std::invoke_result and std::invoke_result_t. " "You can define _SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] = typename result_of<_Ty>::type;
#pragma warning(pop)
template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;
template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Invoke_traits<void, _Callable, _Args...>::template _Is_invocable_r<_Rx>;
template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable,
                             _Args...> { 
};
template <class _Callable, class... _Args>
struct invoke_result
    : _Invoke_traits<void, _Callable, _Args...> { 
};
template <class _Callable, class... _Args>
using invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;
template <class _Callable, class... _Args>
struct is_invocable
    : _Invoke_traits<void, _Callable, _Args...>::_Is_invocable { 
};
template <class _Callable, class... _Args>
inline constexpr bool is_invocable_v = _Invoke_traits<void, _Callable, _Args...>::_Is_invocable::value;
template <class _Callable, class... _Args>
struct is_nothrow_invocable
    : _Invoke_traits<void, _Callable,
          _Args...>::_Is_nothrow_invocable { 
};
template <class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_v = _Invoke_traits<void, _Callable, _Args...>::_Is_nothrow_invocable::value;
template <class _Rx, class _Callable, class... _Args>
struct is_invocable_r : _Is_invocable_r_<_Rx, _Callable,
                            _Args...> { 
};
template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_invocable_r_v = _Is_invocable_r_<_Rx, _Callable, _Args...>::value;
template <class _Rx, class _Callable, class... _Args>
struct is_nothrow_invocable_r
    : _Invoke_traits<void, _Callable, _Args...>::template _Is_nothrow_invocable_r<
          _Rx> { 
};
template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_r_v =
    _Invoke_traits<void, _Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx>::value;
#line 1609 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
template <class _Ty,
    class = void>
struct _Weak_result_type { 
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef typename _Ty::result_type result_type;
};
#pragma warning(pop)
template <class _Ty,
    class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> { 
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>>
    : _Weak_result_type<_Ty> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef typename _Ty::argument_type argument_type;
};
#pragma warning(pop)
template <class _Ty,
    class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> { 
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef typename _Ty::first_argument_type first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef typename _Ty::second_argument_type second_argument_type;
};
#pragma warning(pop)
template <class _Ty>
struct _Weak_types { 
    using _Is_f_or_pf = _Is_function<remove_pointer_t<_Ty>>;
    using _Is_pmf     = _Is_memfunptr<remove_cv_t<_Ty>>;
    using type        = conditional_t<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
        conditional_t<_Is_pmf::_Bool_type::value, _Is_pmf, _Weak_binary_args<_Ty>>>;
};
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept;
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;
template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};
template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>> : true_type {};
template <class _Ty>
class reference_wrapper : public _Weak_types<_Ty>::type { 
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");
    using type = _Ty;
    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
                                          _Refwrap_has_ctor_from<_Ty, _Uty>>,
                              int> = 0>
    reference_wrapper(_Uty&& _Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))) { 
        _Ty& _Ref = ::std:: forward<_Uty>(_Val);
        _Ptr      = ::std:: addressof(_Ref);
    }
    operator _Ty&() const noexcept { 
        return *_Ptr;
    }
    [[nodiscard]] _Ty& get() const noexcept { 
        return *_Ptr;
    }
    template <class... _Types>
    auto operator()(_Types&&... _Args) const
        -> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...)) { 
        return ::std:: invoke(get(), ::std:: forward<_Types>(_Args)...);
    }
private:
    _Ty* _Ptr;
};
template <class _Ty>
reference_wrapper(_Ty&)->reference_wrapper<_Ty>;
#line 1713 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(_Ty& _Val) noexcept { 
    return reference_wrapper<_Ty>(_Val);
}
template <class _Ty>
void ref(const _Ty&&) = delete;
template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(
    reference_wrapper<_Ty> _Val) noexcept { 
    return ::std:: ref(_Val.get());
}
template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(
    const _Ty& _Val) noexcept { 
    return reference_wrapper<const _Ty>(_Val);
}
template <class _Ty>
void cref(const _Ty&&) = delete;
template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(
    reference_wrapper<_Ty> _Val) noexcept { 
    return ::std:: cref(_Val.get());
}
template <class _Ty>
struct _Is_swappable;
template <class _Ty>
struct _Is_nothrow_swappable;
template <class _Ty, class = enable_if_t<is_move_constructible_v<_Ty> && is_move_assignable_v<_Ty>>>
inline
#line 1760 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
    void
    swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);
template <class _Ty, size_t _Size, class = enable_if_t<_Is_swappable<_Ty>::value>>
inline void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);
template <class _Ty1, class _Ty2,
    class = void>
struct _Swappable_with_helper : false_type { 
};
template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
    : true_type { 
};
template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>,
          _Swappable_with_helper<_Ty2, _Ty1>>> { 
};
template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>,
                           add_lvalue_reference_t<_Ty>>::type { 
};
template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw
    : bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
                    && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))> { 
#line 1797 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
};
template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>,
          _Swap_cannot_throw<_Ty1, _Ty2>>> { 
};
template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>,
          add_lvalue_reference_t<_Ty>>::type { 
};
template <class _Ty1, class _Ty2>
struct is_swappable_with
    : _Is_swappable_with<_Ty1, _Ty2>::type { 
};
template <class _Ty1, class _Ty2>
inline constexpr bool is_swappable_with_v = is_swappable_with<_Ty1, _Ty2>::value;
template <class _Ty>
struct is_swappable : _Is_swappable<_Ty>::type { 
};
template <class _Ty>
inline constexpr bool is_swappable_v = is_swappable<_Ty>::value;
template <class _Ty1, class _Ty2>
struct is_nothrow_swappable_with
    : _Is_nothrow_swappable_with<_Ty1,
          _Ty2>::type { 
};
template <class _Ty1, class _Ty2>
inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Ty1, _Ty2>::value;
template <class _Ty>
struct is_nothrow_swappable
    : _Is_nothrow_swappable<_Ty>::type { 
};
template <class _Ty>
inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Ty>::value;
#line 1856 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
namespace _Has_ADL_swap_detail {
    void swap(); 
    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>> : true_type {};
} 
using _Has_ADL_swap_detail::_Has_ADL_swap;
template <class _Ty>
struct _Is_trivially_swappable : bool_constant<conjunction_v<is_trivially_destructible<_Ty>,
                                     is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>,
                                     negation<_Has_ADL_swap<_Ty>>>> { 
};
template <class _Ty>
inline constexpr bool _Is_trivially_swappable_v = _Is_trivially_swappable<_Ty>::value;
inline constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
inline constexpr size_t _FNV_prime        = 1099511628211ULL;
#line 1932 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { 
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }
    return _Val;
}
template <class _Ty>
[[nodiscard]] inline size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { 
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb  = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}
template <class _Kty>
[[nodiscard]] inline size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}
template <class _Kty>
[[nodiscard]] inline size_t _Hash_representation(
    const _Kty& _Keyval) noexcept { 
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}
template <class _Kty>
[[nodiscard]] inline size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}
template <class _Kty>
struct hash;
template <class _Kty,
    bool _Enabled>
struct _Conditionally_enabled_hash { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Kty argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const _Kty& _Keyval) const noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) { 
#line 1987 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};
template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { 
    _Conditionally_enabled_hash()                                   = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&)      = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
};
template <class _Kty>
struct hash
    : _Conditionally_enabled_hash<_Kty,
          !is_const_v<_Kty> && !is_volatile_v<_Kty> && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    static size_t _Do_hash(
        const _Kty& _Keyval) noexcept { 
        return _Hash_representation(_Keyval);
    }
};
template <>
struct hash<float> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef float argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const float _Keyval) const
        noexcept { 
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); 
    }
};
template <>
struct hash<double> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef double argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const double _Keyval) const
        noexcept { 
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); 
    }
};
template <>
struct hash<long double> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef long double argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const long double _Keyval) const
        noexcept { 
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); 
    }
};
template <>
struct hash<nullptr_t> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef nullptr_t argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(nullptr_t) const
        noexcept { 
        void* _Null{};
        return _Hash_representation(_Null);
    }
};
template <class _Kty,
    class = void>
struct _Is_nothrow_hashable : false_type { 
};
template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))> { 
#line 2063 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
};
#line 2130 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
}
#pragma warning(pop)
#pragma pack(pop)
#line 2138 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
#line 2139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\type_traits"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
[[deprecated("warning STL4006: " "std::uncaught_exception() is deprecated in C++17. " "It is superseded by std::uncaught_exceptions(), plural. " "You can define _SILENCE_CXX17_UNCAUGHT_EXCEPTION_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]]  bool __cdecl uncaught_exception() noexcept;
 int __cdecl uncaught_exceptions() noexcept;
}
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;
void* __cdecl _alloca(  size_t _Size);
     intptr_t __cdecl _get_heap_handle(void);
     int __cdecl _heapmin(void);
         int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
           int __cdecl _heapchk(void);
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
     int __cdecl _resetstkoflw(void);
#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
    typedef char __static_assert_t[(sizeof(unsigned int) <= 16) != 0];
    #pragma warning(push)
    #pragma warning(disable:6540)
    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }
    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }
    #pragma warning(pop)
#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
    #line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#line 143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
    #pragma warning(push)
    #pragma warning(disable: 6014)
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            else if (_Marker != 0xCCCC)
            {
                (void)( (!!((("Corrupted pointer passed to _freea" && 0)))) || (1 != _CrtDbgReportW(2, L"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h", 162, 0, L"%ls", L"(\"Corrupted pointer passed to _freea\" && 0)")) || (__debugbreak(), 0) );
            }
            #line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
        }
    }
    #pragma warning(pop)
#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
} __pragma(pack(pop))
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_exception.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\eh.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
typedef void (__cdecl* terminate_handler )();
typedef void (__cdecl* terminate_function)();
     __declspec(noreturn) void __cdecl abort();
     __declspec(noreturn) void __cdecl terminate() throw();
         terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();
         terminate_handler __cdecl _get_terminate();
    #line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"
#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"
} __pragma(pack(pop))
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\eh.h"
__pragma(pack(push, 8)) extern "C" {
typedef void (__cdecl* unexpected_handler )();
typedef void (__cdecl* unexpected_function)();
struct _EXCEPTION_POINTERS;
     __declspec(noreturn) void __cdecl unexpected() noexcept(false);
         unexpected_handler __cdecl set_unexpected(
              unexpected_handler _NewUnexpectedHandler
            ) noexcept;
         unexpected_handler __cdecl _get_unexpected() noexcept;
        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
         _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );
    #line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\eh.h"
    class type_info;
     int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );
     bool __cdecl __uncaught_exception();
     int  __cdecl __uncaught_exceptions();
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\eh.h"
} __pragma(pack(pop))
#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\eh.h"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_exception.h"
#pragma pack(push, 8)
__pragma(pack(push, 8)) extern "C" {
struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};
 void __cdecl __std_exception_copy(
       __std_exception_data const* _From,
      __std_exception_data*       _To
    );
 void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );
} __pragma(pack(pop))
namespace std {
#pragma warning(push)
#pragma warning(disable: 4577) 
class exception
{
public:
    exception() noexcept
        : _Data()
    {
    }
    explicit exception(char const* const _Message) noexcept
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }
    exception(char const* const _Message, int) noexcept
        : _Data()
    {
        _Data._What = _Message;
    }
    exception(exception const& _Other) noexcept
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }
    exception& operator=(exception const& _Other) noexcept
    {
        if (this == &_Other)
        {
            return *this;
        }
        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }
    virtual ~exception() noexcept
    {
        __std_exception_destroy(&_Data);
    }
    virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }
private:
    __std_exception_data _Data;
};
class bad_exception
    : public exception
{
public:
    bad_exception() noexcept
        : exception("bad exception", 1)
    {
    }
};
class bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept
        : exception("bad allocation", 1)
    {
    }
private:
    friend class bad_array_new_length;
    bad_alloc(char const* const _Message) noexcept
        : exception(_Message, 1)
    {
    }
};
class bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept
        : bad_alloc("bad array new length")
    {
    }
};
#pragma warning(pop)
} 
#line 146 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_exception.h"
#pragma pack(pop)
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
namespace std {
using ::terminate;
using ::set_terminate;
using ::terminate_handler;
[[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept { 
    return _get_terminate();
}
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
}
#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
 void __cdecl __ExceptionPtrCreate(  void*);
 void __cdecl __ExceptionPtrDestroy(  void*);
 void __cdecl __ExceptionPtrCopy(  void*,   const void*);
 void __cdecl __ExceptionPtrAssign(  void*,   const void*);
 bool __cdecl __ExceptionPtrCompare(  const void*,   const void*);
 bool __cdecl __ExceptionPtrToBool(  const void*);
 void __cdecl __ExceptionPtrSwap(  void*,   void*);
 void __cdecl __ExceptionPtrCurrentException(  void*);
[[noreturn]]  void __cdecl __ExceptionPtrRethrow(  const void*);
 void __cdecl __ExceptionPtrCopyException(
      void*,   const void*,   const void*);
namespace std {
class exception_ptr {
public:
    exception_ptr() noexcept {
        __ExceptionPtrCreate(this);
    }
    exception_ptr(nullptr_t) noexcept {
        __ExceptionPtrCreate(this);
    }
    ~exception_ptr() noexcept {
        __ExceptionPtrDestroy(this);
    }
    exception_ptr(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrCopy(this, &_Rhs);
    }
    exception_ptr& operator=(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrAssign(this, &_Rhs);
        return *this;
    }
    exception_ptr& operator=(nullptr_t) noexcept {
        exception_ptr _Ptr;
        __ExceptionPtrAssign(this, &_Ptr);
        return *this;
    }
    explicit operator bool() const noexcept {
        return __ExceptionPtrToBool(this);
    }
    [[noreturn]] void _RethrowException() const {
        __ExceptionPtrRethrow(this);
    }
    static exception_ptr _Current_exception() noexcept {
        exception_ptr _Retval;
        __ExceptionPtrCurrentException(&_Retval);
        return _Retval;
    }
    static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr) {
        exception_ptr _Retval;
        if (!_Ptr) {
            return _Retval;
        }
        __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
        return _Retval;
    }
private:
    void* _Data1;
    void* _Data2;
};
inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept {
    __ExceptionPtrSwap(&_Lhs, &_Rhs);
}
[[nodiscard]] inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
    return __ExceptionPtrCompare(&_Lhs, &_Rhs);
}
[[nodiscard]] inline bool operator==(nullptr_t, const exception_ptr& _Rhs) noexcept {
    return !_Rhs;
}
[[nodiscard]] inline bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept {
    return !_Lhs;
}
[[nodiscard]] inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
    return !(_Lhs == _Rhs);
}
[[nodiscard]] inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) noexcept {
    return !(_Lhs == _Rhs);
}
[[nodiscard]] inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) noexcept {
    return !(_Lhs == _Rhs);
}
[[nodiscard]] inline exception_ptr current_exception() noexcept {
    return exception_ptr::_Current_exception();
}
[[noreturn]] inline void rethrow_exception(  exception_ptr _Ptr) {
    _Ptr._RethrowException();
}
template <class _Ex>
void* __GetExceptionInfo(_Ex);
template <class _Ex>
[[nodiscard]] exception_ptr make_exception_ptr(_Ex _Except) noexcept {
    return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
}
class nested_exception { 
public:
    nested_exception() noexcept : _Exc(::std:: current_exception()) { 
    }
    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept {}
    [[noreturn]] void rethrow_nested() const { 
        if (_Exc) {
            ::std:: rethrow_exception(_Exc);
        } else {
            ::std:: terminate();
        }
    }
    [[nodiscard]] exception_ptr nested_ptr() const noexcept { 
        return _Exc;
    }
private:
    exception_ptr _Exc;
};
template <class _Ty, class _Uty>
struct _With_nested : _Uty, nested_exception { 
    explicit _With_nested(_Ty&& _Arg)
        : _Uty(::std:: forward<_Ty>(_Arg)), nested_exception() { 
    }
};
template <class _Ty>
[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, true_type) { 
    using _Uty   = decay_t<_Ty>;
    using _Glued = _With_nested<_Ty, _Uty>;
    throw _Glued(::std:: forward<_Ty>(_Arg));
}
template <class _Ty>
[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, false_type) { 
    throw ::std:: forward<_Ty>(_Arg);
}
template <class _Ty>
[[noreturn]] inline void throw_with_nested(_Ty&& _Arg) { 
    using _Uty = decay_t<_Ty>;
    bool_constant<is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>> _Tag;
    _Throw_with_nested(::std:: forward<_Ty>(_Arg), _Tag);
}
template <class _Ty>
void rethrow_if_nested(const _Ty&) = delete; 
#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
}
#pragma warning(pop)
#pragma pack(pop)
#line 416 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
#line 417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\exception"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\new"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Ty>
[[nodiscard]] constexpr _Ty* launder(_Ty* _Ptr) noexcept {
    static_assert(!is_function_v<_Ty> && !is_void_v<_Ty>,
        "N4727 21.6.4 [ptr.launder]/3: The program is ill-formed if T is a function type or cv void.");
    return __builtin_launder(_Ptr);
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\new"
}
inline constexpr size_t hardware_constructive_interference_size = 64;
inline constexpr size_t hardware_destructive_interference_size  = 64;
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\new"
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\new"
using new_handler = void(__cdecl*)();
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\new"
 new_handler __cdecl set_new_handler(  new_handler) noexcept;
[[nodiscard]]  new_handler __cdecl get_new_handler() noexcept;
}
#pragma warning(pop)
#pragma pack(pop)
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\new"
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\new"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstring"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
 int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );
 int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );
#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
     void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
     int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }
#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
} __pragma(pack(pop))
#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__pragma(pack(push, 8)) extern "C" {
     errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );
     errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );
     errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);
     errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );
     errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );
     char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 84 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(pop)
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );
 int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );
 int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );
 int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(pop)
 size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );
#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char*  __cdecl _strerror(
      char const* _ErrorMessage
    );
 errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl strerror(
      int _ErrorMessage
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );
 int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );
 int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );
 int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );
size_t __cdecl strlen(
      char const* _Str
    );
 errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strlwr( char *_String);
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 258 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );
 int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );
 int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );
 int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );
 int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );
 int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );
 int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );
 size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }
#line 380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );
 char* __cdecl _strrev(
      char* _Str
    );
 errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strset( char *_Destination,  int _Value);
#line 432 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );
 errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 455 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strupr( char *_String);
#line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
 size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );
 size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );
extern "C++"
{
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 528 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
     char* __cdecl strdup(
          char const* _String
        );
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
     int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
     int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
     char* __cdecl strlwr(
          char* _String
        );
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
     int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
     char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
     char* __cdecl strrev(
          char* _String
        );
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
     char* __cdecl strupr(
          char* _String
        );
#line 589 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
} __pragma(pack(pop))
#line 595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstring"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 
using :: size_t;
using :: memchr;
using :: memcmp;
using :: memcpy;
using :: memmove;
using :: memset;
using :: strcat;
using :: strchr;
using :: strcmp;
using :: strcoll;
using :: strcpy;
using :: strcspn;
using :: strerror;
using :: strlen;
using :: strncat;
using :: strncmp;
using :: strncpy;
using :: strpbrk;
using :: strrchr;
using :: strspn;
using :: strstr;
using :: strtok;
using :: strxfrm;
#pragma warning(pop)
}
#pragma warning(pop)
#pragma pack(pop)
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstring"
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cstring"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Ty>
  constexpr const _Ty& _Min_value(const _Ty& _Left, const _Ty& _Right)
    noexcept(noexcept(_Right < _Left)) { 
    return _Right < _Left ? _Right : _Left;
}
template <class _Ty>
  constexpr const _Ty& _Max_value(const _Ty& _Left, const _Ty& _Right)
    noexcept(noexcept(_Left < _Right)) { 
    return _Left < _Right ? _Right : _Left;
}
template <class _FwdIt1, class _FwdIt2>
inline void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { 
    swap(*_Left, *_Right);
}
template <class _Ty, size_t _Size, class>
inline void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
    noexcept(_Is_nothrow_swappable<_Ty>::value) { 
    if (&_Left != &_Right) { 
        _Ty* _First1 = _Left;
        _Ty* _Last1  = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            ::std:: iter_swap(_First1, _First2);
        }
    }
}
template <class _Ty, class>
inline void swap(_Ty& _Left, _Ty& _Right) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) { 
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
    _Ty _Tmp = ::std:: move(_Left);
    _Left    = ::std:: move(_Right);
    _Right   = ::std:: move(_Tmp);
}
template <class _Ty>
inline void _Swap_adl(_Ty& _Left, _Ty& _Right)
    noexcept(_Is_nothrow_swappable<_Ty>::value) { 
    swap(_Left, _Right);
}
struct piecewise_construct_t { 
    explicit piecewise_construct_t() = default;
};
inline constexpr piecewise_construct_t piecewise_construct{};
template <class...>
class tuple;
template <class _Ty1,
    class _Ty2>
struct pair { 
    using first_type  = _Ty1;
    using second_type = _Ty2;
    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>,
                        _Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>,
            int> = 0>
    constexpr pair() noexcept(is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) 
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        : first(), second() {}
    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>,
                        negation<conjunction<_Is_implicitly_default_constructible<_Uty1>,
                            _Is_implicitly_default_constructible<_Uty2>>>>,
            int> = 0>
    constexpr explicit pair() noexcept(is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) 
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        : first(), second() {}
    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>,
                        is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>,
            int> = 0>
    constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
        noexcept(is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) 
        : first(_Val1), second(_Val2) {}
    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<
            conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>,
                negation<conjunction<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>>>,
            int> = 0>
    constexpr explicit pair(const _Ty1& _Val1, const _Ty2& _Val2)
        noexcept(is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) 
        : first(_Val1), second(_Val2) {}
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>,
            int> = 0>
    constexpr pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {}
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>>>,
            int> = 0>
    constexpr explicit pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {}
    pair(const pair&) = default;
    pair(pair&&)      = default;
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>,
                        is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>,
            int> = 0>
    constexpr pair(const pair<_Other1, _Other2>& _Right)
        noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&& is_nothrow_constructible_v<_Ty2, const _Other2&>) 
#line 143 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        : first(_Right.first), second(_Right.second) {}
    template <class _Other1, class _Other2,
        enable_if_t<
            conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>,
                negation<conjunction<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>>>,
            int> = 0>
    constexpr explicit pair(const pair<_Other1, _Other2>& _Right)
        noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&& is_nothrow_constructible_v<_Ty2, const _Other2&>) 
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        : first(_Right.first), second(_Right.second) {}
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>,
            int> = 0>
    constexpr pair(pair<_Other1, _Other2>&& _Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>,
                        negation<conjunction<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>>>,
            int> = 0>
    constexpr explicit pair(pair<_Other1, _Other2>&& _Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
#line 169 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}
    template <class _Tuple1, class _Tuple2, size_t... _Indexes1, size_t... _Indexes2>
    inline pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>);
    template <class... _Types1, class... _Types2>
    inline pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2);
    pair& operator=(const volatile pair&) = delete;
    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>) { 
#line 185 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }
    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>) { 
#line 197 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        first  = ::std:: forward<_Ty1>(_Right.first);
        second = ::std:: forward<_Ty2>(_Right.second);
        return *this;
    }
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
                        is_assignable<_Ty2&, const _Other2&>>,
            int> = 0>
    pair& operator=(const pair<_Other1, _Other2>& _Right)
        noexcept(is_nothrow_assignable_v<_Ty1&, const _Other1&>&& is_nothrow_assignable_v<_Ty2&, const _Other2&>) { 
#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
                        is_assignable<_Ty2&, _Other2>>,
            int> = 0>
    pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>) { 
#line 222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
        first  = ::std:: forward<_Other1>(_Right.first);
        second = ::std:: forward<_Other2>(_Right.second);
        return *this;
    }
    void swap(pair& _Right) noexcept(_Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {
        if (this != ::std:: addressof(_Right)) { 
            _Swap_adl(first, _Right.first);
            _Swap_adl(second, _Right.second);
        }
    }
    _Ty1 first; 
    _Ty2 second; 
};
template <class _Ty1, class _Ty2>
pair(_Ty1, _Ty2)->pair<_Ty1, _Ty2>;
#line 243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
template <class _Ty1, class _Ty2, class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>>
inline void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
    noexcept(noexcept(_Left.swap(_Right))) { 
    _Left.swap(_Right);
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator==(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { 
    return _Left.first == _Right.first && _Left.second == _Right.second;
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator!=(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { 
    return !(_Left == _Right);
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { 
    return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { 
    return _Right < _Left;
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<=(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { 
    return !(_Right < _Left);
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>=(
    const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) { 
    return !(_Left < _Right);
}
template <class _Ty>
struct _Unrefwrap_helper { 
    using type = _Ty;
};
template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> { 
    using type = _Ty&;
};
template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(
    _Ty1&& _Val1, _Ty2&& _Val2) { 
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(::std:: forward<_Ty1>(_Val1), ::std:: forward<_Ty2>(_Val2));
}
namespace rel_ops { 
    template <class _Ty>
    [[nodiscard]] inline bool operator!=(
        const _Ty& _Left, const _Ty& _Right) { 
        return !(_Left == _Right);
    }
    template <class _Ty>
    [[nodiscard]] inline bool operator>(
        const _Ty& _Left, const _Ty& _Right) { 
        return _Right < _Left;
    }
    template <class _Ty>
    [[nodiscard]] inline bool operator<=(
        const _Ty& _Left, const _Ty& _Right) { 
        return !(_Right < _Left);
    }
    template <class _Ty>
    [[nodiscard]] inline bool operator>=(
        const _Ty& _Left, const _Ty& _Right) { 
        return !(_Left < _Right);
    }
} 
}
namespace std {
template <class _Tuple>
struct tuple_size;
template <class _Tuple,
    class = void>
struct _Tuple_size_sfinae { 
};
template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> { 
};
template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> { 
};
template <class _Tuple>
struct tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> { 
};
template <class _Tuple>
struct tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> { 
};
template <class _Ty>
inline constexpr size_t tuple_size_v = tuple_size<_Ty>::value;
template <size_t _Index, class _Tuple>
struct tuple_element;
template <size_t _Index, class _Tuple>
struct tuple_element<_Index, const _Tuple> : public tuple_element<_Index, _Tuple> { 
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_const_t<typename _Mybase::type>;
};
template <size_t _Index, class _Tuple>
struct tuple_element<_Index, volatile _Tuple> : public tuple_element<_Index, _Tuple> { 
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_volatile_t<typename _Mybase::type>;
};
template <size_t _Index, class _Tuple>
struct tuple_element<_Index, const volatile _Tuple>
    : public tuple_element<_Index, _Tuple> { 
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_cv_t<typename _Mybase::type>;
};
template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;
template <class _Ty, size_t _Size>
class array;
template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>>
    : integral_constant<size_t, _Size> { 
};
template <size_t _Idx, class _Ty, size_t _Size>
struct tuple_element<_Idx, array<_Ty, _Size>> { 
    static_assert(_Idx < _Size, "array index out of bounds");
    using type = _Ty;
};
template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> { 
};
template <size_t _Index>
struct tuple_element<_Index, tuple<>> { 
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};
template <class _This, class... _Rest>
struct tuple_element<0, tuple<_This, _Rest...>> { 
    using type   = _This;
    using _Ttype = tuple<_This, _Rest...>;
};
template <size_t _Index, class _This, class... _Rest>
struct tuple_element<_Index, tuple<_This, _Rest...>>
    : public tuple_element<_Index - 1, tuple<_Rest...>> { 
};
template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> { 
};
template <size_t _Idx, class _Ty1, class _Ty2>
struct tuple_element<_Idx, pair<_Ty1, _Ty2>> { 
    static_assert(_Idx < 2, "pair index out of bounds");
    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};
template <class _Ret, class _Pair>
constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 0>) noexcept { 
    return _Pr.first;
}
template <class _Ret, class _Pair>
constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 1>) noexcept { 
    return _Pr.second;
}
template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(
    pair<_Ty1, _Ty2>& _Pr) noexcept { 
    using _Rtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
    return _Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>());
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<0>(_Pr);
}
template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<1>(_Pr);
}
template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { 
    using _Ctype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
    return _Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>());
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<0>(_Pr);
}
template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2& get(
    const pair<_Ty1, _Ty2>& _Pr) noexcept { 
    return ::std:: get<1>(_Pr);
}
template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(
    pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    using _RRtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
    return ::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr));
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<0>(::std:: move(_Pr));
}
template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<1>(::std:: move(_Pr));
}
template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    using _RRtype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
    return ::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr));
}
template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<0>(::std:: move(_Pr));
}
template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2&& get(
    const pair<_Ty1, _Ty2>&& _Pr) noexcept { 
    return ::std:: get<1>(::std:: move(_Pr));
}
template <class _Ty, class _Other = _Ty>
inline _Ty exchange(_Ty& _Val, _Other&& _New_val) { 
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val         = static_cast<_Other&&>(_New_val);
    return _Old_val;
}
template <class _Ty>
[[nodiscard]] constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept { 
    return _Val;
}
template <class _Ty>
void as_const(const _Ty&&) = delete;
struct in_place_t { 
    explicit in_place_t() = default;
};
inline constexpr in_place_t in_place{};
template <class>
struct in_place_type_t { 
    explicit in_place_type_t() = default;
};
template <class _Ty>
inline constexpr in_place_type_t<_Ty> in_place_type{};
template <size_t>
struct in_place_index_t { 
    explicit in_place_index_t() = default;
};
template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};
#line 561 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
#line 569 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
}
#pragma warning(pop)
#pragma pack(pop)
#line 577 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
#line 578 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\utility"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
extern "C" {
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
}
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
namespace std {
template <class _Fx>
struct _Ref_fn { 
    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals) { 
        return _Fn(::std:: forward<_Args>(_Vals)...);
    }
    _Fx& _Fn;
};
template <class _Fn>
inline constexpr bool
    _Pass_functor_by_value_v = sizeof(_Fn) <= sizeof(void*)
                               && conjunction_v<is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
template <class _Fn, enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0>
constexpr _Fn _Pass_fn(_Fn _Val) { 
    return _Val;
}
template <class _Fn, enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0>
constexpr _Ref_fn<_Fn> _Pass_fn(_Fn& _Val) { 
    return {_Val};
}
struct input_iterator_tag { 
};
struct output_iterator_tag { 
};
struct forward_iterator_tag : input_iterator_tag { 
};
struct bidirectional_iterator_tag : forward_iterator_tag { 
};
struct random_access_iterator_tag : bidirectional_iterator_tag { 
};
struct _Unused_parameter { 
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept {}
};
using _Any_tag = _Unused_parameter; 
template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;
template <class,
    class = void>
struct _Iterator_traits_base { 
};
template <class _Iter>
struct _Iterator_traits_base<_Iter, void_t<typename _Iter::iterator_category, typename _Iter::value_type,
                                        typename _Iter::difference_type, typename _Iter::pointer,
                                        typename _Iter::reference>> { 
    using iterator_category = typename _Iter::iterator_category;
    using value_type        = typename _Iter::value_type;
    using difference_type   = typename _Iter::difference_type;
    using pointer   = typename _Iter::pointer;
    using reference = typename _Iter::reference;
};
template <class _Ty,
    bool = is_object_v<_Ty>>
struct _Iterator_traits_pointer_base { 
    using iterator_category = random_access_iterator_tag;
    using value_type        = remove_cv_t<_Ty>;
    using difference_type   = ptrdiff_t;
    using pointer   = _Ty*;
    using reference = _Ty&;
};
template <class _Ty>
struct _Iterator_traits_pointer_base<_Ty, false> { 
};
template <class _Iter>
struct iterator_traits : _Iterator_traits_base<_Iter> { 
};
template <class _Ty>
struct iterator_traits<_Ty*> : _Iterator_traits_pointer_base<_Ty> { 
};
template <class _Iter>
using _Iter_value_t = typename iterator_traits<_Iter>::value_type;
template <class _Iter>
using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;
template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;
template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;
template <class _Ty, class = void>
inline constexpr bool _Is_iterator_v = false;
template <class _Ty>
inline constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;
template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};
template <class _Iter>
inline constexpr bool _Is_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;
template <class _Iter>
inline constexpr bool _Is_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;
template <class _Iter>
inline constexpr bool _Is_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;
template <class _Iter>
inline constexpr bool _Is_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;
template <class,
    class = void>
struct _Is_checked_helper { 
};
template <class _Ty>
constexpr void _Verify_range(
    const _Ty* const _First, const _Ty* const _Last) noexcept { 
    do { if (_First <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 191, 0, "%s", "transposed pointer range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"transposed pointer range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 191, 0); } while (false); } ; } while (false);
}
#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Iter, class = void>
struct _Allow_inheriting_unwrap : true_type {};
template <class _Iter>
struct _Allow_inheriting_unwrap<_Iter, enable_if_t<!is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>>>
    : false_type {};
template <class _Iter, class _Sentinel = _Iter, class = void>
struct _Range_verifiable : false_type {};
template <class _Iter, class _Sentinel>
struct _Range_verifiable<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(::std:: declval<const _Iter&>(), ::std:: declval<const _Sentinel&>()))>>
    : _Allow_inheriting_unwrap<_Iter>::type {};
template <class _Iter, class _Sentinel = _Iter>
inline constexpr bool _Range_verifiable_v = _Range_verifiable<_Iter, _Sentinel>::value;
template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(
    const _Iter& _First, const _Sentinel& _Last) { 
    if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    } else {
        (void) _First; 
        (void) _Last; 
    }
}
#line 242 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Iter, class = void>
struct _Unwrappable : false_type {};
template <class _Iter>
struct _Unwrappable<_Iter, void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<const _Iter&>()._Unwrapped()))>>
    : _Allow_inheriting_unwrap<_Iter>::type {};
template <class _Iter>
inline constexpr bool _Unwrappable_v = _Unwrappable<_Iter>::value;
template <class _Iter, enable_if_t<_Unwrappable_v<_Iter>, int> = 0>
[[nodiscard]] constexpr auto _Get_unwrapped(
    const _Iter& _It) { 
    return _It._Unwrapped();
}
template <class _Iter, enable_if_t<!_Unwrappable_v<_Iter>, int> = 0>
[[nodiscard]] constexpr const _Iter& _Get_unwrapped(
    const _Iter& _It) { 
    return _It;
}
template <class _Iter, enable_if_t<!_Unwrappable_v<_Iter>, int> = 0>
[[nodiscard]] constexpr const _Iter&& _Get_unwrapped(
    const _Iter&& _It) { 
    return static_cast<const _Iter&&>(_It);
}
template <class _Ty>
[[nodiscard]] constexpr _Ty* _Get_unwrapped(_Ty* const _Ptr) { 
    return _Ptr;
}
template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(::std:: declval<const _Iter&>()))>;
template <class _Iter, class = bool>
struct _Do_unwrap_when_unverified : false_type {};
template <class _Iter>
struct _Do_unwrap_when_unverified<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))>
    : bool_constant<static_cast<bool>(_Iter::_Unwrap_when_unverified)> {};
template <class _Iter>
inline constexpr bool _Do_unwrap_when_unverified_v = _Do_unwrap_when_unverified<_Iter>::value;
template <class _Iter>
inline constexpr bool _Unwrappable_for_unverified_v = _Unwrappable_v<_Iter>&& _Do_unwrap_when_unverified_v<_Iter>;
template <class _Iter, enable_if_t<_Unwrappable_for_unverified_v<_Iter>, int> = 0>
[[nodiscard]] constexpr auto _Get_unwrapped_unverified(
    const _Iter& _It) { 
    return _It._Unwrapped();
}
template <class _Iter, enable_if_t<!_Unwrappable_for_unverified_v<_Iter>, int> = 0>
[[nodiscard]] constexpr const _Iter& _Get_unwrapped_unverified(
    const _Iter& _It) { 
    return _It;
}
template <class _Iter, enable_if_t<!_Unwrappable_for_unverified_v<_Iter>, int> = 0>
[[nodiscard]] constexpr const _Iter&& _Get_unwrapped_unverified(
    const _Iter&& _It) { 
    return static_cast<const _Iter&&>(_It);
}
template <class _Ty>
[[nodiscard]] constexpr _Ty* _Get_unwrapped_unverified(_Ty* const _Ptr) { 
    return _Ptr;
}
template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std:: declval<const _Iter&>()))>;
struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};
template <class _Diff>
inline constexpr _Diff _Max_possible_v = static_cast<_Diff>(static_cast<make_unsigned_t<_Diff>>(-1) >> 1);
template <class _Diff>
inline constexpr _Diff _Min_possible_v = -_Max_possible_v<_Diff> - 1;
template <class _Iter, class = void>
struct _Offset_verifiable : false_type {};
template <class _Iter>
struct _Offset_verifiable<_Iter, void_t<decltype(::std:: declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>>
    : true_type {};
template <class _Iter>
inline constexpr bool _Offset_verifiable_v = _Offset_verifiable<_Iter>::value;
template <class _Iter>
inline constexpr bool _Unwrappable_for_offset_v = _Unwrappable_v<_Iter>&& _Offset_verifiable_v<_Iter>;
template <class _Iter, class _Diff, enable_if_t<_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>, int> = 0>
[[nodiscard]] constexpr auto _Get_unwrapped_n(const _Iter& _It,
    const _Diff _Off) { 
    using _IDiff     = _Iter_diff_t<_Iter>;
    using _CDiff     = common_type_t<_Diff, _IDiff>;
    const auto _COff = static_cast<_CDiff>(_Off);
    do { if (_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>) && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 356, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"integer overflow\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 356, 0); } while (false); } ; } while (false);
#line 357 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
    (void) _COff;
    _It._Verify_offset(static_cast<_IDiff>(_Off));
    return _It._Unwrapped();
}
template <class _Iter, class _Diff,
    enable_if_t<
        _Unwrappable_for_unverified_v<_Iter> 
            && ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) || is_same_v<_Diff, _Distance_unknown>),
        int> = 0>
[[nodiscard]] constexpr auto _Get_unwrapped_n(const _Iter& _It,
    _Diff) { 
    return _It._Unwrapped();
}
template <class _Iter, class _Diff,
    enable_if_t<
        !_Unwrappable_for_unverified_v<_Iter> 
            && ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) || is_same_v<_Diff, _Distance_unknown>),
        int> = 0>
[[nodiscard]] constexpr const _Iter& _Get_unwrapped_n(
    const _Iter& _It, _Diff) { 
    return _It;
}
template <class _Iter, class _Diff,
    enable_if_t<
        !_Unwrappable_for_unverified_v<_Iter> 
            && ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) || is_same_v<_Diff, _Distance_unknown>),
        int> = 0>
[[nodiscard]] constexpr const _Iter&& _Get_unwrapped_n(
    const _Iter&& _It, _Diff) { 
    return static_cast<const _Iter&&>(_It);
}
template <class _Ty, class _Diff, enable_if_t<is_same_v<_Diff, _Distance_unknown> || is_integral_v<_Diff>, int> = 0>
[[nodiscard]] constexpr _Ty* _Get_unwrapped_n(_Ty* const _Src, _Diff) {
    return _Src;
}
template <class _Iter>
using _Unwrapped_n_t = _Remove_cvref_t<decltype(_Get_unwrapped_n(::std:: declval<const _Iter&>(), _Iter_diff_t<_Iter>{}))>;
template <class _Iter, class _UIter, class = void>
struct _Wrapped_seekable : false_type {};
template <class _Iter, class _UIter>
struct _Wrapped_seekable<_Iter, _UIter,
    void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<const _UIter&>()))>> : true_type {};
template <class _Iter, class _UIter>
inline constexpr bool _Wrapped_seekable_v = _Wrapped_seekable<_Iter, _UIter>::value;
template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, const _UIter& _UIt) {
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(_UIt);
    } else {
        _It = _UIt;
    }
}
#line 432 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Ty>
constexpr void _Seek_wrapped(_Ty*& _It, _Ty* const _UIt) {
    _It = _UIt;
}
template <class _Ty,
    class = void>
struct _Is_allocator : false_type { 
};
template <class _Ty>
struct _Is_allocator<_Ty, void_t<typename _Ty::value_type, decltype(::std:: declval<_Ty&>().deallocate(
                                                               ::std:: declval<_Ty&>().allocate(size_t{1}), size_t{1}))>>
    : true_type { 
};
template <class _Iter>
using _Guide_key_t = remove_const_t<typename iterator_traits<_Iter>::value_type::first_type>;
template <class _Iter>
using _Guide_val_t = typename iterator_traits<_Iter>::value_type::second_type;
template <class _Iter>
using _Guide_pair_t = pair<add_const_t<typename iterator_traits<_Iter>::value_type::first_type>,
    typename iterator_traits<_Iter>::value_type::second_type>;
#line 462 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Ty>
struct is_execution_policy : false_type {};
template <class _Ty>
inline constexpr bool is_execution_policy_v = is_execution_policy<_Ty>::value;
template <class _ExPo>
using _Enable_if_execution_policy_t = typename remove_reference_t<_ExPo>::_Standard_execution_policy;
#line 481 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Checked, class _Iter>
inline auto _Idl_distance(const _Iter& _First,
    const _Iter& _Last) { 
    if constexpr (_Is_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    } else {
        (void) _First; 
        (void) _Last; 
        return _Distance_unknown{};
    }
}
#line 514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Elem,
    bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum { 
    using type = underlying_type_t<_Elem>;
};
template <class _Elem>
struct _Unwrap_enum<_Elem, false> { 
    using type = _Elem;
};
template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;
template <class>
class move_iterator;
template <class _Source,
    class _Dest>
struct _Ptr_cat_helper { 
    using _USource                        = _Unwrap_enum_t<_Source>;
    using _UDest                          = _Unwrap_enum_t<_Dest>;
    static constexpr bool _Really_trivial = conjunction_v<
        bool_constant<sizeof(_USource) == sizeof(_UDest) && is_same_v<bool, _USource> == is_same_v<bool, _UDest>>,
        is_integral<_USource>, is_integral<_UDest>>;
    static constexpr bool _Trivially_copyable = _Really_trivial;
};
template <class _Elem>
struct _Ptr_cat_helper<_Elem, _Elem> { 
    static constexpr bool _Really_trivial     = conjunction_v<is_trivial<_Elem>, is_trivially_copyable<_Elem>>;
    static constexpr bool _Trivially_copyable = is_trivially_copyable_v<_Elem>;
};
template <class _Anything>
struct _Ptr_cat_helper<_Anything*,
    const _Anything*> { 
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};
template <class _Anything>
struct _Ptr_cat_helper<_Anything*,
    volatile _Anything*> { 
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};
template <class _Anything>
struct _Ptr_cat_helper<_Anything*,
    const volatile _Anything*> { 
    static constexpr bool _Really_trivial     = true;
    static constexpr bool _Trivially_copyable = true;
};
struct _False_copy_cat {
    static constexpr bool _Really_trivial     = false;
    static constexpr bool _Trivially_copyable = false;
};
template <class _Source,
    class _Dest>
struct _Ptr_copy_cat : _False_copy_cat { 
};
template <class _Source, class _Dest>
struct _Ptr_copy_cat<_Source*, _Dest*>
    : conditional_t<is_trivially_assignable_v<_Dest&, _Source&>,
          _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>,
          _False_copy_cat> { 
};
template <class _Source, class _Dest>
struct _Ptr_copy_cat<move_iterator<_Source*>, _Dest*>
    : _Ptr_copy_cat<_Source*, _Dest*> { 
};
template <class _Source,
    class _Dest>
struct _Ptr_move_cat : _False_copy_cat { 
};
template <class _Source, class _Dest>
struct _Ptr_move_cat<_Source*, _Dest*>
    : conditional_t<is_trivially_assignable_v<_Dest&, _Source>,
          _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>,
          _False_copy_cat> { 
};
template <class _Source, class _Dest>
struct _Ptr_move_cat<move_iterator<_Source*>, _Dest*>
    : _Ptr_move_cat<_Source*, _Dest*> { 
};
#line 620 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Pr, class _Ty1, class _Ty2>
constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(noexcept(_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left))) { 
#line 630 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
    const auto _Result = static_cast<bool>(_Pred(_Left, _Right));
    if (_Result) {
        do { if (!_Pred(_Right, _Left)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 632, 0, "%s", "invalid comparator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid comparator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 632, 0); } while (false); } ; } while (false);
    }
    return _Result;
}
template <class _InIt, class _Sentinel, class _Pr>
inline void _Debug_order_unchecked(
    _InIt _First, _Sentinel _Last, _Pr&& _Pred) { 
    if constexpr (_Is_fwd_iter_v<_InIt>) {
        if (_First != _Last) {
            for (auto _Next = _First; ++_Next != _Last; _First = _Next) {
                do { if (!_Debug_lt_pred(_Pred, *_Next, *_First)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 646, 0, "%s", "sequence not ordered")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"sequence not ordered\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 646, 0); } while (false); } ; } while (false);
            }
        }
    } else {
        (void) _First; 
        (void) _Last; 
        (void) _Pred; 
    }
}
#line 677 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _OtherIt, class _InIt, class _Pr>
inline void _Debug_order_set_unchecked(
    _InIt _First, _InIt _Last, _Pr&& _Pred) { 
    if constexpr (is_same_v<_Iter_value_t<_OtherIt>, _Iter_value_t<_InIt>> && _Is_fwd_iter_v<_InIt>) {
        _Debug_order_unchecked(_First, _Last, _Pred);
    } else {
        (void) _First; 
        (void) _Last; 
        (void) _Pred; 
    }
}
#line 718 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#line 719 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt, class _Diff>
constexpr void advance(_InIt& _Where, _Diff _Off) { 
    if constexpr (_Is_random_iter_v<_InIt>) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v<_Diff>) {
            if constexpr (_Is_bidi_iter_v<_InIt>) {
                for (; _Off < 0; ++_Off) {
                    --_Where;
                }
            } else {
                do { if (_Off >= 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 734, 0, "%s", "negative advance of non-bidirectional iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"negative advance of non-bidirectional iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 734, 0); } while (false); } ; } while (false);
            }
        }
        for (; 0 < _Off; --_Off) {
            ++_Where;
        }
    }
}
#line 781 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) { 
    if constexpr (_Is_random_iter_v<_InIt>) {
        return _Last - _First; 
    } else {
        _Adl_verify_range(_First, _Last);
        auto _UFirst             = _Get_unwrapped(_First);
        const auto _ULast        = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }
        return _Off;
    }
}
#line 826 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First) { 
    return ++_First;
}
template <class _InIt>
[[nodiscard]] constexpr _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1) { 
    static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");
    ::std:: advance(_First, _Off);
    return _First;
}
template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First) { 
    return --_First;
}
template <class _BidIt>
[[nodiscard]] constexpr _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1) { 
    static_assert(_Is_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");
    ::std:: advance(_First, -_Off);
    return _First;
}
template <class _Ty>
struct pointer_traits;
template <class _Iterator>
constexpr _Iterator _Operator_arrow(_Iterator _Target, true_type) { 
    return _Target;
}
template <class _Iterator>
constexpr decltype(auto) _Operator_arrow(
    _Iterator&& _Target, false_type) { 
    return ::std:: forward<_Iterator>(_Target).operator->();
}
template <class _BidIt>
class reverse_iterator { 
public:
    using iterator_category = typename iterator_traits<_BidIt>::iterator_category;
    using value_type        = typename iterator_traits<_BidIt>::value_type;
    using difference_type   = typename iterator_traits<_BidIt>::difference_type;
    using pointer           = typename iterator_traits<_BidIt>::pointer;
    using reference         = typename iterator_traits<_BidIt>::reference;
    using iterator_type = _BidIt;
    constexpr reverse_iterator() : current() { 
    }
    constexpr explicit reverse_iterator(_BidIt _Right) : current(_Right) { 
    }
    template <class _Other>
    constexpr reverse_iterator(const reverse_iterator<_Other>& _Right)
        : current(_Right.base()) { 
    }
    template <class _Other>
    constexpr reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) { 
        current = _Right.base();
        return *this;
    }
    [[nodiscard]] constexpr _BidIt base() const { 
        return current;
    }
    [[nodiscard]] constexpr reference operator*() const { 
        _BidIt _Tmp = current;
        return *--_Tmp;
    }
    [[nodiscard]] constexpr pointer operator->() const { 
        _BidIt _Tmp = current;
        --_Tmp;
        return _Operator_arrow(_Tmp, is_pointer<_BidIt>());
    }
    constexpr reverse_iterator& operator++() { 
        --current;
        return *this;
    }
    constexpr reverse_iterator operator++(int) { 
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }
    constexpr reverse_iterator& operator--() { 
        ++current;
        return *this;
    }
    constexpr reverse_iterator operator--(int) { 
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }
    constexpr reverse_iterator& operator+=(const difference_type _Off) { 
        current -= _Off;
        return *this;
    }
    [[nodiscard]] constexpr reverse_iterator operator+(const difference_type _Off) const { 
        return reverse_iterator(current - _Off);
    }
    constexpr reverse_iterator& operator-=(const difference_type _Off) { 
        current += _Off;
        return *this;
    }
    [[nodiscard]] constexpr reverse_iterator operator-(const difference_type _Off) const { 
        return reverse_iterator(current + _Off);
    }
    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    using _Prevent_inheriting_unwrap = reverse_iterator;
    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const {
        do { if (_Off != _Min_possible_v<difference_type>) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 966, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"integer overflow\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 966, 0); } while (false); } ; } while (false);
        current._Verify_offset(-_Off);
    }
    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() const {
        return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(current._Unwrapped());
    }
    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;
    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, _Src>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) {
        current._Seek_to(_It.base());
    }
protected:
    _BidIt current; 
};
template <class _BidIt, class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
constexpr void _Verify_range(const reverse_iterator<_BidIt>& _First, const reverse_iterator<_BidIt2>& _Last) {
    _Verify_range(_Last.base(), _First.base()); 
}
template <class _BidIt>
[[nodiscard]] constexpr reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off,
    const reverse_iterator<_BidIt>& _Right) { 
    return _Right + _Off;
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr auto operator-(const reverse_iterator<_BidIt1>& _Left,
    const reverse_iterator<_BidIt2>& _Right)
    -> decltype(_Right.base() - _Left.base()) { 
    return _Right.base() - _Left.base();
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool operator==(const reverse_iterator<_BidIt1>& _Left,
    const reverse_iterator<_BidIt2>& _Right) { 
    return _Left.base() == _Right.base();
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool operator!=(const reverse_iterator<_BidIt1>& _Left,
    const reverse_iterator<_BidIt2>& _Right) { 
    return !(_Left == _Right);
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool operator<(const reverse_iterator<_BidIt1>& _Left,
    const reverse_iterator<_BidIt2>& _Right) { 
    return _Right.base() < _Left.base();
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool operator>(const reverse_iterator<_BidIt1>& _Left,
    const reverse_iterator<_BidIt2>& _Right) { 
    return _Right < _Left;
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool operator<=(const reverse_iterator<_BidIt1>& _Left,
    const reverse_iterator<_BidIt2>& _Right) { 
    return !(_Right < _Left);
}
template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool operator>=(const reverse_iterator<_BidIt1>& _Left,
    const reverse_iterator<_BidIt2>& _Right) { 
    return !(_Left < _Right);
}
template <class _BidIt>
[[nodiscard]] constexpr reverse_iterator<_BidIt> make_reverse_iterator(
    _BidIt _Iter) { 
    return reverse_iterator<_BidIt>(_Iter);
}
template <class _Container>
[[nodiscard]] constexpr auto begin(_Container& _Cont) -> decltype(_Cont.begin()) { 
    return _Cont.begin();
}
template <class _Container>
[[nodiscard]] constexpr auto begin(const _Container& _Cont) -> decltype(_Cont.begin()) { 
    return _Cont.begin();
}
template <class _Container>
[[nodiscard]] constexpr auto end(_Container& _Cont) -> decltype(_Cont.end()) { 
    return _Cont.end();
}
template <class _Container>
[[nodiscard]] constexpr auto end(const _Container& _Cont) -> decltype(_Cont.end()) { 
    return _Cont.end();
}
template <class _Ty,
    size_t _Size>
[[nodiscard]] constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept { 
    return _Array;
}
template <class _Ty,
    size_t _Size>
[[nodiscard]] constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept { 
    return _Array + _Size;
}
template <class _Container>
[[nodiscard]] constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std:: begin(_Cont)))
    -> decltype(::std:: begin(_Cont)) { 
    return ::std:: begin(_Cont);
}
template <class _Container>
[[nodiscard]] constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std:: end(_Cont)))
    -> decltype(::std:: end(_Cont)) { 
    return ::std:: end(_Cont);
}
template <class _Container>
[[nodiscard]] constexpr auto rbegin(_Container& _Cont)
    -> decltype(_Cont.rbegin()) { 
    return _Cont.rbegin();
}
template <class _Container>
[[nodiscard]] constexpr auto rbegin(const _Container& _Cont)
    -> decltype(_Cont.rbegin()) { 
    return _Cont.rbegin();
}
template <class _Container>
[[nodiscard]] constexpr auto rend(_Container& _Cont) -> decltype(_Cont.rend()) { 
    return _Cont.rend();
}
template <class _Container>
[[nodiscard]] constexpr auto rend(const _Container& _Cont) -> decltype(_Cont.rend()) { 
    return _Cont.rend();
}
template <class _Ty,
    size_t _Size>
[[nodiscard]] constexpr reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) { 
    return reverse_iterator<_Ty*>(_Array + _Size);
}
template <class _Ty,
    size_t _Size>
[[nodiscard]] constexpr reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) { 
    return reverse_iterator<_Ty*>(_Array);
}
template <class _Elem>
[[nodiscard]] constexpr reverse_iterator<const _Elem*> rbegin(
    initializer_list<_Elem> _Ilist) { 
    return reverse_iterator<const _Elem*>(_Ilist.end());
}
template <class _Elem>
[[nodiscard]] constexpr reverse_iterator<const _Elem*> rend(
    initializer_list<_Elem> _Ilist) { 
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}
template <class _Container>
[[nodiscard]] constexpr auto crbegin(const _Container& _Cont)
    -> decltype(::std:: rbegin(_Cont)) { 
    return ::std:: rbegin(_Cont);
}
template <class _Container>
[[nodiscard]] constexpr auto crend(const _Container& _Cont)
    -> decltype(::std:: rend(_Cont)) { 
    return ::std:: rend(_Cont);
}
template <class _Container>
[[nodiscard]] constexpr auto size(const _Container& _Cont) -> decltype(_Cont.size()) { 
    return _Cont.size();
}
template <class _Ty,
    size_t _Size>
[[nodiscard]] constexpr size_t size(const _Ty (&)[_Size]) noexcept { 
    return _Size;
}
template <class _Container>
[[nodiscard]] constexpr auto empty(const _Container& _Cont) -> decltype(_Cont.empty()) { 
    return _Cont.empty();
}
template <class _Ty,
    size_t _Size>
[[nodiscard]] constexpr bool empty(const _Ty (&)[_Size]) noexcept { 
    return false;
}
template <class _Elem>
[[nodiscard]] constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept { 
    return _Ilist.size() == 0;
}
template <class _Container>
[[nodiscard]] constexpr auto data(_Container& _Cont) -> decltype(_Cont.data()) { 
    return _Cont.data();
}
template <class _Container>
[[nodiscard]] constexpr auto data(const _Container& _Cont)
    -> decltype(_Cont.data()) { 
    return _Cont.data();
}
template <class _Ty,
    size_t _Size>
[[nodiscard]] constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept { 
    return _Array;
}
template <class _Elem>
[[nodiscard]] constexpr const _Elem* data(
    initializer_list<_Elem> _Ilist) noexcept { 
    return _Ilist.begin();
}
struct _Container_proxy;
struct _Iterator_base12;
struct _Iterator_base12_compatible { 
    _Container_proxy* _Myproxy{};
    _Iterator_base12* _Mynextiter{};
};
#line 1220 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Ty,
    size_t _Size>
class _Array_const_iterator
    : private _Iterator_base12_compatible
#line 1227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
{ 
public:
    using iterator_category = random_access_iterator_tag;
    using value_type      = _Ty;
    using difference_type = ptrdiff_t;
    using pointer         = const _Ty*;
    using reference       = const _Ty&;
    enum { _EEN_SIZE = _Size }; 
#line 1342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
    constexpr _Array_const_iterator() : _Ptr(), _Idx(0) { 
    }
    constexpr explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
        : _Ptr(_Parg), _Idx(_Off) { 
    }
    [[nodiscard]] constexpr reference operator*() const { 
        return *operator->();
    }
    [[nodiscard]] constexpr pointer operator->() const { 
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1354, 0, "%s", "cannot dereference value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1354, 0); } while (false); } ; } while (false);
        do { if (_Idx < _Size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1355, 0, "%s", "cannot dereference out of range array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference out of range array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1355, 0); } while (false); } ; } while (false);
        return _Ptr + _Idx;
    }
    constexpr _Array_const_iterator& operator++() { 
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1360, 0, "%s", "cannot increment value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1360, 0); } while (false); } ; } while (false);
        do { if (_Idx < _Size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1361, 0, "%s", "cannot increment array iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment array iterator past end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1361, 0); } while (false); } ; } while (false);
        ++_Idx;
        return *this;
    }
    constexpr _Array_const_iterator operator++(int) { 
        _Array_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    constexpr _Array_const_iterator& operator--() { 
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1373, 0, "%s", "cannot decrement value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1373, 0); } while (false); } ; } while (false);
        do { if (_Idx != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1374, 0, "%s", "cannot decrement array iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement array iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1374, 0); } while (false); } ; } while (false);
        --_Idx;
        return *this;
    }
    constexpr _Array_const_iterator operator--(int) { 
        _Array_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    constexpr void _Verify_offset(const ptrdiff_t _Off) const noexcept {
        if (_Off != 0) {
            do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1387, 0, "%s", "cannot seek value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1387, 0); } while (false); } ; } while (false);
        }
        if (_Off < 0) {
#pragma warning(suppress : 4146) 
            do { if (_Idx >= -static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1392, 0, "%s", "cannot seek array iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek array iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1392, 0); } while (false); } ; } while (false);
        }
        if (_Off > 0) {
            do { if (_Size - _Idx >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1396, 0, "%s", "cannot seek array iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek array iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1396, 0); } while (false); } ; } while (false);
        }
    }
    constexpr _Array_const_iterator& operator+=(const ptrdiff_t _Off) { 
        _Verify_offset(_Off);
        _Idx += _Off;
        return *this;
    }
    [[nodiscard]] constexpr _Array_const_iterator operator+(const ptrdiff_t _Off) const { 
        _Array_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    constexpr _Array_const_iterator& operator-=(const ptrdiff_t _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] constexpr _Array_const_iterator operator-(const ptrdiff_t _Off) const { 
        _Array_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] constexpr ptrdiff_t operator-(
        const _Array_const_iterator& _Right) const { 
        _Compat(_Right);
        return static_cast<ptrdiff_t>(_Idx - _Right._Idx);
    }
    [[nodiscard]] constexpr reference operator[](const ptrdiff_t _Off) const { 
        return *(*this + _Off);
    }
    [[nodiscard]] constexpr bool operator==(const _Array_const_iterator& _Right) const { 
        _Compat(_Right);
        return _Idx == _Right._Idx;
    }
    [[nodiscard]] constexpr bool operator!=(const _Array_const_iterator& _Right) const { 
        return !(*this == _Right);
    }
    [[nodiscard]] constexpr bool operator<(const _Array_const_iterator& _Right) const { 
        _Compat(_Right);
        return _Idx < _Right._Idx;
    }
    [[nodiscard]] constexpr bool operator>(const _Array_const_iterator& _Right) const { 
        return _Right < *this;
    }
    [[nodiscard]] constexpr bool operator<=(const _Array_const_iterator& _Right) const { 
        return !(_Right < *this);
    }
    [[nodiscard]] constexpr bool operator>=(const _Array_const_iterator& _Right) const { 
        return !(*this < _Right);
    }
    constexpr void _Compat(const _Array_const_iterator& _Right) const { 
        do { if (_Ptr == _Right._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1457, 0, "%s", "array iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1457, 0); } while (false); } ; } while (false);
    }
    using _Prevent_inheriting_unwrap = _Array_const_iterator;
    [[nodiscard]] constexpr pointer _Unwrapped() const {
        return _Ptr + _Idx;
    }
    constexpr void _Verify_with(const _Array_const_iterator& _Last) const noexcept {
        do { if (*this <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1468, 0, "%s", "array iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array iterator range transposed\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1468, 0); } while (false); } ; } while (false);
    }
    constexpr void _Seek_to(pointer _It) {
        _Idx = static_cast<size_t>(_It - _Ptr);
    }
private:
    pointer _Ptr; 
    size_t _Idx; 
#line 1479 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
};
template <class _Ty, size_t _Size>
constexpr void _Verify_range(
    const _Array_const_iterator<_Ty, _Size>& _First, const _Array_const_iterator<_Ty, _Size>& _Last) noexcept {
    _First._Verify_with(_Last);
}
#line 1489 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Array_const_iterator<_Ty, _Size> operator+(
    ptrdiff_t _Off, _Array_const_iterator<_Ty, _Size> _Next) { 
    return _Next += _Off;
}
template <class _Ty, size_t _Size>
class _Array_iterator : public _Array_const_iterator<_Ty, _Size> { 
public:
    using _Mybase           = _Array_const_iterator<_Ty, _Size>;
    using iterator_category = random_access_iterator_tag;
    using value_type      = _Ty;
    using difference_type = ptrdiff_t;
    using pointer         = _Ty*;
    using reference       = _Ty&;
    constexpr _Array_iterator() { 
    }
    constexpr explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
        : _Mybase(_Parg, _Off) { 
    }
    enum { _EEN_SIZE = _Size }; 
    [[nodiscard]] constexpr reference operator*() const { 
        return const_cast<reference>(_Mybase::operator*());
    }
    [[nodiscard]] constexpr pointer operator->() const { 
        return const_cast<pointer>(_Mybase::operator->());
    }
    constexpr _Array_iterator& operator++() { 
        ++*static_cast<_Mybase*>(this);
        return *this;
    }
    constexpr _Array_iterator operator++(int) { 
        _Array_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    constexpr _Array_iterator& operator--() { 
        --*static_cast<_Mybase*>(this);
        return *this;
    }
    constexpr _Array_iterator operator--(int) { 
        _Array_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    constexpr _Array_iterator& operator+=(const ptrdiff_t _Off) { 
        *static_cast<_Mybase*>(this) += _Off;
        return *this;
    }
    [[nodiscard]] constexpr _Array_iterator operator+(const ptrdiff_t _Off) const { 
        _Array_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    constexpr _Array_iterator& operator-=(const ptrdiff_t _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] constexpr _Array_iterator operator-(const ptrdiff_t _Off) const { 
        _Array_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] constexpr ptrdiff_t operator-(const _Mybase& _Right) const { 
        return *static_cast<const _Mybase*>(this) - _Right;
    }
    [[nodiscard]] constexpr reference operator[](const ptrdiff_t _Off) const { 
        return *(*this + _Off);
    }
    using _Prevent_inheriting_unwrap = _Array_iterator;
    [[nodiscard]] constexpr pointer _Unwrapped() const {
        return const_cast<pointer>(_Mybase::_Unwrapped());
    }
};
template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Array_iterator<_Ty, _Size> operator+(
    ptrdiff_t _Off, _Array_iterator<_Ty, _Size> _Next) { 
    return _Next += _Off;
}
template <class _Iter>
class move_iterator { 
public:
    using iterator_category = typename iterator_traits<_Iter>::iterator_category;
    using value_type        = typename iterator_traits<_Iter>::value_type;
    using difference_type   = typename iterator_traits<_Iter>::difference_type;
    using pointer           = _Iter;
    using _Ref0             = typename iterator_traits<_Iter>::reference;
    using reference         = conditional_t<is_reference_v<_Ref0>, remove_reference_t<_Ref0>&&, _Ref0>;
    using iterator_type     = _Iter;
    constexpr move_iterator() : current() { 
    }
    constexpr explicit move_iterator(iterator_type _Right)
        : current(_Right) { 
    }
    template <class _Iter2>
    constexpr move_iterator(const move_iterator<_Iter2>& _Right)
        : current(_Right.base()) { 
    }
    template <class _Iter2>
    constexpr move_iterator& operator=(const move_iterator<_Iter2>& _Right) { 
        current = _Right.base();
        return *this;
    }
    [[nodiscard]] constexpr _Iter base() const { 
        return current;
    }
    [[nodiscard]] constexpr reference operator*() const { 
        return static_cast<reference>(*current);
    }
    [[nodiscard]] constexpr pointer operator->() const { 
        return current;
    }
    constexpr move_iterator& operator++() { 
        ++current;
        return *this;
    }
    constexpr move_iterator operator++(int) { 
        move_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }
    constexpr move_iterator& operator--() { 
        --current;
        return *this;
    }
    constexpr move_iterator operator--(int) { 
        move_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }
    constexpr move_iterator& operator+=(const difference_type _Off) { 
        current += _Off;
        return *this;
    }
    [[nodiscard]] constexpr move_iterator operator+(const difference_type _Off) const { 
        return move_iterator(current + _Off);
    }
    constexpr move_iterator& operator-=(const difference_type _Off) { 
        current -= _Off;
        return *this;
    }
    [[nodiscard]] constexpr move_iterator operator-(const difference_type _Off) const { 
        return move_iterator(current - _Off);
    }
    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const { 
        return ::std:: move(current[_Off]);
    }
    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) {
        _Verify_range(_First.base(), _Last.base());
    }
    using _Prevent_inheriting_unwrap = move_iterator;
    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const {
        current._Verify_offset(_Off);
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() const {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(current._Unwrapped());
    }
    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>& _It) {
        current._Seek_to(_It.base());
    }
protected:
    iterator_type current; 
};
template <class _Iter>
[[nodiscard]] constexpr move_iterator<_Iter> operator+(typename move_iterator<_Iter>::difference_type _Off,
    const move_iterator<_Iter>& _Right) { 
    return _Right + _Off;
}
template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr auto operator-(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right)
    -> decltype(_Left.base() - _Right.base()) { 
    return _Left.base() - _Right.base();
}
template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator==(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) { 
    return _Left.base() == _Right.base();
}
template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator!=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) { 
    return !(_Left == _Right);
}
template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator<(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) { 
    return _Left.base() < _Right.base();
}
template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) { 
    return _Right < _Left;
}
template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator<=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) { 
    return !(_Right < _Left);
}
template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator>=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) { 
    return !(_Left < _Right);
}
template <class _Iter>
[[nodiscard]] constexpr move_iterator<_Iter> make_move_iterator(_Iter _It) { 
    return move_iterator<_Iter>(_It);
}
template <class _InIt, class _OutIt>
inline _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    :: memmove(_Dest_ch, _First_ch, _Count);
    return reinterpret_cast<_OutIt>(_Dest_ch + _Count);
}
template <class _InIt, class _OutIt>
inline _OutIt _Copy_memmove(move_iterator<_InIt> _First, move_iterator<_InIt> _Last, _OutIt _Dest) {
    return _Copy_memmove(_First.base(), _Last.base(), _Dest);
}
template <class _InIt, class _OutIt>
inline _OutIt _Copy_unchecked(
    _InIt _First, _InIt _Last, _OutIt _Dest) { 
    if constexpr (_Ptr_copy_cat<_InIt, _OutIt>::_Trivially_copyable) {
        return _Copy_memmove(_First, _Last, _Dest);
    } else {
        for (; _First != _Last; ++_Dest, (void) ++_First) {
            *_Dest = *_First;
        }
        return _Dest;
    }
}
#line 1814 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt, class _OutIt>
inline _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}
template <class _InIt, class _DestTy, size_t _DestSize>
inline _DestTy* copy(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: copy(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest))._Unwrapped();
}
#line 1831 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
    _FwdIt2 _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: copy(_First, _Last, _Dest);
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: copy(_First, _Last, _Dest);
}
#line 1851 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#line 1852 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt, class _Diff, class _OutIt>
inline _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Trivially_copyable) {
            _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
        } else {
            for (;;) {
                *_UDest = *_UFirst;
                ++_UDest;
                --_Count;
                if (_Count == 0) { 
                    break;
                }
                ++_UFirst;
            }
        }
        _Seek_wrapped(_Dest, _UDest);
    }
    return _Dest;
}
#line 1923 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _SourceTy, size_t _SourceSize, class _Diff, class _OutIt>
inline _OutIt copy_n(_SourceTy (&_First)[_SourceSize], _Diff _Count_raw,
    _OutIt _Dest) { 
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1930, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1930, 0); } while (false); } ; } while (false);
        _Seek_wrapped(_Dest, ::std:: copy_n(static_cast<_SourceTy*>(_First), _Count, _Get_unwrapped_n(_Dest, _Count)));
    }
    return _Dest;
}
template <class _InIt, class _Diff, class _DestTy, size_t _DestSize>
inline _DestTy* copy_n(_InIt _First, _Diff _Count_raw,
    _DestTy (&_Dest)[_DestSize]) { 
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1942, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1942, 0); } while (false); } ; } while (false);
        return ::std:: copy_n(_First, _Count, static_cast<_DestTy*>(_Dest));
    }
    return _Dest;
}
template <class _SourceTy, size_t _SourceSize, class _Diff, class _DestTy, size_t _DestSize>
inline _DestTy* copy_n(_SourceTy (&_First)[_SourceSize], _Diff _Count_raw,
    _DestTy (&_Dest)[_DestSize]) { 
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1954, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1954, 0); } while (false); } ; } while (false);
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1955, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 1955, 0); } while (false); } ; } while (false);
        return ::std:: copy_n(static_cast<_SourceTy*>(_First), _Count, static_cast<_DestTy*>(_Dest));
    }
    return _Dest;
}
#line 1962 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _ExPo, class _FwdIt1, class _Diff, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw,
    _FwdIt2 _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: copy_n(_First, _Count_raw, _Dest);
}
template <class _ExPo, class _SourceTy, size_t _SourceSize, class _Diff, class _FwdIt2,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 copy_n(_ExPo&&, _SourceTy (&_First)[_SourceSize], _Diff _Count_raw,
    _FwdIt2 _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: copy_n(_First, _Count_raw, _Dest);
}
template <class _ExPo, class _FwdIt1, class _Diff, class _DestTy, size_t _DestSize,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: copy_n(_First, _Count_raw, _Dest);
}
template <class _ExPo, class _SourceTy, size_t _SourceSize, class _Diff, class _DestTy, size_t _DestSize,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* copy_n(_ExPo&&, _SourceTy (&_First)[_SourceSize], _Diff _Count_raw,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    return ::std:: copy_n(_First, _Count_raw, _Dest);
}
#line 2000 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#line 2001 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _BidIt1, class _BidIt2>
inline _BidIt2 _Copy_backward_memmove(
    _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) { 
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    return static_cast<_BidIt2>(:: memmove(_Dest_ch - _Count, _First_ch, _Count));
}
template <class _BidIt1, class _BidIt2>
inline _BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
    return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}
template <class _BidIt1, class _BidIt2>
inline _BidIt2 copy_backward(
    _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    if constexpr (_Ptr_copy_cat<decltype(_ULast), decltype(_UDest)>::_Trivially_copyable) {
        _UDest = _Copy_backward_memmove(_UFirst, _ULast, _UDest);
    } else {
        while (_UFirst != _ULast) {
            *--_UDest = *--_ULast;
        }
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
#line 2066 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _ExPo, class _BidIt1, class _BidIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _BidIt2 copy_backward(_ExPo&&, _BidIt1 _First, _BidIt1 _Last,
    _BidIt2 _Dest) noexcept { 
    return ::std:: copy_backward(_First, _Last, _Dest);
}
#line 2075 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt, class _OutIt>
inline _OutIt _Move_unchecked(
    _InIt _First, _InIt _Last, _OutIt _Dest) { 
    if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
        return _Copy_memmove(_First, _Last, _Dest);
    } else {
        for (; _First != _Last; ++_Dest, (void) ++_First) {
            *_Dest = ::std:: move(*_First);
        }
        return _Dest;
    }
}
#line 2116 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt, class _OutIt>
inline _OutIt move(_InIt _First, _InIt _Last,
    _OutIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}
template <class _InIt, class _DestTy, size_t _DestSize>
inline _DestTy* move(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: move(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest))._Unwrapped();
}
#line 2134 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
    _FwdIt2 _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: move(_First, _Last, _Dest);
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: move(_First, _Last, _Dest);
}
#line 2154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#line 2155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _BidIt1, class _BidIt2>
inline _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
    _BidIt2 _Dest) { 
    if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
        return _Copy_backward_memmove(_First, _Last, _Dest);
    } else {
        while (_First != _Last) {
            *--_Dest = ::std:: move(*--_Last);
        }
        return _Dest;
    }
}
#line 2197 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _BidIt1, class _BidIt2>
inline _BidIt2 move_backward(
    _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}
template <class _ExPo, class _BidIt1, class _BidIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _BidIt2 move_backward(_ExPo&&, _BidIt1 _First, _BidIt1 _Last,
    _BidIt2 _Dest) noexcept { 
    return ::std:: move_backward(_First, _Last, _Dest);
}
#line 2217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Ty>
struct _Is_character : false_type { 
};
template <>
struct _Is_character<char> : true_type { 
};
template <>
struct _Is_character<signed char> : true_type { 
};
template <>
struct _Is_character<unsigned char> : true_type { 
};
template <class _FwdIt,
    class _Ty>
struct _Fill_memset_is_safe_helper { 
    using _Value_type = _Iter_value_t<_FwdIt>;
    using _Raw_ty         = _Unwrap_enum_t<_Ty>;
    using _Raw_value_type = _Unwrap_enum_t<_Value_type>;
    using type = bool_constant<conjunction_v<is_pointer<_FwdIt>,
        disjunction<conjunction<_Is_character<_Raw_ty>, _Is_character<_Raw_value_type>>,
            conjunction<is_same<bool, _Raw_ty>, is_same<bool, _Raw_value_type>>>,
        is_convertible<_Ty, _Value_type>>>;
};
template <class _FwdIt, class _Ty>
inline typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type _Fill_memset_is_safe(
    const _FwdIt&, const _Ty&) { 
    return {};
}
template <class _FwdIt, class _Ty>
inline void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val,
    false_type) { 
    for (; _First != _Last; ++_First) {
        *_First = _Val;
    }
}
template <class _FwdIt, class _Ty>
inline void _Fill_unchecked1(
    _FwdIt _First, _FwdIt _Last, const _Ty& _Val, true_type) { 
    :: memset(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First));
}
template <class _FwdIt, class _Ty>
inline void _Fill_unchecked(
    _FwdIt _First, _FwdIt _Last, const _Ty& _Val) { 
    _Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
}
template <class _FwdIt, class _Ty>
inline void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    _Fill_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val);
}
template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void fill(_ExPo&&, _FwdIt _First, _FwdIt _Last,
    const _Ty& _Val) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: fill(_First, _Last, _Val);
}
#line 2290 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _OutIt, class _Diff, class _Ty>
inline _OutIt _Fill_n_unchecked2(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
    false_type) { 
    for (; 0 < _Count; --_Count, (void) ++_Dest) {
        *_Dest = _Val;
    }
    return _Dest;
}
template <class _OutIt, class _Diff, class _Ty>
inline _OutIt _Fill_n_unchecked2(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
    true_type) { 
    :: memset(_Dest, static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
    return _Dest + _Count;
}
template <class _OutIt, class _Diff, class _Ty>
inline _OutIt fill_n(_OutIt _Dest, _Diff _Count_raw, const _Ty& _Val) { 
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        const auto _UDest = _Get_unwrapped_n(_Dest, _Count);
        _Seek_wrapped(_Dest, _Fill_n_unchecked2(_UDest, _Count, _Val, _Fill_memset_is_safe(_UDest, _Val)));
    }
    return _Dest;
}
template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt fill_n(_ExPo&&, _FwdIt _Dest, _Diff _Count_raw,
    const _Ty& _Val) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: fill_n(_Dest, _Count_raw, _Val);
}
#line 2330 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Elem1,
    class _Elem2>
struct _Value_equality_is_bitwise_equality
    : bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)> { 
};
template <class _Elem1, class _Elem2,
    class _Pr>
struct _Equal_memcmp_is_safe_helper : false_type { 
};
template <class _Elem1, class _Elem2>
struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, equal_to<>>
    : bool_constant<conjunction_v<bool_constant<sizeof(_Elem1) == sizeof(_Elem2)>, _Is_nonbool_integral<_Elem1>,
          _Is_nonbool_integral<_Elem2>, negation<is_volatile<_Elem1>>, negation<is_volatile<_Elem2>>,
          _Value_equality_is_bitwise_equality<_Elem1, _Elem2>>> { 
};
template <class _Elem1, class _Elem2>
struct _Equal_memcmp_is_safe_helper<_Elem1*, _Elem2*, equal_to<>>
    : is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2>>::type { 
};
template <>
struct _Equal_memcmp_is_safe_helper<byte, byte, equal_to<>> : true_type { 
};
#line 2368 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Elem>
struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<_Elem>>
    : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { 
};
template <class _Iter1, class _Iter2, class _Pr>
inline false_type _Equal_memcmp_is_safe(
    const _Iter1&, const _Iter2&, const _Pr&) { 
    return {};
}
template <class _Obj1, class _Obj2, class _Pr>
inline typename _Equal_memcmp_is_safe_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _Pr>::type
    _Equal_memcmp_is_safe(_Obj1* const&, _Obj2* const&, const _Pr&) { 
    return {};
}
template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (decltype(_Equal_memcmp_is_safe(_UFirst1, _UFirst2, _Pred))::value) {
        const auto _First1_ch = reinterpret_cast<const char*>(_UFirst1);
        const auto _First2_ch = reinterpret_cast<const char*>(_UFirst2);
        const auto _Count     = static_cast<size_t>(reinterpret_cast<const char*>(_ULast1) - _First1_ch);
        return :: memcmp(_First1_ch, _First2_ch, _Count) == 0;
    } else {
        for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }
        }
        return true;
    }
}
#line 2449 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt1, class _RightTy, size_t _RightSize, class _Pr, enable_if_t<!is_same_v<_RightTy*, _Pr>, int> = 0>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, _RightTy (&_First2)[_RightSize],
    _Pr _Pred) { 
    return ::std:: equal(_First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred));
}
#line 2457 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool equal(
    _ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, _Pr _Pred) noexcept;
template <class _ExPo, class _FwdIt1, class _RightTy, size_t _RightSize, class _Pr,
    enable_if_t<is_execution_policy_v<decay_t<_ExPo>> && !is_same_v<_RightTy*, _Pr>, int> >
[[nodiscard]] inline bool equal(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _RightTy (&_First2)[_RightSize],
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    _Adl_verify_range(_First1, _Last1);
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _Get_unwrapped(_First1), _Get_unwrapped(_Last1),
        _Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred));
}
#line 2474 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#line 2475 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) { 
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>());
}
template <class _InIt1, class _RightTy, size_t _RightSize>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1,
    _RightTy (&_First2)[_RightSize]) { 
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>());
}
#line 2489 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
    const _FwdIt2 _First2) noexcept { 
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to<>());
}
template <class _ExPo, class _FwdIt1, class _RightTy, size_t _RightSize, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
    _RightTy (&_First2)[_RightSize]) noexcept { 
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to<>());
}
#line 2504 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#line 2505 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_InIt1> && _Is_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }
        return ::std:: equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }
            if (_UFirst2 == _ULast2) {
                return false;
            }
            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }
            ++_UFirst1;
            ++_UFirst2;
        }
    }
}
#line 2584 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept;
#line 2590 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2,
    const _InIt2 _Last2) { 
    return ::std:: equal(_First1, _Last1, _First2, _Last2, equal_to<>());
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept { 
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to<>());
}
#line 2604 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Elem1, class _Elem2, class _FTy>
struct _Lex_compare_check_element_types_helper
    : bool_constant<conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, _Is_character<_FTy>,
          is_unsigned<_FTy>>> { 
};
template <class _Elem1, class _Elem2>
struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
    : bool_constant<conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, is_unsigned<_Elem1>,
          is_unsigned<_Elem2>>> { 
};
template <>
struct _Lex_compare_check_element_types_helper<byte, byte, byte>
    : true_type { 
};
template <>
struct _Lex_compare_check_element_types_helper<byte, byte, void>
    : true_type { 
};
#line 2631 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Memcmp_pr>
struct _Lex_compare_optimize { 
};
template <class _Memcmp_pr, class _Obj1, class _Obj2, class _FTy>
using _Lex_compare_check_element_types = _Lex_compare_optimize<
    conditional_t<_Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value,
        _Memcmp_pr, void>>; 
template <class _InIt1, class _InIt2, class _Pr>
inline _Lex_compare_optimize<void> _Lex_compare_memcmp_classify(
    const _InIt1&, const _InIt2&, const _Pr&) { 
    return {};
}
template <class _Obj1, class _Obj2, class _FTy>
inline _Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy> _Lex_compare_memcmp_classify(_Obj1* const&,
    _Obj2* const&, const less<_FTy>&) { 
    return {};
}
template <class _Obj1, class _Obj2, class _FTy>
inline _Lex_compare_check_element_types<greater<int>, _Obj1, _Obj2, _FTy> _Lex_compare_memcmp_classify(_Obj1* const&,
    _Obj2* const&,
    const greater<_FTy>&) { 
    return {};
}
template <class _InIt1, class _InIt2, class _Pr>
inline bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
    _Lex_compare_optimize<void>) { 
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) { 
        if (_Debug_lt_pred(_Pred, *_First1, *_First2)) {
            return true;
        } else if (_Pred(*_First2, *_First1)) {
            return false;
        }
    }
    return _First1 == _Last1 && _First2 != _Last2;
}
template <class _InIt1, class _InIt2, class _Pr, class _Memcmp_pr>
inline bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr,
    _Lex_compare_optimize<_Memcmp_pr>) { 
    const auto _Num1 = static_cast<size_t>(_Last1 - _First1);
    const auto _Num2 = static_cast<size_t>(_Last2 - _First2);
    const int _Ans   = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
    return _Memcmp_pr{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
}
template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    return _Lex_compare_unchecked(
        _UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred), _Lex_compare_memcmp_classify(_UFirst1, _UFirst2, _Pred));
}
template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool lexicographical_compare(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) { 
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>());
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool lexicographical_compare(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _FwdIt2 _Last2,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool lexicographical_compare(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _FwdIt2 _Last2) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2);
}
#line 2722 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _Ty>
inline bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag) { 
    return (-128) <= _Val && _Val <= 127;
}
template <class _Ty>
inline bool _Within_limits(
    const _Ty& _Val, true_type, false_type, true_type) { 
    return _Val <= 127 || static_cast<_Ty>((-128)) <= _Val;
}
template <class _Ty>
inline bool _Within_limits(
    const _Ty& _Val, true_type, false_type, false_type) { 
    return _Val <= 127;
}
template <class _Ty>
inline bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag) { 
    return 0 <= _Val && _Val <= 0xff;
}
template <class _Ty>
inline bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag) { 
    return _Val <= 0xff;
}
template <class _InIt, class _Ty>
inline bool _Within_limits(_InIt, const _Ty& _Val) { 
    using _Elem = remove_pointer_t<_InIt>;
    return _Within_limits(_Val, is_signed<_Elem>{}, is_signed<_Ty>{}, bool_constant<-1 == static_cast<_Ty>(-1)>{});
}
template <class _InIt>
inline bool _Within_limits(_InIt, const bool&) { 
    return true;
}
template <class _InIt, class _Ty>
inline _InIt _Find_unchecked1(
    _InIt _First, const _InIt _Last, const _Ty& _Val, true_type) { 
    if (!_Within_limits(_First, _Val)) {
        return _Last;
    }
    _First =
        static_cast<_InIt>(:: memchr(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
    return _First ? _First : _Last;
}
template <class _InIt, class _Ty>
inline _InIt _Find_unchecked1(
    _InIt _First, const _InIt _Last, const _Ty& _Val, false_type) { 
    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }
    return _First;
}
template <class _InIt, class _Ty>
inline _InIt _Find_unchecked(
    const _InIt _First, const _InIt _Last, const _Ty& _Val) { 
    using _Memchr_opt = bool_constant<
        is_integral_v<_Ty> && _Is_any_of_v<_InIt, char*, signed char*, unsigned char*, 
            const char*, const signed char*, const unsigned char*>>;
    return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});
}
template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    return _First;
}
template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt find(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) noexcept;
#line 2808 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt, class _Ty, class _Pr>
inline _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred) { 
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }
    return _First;
}
template <class _InIt, class _Ty>
[[nodiscard]] inline _Iter_diff_t<_InIt> count(
    const _InIt _First, const _InIt _Last, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst               = _Get_unwrapped(_First);
    const auto _ULast          = _Get_unwrapped(_Last);
    _Iter_diff_t<_InIt> _Count = 0;
    for (; _UFirst != _ULast; ++_UFirst) {
        if (*_UFirst == _Val) {
            ++_Count;
        }
    }
    return _Count;
}
template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _Iter_diff_t<_FwdIt> count(
    _ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) noexcept;
#line 2844 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _InIt, class _Ty, class _Pr>
inline _Iter_diff_t<_InIt> _Count_pr(
    _InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred) { 
    _Iter_diff_t<_InIt> _Count = 0;
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }
    return _Count;
}
template <class _FwdIt1, class _FwdIt2, class _Pr>
inline void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr, forward_iterator_tag,
    forward_iterator_tag) { 
}
template <class _FwdIt1, class _FwdIt2, class _Pr>
inline void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred, bidirectional_iterator_tag,
    bidirectional_iterator_tag) { 
    do { 
        --_Last1;
        --_Last2;
    } while (_Pred(*_Last1, *_Last2));
    ++_Last1;
    ++_Last2;
}
template <class _FwdIt1, class _FwdIt2, class _Pr>
inline bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _Pr _Pred) { 
    _Trim_matching_suffixes(_Last1, _Last2, _Pred, _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) { 
            _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; 
            }
            _FwdIt1 _Skip1                = _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; 
            }
        }
    }
    return true;
}
template <class _FwdIt1, class _FwdIt2, class _Pr>
inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _Pr _Pred) { 
    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        if (!_Pred(*_First1, *_First2)) { 
            auto _Last2 = ::std:: next(_First2, static_cast<_Iter_diff_t<_FwdIt2>>(::std:: distance(_First1, _Last1)));
            return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
        }
    }
    return true;
}
template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
    return _Is_permutation_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
}
template <class _FwdIt1, class _RightTy, size_t _RightSize, class _Pr, class = enable_if_t<!is_same_v<_RightTy*, _Pr>>>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _RightTy (&_First2)[_RightSize],
    _Pr _Pred) { 
    return ::std:: is_permutation(_First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred));
}
#line 2934 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _FwdIt1, class _FwdIt2>
inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _First2) { 
    return ::std:: is_permutation(_First1, _Last1, _First2, equal_to<>());
}
template <class _FwdIt1, class _RightTy, size_t _RightSize>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
    _RightTy (&_First2)[_RightSize]) { 
    return ::std:: is_permutation(_First1, _Last1, _First2, equal_to<>());
}
#line 2949 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _FwdIt1, class _FwdIt2, class _Pr>
inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    forward_iterator_tag, forward_iterator_tag) { 
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
        if (!_Pred(*_First1, *_First2)) { 
            if (::std:: distance(_First1, _Last1) == ::std:: distance(_First2, _Last2)) {
                return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
            } else {
                return false; 
            }
        }
    }
    return _First1 == _Last1 && _First2 == _Last2;
}
template <class _FwdIt1, class _FwdIt2, class _Pr>
inline bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
    random_access_iterator_tag, random_access_iterator_tag) { 
    if (_Last1 - _First1 != _Last2 - _First2) {
        return false;
    }
    return _Is_permutation_unchecked(_First1, _Last1, _First2, _Pred);
}
template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    return _Is_permutation_unchecked(_Get_unwrapped(_First1), _Get_unwrapped(_Last1), _Get_unwrapped(_First2),
        _Get_unwrapped(_Last2), _Pass_fn(_Pred), _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
}
template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _FwdIt2 _Last2) { 
    return ::std:: is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>());
}
template <class _BidIt>
inline void reverse(const _BidIt _First, const _BidIt _Last) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    using _Elem = remove_pointer_t<decltype(_UFirst)>;
    constexpr bool _Allow_vectorization =
        conjunction_v<is_pointer<decltype(_UFirst)>, _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    if constexpr (_Allow_vectorization && sizeof(_Elem) == 1) {
        __std_reverse_trivially_swappable_1(_UFirst, _ULast);
    } else if constexpr (_Allow_vectorization && sizeof(_Elem) == 2) {
        __std_reverse_trivially_swappable_2(_UFirst, _ULast);
    } else if constexpr (_Allow_vectorization && sizeof(_Elem) == 4) {
        __std_reverse_trivially_swappable_4(_UFirst, _ULast);
    } else if constexpr (_Allow_vectorization && sizeof(_Elem) == 8) {
        __std_reverse_trivially_swappable_8(_UFirst, _ULast);
    } else
#line 3016 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
    {
        for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
            ::std:: iter_swap(_UFirst, _ULast);
        }
    }
}
#line 3081 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _ExPo, class _BidIt, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void reverse(
    _ExPo&&, _BidIt _First, _BidIt _Last) noexcept { 
    return ::std:: reverse(_First, _Last);
}
#line 3090 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _BidIt>
inline pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(
    _BidIt _First, _BidIt _Sentinel, _BidIt _Last) { 
    while (_First != _Sentinel && _Last != _Sentinel) {
        ::std:: iter_swap(_First, --_Last);
        ++_First;
    }
    return pair<_BidIt, _BidIt>(_First, _Last);
}
template <class _FwdIt>
inline _FwdIt rotate(
    _FwdIt _First, _FwdIt _Mid, _FwdIt _Last) { 
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    auto _UMid        = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }
    if (_UMid == _ULast) {
        return _First;
    }
    if constexpr (_Is_random_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        ::std:: reverse(_UFirst, _ULast);
        _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_bidi_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        ::std:: reverse(_Tmp.first, _Tmp.second);
        _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do { 
            ::std:: iter_swap(_UFirst, _UNext);
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { 
            _UNext = _UMid;
            do {
                ::std:: iter_swap(_UFirst, _UNext);
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }
    return _First;
}
#line 3227 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt rotate(_ExPo&&, _FwdIt _First, _FwdIt _Mid,
    _FwdIt _Last) noexcept { 
    return ::std:: rotate(_First, _Mid, _Last);
}
#line 3236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt lower_bound(
    _FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));
    while (0 < _Count) { 
        const _Iter_diff_t<_FwdIt> _Count2 = _Count >> 1; 
        const auto _UMid                   = ::std:: next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }
    _Seek_wrapped(_First, _UFirst);
    return _First;
}
template <class _Diff,
    class _Urng>
class _Rng_from_urng { 
public:
    using _Ty0 = make_unsigned_t<_Diff>;
    using _Ty1 = typename _Urng::result_type;
    using _Udiff = conditional_t<sizeof(_Ty1) < sizeof(_Ty0), _Ty0, _Ty1>;
    explicit _Rng_from_urng(_Urng& _Func)
        : _Ref(_Func), _Bits(8 * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { 
        for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1) {
            --_Bits;
        }
    }
    _Diff operator()(_Diff _Index) { 
        for (;;) { 
            _Udiff _Ret  = 0; 
            _Udiff _Mask = 0; 
            while (_Mask < _Udiff(_Index - 1)) { 
                _Ret <<= _Bits - 1; 
                _Ret <<= 1;
                _Ret |= _Get_bits();
                _Mask <<= _Bits - 1; 
                _Mask <<= 1;
                _Mask |= _Bmask;
            }
            if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {
                return static_cast<_Diff>(_Ret % _Index);
            }
        }
    }
    _Udiff _Get_all_bits() { 
        _Udiff _Ret = 0;
        for (size_t _Num = 0; _Num < 8 * sizeof(_Udiff); _Num += _Bits) { 
            _Ret <<= _Bits - 1; 
            _Ret <<= 1;
            _Ret |= _Get_bits();
        }
        return _Ret;
    }
    _Rng_from_urng(const _Rng_from_urng&) = delete;
    _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;
private:
    _Udiff _Get_bits() { 
        for (;;) { 
            _Udiff _Val = _Ref() - (_Urng::min)();
            if (_Val <= _Bmask) {
                return _Val;
            }
        }
    }
    _Urng& _Ref; 
    size_t _Bits; 
    _Udiff _Bmask; 
};
template <class _Elem>
class  _Yarn { 
public:
     _Yarn() : _Myptr(nullptr), _Nul(0) { 
    }
     _Yarn(const _Yarn& _Right) : _Myptr(nullptr), _Nul(0) { 
        *this = _Right;
    }
     _Yarn(const _Elem* _Right) : _Myptr(nullptr), _Nul(0) { 
        *this = _Right;
    }
    _Yarn&  operator=(const _Yarn& _Right) { 
        return *this = _Right._Myptr;
    }
    _Yarn&  operator=(const _Elem* _Right) { 
        if (_Myptr != _Right) { 
            _Tidy();
            if (_Right != nullptr) { 
                const _Elem* _Ptr = _Right;
                while (*_Ptr != (_Elem) 0) {
                    ++_Ptr;
                }
                const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);
                _Myptr = (_Elem*) _malloc_dbg(_Count, 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility", 3363);
#line 3368 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
                if (_Myptr != nullptr) {
                    :: memcpy(_Myptr, _Right, _Count);
                }
            }
        }
        return *this;
    }
     ~_Yarn() noexcept { 
        _Tidy();
    }
    bool  empty() const { 
        return _Myptr == nullptr;
    }
      const _Elem*  c_str() const { 
        return _Myptr != nullptr ? _Myptr : &_Nul;
    }
    bool  _Empty() const { 
        return _Myptr == nullptr;
    }
      const _Elem*  _C_str() const { 
        return _Myptr != nullptr ? _Myptr : &_Nul;
    }
private:
    void  _Tidy() noexcept { 
        if (_Myptr != nullptr) {
            _free_dbg(_Myptr, 2);
#line 3406 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
        }
        _Myptr = nullptr;
    }
    _Elem* _Myptr; 
    _Elem _Nul; 
};
template <class _Container>
class back_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using container_type = _Container;
    explicit back_insert_iterator(_Container& _Cont) : container(::std:: addressof(_Cont)) { 
    }
    back_insert_iterator& operator=(const typename _Container::value_type& _Val) { 
        container->push_back(_Val);
        return *this;
    }
    back_insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        container->push_back(::std:: move(_Val));
        return *this;
    }
    [[nodiscard]] back_insert_iterator& operator*() { 
        return *this;
    }
    back_insert_iterator& operator++() { 
        return *this;
    }
    back_insert_iterator operator++(int) { 
        return *this;
    }
protected:
    _Container* container; 
};
template <class _Container>
[[nodiscard]] inline back_insert_iterator<_Container> back_inserter(_Container& _Cont) { 
    return back_insert_iterator<_Container>(_Cont);
}
template <class _Ty, class _Alloc,
    class = void>
struct _Has_allocator_type : false_type { 
};
template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type { 
};
struct allocator_arg_t { 
    explicit allocator_arg_t() = default;
};
inline constexpr allocator_arg_t allocator_arg{};
[[noreturn]]  void __cdecl _Xbad_alloc();
[[noreturn]]  void __cdecl _Xinvalid_argument(  const char*);
[[noreturn]]  void __cdecl _Xlength_error(  const char*);
[[noreturn]]  void __cdecl _Xout_of_range(  const char*);
[[noreturn]]  void __cdecl _Xoverflow_error(  const char*);
[[noreturn]]  void __cdecl _Xruntime_error(  const char*);
template <class _Ty, class _Alloc>
struct uses_allocator
    : _Has_allocator_type<_Ty, _Alloc>::type { 
};
template <class _Ty, class _Alloc>
inline constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;
template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*,
    class _Reference = _Ty&>
struct  iterator { 
    using iterator_category = _Category;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = _Pointer;
    using reference         = _Reference;
};
template <class _Ty>
struct _Tidy_guard { 
    _Ty* _Target;
    ~_Tidy_guard() {
        if (_Target) {
            _Target->_Tidy();
        }
    }
};
template <class _Ty>
struct _Tidy_deallocate_guard { 
    _Ty* _Target;
    ~_Tidy_deallocate_guard() {
        if (_Target) {
            _Target->_Tidy_deallocate();
        }
    }
};
}
#pragma warning(pop)
#pragma pack(pop)
#line 3536 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#line 3537 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xutility"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <size_t _Ty_size>
[[nodiscard]] constexpr size_t _Get_size_of_n(
    const size_t _Count) noexcept { 
    constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
    size_t _Result                 = _Count * _Ty_size;
    if (_Max_possible < _Count) { 
        _Result = static_cast<size_t>(-1);
    }
    return _Result;
}
template <>
[[nodiscard]] constexpr size_t _Get_size_of_n<1>(
    const size_t _Count) noexcept { 
    return _Count;
}
template <class _Ty>
inline constexpr size_t _New_alignof = _Max_value(alignof(_Ty),
    static_cast<size_t>(16ull) 
);
struct _Default_allocate_traits {
    __declspec(allocator) static void* _Allocate(const size_t _Bytes) {
        return ::operator new(_Bytes);
    }
    __declspec(allocator) static void* _Allocate_aligned(const size_t _Bytes, const size_t _Align) {
        return ::operator new (_Bytes, align_val_t{_Align});
    }
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
};
constexpr bool _Is_pow_2(const size_t _Value) noexcept {
    return _Value != 0 && (_Value & (_Value - 1)) == 0;
}
constexpr size_t _Big_allocation_threshold = 4096;
constexpr size_t _Big_allocation_alignment = 32;
static_assert(2 * sizeof(void*) <= _Big_allocation_alignment,
    "Big allocation alignment should at least match vector register alignment");
static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");
constexpr size_t _Non_user_size = 2 * sizeof(void*) + _Big_allocation_alignment - 1;
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
template <class _Traits>
inline __declspec(allocator) void* _Allocate_manually_vector_aligned(
    const size_t _Bytes) { 
    size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size <= _Bytes) { 
        _Block_size = static_cast<size_t>(-1);
    }
    const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
    do { if (_Ptr_container != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 94, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 94, 0); } while (false); } ; } while (false); 
    void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
    static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;
    static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
#line 101 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    return _Ptr;
}
inline void _Adjust_manually_vector_aligned(void*& _Ptr,
    size_t& _Bytes) { 
    _Bytes += _Non_user_size;
    const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
    const uintptr_t _Ptr_container   = _Ptr_user[-1];
    do { if (_Ptr_user[-2] == _Big_allocation_sentinel) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 114, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 114, 0); } while (false); } ; } while (false);
    constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
#line 123 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
    do { if (_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 124, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 124, 0); } while (false); } ; } while (false);
    _Ptr = reinterpret_cast<void*>(_Ptr_container);
}
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(_Align > 16ull), int> = 0>
inline __declspec(allocator) void* _Allocate(
    const size_t _Bytes) { 
    if (_Bytes == 0) {
        return nullptr;
    }
    size_t _Passed_align = _Align;
    if (_Bytes >= _Big_allocation_threshold) { 
        _Passed_align = _Max_value(_Align, _Big_allocation_alignment);
    }
#line 145 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
}
template <size_t _Align, enable_if_t<(_Align > 16ull), int> = 0>
inline void _Deallocate(
    void* _Ptr, const size_t _Bytes) noexcept { 
    size_t _Passed_align = _Align;
    if (_Bytes >= _Big_allocation_threshold) { 
        _Passed_align = _Max_value(_Align, _Big_allocation_alignment);
    }
#line 159 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    ::operator delete (_Ptr, _Bytes, align_val_t{_Passed_align});
}
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(!1 || _Align <= 16ull), int> = 0>
inline __declspec(allocator) void* _Allocate(
    const size_t _Bytes) { 
    if (_Bytes >= _Big_allocation_threshold) { 
        return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
    }
#line 177 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    if (_Bytes != 0) {
        return _Traits::_Allocate(_Bytes);
    }
    return nullptr;
}
template <size_t _Align, enable_if_t<(!1 || _Align <= 16ull), int> = 0>
inline void _Deallocate(
    void* _Ptr, size_t _Bytes) noexcept { 
    if (_Bytes >= _Big_allocation_threshold) { 
        _Adjust_manually_vector_aligned(_Ptr, _Bytes);
    }
#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    ::operator delete(_Ptr, _Bytes);
}
template <class _Ty, class... _Types>
inline void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) { 
#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    ::new (const_cast<void*>(static_cast<const volatile void*>(::std:: addressof(_Obj))))
        _Ty(::std:: forward<_Types>(_Args)...);
}
template <class _Ty,
    class... _Types>
inline _Ty* _Global_new(_Types&&... _Args) { 
    struct _Guard_type {
        void* _Result;
        ~_Guard_type() {
            if (_Result) {
                _Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
            }
        }
    };
    _Guard_type _Guard{_Allocate<_New_alignof<_Ty>>(sizeof(_Ty))};
    ::new (_Guard._Result) _Ty(::std:: forward<_Types>(_Args)...);
    return static_cast<_Ty*>(::std:: exchange(_Guard._Result, nullptr));
}
template <class _Ty>
struct _Get_first_parameter;
template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> { 
    using type = _First;
};
template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;
template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { 
    using type = _Ty<_Newfirst, _Rest...>;
};
template <class _Ty,
    class = void>
struct _Get_element_type { 
    using type = typename _Get_first_parameter<_Ty>::type;
};
template <class _Ty>
struct _Get_element_type<_Ty, void_t<typename _Ty::element_type>> { 
    using type = typename _Ty::element_type;
};
template <class _Ty,
    class = void>
struct _Get_ptr_difference_type { 
    using type = ptrdiff_t;
};
template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> { 
    using type = typename _Ty::difference_type;
};
template <class _Ty, class _Other,
    class = void>
struct _Get_rebind_alias { 
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};
template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> { 
    using type = typename _Ty::template rebind<_Other>;
};
template <class _Ty>
struct pointer_traits { 
    using element_type    = typename _Get_element_type<_Ty>::type;
    using pointer         = _Ty;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;
    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;
    using _Reftype = conditional_t<is_void_v<element_type>, char&, add_lvalue_reference_t<element_type>>;
    [[nodiscard]] static pointer pointer_to(_Reftype _Val) { 
        return _Ty::pointer_to(_Val);
    }
};
template <class _Ty>
struct pointer_traits<_Ty*> { 
    using element_type    = _Ty;
    using pointer         = _Ty*;
    using difference_type = ptrdiff_t;
    template <class _Other>
    using rebind = _Other*;
    using _Reftype = conditional_t<is_void_v<_Ty>, char&, add_lvalue_reference_t<_Ty>>;
    [[nodiscard]] static pointer pointer_to(_Reftype _Val) noexcept { 
        return ::std:: addressof(_Val);
    }
};
template <class _Ptr, class _Ty>
using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;
template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(
    typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept { 
    return pointer_traits<_Pointer>::pointer_to(*_Ptr);
}
template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(_Pointer _Ptr) noexcept { 
    return _Ptr;
}
template <class _Ty>
inline void _Destroy_in_place(_Ty& _Obj) noexcept { 
    _Obj.~_Ty();
}
template <class _Ptrty>
inline auto _Const_cast(_Ptrty _Ptr) noexcept { 
    using _Elem       = typename pointer_traits<_Ptrty>::element_type;
    using _Modifiable = remove_const_t<_Elem>;
    using _Dest       = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;
    return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
}
template <class _Ty>
inline auto _Const_cast(_Ty* _Ptr) noexcept { 
    return const_cast<remove_const_t<_Ty>*>(_Ptr);
}
template <class _Ty,
    class = void>
struct _Get_pointer_type { 
    using type = typename _Ty::value_type*;
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>> { 
    using type = typename _Ty::pointer;
};
#pragma warning(pop)
template <class _Ty,
    class = void>
struct _Get_const_pointer_type { 
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using _Valty = typename _Ty::value_type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>> { 
    using type = typename _Ty::const_pointer;
};
#pragma warning(pop)
template <class _Ty,
    class = void>
struct _Get_void_pointer_type { 
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<void>;
};
template <class _Ty>
struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>> { 
    using type = typename _Ty::void_pointer;
};
template <class _Ty,
    class = void>
struct _Get_const_void_pointer_type { 
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const void>;
};
template <class _Ty>
struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>> { 
    using type = typename _Ty::const_void_pointer;
};
template <class _Ty,
    class = void>
struct _Get_difference_type { 
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::difference_type;
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>> { 
    using type = typename _Ty::difference_type;
};
#pragma warning(pop)
template <class _Ty,
    class = void>
struct _Get_size_type { 
    using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty>
struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>> { 
    using type = typename _Ty::size_type;
};
#pragma warning(pop)
template <class _Ty,
    class = void>
struct _Get_propagate_on_container_copy { 
    using type = false_type;
};
template <class _Ty>
struct _Get_propagate_on_container_copy<_Ty,
    void_t<typename _Ty::propagate_on_container_copy_assignment>> { 
    using type = typename _Ty::propagate_on_container_copy_assignment;
};
template <class _Ty,
    class = void>
struct _Get_propagate_on_container_move { 
    using type = false_type;
};
template <class _Ty>
struct _Get_propagate_on_container_move<_Ty,
    void_t<typename _Ty::propagate_on_container_move_assignment>> { 
    using type = typename _Ty::propagate_on_container_move_assignment;
};
template <class _Ty,
    class = void>
struct _Get_propagate_on_container_swap { 
    using type = false_type;
};
template <class _Ty>
struct _Get_propagate_on_container_swap<_Ty,
    void_t<typename _Ty::propagate_on_container_swap>> { 
    using type = typename _Ty::propagate_on_container_swap;
};
template <class _Ty,
    class = void>
struct _Get_is_always_equal { 
    using type = typename is_empty<_Ty>::type;
};
template <class _Ty>
struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>> { 
    using type = typename _Ty::is_always_equal;
};
template <class _Ty, class _Other,
    class = void>
struct _Get_rebind_type { 
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Ty, class _Other>
struct _Get_rebind_type<_Ty, _Other,
    void_t<typename _Ty::template rebind<_Other>::other>> { 
    using type = typename _Ty::template rebind<_Other>::other;
};
#pragma warning(pop)
template <class _Ty>
class allocator;
template <class _Alloc,
    class = void>
struct _Is_default_allocator
    : false_type { 
};
template <class _Ty>
struct _Is_default_allocator<allocator<_Ty>, typename allocator<_Ty>::_Not_user_specialized>
    : true_type { 
};
template <class _Void,
    class... _Types>
struct _Has_no_alloc_construct : true_type { 
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc, class _Ptr, class... _Args>
struct _Has_no_alloc_construct<
    void_t<decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>, _Alloc, _Ptr,
    _Args...> : false_type { 
};
#pragma warning(pop)
template <class _Alloc, class _Ptr, class... _Args>
using _Uses_default_construct =
    disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_construct<void, _Alloc, _Ptr, _Args...>>;
template <class _Alloc, class _Ptr,
    class = void>
struct _Has_no_alloc_destroy : true_type { 
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc, class _Ptr>
struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
    : false_type { 
};
#pragma warning(pop)
template <class _Alloc, class _Ptr>
using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;
template <class _Alloc, class _Ptr>
using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;
template <class _Alloc, class _Size_type, class _Const_void_pointer,
    class = void>
struct _Has_allocate_hint : false_type { 
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc, class _Size_type, class _Const_void_pointer>
struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer,
    void_t<decltype(::std:: declval<_Alloc&>().allocate(::std:: declval<const _Size_type&>(),
        ::std:: declval<const _Const_void_pointer&>()))>> : true_type { 
};
#pragma warning(pop)
template <class _Alloc,
    class = void>
struct _Has_max_size : false_type { 
};
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc>
struct _Has_max_size<_Alloc, void_t<decltype(::std:: declval<const _Alloc&>().max_size())>>
    : true_type { 
};
#pragma warning(pop)
template <class _Alloc,
    class = void>
struct _Has_select_on_container_copy_construction
    : false_type { 
};
template <class _Alloc>
struct _Has_select_on_container_copy_construction<_Alloc,
    void_t<decltype(::std:: declval<const _Alloc&>().select_on_container_copy_construction())>>
    : true_type { 
};
template <class _Alloc>
struct allocator_traits;
#pragma warning(push)
#pragma warning(disable : 4996) 
template <class _Alloc>
struct _Normal_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;
    using pointer            = typename _Get_pointer_type<_Alloc>::type;
    using const_pointer      = typename _Get_const_pointer_type<_Alloc>::type;
    using void_pointer       = typename _Get_void_pointer_type<_Alloc>::type;
    using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;
    using size_type       = typename _Get_size_type<_Alloc>::type;
    using difference_type = typename _Get_difference_type<_Alloc>::type;
    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
    using propagate_on_container_swap            = typename _Get_propagate_on_container_swap<_Alloc>::type;
    using is_always_equal                        = typename _Get_is_always_equal<_Alloc>::type;
    template <class _Other>
    using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
    template <class _Other>
    using rebind_traits = allocator_traits<rebind_alloc<_Other>>;
    [[nodiscard]] static __declspec(allocator) pointer allocate(
        _Alloc& _Al,  const size_type _Count) { 
        return _Al.allocate(_Count);
    }
    [[nodiscard]] static __declspec(allocator) pointer allocate(_Alloc& _Al,  const size_type _Count,
        const const_void_pointer _Hint) { 
        if constexpr (_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value) {
            return _Al.allocate(_Count, _Hint);
        } else {
            (void) _Hint;
            return _Al.allocate(_Count);
        }
    }
#line 667 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    static void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count) { 
        _Al.deallocate(_Ptr, _Count);
    }
    template <class _Ty, class... _Types>
    static void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) { 
        if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
            (void) _Al;
            ::new (static_cast<void*>(_Ptr)) _Ty(::std:: forward<_Types>(_Args)...);
        } else {
            _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
        }
    }
#line 701 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    template <class _Ty>
    static void destroy(_Alloc& _Al, _Ty* _Ptr) { 
        if constexpr (_Uses_default_destroy_t<_Alloc, _Ty*>::value) {
            (void) _Al;
            _Ptr->~_Ty();
        } else {
            _Al.destroy(_Ptr);
        }
    }
#line 728 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    [[nodiscard]] static size_type max_size(const _Alloc& _Al) noexcept { 
        if constexpr (_Has_max_size<_Alloc>::value) {
            return _Al.max_size();
        } else {
            (void) _Al;
            return (numeric_limits<size_type>::max)() / sizeof(value_type);
        }
    }
#line 751 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    [[nodiscard]] static _Alloc select_on_container_copy_construction(const _Alloc& _Al) { 
        if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
            return _Al.select_on_container_copy_construction();
        } else {
            return _Al;
        }
    }
#line 775 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
};
#pragma warning(pop)
template <class _Alloc>
struct _Default_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;
    using pointer            = value_type*;
    using const_pointer      = const value_type*;
    using void_pointer       = void*;
    using const_void_pointer = const void*;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap            = false_type;
    using is_always_equal                        = true_type;
    template <class _Other>
    using rebind_alloc = allocator<_Other>;
    template <class _Other>
    using rebind_traits = allocator_traits<allocator<_Other>>;
    [[nodiscard]] static __declspec(allocator) pointer allocate(
        _Alloc&,  const size_type _Count) { 
        return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
    }
    [[nodiscard]] static __declspec(allocator) pointer allocate(_Alloc&,  const size_type _Count,
        const_void_pointer) { 
        return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
    }
    static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) { 
        _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
    }
    template <class _Objty, class... _Types>
    static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { 
        ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(::std:: forward<_Types>(_Args)...);
    }
    template <class _Uty>
    static void destroy(_Alloc&, _Uty* const _Ptr) { 
        _Ptr->~_Uty();
    }
    [[nodiscard]] static size_type max_size(const _Alloc&) noexcept { 
        return static_cast<size_t>(-1) / sizeof(value_type);
    }
    [[nodiscard]] static _Alloc select_on_container_copy_construction(const _Alloc& _Al) { 
        return _Al;
    }
};
template <class _Alloc>
struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>,
                              _Normal_allocator_traits<_Alloc>> { 
};
template <class _Alloc>
using _Choose_pocca = bool_constant<allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value
                                    && !allocator_traits<_Alloc>::is_always_equal::value>;
struct _Equal_allocators {}; 
using _Propagate_allocators    = true_type; 
using _No_propagate_allocators = false_type; 
template <class _Alloc>
using _Choose_pocma = conditional_t<allocator_traits<_Alloc>::is_always_equal::value, _Equal_allocators,
    typename allocator_traits<_Alloc>::propagate_on_container_move_assignment::type>;
template <class _Alloc, class _Value_type>
using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;
template <class _Alloc> 
inline constexpr bool _Is_simple_alloc_v = is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>&&
    is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>&&
        is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>&&
            is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;
template <class _Value_type>
struct _Simple_types { 
    using value_type      = _Value_type;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = value_type*;
    using const_pointer   = const value_type*;
};
template <class _Ty>
class allocator { 
public:
    static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
                                    "because allocator<const T> is ill-formed.");
    using _Not_user_specialized = void;
    using value_type = _Ty;
    [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty* pointer;
    [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef const _Ty* const_pointer;
    [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef _Ty& reference;
    [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef const _Ty& const_reference;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using propagate_on_container_move_assignment = true_type;
    using is_always_equal                        = true_type;
    template <class _Other>
    struct [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] rebind { 
        using other = allocator<_Other>;
    };
    [[nodiscard]] [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] _Ty* address(_Ty& _Val) const
        noexcept { 
        return ::std:: addressof(_Val);
    }
    [[nodiscard]] [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] const _Ty* address(const _Ty& _Val) const
        noexcept { 
        return ::std:: addressof(_Val);
    }
    constexpr allocator() noexcept { 
    }
    constexpr allocator(const allocator&) noexcept = default;
    template <class _Other>
    constexpr allocator(const allocator<_Other>&) noexcept { 
    }
    void deallocate(_Ty* const _Ptr, const size_t _Count) { 
        _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    }
    [[nodiscard]] __declspec(allocator) _Ty* allocate(
         const size_t _Count) { 
        return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    }
    [[nodiscard]] [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] __declspec(allocator) _Ty* allocate(
         const size_t _Count, const void*) { 
        return allocate(_Count);
    }
    template <class _Objty, class... _Types>
    [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] void construct(
        _Objty* const _Ptr, _Types&&... _Args) { 
        ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(::std:: forward<_Types>(_Args)...);
    }
    template <class _Uty>
    [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] void destroy(_Uty* const _Ptr) { 
        _Ptr->~_Uty();
    }
    [[nodiscard]] [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] size_t max_size() const noexcept { 
        return static_cast<size_t>(-1) / sizeof(_Ty);
    }
};
template <>
class allocator<void> { 
public:
    using value_type = void;
    [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef void* pointer;
    [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef const void* const_pointer;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using propagate_on_container_move_assignment = true_type;
    using is_always_equal                        = true_type;
    template <class _Other>
    struct [[deprecated("warning STL4010: " "Various members of std::allocator are deprecated in C++17. " "Use std::allocator_traits instead of accessing these members directly. " "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] rebind { 
        using other = allocator<_Other>;
    };
};
template <class _Ty, class _Other>
[[nodiscard]] inline bool operator==(const allocator<_Ty>&,
    const allocator<_Other>&) noexcept { 
    return true;
}
template <class _Ty, class _Other>
[[nodiscard]] inline bool operator!=(const allocator<_Ty>&,
    const allocator<_Other>&) noexcept { 
    return false;
}
template <class _Alloc>
using _Guide_size_type_t =
    typename allocator_traits<conditional_t<_Is_allocator<_Alloc>::value, _Alloc, allocator<int>>>::size_type;
#line 992 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
template <class _Alloc>
inline void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept { 
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    } else {
        (void) _Left; 
        (void) _Right; 
    }
}
#line 1020 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
template <class _Alloc>
inline void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { 
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
        _Left = ::std:: move(_Right);
    } else {
        (void) _Left; 
        (void) _Right; 
    }
}
#line 1048 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
template <class _Alloc>
inline void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept { 
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
        _Swap_adl(_Left, _Right);
    } else {
        do { if (_Left == _Right) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 1056, 0, "%s", "containers incompatible for swap")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"containers incompatible for swap\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 1056, 0); } while (false); } ; } while (false);
        (void) _Left; 
        (void) _Right; 
    }
}
#line 1080 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
template <class _Alloc>
inline void _Destroy_range(typename allocator_traits<_Alloc>::pointer _First,
    typename allocator_traits<_Alloc>::pointer _Last,
    _Alloc& _Al) noexcept { 
    using _Val = typename _Alloc::value_type;
    if
        constexpr(conjunction_v<is_trivially_destructible<_Val>, _Uses_default_destroy<_Alloc, _Val*>>) {
            (void) _First;
            (void) _Last;
            (void) _Al;
        }
    else {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
        }
    }
}
template <class _NoThrowFwdIt>
inline void _Destroy_range(
    _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept { 
    if
        constexpr(is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
            (void) _First;
            (void) _Last;
        }
    else {
        for (; _First != _Last; ++_First) {
            _Destroy_in_place(*_First);
        }
    }
}
template <class _Size_type>
[[nodiscard]] constexpr _Size_type _Convert_size(
    const size_t _Len) noexcept { 
    if (_Len > (numeric_limits<_Size_type>::max)()) {
        _Xlength_error("size_t too long for _Size_type");
    }
    return static_cast<_Size_type>(_Len);
}
template <>
[[nodiscard]] constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept { 
    return _Len;
}
template <class _Alloc>
inline void _Deallocate_plain(
    _Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept { 
    using _Alloc_traits = allocator_traits<_Alloc>;
    if constexpr (is_same_v<typename _Alloc_traits::pointer, typename _Alloc::value_type*>) {
        _Alloc_traits::deallocate(_Al, _Ptr, 1);
    } else {
        using _Ptr_traits = pointer_traits<typename _Alloc_traits::pointer>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
}
#line 1170 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
template <class _Alloc>
inline void _Delete_plain(
    _Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept { 
    allocator_traits<_Alloc>::destroy(_Al, _Ptr);
    _Deallocate_plain(_Al, _Ptr);
}
template <class _Alloc>
struct _Alloc_construct_ptr { 
    using pointer = typename allocator_traits<_Alloc>::pointer;
    _Alloc& _Al;
    pointer _Ptr;
    explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}
    [[nodiscard]] pointer _Release() noexcept { 
        return ::std:: exchange(_Ptr, nullptr);
    }
    void _Allocate() { 
        _Ptr = nullptr; 
        _Ptr = _Al.allocate(1);
    }
    ~_Alloc_construct_ptr() { 
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }
    _Alloc_construct_ptr(const _Alloc_construct_ptr&) = delete;
    _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
};
template <class _Alloc, class... _Args, enable_if_t<!is_const_v<_Alloc>, int> = 0>
[[nodiscard]] inline typename allocator_traits<_Alloc>::pointer _Alloc_new(
    _Alloc& _Al, _Args&&... _Vals) { 
    _Alloc_construct_ptr<_Alloc> _Constructor{_Al};
    _Constructor._Allocate();
    allocator_traits<_Alloc>::construct(_Constructor._Al, _Unfancy(_Constructor._Ptr), ::std:: forward<_Args>(_Vals)...);
    return _Constructor._Release();
}
template <class _Ty, class _Alloc, class... _Args>
[[nodiscard]] inline typename allocator_traits<remove_const_t<_Alloc>>::template rebind_traits<_Ty>::pointer
    _Alloc_rebound(_Alloc& _Al, _Args&&... _Vals) { 
    using _Rebound_alloc = _Rebind_alloc_t<remove_const_t<_Alloc>, _Ty>;
    using _Rebound_instance = conditional_t<is_same_v<_Rebound_alloc, _Alloc>, _Alloc&, _Rebound_alloc>;
    _Rebound_instance _Rebound(_Al);
    return _Alloc_new(_Rebound, ::std:: forward<_Args>(_Vals)...);
}
struct _Fake_allocator {};
struct _Container_base0 { 
    void _Orphan_all() noexcept { 
    }
    void _Swap_proxy_and_iterators(_Container_base0&) noexcept { 
    }
    void _Alloc_proxy(const _Fake_allocator&) noexcept { 
    }
    void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept { 
    }
};
struct _Iterator_base0 { 
    void _Adopt(const void*) noexcept { 
    }
    const _Container_base0* _Getcont() const noexcept { 
        return nullptr;
    }
    static constexpr bool _Unwrap_when_unverified = true;
};
struct _Container_base12;
struct _Container_proxy { 
    _Container_proxy() noexcept : _Mycont(nullptr), _Myfirstiter(nullptr) {}
    _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}
    const _Container_base12* _Mycont;
    _Iterator_base12* _Myfirstiter;
};
struct _Container_base12 { 
public:
    _Container_base12() : _Myproxy(nullptr) { 
    }
    _Container_base12(const _Container_base12&) noexcept : _Myproxy(nullptr) { 
    }
    _Container_base12& operator=(const _Container_base12&) noexcept { 
        return *this;
    }
    _Iterator_base12** _Getpfirst() const noexcept { 
        return _Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter;
    }
    void _Orphan_all() noexcept; 
    void _Swap_proxy_and_iterators(_Container_base12&) noexcept; 
    template <class _Alloc>
    void _Alloc_proxy(_Alloc&& _Al) { 
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        allocator_traits<remove_reference_t<_Alloc>>::construct(_Al, _New_proxy, this);
        _Myproxy            = _New_proxy;
        _New_proxy->_Mycont = this;
    }
    template <class _Alloc>
    void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        allocator_traits<remove_reference_t<_Alloc>>::construct(_New_alloc, _New_proxy, this);
        _New_proxy->_Mycont = this;
        _Delete_plain(_Old_alloc, ::std:: exchange(_Myproxy, _New_proxy));
    }
    _Container_proxy* _Myproxy;
};
struct _Iterator_base12 { 
    _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) { 
    }
    _Iterator_base12(const _Iterator_base12& _Right) noexcept
        : _Myproxy(nullptr), _Mynextiter(nullptr) { 
        *this = _Right;
    }
    _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept { 
        if (_Myproxy != _Right._Myproxy) {
            if (_Right._Myproxy == nullptr) { 
                _Lockit _Lock(3);
                _Orphan_me();
#line 1323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
            } else {
                _Adopt(_Right._Myproxy->_Mycont);
            }
        }
        return *this;
    }
    ~_Iterator_base12() noexcept { 
        _Lockit _Lock(3);
        _Orphan_me();
#line 1336 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    }
    void _Adopt(const _Container_base12* _Parent) noexcept { 
        if (_Parent == nullptr) { 
            _Lockit _Lock(3);
            _Orphan_me();
#line 1344 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
        } else { 
            _Container_proxy* _Parent_proxy = _Parent->_Myproxy;
            if (_Myproxy != _Parent_proxy) { 
                _Lockit _Lock(3);
                _Orphan_me();
                _Mynextiter                 = _Parent_proxy->_Myfirstiter;
                _Parent_proxy->_Myfirstiter = this;
                _Myproxy                    = _Parent_proxy;
            }
#line 1359 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
        }
    }
    void _Clrcont() noexcept { 
        _Myproxy = nullptr;
    }
    const _Container_base12* _Getcont() const noexcept { 
        return _Myproxy == nullptr ? nullptr : _Myproxy->_Mycont;
    }
    _Iterator_base12** _Getpnext() noexcept { 
        return &_Mynextiter;
    }
    void _Orphan_me() noexcept { 
        if (_Myproxy != nullptr) { 
            _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;
            while (*_Pnext != nullptr && *_Pnext != this) {
                _Pnext = &(*_Pnext)->_Mynextiter;
            }
            do { if (*_Pnext) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 1382, 0, "%s", "ITERATOR LIST CORRUPTED!")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"ITERATOR LIST CORRUPTED!\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0", 1382, 0); } while (false); } ; } while (false);
            *_Pnext  = _Mynextiter;
            _Myproxy = nullptr;
        }
#line 1387 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    }
    static constexpr bool _Unwrap_when_unverified = 2 == 0;
    _Container_proxy* _Myproxy;
    _Iterator_base12* _Mynextiter;
};
inline void _Container_base12::_Orphan_all() noexcept { 
    if (_Myproxy != nullptr) { 
        _Lockit _Lock(3);
        for (_Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter; *_Pnext != nullptr;
             *_Pnext                   = (*_Pnext)->_Mynextiter) {
            (*_Pnext)->_Myproxy = nullptr;
        }
        _Myproxy->_Myfirstiter = nullptr;
    }
#line 1409 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
}
inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept { 
    _Lockit _Lock(3);
#line 1415 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
    _Container_proxy* _Temp = _Myproxy;
    _Myproxy                = _Right._Myproxy;
    _Right._Myproxy         = _Temp;
    if (_Myproxy != nullptr) {
        _Myproxy->_Mycont = (_Container_base12*) this;
    }
    if (_Right._Myproxy != nullptr) {
        _Right._Myproxy->_Mycont = (_Container_base12*) &_Right;
    }
}
#line 1434 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
using _Container_base = _Container_base12;
using _Iterator_base = _Iterator_base12;
#line 1437 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
struct _Leave_proxy_unbound { 
};
struct _Fake_proxy_ptr_impl { 
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&) = delete;
    _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
    _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept {}
    _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}
    void _Bind(const _Fake_allocator&, _Container_base0*) noexcept {}
    void _Release() noexcept {}
};
struct _Basic_container_proxy_ptr12 { 
    _Container_proxy* _Ptr;
    void _Release() noexcept { 
        _Ptr = nullptr;
    }
protected:
    _Basic_container_proxy_ptr12()                                    = default;
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&)      = delete;
};
template <class _Alloc>
struct _Container_proxy_ptr12
    : _Basic_container_proxy_ptr12 { 
    _Alloc& _Al;
    _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound) : _Al(_Al_) { 
        _Ptr = _Unfancy(_Al_.allocate(1));
        allocator_traits<_Alloc>::construct(_Al, _Ptr); 
    }
    _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont)
        : _Al(_Al_) { 
        _Ptr = _Unfancy(_Al_.allocate(1));
        allocator_traits<_Alloc>::construct(_Al, _Ptr, ::std:: addressof(_Mycont)); 
        _Mycont._Myproxy = _Ptr;
    }
    void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept {
        _Ptr->_Mycont = _Mycont;
        _Delete_plain(_Old_alloc, ::std:: exchange(_Mycont->_Myproxy, ::std:: exchange(_Ptr, nullptr)));
    }
    ~_Container_proxy_ptr12() {
        if (_Ptr) {
            _Delete_plain(_Al, _Ptr);
        }
    }
};
#line 1504 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
template <class _Alloc>
using _Container_proxy_ptr = _Container_proxy_ptr12<_Rebind_alloc_t<_Alloc, _Container_proxy>>;
#line 1508 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
struct _Zero_then_variadic_args_t { 
}; 
struct _One_then_variadic_args_t { 
}; 
template <class _Ty1, class _Ty2,
    bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 { 
private:
    _Ty2 _Myval2;
    using _Mybase = _Ty1; 
public:
    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2)
        : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...) { 
    }
    template <class _Other1, class... _Other2>
    _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2)
        : _Ty1(::std:: forward<_Other1>(_Val1)),
          _Myval2(::std:: forward<_Other2>(_Val2)...) { 
    }
    _Ty1& _Get_first() noexcept { 
        return *this;
    }
    const _Ty1& _Get_first() const noexcept { 
        return *this;
    }
    _Ty2& _Get_second() noexcept { 
        return _Myval2;
    }
    const _Ty2& _Get_second() const noexcept { 
        return _Myval2;
    }
};
template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final { 
private:
    _Ty1 _Myval1;
    _Ty2 _Myval2;
public:
    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2)
        : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...) { 
    }
    template <class _Other1, class... _Other2>
    _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2)
        : _Myval1(::std:: forward<_Other1>(_Val1)),
          _Myval2(::std:: forward<_Other2>(_Val2)...) { 
    }
    _Ty1& _Get_first() noexcept { 
        return _Myval1;
    }
    const _Ty1& _Get_first() const noexcept { 
        return _Myval1;
    }
    _Ty2& _Get_second() noexcept { 
        return _Myval2;
    }
    const _Ty2& _Get_second() const noexcept { 
        return _Myval2;
    }
};
struct _Move_allocator_tag {};
}
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xatomic0.h"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};
using _Uint4_t           = unsigned long;
using _Atomic_integral_t = _Uint4_t;
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xatomic0.h"
using _Atomic_counter_t = _Atomic_integral_t;
inline _Atomic_integral_t _Get_atomic_count(const _Atomic_counter_t& _Counter) { 
    return _Counter;
}
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xatomic0.h"
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xatomic0.h"
}
#pragma warning(pop)
#pragma pack(pop)
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xatomic0.h"
#line 69 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xatomic0.h"
#line 1593 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#pragma once
extern "C" {
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 89 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 94 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);
unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);
unsigned char _bittest(long const *, long);
long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);
__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedAnd8(char volatile * _Value, char _Mask);
long  _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);
short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);
__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);
char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);
long  _InterlockedDecrement(long volatile * _Addend);
long  _InterlockedExchange(long volatile * _Target, long _Value);
short _InterlockedExchange16(short volatile * _Target, short _Value);
__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);
char _InterlockedExchange8(char volatile * _Target, char _Value);
long  _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);
__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);
char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);
long  _InterlockedIncrement(long volatile * _Addend);
long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);
__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedOr8(char volatile * _Value, char _Mask);
long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);
__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedXor8(char volatile * _Value, char _Mask);
void _ReadWriteBarrier(void);
unsigned char _interlockedbittestandset(long volatile *, long);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);
}
#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 255 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin0.h"
#line 1596 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#line 1606 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#pragma warning(pop)
#pragma pack(pop)
#line 1612 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#line 1613 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory0"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Ty>
inline pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(
    ptrdiff_t _Count) noexcept { 
    if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
        for (; 0 < _Count; _Count /= 2) {
            const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
            void* _Pbuf;
            if constexpr (alignof(_Ty) > 16ull) {
                _Pbuf = ::operator new (_Size, align_val_t{alignof(_Ty)}, nothrow);
            } else
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory"
            {
                _Pbuf = ::operator new(_Size, nothrow);
            }
            if (_Pbuf) {
                return {static_cast<_Ty*>(_Pbuf), _Count};
            }
        }
    }
    return {nullptr, 0};
}
template <class _Ty>
inline void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept { 
    if constexpr (alignof(_Ty) > 16ull) {
        ::operator delete (_Pbuf, align_val_t{alignof(_Ty)});
    } else
#line 50 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory"
    {
        ::operator delete(_Pbuf);
    }
}
template <class _NoThrowFwdIt>
struct _Uninitialized_backout { 
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;
    explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}
    _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}
    _Uninitialized_backout(const _Uninitialized_backout&) = delete;
    _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;
    ~_Uninitialized_backout() { 
        _Destroy_range(_First, _Last);
    }
    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { 
        _Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }
    _NoThrowFwdIt _Release() { 
        _First = _Last;
        return _Last;
    }
};
template <class _InIt, class _NoThrowFwdIt>
inline _NoThrowFwdIt _Uninitialized_move_unchecked(
    _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) { 
    if constexpr (_Ptr_move_cat<_InIt, _NoThrowFwdIt>::_Really_trivial) {
        return _Copy_memmove(_First, _Last, _Dest);
    } else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
        for (; _First != _Last; ++_First) {
            _Backout._Emplace_back(::std:: move(*_First));
        }
        return _Backout._Release();
    }
}
#line 125 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory"
template <class _NoThrowFwdIt,
    class _Alloc>
class _Uninitialized_backout_al { 
public:
    _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}
    _Uninitialized_backout_al(const _Uninitialized_backout_al&) = delete;
    _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;
    ~_Uninitialized_backout_al() { 
        _Destroy_range(_First, _Last, _Al);
    }
    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { 
        allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }
    _NoThrowFwdIt _Release() { 
        _First = _Last;
        return _Last;
    }
private:
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;
    _Alloc& _Al;
};
template <class _InIt, class _NoThrowFwdIt, class _Alloc>
inline _NoThrowFwdIt _Uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest,
    _Alloc& _Al) { 
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial>,
                      _Uses_default_construct<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>>) {
        _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);
        (void) _Al;
    } else {
        _Uninitialized_backout_al<decltype(_UDest), _Alloc> _Backout{_UDest, _Al};
        for (; _UFirst != _ULast; ++_UFirst) {
            _Backout._Emplace_back(*_UFirst);
        }
        _UDest = _Backout._Release();
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory"
template <class _InIt, class _NoThrowFwdIt, class _Alloc>
inline _NoThrowFwdIt _Uninitialized_move(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest,
    _Alloc& _Al) { 
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial>,
                      _Uses_default_construct<_Alloc, decltype(_Unfancy(_UDest)), decltype(::std:: move(*_UFirst))>>) {
        _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);
        (void) _Al;
    } else {
        _Uninitialized_backout_al<decltype(_UDest), _Alloc> _Backout{_UDest, _Al};
        for (; _UFirst != _ULast; ++_UFirst) {
            _Backout._Emplace_back(::std:: move(*_UFirst));
        }
        _UDest = _Backout._Release();
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
#line 274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory"
template <class _NoThrowFwdIt, class _Diff, class _Alloc>
inline _NoThrowFwdIt _Uninit_alloc_fill_n1(const _NoThrowFwdIt _First, _Diff _Count,
    const _Iter_value_t<_NoThrowFwdIt>& _Val, _Alloc& _Al,
    false_type) { 
    _Uninitialized_backout_al<_NoThrowFwdIt, _Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }
    return _Backout._Release();
}
template <class _NoThrowFwdIt, class _Diff, class _Alloc>
inline _NoThrowFwdIt _Uninit_alloc_fill_n1(const _NoThrowFwdIt _First, const _Diff _Count,
    const _Iter_value_t<_NoThrowFwdIt>& _Val, _Alloc&,
    true_type) { 
    :: memset(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
    return _First + _Count;
}
template <class _NoThrowFwdIt, class _Diff, class _Alloc>
inline _NoThrowFwdIt _Uninitialized_fill_n(const _NoThrowFwdIt _First, const _Diff _Count,
    const _Iter_value_t<_NoThrowFwdIt>& _Val, _Alloc& _Al) { 
    return _Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,
        bool_constant<conjunction_v<decltype(_Fill_memset_is_safe(_First, _Val)),
            _Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(_Val)>>>{});
}
template <class _NoThrowFwdIt>
using _Use_memset_value_construct_t = bool_constant<conjunction_v<is_pointer<_NoThrowFwdIt>,
    is_scalar<_Iter_value_t<_NoThrowFwdIt>>, negation<is_volatile<_Iter_value_t<_NoThrowFwdIt>>>,
    negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>>;
template <class _Ptr>
inline _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { 
    char* const _First_ch = reinterpret_cast<char*>(_First);
    char* const _Last_ch  = reinterpret_cast<char*>(_Last);
    :: memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
    return _Last;
}
template <class _NoThrowFwdIt, class _Diff, class _Alloc>
inline _NoThrowFwdIt _Uninitialized_value_construct_n1(const _NoThrowFwdIt _First, _Diff _Count, _Alloc& _Al,
    false_type) { 
    _Uninitialized_backout_al<_NoThrowFwdIt, _Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back();
    }
    return _Backout._Release();
}
template <class _NoThrowFwdIt, class _Diff, class _Alloc>
inline _NoThrowFwdIt _Uninitialized_value_construct_n1(_NoThrowFwdIt _First, _Diff _Count, _Alloc&,
    true_type) { 
    return _Zero_range(_First, _First + _Count);
}
template <class _NoThrowFwdIt, class _Diff, class _Alloc>
inline _NoThrowFwdIt _Uninitialized_value_construct_n(
    _NoThrowFwdIt _First, _Diff _Count, _Alloc& _Al) { 
    return _Uninitialized_value_construct_n1(_First, _Count, _Al,
        bool_constant<conjunction_v<_Use_memset_value_construct_t<_NoThrowFwdIt>,
            _Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{});
}
struct _Not_a_node_tag { 
};
template <class _Ty>
[[nodiscard]] [[deprecated("warning STL4012: " "std::get_temporary_buffer() and std::return_temporary_buffer() are deprecated in C++17. " "You can define _SILENCE_CXX17_TEMPORARY_BUFFER_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] pair<_Ty*, ptrdiff_t> get_temporary_buffer(
    ptrdiff_t _Count) noexcept { 
    return _Get_temporary_buffer<_Ty>(_Count);
}
template <class _Ty>
[[deprecated("warning STL4012: " "std::get_temporary_buffer() and std::return_temporary_buffer() are deprecated in C++17. " "You can define _SILENCE_CXX17_TEMPORARY_BUFFER_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] void return_temporary_buffer(_Ty* _Pbuf) { 
    _Return_temporary_buffer(_Pbuf);
}
}
#pragma warning(pop)
#pragma pack(pop)
#line 366 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory"
#line 367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmemory"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
extern "C" {
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
    void* _First1, void* _Last1, void* _First2) noexcept;
}
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
namespace std {
const int _ISORT_MAX = 32; 
template <class _Diff>
constexpr ptrdiff_t _Temporary_buffer_size(
    const _Diff _Value) noexcept { 
    using _CT = common_type_t<ptrdiff_t, _Diff>;
    return static_cast<ptrdiff_t>(_Min_value(static_cast<_CT>(9223372036854775807i64), static_cast<_CT>(_Value)));
}
template <class _Ty>
struct _Optimistic_temporary_buffer { 
    static constexpr size_t _Optimistic_size  = 4096; 
    static constexpr size_t _Optimistic_count = _Max_value(static_cast<size_t>(1), _Optimistic_size / sizeof(_Ty));
    template <class _Diff>
    explicit _Optimistic_temporary_buffer(const _Diff _Requested_size) noexcept { 
        const auto _Attempt = _Temporary_buffer_size(_Requested_size);
        if (_Requested_size <= _Optimistic_count) { 
            _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
            _Capacity = static_cast<ptrdiff_t>(_Requested_size); 
            return;
        }
        const pair<_Ty*, ptrdiff_t> _Raw = _Get_temporary_buffer<_Ty>(_Attempt);
        if (_Raw.second > _Optimistic_count) { 
            _Data     = _Raw.first;
            _Capacity = _Raw.second;
            return;
        }
        _Return_temporary_buffer(_Raw.first);
        _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
        _Capacity = _Optimistic_count;
    }
    _Optimistic_temporary_buffer(const _Optimistic_temporary_buffer&) = delete;
    _Optimistic_temporary_buffer& operator=(const _Optimistic_temporary_buffer&) = delete;
    ~_Optimistic_temporary_buffer() noexcept { 
        if (_Capacity > _Optimistic_count) {
            _Return_temporary_buffer(_Data);
        }
    }
    _Ty* _Data; 
    ptrdiff_t _Capacity;
    aligned_union_t<0, _Ty> _Stack_space[_Optimistic_count];
};
template <class _InIt, class _Fn>
inline _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        _Func(*_UFirst);
    }
    return _Func;
}
template <class _ExPo, class _FwdIt, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void for_each(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Fn _Func) noexcept;
template <class _InIt, class _Diff, class _Fn>
inline _InIt for_each_n(
    _InIt _First, const _Diff _Count_raw, _Fn _Func) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        do {
            _Func(*_UFirst);
            --_Count;
            ++_UFirst;
        } while (0 < _Count);
        _Seek_wrapped(_First, _UFirst);
    }
    return _First;
}
template <class _ExPo, class _FwdIt, class _Diff, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt for_each_n(_ExPo&& _Exec, _FwdIt _First, _Diff _Count_raw, _Fn _Func) noexcept;
template <class _InTy, size_t _InSize, class _Diff, class _Fn>
inline _InTy* for_each_n(_InTy (&_First)[_InSize], const _Diff _Count_raw,
    _Fn _Func) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 120, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 120, 0); } while (false); } ; } while (false);
    _InTy* _UFirst = _First;
    for (; 0 < _Count; --_Count, (void) ++_UFirst) {
        _Func(*_UFirst);
    }
    return _UFirst;
}
template <class _ExPo, class _SourceTy, size_t _SourceSize, class _Diff, class _Fn,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _SourceTy* for_each_n(_ExPo&& _Exec, _SourceTy (&_First)[_SourceSize], _Diff _Count_raw, _Fn _Func) noexcept;
#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 134 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _Pr>
[[nodiscard]] inline _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }
    _Seek_wrapped(_First, _UFirst);
    return _First;
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt find_if(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last, _Pr _Pred) noexcept;
#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _Pr>
[[nodiscard]] inline _InIt find_if_not(
    _InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            break;
        }
    }
    _Seek_wrapped(_First, _UFirst);
    return _First;
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt find_if_not(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept;
#line 177 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt adjacent_find(
    const _FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UNext = _UFirst; ++_UNext != _ULast; _UFirst = _UNext) {
            if (_Pred(*_UFirst, *_UNext)) {
                _ULast = _UFirst;
                break;
            }
        }
    }
    _Seek_wrapped(_Last, _ULast);
    return _Last;
}
template <class _FwdIt>
[[nodiscard]] inline _FwdIt adjacent_find(const _FwdIt _First, const _FwdIt _Last) { 
    return ::std:: adjacent_find(_First, _Last, equal_to<>());
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt adjacent_find(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept;
template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt adjacent_find(
    _ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last) noexcept { 
    return ::std:: adjacent_find(::std:: forward<_ExPo>(_Exec), _First, _Last, equal_to<>());
}
#line 213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _Pr>
[[nodiscard]] inline _Iter_diff_t<_InIt> count_if(
    _InIt _First, _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst               = _Get_unwrapped(_First);
    const auto _ULast          = _Get_unwrapped(_Last);
    _Iter_diff_t<_InIt> _Count = 0;
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            ++_Count;
        }
    }
    return _Count;
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _Iter_diff_t<_FwdIt> count_if(
    _ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, _Pr _Pred) noexcept;
#line 236 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
        ++_UFirst1;
        ++_UFirst2;
    }
    _Seek_wrapped(_First2, _UFirst2);
    _Seek_wrapped(_First1, _UFirst1);
    return {_First1, _First2};
}
template <class _InIt1, class _RightTy, size_t _RightSize, class _Pr, enable_if_t<!is_same_v<_RightTy*, _Pr>, int> = 0>
[[nodiscard]] inline pair<_InIt1, _RightTy*> mismatch(const _InIt1 _First1, const _InIt1 _Last1,
    _RightTy (&_First2)[_RightSize], _Pr _Pred) { 
    const auto _Result =
        ::std:: mismatch(_First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred));
    return {_Result.first, _Result.second._Unwrapped()};
}
#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline pair<_FwdIt1, _FwdIt2> mismatch(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred) noexcept;
template <class _ExPo, class _FwdIt1, class _RightTy, size_t _RightSize, class _Pr,
    enable_if_t<is_execution_policy_v<decay_t<_ExPo>> && !is_same_v<_RightTy*, _Pr>, int> = 0>
[[nodiscard]] inline pair<_FwdIt1, _RightTy*> mismatch(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
    _RightTy (&_First2)[_RightSize], _Pr _Pred) { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    const auto _Result = ::std:: mismatch(
        ::std:: forward<_ExPo>(_Exec), _First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred));
    return {_Result.first, _Result.second._Unwrapped()};
}
#line 281 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(const _InIt1 _First1, const _InIt1 _Last1,
    const _InIt2 _First2) { 
    return ::std:: mismatch(_First1, _Last1, _First2, equal_to<>());
}
template <class _InIt1, class _RightTy, size_t _RightSize>
[[nodiscard]] inline pair<_InIt1, _RightTy*> mismatch(const _InIt1 _First1, const _InIt1 _Last1,
    _RightTy (&_First2)[_RightSize]) { 
    return ::std:: mismatch(_First1, _Last1, _First2, equal_to<>());
}
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline pair<_FwdIt1, _FwdIt2> mismatch(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
    const _FwdIt2 _First2) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: mismatch(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to<>());
}
template <class _ExPo, class _FwdIt1, class _RightTy, size_t _RightSize, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline pair<_FwdIt1, _RightTy*> mismatch(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
    _RightTy (&_First2)[_RightSize]) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: mismatch(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to<>());
}
#line 314 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 315 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    auto _ULast1       = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_InIt1> && _Is_random_iter_v<_InIt2>) {
        using _CT         = _Common_diff_t<_InIt1, _InIt2>;
        const _CT _Count1 = _ULast1 - _UFirst1;
        const _CT _Count2 = _ULast2 - _UFirst2;
        const auto _Count = static_cast<_Iter_diff_t<_InIt1>>(_Min_value(_Count1, _Count2));
        _ULast1           = _UFirst1 + _Count;
        while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst1;
            ++_UFirst2;
        }
    } else {
        while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2 && _Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst1;
            ++_UFirst2;
        }
    }
    _Seek_wrapped(_First2, _UFirst2);
    _Seek_wrapped(_First1, _UFirst1);
    return {_First1, _First2};
}
#line 384 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline pair<_FwdIt1, _FwdIt2> mismatch(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept;
#line 390 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2>
[[nodiscard]] inline pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
    _InIt2 _Last2) { 
    return ::std:: mismatch(_First1, _Last1, _First2, _Last2, equal_to<>());
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline pair<_FwdIt1, _FwdIt2> mismatch(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _FwdIt2 _Last2) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: mismatch(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to<>());
}
#line 406 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _Pr>
[[nodiscard]] inline bool all_of(_InIt _First, _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            return false;
        }
    }
    return true;
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool all_of(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept;
#line 426 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _Pr>
[[nodiscard]] inline bool any_of(const _InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            return true;
        }
    }
    return false;
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool any_of(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _Pr _Pred) noexcept;
#line 446 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _Pr>
[[nodiscard]] inline bool none_of(const _InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            return false;
        }
    }
    return true;
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool none_of(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _Pr _Pred) noexcept;
#line 466 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _OutIt, class _Pr>
inline _OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
template <class _InIt, class _DestTy, size_t _DestSize, class _Pr>
inline _DestTy* copy_if(
    _InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize], _Pr _Pred) { 
    return ::std:: copy_if(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))._Unwrapped();
}
#line 492 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: copy_if(_First, _Last, _Dest, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: copy_if(_First, _Last, _Dest, _Pass_fn(_Pred));
}
#line 513 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _OutIt1, class _OutIt2, class _Pr>
inline pair<_OutIt1, _OutIt2> partition_copy(_InIt _First, _InIt _Last, _OutIt1 _Dest_true, _OutIt2 _Dest_false,
    _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest_true  = _Get_unwrapped_unverified(_Dest_true);
    auto _UDest_false = _Get_unwrapped_unverified(_Dest_false);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UDest_true = *_UFirst;
            ++_UDest_true;
        } else {
            *_UDest_false = *_UFirst;
            ++_UDest_false;
        }
    }
    _Seek_wrapped(_Dest_false, _UDest_false);
    _Seek_wrapped(_Dest_true, _UDest_true);
    return {_Dest_true, _Dest_false};
}
template <class _InIt, class _DestTrueTy, size_t _DestTrueSize, class _OutIt2, class _Pr>
inline pair<_DestTrueTy*, _OutIt2> partition_copy(_InIt _First, _InIt _Last, _DestTrueTy (&_Dest_true)[_DestTrueSize],
    _OutIt2 _Dest_false, _Pr _Pred) { 
    const auto _Result = ::std:: partition_copy(
        _First, _Last, _Array_iterator<_DestTrueTy, _DestTrueSize>(_Dest_true), _Dest_false, _Pass_fn(_Pred));
    return {_Result.first._Unwrapped(), _Result.second};
}
template <class _InIt, class _OutIt1, class _DestFalseTy, size_t _DestFalseSize, class _Pr>
inline pair<_OutIt1, _DestFalseTy*> partition_copy(_InIt _First, _InIt _Last, _OutIt1 _Dest_true,
    _DestFalseTy (&_Dest_false)[_DestFalseSize],
    _Pr _Pred) { 
    const auto _Result = ::std:: partition_copy(
        _First, _Last, _Dest_true, _Array_iterator<_DestFalseTy, _DestFalseSize>(_Dest_false), _Pass_fn(_Pred));
    return {_Result.first, _Result.second._Unwrapped()};
}
template <class _InIt, class _DestTrueTy, size_t _DestTrueSize, class _DestFalseTy, size_t _DestFalseSize, class _Pr>
inline pair<_DestTrueTy*, _DestFalseTy*> partition_copy(_InIt _First, _InIt _Last,
    _DestTrueTy (&_Dest_true)[_DestTrueSize], _DestFalseTy (&_Dest_false)[_DestFalseSize],
    _Pr _Pred) { 
    const auto _Result = ::std:: partition_copy(_First, _Last, _Array_iterator<_DestTrueTy, _DestTrueSize>(_Dest_true),
        _Array_iterator<_DestFalseTy, _DestFalseSize>(_Dest_false), _Pass_fn(_Pred));
    return {_Result.first._Unwrapped(), _Result.second._Unwrapped()};
}
#line 566 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline pair<_FwdIt2, _FwdIt3> partition_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest_true,
    _FwdIt3 _Dest_false,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt3>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: partition_copy(_First, _Last, _Dest_true, _Dest_false, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _DestTrueTy, size_t _DestTrueSize, class _FwdIt3, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline pair<_DestTrueTy*, _FwdIt3> partition_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
    _DestTrueTy (&_Dest_true)[_DestTrueSize], _FwdIt3 _Dest_false,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt3>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: partition_copy(_First, _Last, _Dest_true, _Dest_false, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestFalseTy, size_t _DestFalseSize, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline pair<_FwdIt2, _DestFalseTy*> partition_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest_true,
    _DestFalseTy (&_Dest_false)[_DestFalseSize],
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: partition_copy(_First, _Last, _Dest_true, _Dest_false, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _DestTrueTy, size_t _DestTrueSize, class _DestFalseTy,
    size_t _DestFalseSize, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline pair<_DestTrueTy*, _DestFalseTy*> partition_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
    _DestTrueTy (&_Dest_true)[_DestTrueSize], _DestFalseTy (&_Dest_false)[_DestFalseSize],
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: partition_copy(_First, _Last, _Dest_true, _Dest_false, _Pass_fn(_Pred));
}
#line 612 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 613 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _Pr>
[[nodiscard]] inline bool is_partitioned(
    const _InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (;; ++_UFirst) { 
        if (_UFirst == _ULast) {
            return true;
        }
        if (!_Pred(*_UFirst)) {
            break;
        }
    }
    while (++_UFirst != _ULast) { 
        if (_Pred(*_UFirst)) {
            return false; 
        }
    }
    return true;
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool is_partitioned(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _Pr _Pred) noexcept;
#line 645 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt partition_point(
    _FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _Count       = ::std:: distance(_UFirst, _ULast);
    while (0 < _Count) { 
        const auto _Count2 = static_cast<_Iter_diff_t<_FwdIt>>(_Count >> 1);
        const auto _UMid   = ::std:: next(_UFirst, _Count2);
        if (_Pred(*_UMid)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2;
            --_Count;
        } else {
            _Count = _Count2;
        }
    }
    _Seek_wrapped(_First, _UFirst);
    return _First;
}
template <class _InIt1, class _InIt2, class _Pr>
inline bool _Equal_rev_pred_unchecked(_InIt1 _First1, _InIt2 _First2, const _InIt2 _Last2,
    _Pr _Pred) { 
    if constexpr (decltype(_Equal_memcmp_is_safe(_First1, _First2, _Pred))::value) {
        const auto _First1_ch = reinterpret_cast<const char*>(_First1);
        const auto _First2_ch = reinterpret_cast<const char*>(_First2);
        const auto _Count     = static_cast<size_t>(reinterpret_cast<const char*>(_Last2) - _First2_ch);
        return :: memcmp(_First1_ch, _First2_ch, _Count) == 0;
    } else {
        for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!_Pred(*_First1, *_First2)) {
                return false;
            }
        }
        return true;
    }
}
#line 719 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdItHaystack, class _FwdItPat, class _Pr>
[[nodiscard]] inline _FwdItHaystack search(_FwdItHaystack _First1, _FwdItHaystack _Last1, const _FwdItPat _First2,
    const _FwdItPat _Last2, _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_FwdItHaystack> && _Is_random_iter_v<_FwdItPat>) {
        const _Iter_diff_t<_FwdItPat> _Count2 = _ULast2 - _UFirst2;
        if (_ULast1 - _UFirst1 >= _Count2) {
            const auto _Last_possible = _ULast1 - static_cast<_Iter_diff_t<_FwdItHaystack>>(_Count2);
            for (;; ++_UFirst1) {
                if (_Equal_rev_pred_unchecked(_UFirst1, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
                    _Seek_wrapped(_Last1, _UFirst1);
                    break;
                }
                if (_UFirst1 == _Last_possible) {
                    break;
                }
            }
        }
    } else {
        for (;; ++_UFirst1) { 
            auto _UMid1 = _UFirst1;
            for (auto _UMid2 = _UFirst2;; ++_UMid1, (void) ++_UMid2) {
                if (_UMid2 == _ULast2) {
                    _Seek_wrapped(_Last1, _UFirst1);
                    return _Last1;
                } else if (_UMid1 == _ULast1) {
                    return _Last1;
                } else if (!_Pred(*_UMid1, *_UMid2)) {
                    break;
                }
            }
        }
    }
    return _Last1;
}
#line 815 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdItHaystack, class _FwdItPat, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdItHaystack search(_ExPo&& _Exec, const _FwdItHaystack _First1, _FwdItHaystack _Last1,
    const _FwdItPat _First2, const _FwdItPat _Last2, _Pr _Pred) noexcept;
#line 821 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdItHaystack, class _FwdItPat>
[[nodiscard]] inline _FwdItHaystack search(const _FwdItHaystack _First1, const _FwdItHaystack _Last1,
    const _FwdItPat _First2, const _FwdItPat _Last2) { 
    return ::std:: search(_First1, _Last1, _First2, _Last2, equal_to<>());
}
template <class _ExPo, class _FwdItHaystack, class _FwdItPat, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdItHaystack search(_ExPo&& _Exec, const _FwdItHaystack _First1, const _FwdItHaystack _Last1,
    const _FwdItPat _First2, const _FwdItPat _Last2) noexcept { 
    return ::std:: search(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to<>());
}
#line 835 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdItHaystack, class _Searcher>
[[nodiscard]] inline _FwdItHaystack search(const _FwdItHaystack _First, const _FwdItHaystack _Last,
    const _Searcher& _Search) { 
    return _Search(_First, _Last).first;
}
template <class _FwdIt, class _Diff, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt search_n(const _FwdIt _First, _FwdIt _Last, const _Diff _Count_raw, const _Ty& _Val,
    _Pr _Pred) { 
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }
    if (static_cast<uintmax_t>(_Count)
        > static_cast<uintmax_t>(
              (numeric_limits<_Iter_diff_t<_FwdIt>>::max)())) { 
        return _Last;
    }
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Is_random_iter_v<_FwdIt>) {
        const auto _Count_diff = static_cast<_Iter_diff_t<_FwdIt>>(_Count);
        auto _UOld_first       = _UFirst;
        for (_Iter_diff_t<_FwdIt> _Inc = 0; _Count_diff <= _ULast - _UOld_first;) { 
            _UFirst = _UOld_first + _Inc;
            if (_Pred(*_UFirst, _Val)) { 
                _Iter_diff_t<_FwdIt> _Count1 = _Count_diff;
                auto _UMid                   = _UFirst;
                while (_UOld_first != _UFirst && _Pred(_UFirst[-1], _Val)) { 
                    --_Count1;
                    --_UFirst;
                }
                if (_Count1 <= _ULast - _UMid) {
                    for (;;) { 
                        if (--_Count1 == 0) {
                            _Seek_wrapped(_Last, _UFirst); 
                            return _Last;
                        } else if (!_Pred(*++_UMid, _Val)) { 
                            break;
                        }
                    }
                }
                _UOld_first = ++_UMid; 
                _Inc        = 0;
            } else { 
                _UOld_first = _UFirst + 1;
                _Inc        = _Count_diff - 1;
            }
        }
    } else {
        for (; _UFirst != _ULast; ++_UFirst) {
            if (_Pred(*_UFirst, _Val)) { 
                auto _UMid = _UFirst;
                for (_Algorithm_int_t<_Diff> _Count1 = _Count;;) {
                    if (--_Count1 == 0) {
                        _Seek_wrapped(_Last, _UFirst); 
                        return _Last;
                    } else if (++_UMid == _ULast) {
                        return _Last; 
                    } else if (!_Pred(*_UMid, _Val)) { 
                        break;
                    }
                }
                _UFirst = _UMid; 
            }
        }
    }
    return _Last;
}
#line 1000 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt, class _Diff, class _Ty, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt search_n(
    _ExPo&& _Exec, const _FwdIt _First, _FwdIt _Last, const _Diff _Count_raw, const _Ty& _Val, _Pr _Pred) noexcept;
#line 1006 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Diff, class _Ty>
[[nodiscard]] inline _FwdIt search_n(
    const _FwdIt _First, const _FwdIt _Last, const _Diff _Count, const _Ty& _Val) { 
    return ::std:: search_n(_First, _Last, _Count, _Val, equal_to<>());
}
template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt search_n(_ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, const _Diff _Count,
    const _Ty& _Val) noexcept { 
    return ::std:: search_n(::std:: forward<_ExPo>(_Exec), _First, _Last, _Count, _Val, equal_to<>());
}
#line 1020 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline _FwdIt1 find_end(_FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    if constexpr (_Is_random_iter_v<_FwdIt1> && _Is_random_iter_v<_FwdIt2>) {
        const _Iter_diff_t<_FwdIt2> _Count2 = _ULast2 - _UFirst2;
        if (0 < _Count2 && _Count2 <= _ULast1 - _UFirst1) {
            for (auto _UCandidate = _ULast1 - static_cast<_Iter_diff_t<_FwdIt1>>(_Count2);; --_UCandidate) {
                if (_Equal_rev_pred_unchecked(_UCandidate, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
                    _Seek_wrapped(_First1, _UCandidate);
                    return _First1;
                }
                if (_UFirst1 == _UCandidate) {
                    break;
                }
            }
        }
        return _Last1;
    } else if constexpr (_Is_bidi_iter_v<_FwdIt1> && _Is_bidi_iter_v<_FwdIt2>) {
        for (auto _UCandidate = _ULast1;; --_UCandidate) { 
            auto _UNext1 = _UCandidate;
            auto _UNext2 = _ULast2;
            for (;;) { 
                if (_UFirst2 == _UNext2) { 
                    _Seek_wrapped(_First1, _UNext1);
                    return _First1;
                }
                if (_UFirst1 == _UNext1) { 
                    return _Last1;
                }
                --_UNext1;
                --_UNext2;
                if (!_Pred(*_UNext1, *_UNext2)) { 
                    break;
                }
            }
        }
    } else {
        auto _UResult = _ULast1;
        for (;;) { 
            auto _UNext1 = _UFirst1;
            auto _UNext2 = _UFirst2;
            for (;;) { 
                const bool _End_of_needle = static_cast<bool>(_UNext2 == _ULast2);
                if (_End_of_needle) { 
                    _UResult = _UFirst1;
                }
                if (_UNext1 == _ULast1) { 
                    _Seek_wrapped(_First1, _UResult);
                    return _First1;
                }
                if (_End_of_needle
                    || !_Pred(*_UNext1, *_UNext2)) { 
                    break;
                }
                ++_UNext1;
                ++_UNext2;
            }
            ++_UFirst1;
        }
        _Seek_wrapped(_First1, _UResult);
        return _First1;
    }
}
#line 1194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline _FwdIt1 find_end(_FwdIt1 const _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) { 
    return ::std:: find_end(_First1, _Last1, _First2, _Last2, equal_to<>());
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt1 find_end(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept;
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt1 find_end(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _FwdIt2 _Last2) noexcept { 
    return ::std:: find_end(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to<>());
}
#line 1212 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline _FwdIt1 find_first_of(_FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    for (; _UFirst1 != _ULast1; ++_UFirst1) {
        for (auto _UMid2 = _UFirst2; _UMid2 != _ULast2; ++_UMid2) {
            if (_Pred(*_UFirst1, *_UMid2)) {
                _Seek_wrapped(_First1, _UFirst1);
                return _First1;
            }
        }
    }
    _Seek_wrapped(_First1, _UFirst1);
    return _First1;
}
template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] inline _FwdIt1 find_first_of(const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) { 
    return ::std:: find_first_of(_First1, _Last1, _First2, _Last2, equal_to<>());
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt1 find_first_of(_ExPo&& _Exec, const _FwdIt1 _First1, _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept;
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt1 find_first_of(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1,
    const _FwdIt2 _First2, const _FwdIt2 _Last2) noexcept { 
    return ::std:: find_first_of(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to<>());
}
#line 1253 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt1, class _FwdIt2>
inline _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1,
    _FwdIt2 _First2) { 
    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        ::std:: iter_swap(_First1, _First2);
    }
    return _First2;
}
template <class _Ty, enable_if_t<_Is_trivially_swappable_v<_Ty>, int> = 0>
inline _Ty* _Swap_ranges_unchecked(_Ty* const _First1, _Ty* const _Last1,
    _Ty* const _First2) { 
    __std_swap_ranges_trivially_swappable_noalias(_First1, _Last1, _First2);
    return _First2 + (_Last1 - _First1);
}
#line 1274 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt1, class _FwdIt2>
inline _FwdIt2 swap_ranges(
    const _FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) { 
    _Adl_verify_range(_First1, _Last1);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
    _Seek_wrapped(_First2, _Swap_ranges_unchecked(_UFirst1, _ULast1, _UFirst2));
    return _First2;
}
template <class _FwdIt1, class _DestTy, size_t _DestSize>
inline _DestTy* swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
    _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: swap_ranges(_First1, _Last1, _Array_iterator<_DestTy, _DestSize>(_Dest))._Unwrapped();
}
#line 1293 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 swap_ranges(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1,
    _FwdIt2 _Dest) noexcept { 
    return ::std:: swap_ranges(_First1, _Last1, _Dest);
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* swap_ranges(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    return ::std:: swap_ranges(_First1, _Last1, _Dest);
}
#line 1310 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 1311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _OutIt, class _Fn>
inline _OutIt transform(
    const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        *_UDest = _Func(*_UFirst);
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
template <class _InIt, class _DestTy, size_t _DestSize, class _Fn>
inline _DestTy* transform(const _InIt _First, const _InIt _Last, _DestTy (&_Dest)[_DestSize],
    _Fn _Func) { 
    return ::std:: transform(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))._Unwrapped();
}
#line 1335 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 transform(_ExPo&& _Exec, const _FwdIt1 _First, const _FwdIt1 _Last, _FwdIt2 _Dest, _Fn _Func) noexcept;
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, class _Fn,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* transform(_ExPo&& _Exec, _FwdIt1 _First, _FwdIt1 _Last, _DestTy (&_Dest)[_DestSize],
    _Fn _Func) noexcept { 
    return ::std:: transform(
        ::std:: forward<_ExPo>(_Exec), _First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))
        ._Unwrapped();
}
#line 1350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 1351 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt, class _Fn>
inline _OutIt transform(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _OutIt _Dest,
    _Fn _Func) { 
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    const auto _Count  = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Count);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Count);
    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2, ++_UDest) {
        *_UDest = _Func(*_UFirst1, *_UFirst2);
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
template <class _InIt1, class _RightTy, size_t _RightSize, class _OutIt, class _Fn>
inline _OutIt transform(const _InIt1 _First1, const _InIt1 _Last1, _RightTy (&_First2)[_RightSize], const _OutIt _Dest,
    _Fn _Func) { 
    return ::std:: transform(_First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2), _Dest, _Pass_fn(_Func));
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize, class _Fn>
inline _DestTy* transform(const _InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _DestTy (&_Dest)[_DestSize],
    _Fn _Func) { 
    return ::std:: transform(_First1, _Last1, _First2, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))
        ._Unwrapped();
}
template <class _InIt1, class _RightTy, size_t _RightSize, class _DestTy, size_t _DestSize, class _Fn>
inline _DestTy* transform(const _InIt1 _First1, const _InIt1 _Last1, _RightTy (&_First2)[_RightSize],
    _DestTy (&_Dest)[_DestSize], _Fn _Func) { 
    return ::std:: transform(_First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2),
        _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))
        ._Unwrapped();
}
#line 1391 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 transform(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    _FwdIt3 _Dest, _Fn _Func) noexcept;
template <class _ExPo, class _FwdIt1, class _RightTy, size_t _RightSize, class _FwdIt3, class _Fn,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 transform(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, _RightTy (&_First2)[_RightSize],
    const _FwdIt3 _Dest, _Fn _Func) noexcept { 
    return ::std:: transform(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2),
        _Dest, _Pass_fn(_Func));
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize, class _Fn,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* transform(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2,
    _DestTy (&_Dest)[_DestSize], _Fn _Func) noexcept { 
    return ::std:: transform(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2,
        _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))
        ._Unwrapped();
}
template <class _ExPo, class _FwdIt1, class _RightTy, size_t _RightSize, class _DestTy, size_t _DestSize, class _Fn,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* transform(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, _RightTy (&_First2)[_RightSize],
    _DestTy (&_Dest)[_DestSize],
    _Fn _Func) noexcept { 
    return ::std:: transform(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _Array_iterator<_RightTy, _RightSize>(_First2),
        _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Func))
        ._Unwrapped();
}
#line 1425 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 1426 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Ty>
inline void replace(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Oldval,
    const _Ty& _Newval) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (*_UFirst == _Oldval) {
            *_UFirst = _Newval;
        }
    }
}
template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void replace(
    _ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, const _Ty& _Oldval, const _Ty& _Newval) noexcept;
#line 1446 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Pr, class _Ty>
inline void replace_if(
    const _FwdIt _First, const _FwdIt _Last, _Pr _Pred, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UFirst = _Val;
        }
    }
}
template <class _ExPo, class _FwdIt, class _Pr, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void replace_if(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val) noexcept;
#line 1465 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _OutIt, class _Ty>
inline _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Oldval,
    const _Ty& _Newval) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        if (*_UFirst == _Oldval) {
            *_UDest = _Newval;
        } else {
            *_UDest = *_UFirst;
        }
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
template <class _InIt, class _DestTy, size_t _DestSize, class _Ty>
inline _DestTy* replace_copy(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize], const _Ty& _Oldval,
    const _Ty& _Newval) { 
    return ::std:: replace_copy(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest), _Oldval, _Newval)._Unwrapped();
}
#line 1493 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 replace_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, const _Ty& _Oldval,
    const _Ty&
        _Newval) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: replace_copy(_First, _Last, _Dest, _Oldval, _Newval);
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, class _Ty,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* replace_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _DestTy (&_Dest)[_DestSize], const _Ty& _Oldval,
    const _Ty&
        _Newval) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: replace_copy(_First, _Last, _Dest, _Oldval, _Newval);
}
#line 1516 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 1517 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _OutIt, class _Pr, class _Ty>
inline _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
    const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        if (_Pred(*_UFirst)) {
            *_UDest = _Val;
        } else {
            *_UDest = *_UFirst;
        }
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
template <class _InIt, class _DestTy, size_t _DestSize, class _Pr, class _Ty>
inline _DestTy* replace_copy_if(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize], _Pr _Pred,
    const _Ty& _Val) { 
    return ::std:: replace_copy_if(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred), _Val)
        ._Unwrapped();
}
#line 1546 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 replace_copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Pr _Pred,
    const _Ty& _Val) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: replace_copy_if(_First, _Last, _Dest, _Pass_fn(_Pred), _Val);
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, class _Pr, class _Ty,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* replace_copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _DestTy (&_Dest)[_DestSize], _Pr _Pred,
    const _Ty& _Val) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: replace_copy_if(_First, _Last, _Dest, _Pass_fn(_Pred), _Val);
}
#line 1567 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 1568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Fn>
inline void generate(_FwdIt _First, _FwdIt _Last, _Fn _Func) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        *_UFirst = _Func();
    }
}
template <class _ExPo, class _FwdIt, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void generate(_ExPo&&, _FwdIt _First, _FwdIt _Last,
    _Fn _Func) noexcept { 
    return ::std:: generate(_First, _Last, _Pass_fn(_Func));
}
#line 1588 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _OutIt, class _Diff, class _Fn>
inline _OutIt generate_n(
    _OutIt _Dest, const _Diff _Count_raw, _Fn _Func) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UDest = _Get_unwrapped_n(_Dest, _Count);
        do {
            *_UDest = _Func();
            --_Count;
            ++_UDest;
        } while (0 < _Count);
        _Seek_wrapped(_Dest, _UDest);
    }
    return _Dest;
}
template <class _DestTy, size_t _DestSize, class _Diff, class _Fn>
inline _DestTy* generate_n(_DestTy (&_Dest)[_DestSize], const _Diff _Count_raw,
    _Fn _Func) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 1613, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 1613, 0); } while (false); } ; } while (false);
    _DestTy* _UDest = _Dest;
    for (; 0 < _Count; --_Count, (void) ++_UDest) {
        *_UDest = _Func();
    }
    return _UDest;
}
#line 1622 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt, class _Diff, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt generate_n(_ExPo&&, const _FwdIt _Dest, const _Diff _Count_raw,
    _Fn _Func) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: generate_n(_Dest, _Count_raw, _Pass_fn(_Func));
}
template <class _ExPo, class _DestTy, size_t _DestSize, class _Diff, class _Fn,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* generate_n(_ExPo&&, _DestTy (&_Dest)[_DestSize], const _Diff _Count_raw,
    _Fn _Func) noexcept { 
    return ::std:: generate_n(_Dest, _Count_raw, _Pass_fn(_Func));
}
#line 1641 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 1642 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _OutIt, class _Ty>
inline _OutIt remove_copy(
    _InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!(*_UFirst == _Val)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
template <class _InIt, class _DestTy, size_t _DestSize, class _Ty>
inline _DestTy* remove_copy(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize],
    const _Ty& _Val) { 
    return ::std:: remove_copy(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest), _Val)._Unwrapped();
}
#line 1669 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 remove_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest,
    const _Ty& _Val) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: remove_copy(_First, _Last, _Dest, _Val);
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, class _Ty,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* remove_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _DestTy (&_Dest)[_DestSize],
    const _Ty& _Val) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: remove_copy(_First, _Last, _Dest, _Val);
}
#line 1690 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 1691 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _OutIt, class _Pr>
inline _OutIt remove_copy_if(
    _InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
template <class _InIt, class _DestTy, size_t _DestSize, class _Pr>
inline _DestTy* remove_copy_if(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) { 
    return ::std:: remove_copy_if(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))._Unwrapped();
}
#line 1718 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 remove_copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: remove_copy_if(_First, _Last, _Dest, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* remove_copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: remove_copy_if(_First, _Last, _Dest, _Pass_fn(_Pred));
}
#line 1739 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 1740 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = _Find_unchecked(_UFirst, _ULast, _Val);
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!(*_UFirst == _Val)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }
    _Seek_wrapped(_First, _UNext);
    return _First;
}
template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt remove(_ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) noexcept;
#line 1766 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: find_if(_UFirst, _ULast, _Pass_fn(_Pred));
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!_Pred(*_UFirst)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }
    _Seek_wrapped(_First, _UNext);
    return _First;
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt remove_if(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last, _Pr _Pred) noexcept;
#line 1792 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UFirstb = _UFirst; ++_UFirst != _ULast; _UFirstb = _UFirst) {
            if (_Pred(*_UFirstb, *_UFirst)) { 
                while (++_UFirst != _ULast) {
                    if (!_Pred(*_UFirstb, *_UFirst)) {
                        *++_UFirstb = ::std:: move(*_UFirst);
                    }
                }
                _Seek_wrapped(_Last, ++_UFirstb);
                return _Last;
            }
        }
    }
    _Seek_wrapped(_Last, _ULast);
    return _Last;
}
template <class _FwdIt>
[[nodiscard]] inline _FwdIt unique(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: unique(_First, _Last, equal_to<>());
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt unique(_ExPo&&, _FwdIt _First, _FwdIt _Last,
    _Pr _Pred) noexcept { 
    return ::std:: unique(_First, _Last, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt unique(_ExPo&&, _FwdIt _First,
    _FwdIt _Last) noexcept { 
    return ::std:: unique(_First, _Last);
}
#line 1838 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _OutIt, class _Pr>
inline _OutIt _Unique_copy_unchecked(_FwdIt _First, _FwdIt _Last, _OutIt _Dest, _Pr _Pred, true_type,
    _Any_tag) { 
    if (_First != _Last) {
        _FwdIt _Firstb = _First;
        *_Dest = *_Firstb;
        ++_Dest;
        while (++_First != _Last) {
            if (!_Pred(*_Firstb, *_First)) { 
                _Firstb = _First;
                *_Dest  = *_Firstb;
                ++_Dest;
            }
        }
    }
    return _Dest;
}
template <class _InIt, class _FwdIt, class _Pr>
inline _FwdIt _Unique_copy_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest, _Pr _Pred, false_type,
    true_type) { 
    if (_First != _Last) {
        *_Dest = *_First;
        while (++_First != _Last) {
            if (!_Pred(*_Dest, *_First)) {
                *++_Dest = *_First;
            }
        }
        ++_Dest;
    }
    return _Dest;
}
template <class _InIt, class _OutIt, class _Pr>
inline _OutIt _Unique_copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, false_type,
    false_type) { 
    if (_First != _Last) {
        _Iter_value_t<_InIt> _Val = *_First;
        *_Dest = _Val;
        ++_Dest;
        while (++_First != _Last) {
            if (!_Pred(_Val, *_First)) { 
                _Val   = *_First;
                *_Dest = _Val;
                ++_Dest;
            }
        }
    }
    return _Dest;
}
template <class _InIt, class _OutIt, class _Pr>
inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(
        _Dest, _Unique_copy_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Get_unwrapped_unverified(_Dest),
                   _Pass_fn(_Pred), bool_constant<_Is_fwd_iter_v<_InIt>>{}, 
                   bool_constant<conjunction_v<bool_constant<_Is_fwd_iter_v<_OutIt>>,
                       is_same<_Iter_value_t<_InIt>, _Iter_value_t<_OutIt>>>>{}));
    return _Dest;
}
template <class _InIt, class _DestTy, size_t _DestSize, class _Pr>
inline _DestTy* unique_copy(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) { 
    return ::std:: unique_copy(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))._Unwrapped();
}
#line 1922 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _OutIt>
inline _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    return ::std:: unique_copy(_First, _Last, _Dest, equal_to<>());
}
template <class _InIt, class _DestTy, size_t _DestSize>
inline _DestTy* unique_copy(
    _InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: unique_copy(_First, _Last, _Dest, equal_to<>());
}
#line 1935 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 unique_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: unique_copy(_First, _Last, _Dest, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* unique_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: unique_copy(_First, _Last, _Dest, _Pass_fn(_Pred));
}
#line 1956 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 unique_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
    _FwdIt2 _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: unique_copy(_First, _Last, _Dest);
}
template <class _ExPo, class _FwdIt1, class _DestTy, size_t _DestSize, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* unique_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: unique_copy(_First, _Last, _Dest);
}
#line 1976 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 1977 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _BidIt, class _OutIt>
inline _OutIt reverse_copy(_BidIt _First, _BidIt _Last,
    _OutIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_BidIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UDest) {
        *_UDest = *--_ULast;
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
template <class _BidIt, class _DestTy, size_t _DestSize>
inline _DestTy* reverse_copy(_BidIt _First, _BidIt _Last,
    _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: reverse_copy(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest))._Unwrapped();
}
#line 2001 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _BidIt, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt reverse_copy(_ExPo&&, _BidIt _First, _BidIt _Last,
    _FwdIt _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: reverse_copy(_First, _Last, _Dest);
}
template <class _ExPo, class _BidIt, class _DestTy, size_t _DestSize, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* reverse_copy(_ExPo&&, _BidIt _First, _BidIt _Last,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    return ::std:: reverse_copy(_First, _Last, _Dest);
}
#line 2019 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 2020 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _OutIt>
inline _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest) { 
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _UMid   = _Get_unwrapped(_Mid);
    const auto _ULast  = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_FwdIt>(_UFirst, _ULast));
    _UDest             = _Copy_unchecked(_UMid, _ULast, _UDest);
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _UMid, _UDest));
    return _Dest;
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt2 rotate_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Mid, _FwdIt1 _Last,
    _FwdIt2 _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: rotate_copy(_First, _Mid, _Last, _Dest);
}
template <class _PopIt, class _SampleIt, class _Diff, class _RngFn>
inline _SampleIt _Sample_reservoir_unchecked(_PopIt _First, const _PopIt _Last, const _SampleIt _Dest,
    const _Diff _Count,
    _RngFn& _RngFunc) { 
    using _Diff_sample = _Iter_diff_t<_SampleIt>;
    const auto _SCount = static_cast<_Diff_sample>(_Count);
    _Iter_diff_t<_PopIt> _PopSize{};
    for (; _PopSize < _SCount; ++_PopSize, (void) ++_First) {
        const auto _Sample_pop = static_cast<_Diff_sample>(_PopSize);
        if (_First == _Last) {
            return _Dest + _Sample_pop;
        }
        _Dest[_Sample_pop] = *_First;
    }
    for (; _First != _Last; ++_First) {
        const auto _Idx = _RngFunc(++_PopSize);
        if (_Idx < _SCount) {
            _Dest[static_cast<_Diff_sample>(_Idx)] = *_First; 
        }
    }
    return _Dest + _SCount;
}
template <class _PopIt, class _SampleIt, class _Diff, class _RngFn>
inline _SampleIt _Sample_selection_unchecked(_PopIt _First, const _PopIt _Last, _Iter_diff_t<_PopIt> _PopSize,
    _SampleIt _Dest, _Diff _Count,
    _RngFn& _RngFunc) { 
    using _CT = common_type_t<_Iter_diff_t<_PopIt>, _Diff>;
    for (; _Count > 0 && _First != _Last; ++_First, (void) --_PopSize) {
        if (static_cast<_CT>(_RngFunc(_PopSize)) < static_cast<_CT>(_Count)) {
            --_Count;
            *_Dest = *_First;
            ++_Dest;
        }
    }
    return _Dest;
}
template <class _PopIt, class _SampleIt, class _Diff, class _RngFn>
inline _SampleIt _Sample1(_PopIt _First, _PopIt _Last, _SampleIt _Dest, _Diff _Count, _RngFn& _RngFunc,
    input_iterator_tag) { 
    _Seek_wrapped(
        _Dest, _Sample_reservoir_unchecked(_First, _Last, _Get_unwrapped_unverified(_Dest), _Count, _RngFunc));
    return _Dest;
}
template <class _PopIt, class _SampleIt, class _Diff, class _RngFn>
inline _SampleIt _Sample1(_PopIt _First, _PopIt _Last, _SampleIt _Dest, _Diff _Count, _RngFn& _RngFunc,
    forward_iterator_tag) { 
    using _PopDiff      = _Iter_diff_t<_PopIt>;
    using _CT           = common_type_t<_Diff, _PopDiff>;
    const auto _PopSize = ::std:: distance(_First, _Last);
    if (static_cast<_CT>(_Count) > static_cast<_CT>(_PopSize)) {
        _Count = static_cast<_Diff>(_PopSize); 
    }
    _Seek_wrapped(
        _Dest, _Sample_selection_unchecked(_First, _Last, _PopSize, _Get_unwrapped_n(_Dest, _Count), _Count, _RngFunc));
    return _Dest;
}
template <class _PopIt, class _SampleIt, class _Diff, class _Urng>
inline _SampleIt sample(_PopIt _First, _PopIt _Last, _SampleIt _Dest, _Diff _Count,
    _Urng&& _Func) { 
    static_assert(_Is_fwd_iter_v<_PopIt> || _Is_random_iter_v<_SampleIt>,
        "If the source range is not forward, the destination range must be random-access.");
    static_assert(is_integral_v<_Diff>, "The sample size must have an integer type.");
    _Adl_verify_range(_First, _Last);
    if (0 < _Count) {
        _Rng_from_urng<_Iter_diff_t<_PopIt>, remove_reference_t<_Urng>> _RngFunc(_Func);
        _Dest = _Sample1(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Dest, _Count, _RngFunc, _Iter_cat_t<_PopIt>());
    }
    return _Dest;
}
template <class _PopIt, class _DestTy, size_t _DestSize, class _Diff, class _Urng>
inline _DestTy* sample(_PopIt _First, _PopIt _Last, _DestTy (&_Dest)[_DestSize], _Diff _Count,
    _Urng&& _Func) { 
    return ::std:: sample(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest), _Count, _Func)._Unwrapped();
}
#line 2136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 2137 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _RanIt, class _RngFn>
inline void _Random_shuffle1(
    _RanIt _First, _RanIt _Last, _RngFn& _RngFunc) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _ULast) {
        return;
    }
    using _Diff         = _Iter_diff_t<_RanIt>;
    auto _UTarget       = _UFirst;
    _Diff _Target_index = 1;
    for (; ++_UTarget != _ULast; ++_Target_index) { 
        _Diff _Off = _RngFunc(static_cast<_Diff>(_Target_index + 1));
        do { if (0 <= _Off && _Off <= _Target_index) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 2154, 0, "%s", "random value out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"random value out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 2154, 0); } while (false); } ; } while (false);
        if (_Off != _Target_index) { 
            ::std:: iter_swap(_UTarget, _UFirst + _Off);
        }
    }
}
template <class _RanIt, class _Urng>
inline void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func) { 
    using _Urng0 = remove_reference_t<_Urng>;
    _Rng_from_urng<_Iter_diff_t<_RanIt>, _Urng0> _RngFunc(_Func);
    _Random_shuffle1(_First, _Last, _RngFunc);
}
#line 2200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Pr>
inline _FwdIt partition(
    _FwdIt _First, const _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if constexpr (_Is_bidi_iter_v<_FwdIt>) {
        for (;;) { 
            for (;;) { 
                if (_UFirst == _ULast) {
                    _Seek_wrapped(_First, _UFirst);
                    return _First;
                }
                if (!_Pred(*_UFirst)) {
                    break;
                }
                ++_UFirst;
            }
            do { 
                --_ULast;
                if (_UFirst == _ULast) {
                    _Seek_wrapped(_First, _UFirst);
                    return _First;
                }
            } while (!_Pred(*_ULast));
            ::std:: iter_swap(_UFirst, _ULast); 
            ++_UFirst;
        }
    } else {
        for (;;) { 
            if (_UFirst == _ULast) {
                _Seek_wrapped(_First, _UFirst);
                return _First;
            }
            if (!_Pred(*_UFirst)) {
                break;
            }
            ++_UFirst;
        }
        for (auto _UNext = _UFirst; ++_UNext != _ULast;) {
            if (_Pred(*_UNext)) {
                ::std:: iter_swap(_UFirst, _UNext); 
                ++_UFirst;
            }
        }
    }
    _Seek_wrapped(_First, _UFirst);
    return _First;
}
#line 2324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt partition(_ExPo&& _Exec, _FwdIt _First, const _FwdIt _Last, _Pr _Pred) noexcept;
#line 2329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _BidIt>
inline _BidIt _Buffered_rotate_unchecked(const _BidIt _First, const _BidIt _Mid, const _BidIt _Last,
    const _Iter_diff_t<_BidIt> _Count1, const _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr,
    const ptrdiff_t _Capacity) { 
    if (_Count1 == 0) {
        return _Last;
    }
    if (_Count2 == 0) {
        return _First;
    }
    if (_Count1 <= _Count2 && _Count1 <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
            _Temp_ptr, _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr)};
        const _BidIt _New_mid = _Move_unchecked(_Mid, _Last, _First);
        _Move_unchecked(_Backout._First, _Backout._Last, _New_mid);
        return _New_mid; 
    }
    if (_Count2 <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
            _Temp_ptr, _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr)};
        _Move_backward_unchecked(_First, _Mid, _Last);
        return _Move_unchecked(_Backout._First, _Backout._Last, _First); 
    }
    return ::std:: rotate(_First, _Mid, _Last);
}
template <class _BidIt, class _Pr>
inline pair<_BidIt, _Iter_diff_t<_BidIt>> _Stable_partition_unchecked1(_BidIt _First, _BidIt _Last, _Pr _Pred,
    const _Iter_diff_t<_BidIt> _Count, _Iter_value_t<_BidIt>* const _Temp_ptr,
    const ptrdiff_t _Capacity) { 
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count - static_cast<_Diff>(1) <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{_Temp_ptr};
        _BidIt _Next = _First;
        _Backout._Emplace_back(::std:: move(*_First));
        while (++_First != _Last) { 
            if (_Pred(*_First)) {
                *_Next = ::std:: move(*_First);
                ++_Next;
            } else {
                _Backout._Emplace_back(::std:: move(*_First));
            }
        }
        *_Next = ::std:: move(*_Last);
        ++_Next;
        _Move_unchecked(_Backout._First, _Backout._Last, _Next); 
        _Diff _True_distance = static_cast<_Diff>(_Count - static_cast<_Diff>(_Backout._Last - _Backout._First));
        return pair<_BidIt, _Diff>(_Next, _True_distance); 
    }
    const _Diff _Mid_offset = _Count / static_cast<_Diff>(2); 
    const _BidIt _Mid       = ::std:: next(_First, _Mid_offset);
    _BidIt _Left           = _Mid;
    _Diff _Left_true_count = _Mid_offset;
    for (;;) { 
        --_Left;
        if (_First == _Left) { 
            --_Left_true_count; 
            break;
        }
        if (_Pred(*_Left)) { 
            const pair<_BidIt, _Diff> _Low =
                _Stable_partition_unchecked1(_First, _Left, _Pred, _Left_true_count, _Temp_ptr, _Capacity);
            _Left            = _Low.first;
            _Left_true_count = _Low.second;
            break;
        }
        --_Left_true_count;
    }
    _BidIt _Right           = _Mid;
    _Diff _Right_true_count = 0;
    for (;;) { 
        if (_Right == _Last) { 
            ++_Right; 
            ++_Right_true_count;
            break;
        }
        if (!_Pred(*_Right)) { 
            const _Diff _Right_count = _Count - _Mid_offset;
            const _Diff _Remaining   = _Right_count - _Right_true_count;
            const pair<_BidIt, _Diff> _High =
                _Stable_partition_unchecked1(_Right, _Last, _Pred, _Remaining, _Temp_ptr, _Capacity);
            _Right = _High.first;
            _Right_true_count += _High.second;
            break;
        }
        ++_Right;
        ++_Right_true_count;
    }
    const _BidIt _Partition_point = _Buffered_rotate_unchecked(_Left, _Mid, _Right,
        static_cast<_Diff>(_Mid_offset - _Left_true_count), _Right_true_count, _Temp_ptr, _Capacity);
    return pair<_BidIt, _Diff>(_Partition_point, static_cast<_Diff>(_Left_true_count + _Right_true_count));
}
template <class _BidIt, class _Pr>
inline _BidIt _Stable_partition_unchecked(
    _BidIt _First, _BidIt _Last, _Pr _Pred) { 
    for (;;) {
        if (_First == _Last) { 
            return _First;
        }
        if (!_Pred(*_First)) { 
            break;
        }
        ++_First;
    }
    for (;;) {
        --_Last;
        if (_First == _Last) { 
            return _First;
        }
        if (_Pred(*_Last)) { 
            break;
        }
    }
    using _Diff              = _Iter_diff_t<_BidIt>;
    const _Diff _Temp_count  = ::std:: distance(_First, _Last); 
    const _Diff _Total_count = _Temp_count + static_cast<_Diff>(1);
    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Temp_count};
    return _Stable_partition_unchecked1(_First, _Last, _Pred, _Total_count, _Temp_buf._Data, _Temp_buf._Capacity).first;
}
template <class _BidIt, class _Pr>
inline _BidIt stable_partition(
    _BidIt _First, _BidIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Stable_partition_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}
template <class _ExPo, class _BidIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _BidIt stable_partition(_ExPo&&, _BidIt _First, _BidIt _Last,
    _Pr _Pred) noexcept { 
    return ::std:: stable_partition(_First, _Last, _Pass_fn(_Pred));
}
#line 2500 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _RanIt, class _Ty, class _Pr>
inline void _Push_heap_by_index(_RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val,
    _Pr _Pred) { 
    for (_Iter_diff_t<_RanIt> _Idx = (_Hole - 1) >> 1; 
         _Top < _Hole && _Debug_lt_pred(_Pred, *(_First + _Idx), _Val);
         _Idx = (_Hole - 1) >> 1) 
    { 
        *(_First + _Hole) = ::std:: move(*(_First + _Idx));
        _Hole             = _Idx;
    }
    *(_First + _Hole) = ::std:: move(_Val); 
}
template <class _RanIt, class _Pr>
inline void push_heap(
    _RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    using _Diff        = _Iter_diff_t<_RanIt>;
    _Diff _Count       = _ULast - _UFirst;
    if (2 <= _Count) {
        _Iter_value_t<_RanIt> _Val = ::std:: move(*--_ULast);
        _Push_heap_by_index(_UFirst, --_Count, _Diff(0), ::std:: move(_Val), _Pass_fn(_Pred));
    }
}
template <class _RanIt>
inline void push_heap(
    _RanIt _First, _RanIt _Last) { 
    ::std:: push_heap(_First, _Last, less<>());
}
template <class _RanIt, class _Ty, class _Pr>
inline void _Pop_heap_hole_by_index(_RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val,
    _Pr _Pred) { 
    using _Diff      = _Iter_diff_t<_RanIt>;
    const _Diff _Top = _Hole;
    _Diff _Idx       = _Hole;
    const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; 
    while (_Idx < _Max_sequence_non_leaf) { 
        _Idx = 2 * _Idx + 2;
        if (_Debug_lt_pred(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {
            --_Idx;
        }
        *(_First + _Hole) = ::std:: move(*(_First + _Idx));
        _Hole             = _Idx;
    }
    if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { 
        *(_First + _Hole) = ::std:: move(*(_First + (_Bottom - 1)));
        _Hole             = _Bottom - 1;
    }
    _Push_heap_by_index(_First, _Hole, _Top, ::std:: move(_Val), _Pred);
}
template <class _RanIt, class _Ty, class _Pr>
inline void _Pop_heap_hole_unchecked(
    _RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) { 
    *_Dest = ::std:: move(*_First);
    _Pop_heap_hole_by_index(
        _First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First), ::std:: move(_Val), _Pred);
}
template <class _RanIt, class _Pr>
inline void _Pop_heap_unchecked(
    _RanIt _First, _RanIt _Last, _Pr _Pred) { 
    if (2 <= _Last - _First) {
        --_Last;
        _Iter_value_t<_RanIt> _Val = ::std:: move(*_Last);
        _Pop_heap_hole_unchecked(_First, _Last, _Last, ::std:: move(_Val), _Pred);
    }
}
template <class _RanIt, class _Pr>
inline void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
}
template <class _RanIt>
inline void pop_heap(_RanIt _First, _RanIt _Last) { 
    ::std:: pop_heap(_First, _Last, less<>());
}
template <class _RanIt, class _Pr>
inline void _Make_heap_unchecked(
    _RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Iter_diff_t<_RanIt> _Bottom = _Last - _First;
    for (_Iter_diff_t<_RanIt> _Hole = _Bottom >> 1; 0 < _Hole;) 
    { 
        --_Hole;
        _Iter_value_t<_RanIt> _Val = ::std:: move(*(_First + _Hole));
        _Pop_heap_hole_by_index(_First, _Hole, _Bottom, ::std:: move(_Val), _Pred);
    }
}
template <class _RanIt, class _Pr>
inline void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Make_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
}
template <class _RanIt>
inline void make_heap(_RanIt _First, _RanIt _Last) { 
    ::std:: make_heap(_First, _Last, less<>());
}
template <class _RanIt, class _Pr>
inline _RanIt _Is_heap_until_unchecked(
    _RanIt _First, _RanIt _Last, _Pr _Pred) { 
    const _Iter_diff_t<_RanIt> _Size = _Last - _First;
    for (_Iter_diff_t<_RanIt> _Off = 1; _Off < _Size; ++_Off) {
        if (_Debug_lt_pred(_Pred, _First[(_Off - 1) >> 1], _First[_Off])) { 
            return _First + _Off;
        }
    }
    return _Last;
}
template <class _RanIt, class _Pr>
[[nodiscard]] inline _RanIt is_heap_until(
    _RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Is_heap_until_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}
template <class _RanIt, class _Pr>
[[nodiscard]] inline bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    return _Is_heap_until_unchecked(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast;
}
template <class _RanIt>
[[nodiscard]] inline _RanIt is_heap_until(
    _RanIt _First, _RanIt _Last) { 
    return ::std:: is_heap_until(_First, _Last, less<>());
}
template <class _RanIt>
[[nodiscard]] inline bool is_heap(_RanIt _First, _RanIt _Last) { 
    return ::std:: is_heap(_First, _Last, less<>());
}
template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _RanIt is_heap_until(_ExPo&& _Exec, _RanIt _First, _RanIt _Last, _Pr _Pred) noexcept;
template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool is_heap(
    _ExPo&& _Exec, _RanIt _First, _RanIt _Last, _Pr _Pred) noexcept { 
    return ::std:: is_heap_until(::std:: forward<_ExPo>(_Exec), _First, _Last, _Pass_fn(_Pred)) == _Last;
}
template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _RanIt is_heap_until(
    _ExPo&& _Exec, _RanIt _First, _RanIt _Last) noexcept { 
    return ::std:: is_heap_until(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}
template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool is_heap(
    _ExPo&& _Exec, _RanIt _First, _RanIt _Last) noexcept { 
    return ::std:: is_heap(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}
#line 2683 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _RanIt, class _Pr>
inline void _Sort_heap_unchecked(
    _RanIt _First, _RanIt _Last, _Pr _Pred) { 
    for (; 2 <= _Last - _First; --_Last) {
        _Pop_heap_unchecked(_First, _Last, _Pred);
    }
}
template <class _RanIt, class _Pr>
inline void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _Counterexample = _Is_heap_until_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
    if (_Counterexample != _ULast) {
        do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 2701, 0, "%s", "invalid heap in sort_heap()")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid heap in sort_heap()\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 2701, 0); } while (false);
    }
#line 2704 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
    _Sort_heap_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
}
template <class _RanIt>
inline void sort_heap(_RanIt _First, _RanIt _Last) { 
    ::std:: sort_heap(_First, _Last, less<>());
}
template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt lower_bound(
    _FwdIt _First, _FwdIt _Last, const _Ty& _Val) { 
    return ::std:: lower_bound(_First, _Last, _Val, less<>());
}
template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt upper_bound(
    _FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));
    while (0 < _Count) { 
        _Iter_diff_t<_FwdIt> _Count2 = _Count >> 1; 
        const auto _UMid             = ::std:: next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        } else { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }
    _Seek_wrapped(_First, _UFirst);
    return _First;
}
template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt upper_bound(
    _FwdIt _First, _FwdIt _Last, const _Ty& _Val) { 
    return ::std:: upper_bound(_First, _Last, _Val, less<>());
}
template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline pair<_FwdIt, _FwdIt> equal_range(
    _FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    using _Diff  = _Iter_diff_t<_FwdIt>;
    _Diff _Count = ::std:: distance(_UFirst, _ULast);
    for (;;) { 
        if (_Count <= 0) {
            _Seek_wrapped(_Last, _UFirst); 
            _Seek_wrapped(_First, _UFirst);
            break;
        }
        _Diff _Count2    = _Count >> 1; 
        const auto _UMid = ::std:: next(_UFirst, _Count2);
        if (_Debug_lt_pred(_Pred, *_UMid, _Val)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else if (_Pred(_Val, *_UMid)) {
            _Count = _Count2; 
        } else { 
            auto _UFirst2 = ::std:: lower_bound(_UFirst, _UMid, _Val, _Pass_fn(_Pred));
            ::std:: advance(_UFirst, _Count);
            auto _ULast2 = ::std:: upper_bound(_Next_iter(_UMid), _UFirst, _Val, _Pass_fn(_Pred));
            _Seek_wrapped(_Last, _ULast2);
            _Seek_wrapped(_First, _UFirst2);
            break;
        }
    }
    return {_First, _Last};
}
template <class _FwdIt, class _Ty>
[[nodiscard]] inline pair<_FwdIt, _FwdIt> equal_range(
    _FwdIt _First, _FwdIt _Last, const _Ty& _Val) { 
    return ::std:: equal_range(_First, _Last, _Val, less<>());
}
template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline bool binary_search(
    _FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: lower_bound(_UFirst, _ULast, _Val, _Pass_fn(_Pred));
    return _UFirst != _ULast && !_Pred(_Val, *_UFirst);
}
template <class _FwdIt, class _Ty>
[[nodiscard]] inline bool binary_search(
    _FwdIt _First, _FwdIt _Last, const _Ty& _Val) { 
    return ::std:: binary_search(_First, _Last, _Val, less<>());
}
inline _Distance_unknown _Idl_dist_add(
    _Distance_unknown, _Distance_unknown) { 
    return {};
}
template <class _Diff1>
inline _Distance_unknown _Idl_dist_add(_Diff1, _Distance_unknown) { 
    return {};
}
template <class _Diff2>
inline _Distance_unknown _Idl_dist_add(_Distance_unknown, _Diff2) { 
    return {};
}
template <class _Diff1, class _Diff2>
inline auto _Idl_dist_add(_Diff1 _Lhs, _Diff2 _Rhs) { 
    return _Lhs + _Rhs;
}
template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    const auto _Count1 = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
    const auto _Count2 = _Idl_distance<_InIt2>(_UFirst2, _ULast2);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_dist_add(_Count1, _Count2));
    if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        for (;;) {
            if (_Debug_lt_pred(_Pred, *_UFirst2, *_UFirst1)) {
                *_UDest = *_UFirst2;
                ++_UDest;
                ++_UFirst2;
                if (_UFirst2 == _ULast2) {
                    break;
                }
            } else {
                *_UDest = *_UFirst1;
                ++_UDest;
                ++_UFirst1;
                if (_UFirst1 == _ULast1) {
                    break;
                }
            }
        }
    }
    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest); 
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize, class _Pr>
inline _DestTy* merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) { 
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))
        ._Unwrapped();
}
#line 2879 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _OutIt _Dest) { 
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize>
inline _DestTy* merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
#line 2893 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 merge(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt3>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* merge(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest, _Pass_fn(_Pred));
}
#line 2917 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 merge(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt3>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest);
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* merge(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest);
}
#line 2940 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 2941 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _BidIt>
inline void _Rotate_one_right(
    _BidIt _First, _BidIt _Mid, _BidIt _Last) { 
    _Iter_value_t<_BidIt> _Temp(::std:: move(*_Mid));
    _Move_backward_unchecked(_First, _Mid, _Last);
    *_First = ::std:: move(_Temp);
}
template <class _BidIt>
inline void _Rotate_one_left(
    _BidIt _First, _BidIt _Mid, _BidIt _Last) { 
    _Iter_value_t<_BidIt> _Temp(::std:: move(*_First));
    *_Move_unchecked(_Mid, _Last, _First) = ::std:: move(_Temp);
}
template <class _BidIt, class _Pr>
inline void _Inplace_merge_buffer_left(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_value_t<_BidIt>* const _Temp_ptr,
    _Pr _Pred) { 
    using _Ptr_ty = _Iter_value_t<_BidIt>*;
    _Uninitialized_backout<_Ptr_ty> _Backout{_Temp_ptr, _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr)};
    _Ptr_ty _Left_first      = _Temp_ptr;
    const _Ptr_ty _Left_last = _Backout._Last - 1; 
    *_First                  = ::std:: move(*_Mid); 
    ++_First;
    ++_Mid;
    for (;;) {
        if (_Pred(*_Mid, *_Left_first)) { 
            *_First = ::std:: move(*_Mid);
            ++_First;
            ++_Mid;
            if (_Mid == _Last) {
                _Move_unchecked(_Left_first, _Backout._Last, _First); 
                return;
            }
        } else { 
            *_First = ::std:: move(*_Left_first);
            ++_First;
            ++_Left_first;
            if (_Left_first == _Left_last) { 
                *_Move_unchecked(_Mid, _Last, _First) = ::std:: move(*_Left_last);
                return;
            }
        }
    }
}
template <class _BidIt, class _Pr>
inline void _Inplace_merge_buffer_right(_BidIt _First, _BidIt _Mid, _BidIt _Last,
    _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) { 
    using _Ptr_ty = _Iter_value_t<_BidIt>*;
    _Uninitialized_backout<_Ptr_ty> _Backout{_Temp_ptr, _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr)};
    *--_Last                   = ::std:: move(*--_Mid); 
    const _Ptr_ty _Right_first = _Temp_ptr;
    _Ptr_ty _Right_last        = _Backout._Last - 1;
    --_Mid;
    for (;;) {
        if (_Pred(*_Right_last, *_Mid)) { 
            *--_Last = ::std:: move(*_Mid);
            if (_First == _Mid) {
                *--_Last = ::std:: move(*_Right_last); 
                _Move_backward_unchecked(_Right_first, _Right_last, _Last); 
                return;
            }
            --_Mid;
        } else { 
            *--_Last = ::std:: move(*_Right_last);
            --_Right_last;
            if (_Right_first == _Right_last) { 
                *--_Last = ::std:: move(*_Mid); 
                _Move_backward_unchecked(_First, _Mid, _Last);
                *_First = ::std:: move(*_Right_first);
                return;
            }
        }
    }
}
template <class _BidIt, class _Pr>
inline void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred);
template <class _BidIt, class _Pr>
inline void _Buffered_inplace_merge_divide_and_conquer2(_BidIt _First, _BidIt _Mid, _BidIt _Last,
    _Iter_diff_t<_BidIt> _Count1, _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr,
    const ptrdiff_t _Capacity, _Pr _Pred, _BidIt _Firstn, _BidIt _Lastn, _Iter_diff_t<_BidIt> _Count1n,
    _Iter_diff_t<_BidIt> _Count2n) { 
    using _Diff  = _Iter_diff_t<_BidIt>;
    _BidIt _Midn = _Buffered_rotate_unchecked(_Firstn, _Mid, _Lastn, static_cast<_Diff>(_Count1 - _Count1n), _Count2n,
        _Temp_ptr, _Capacity); 
    _Buffered_inplace_merge_unchecked(
        _First, _Firstn, _Midn, _Count1n, _Count2n, _Temp_ptr, _Capacity, _Pred); 
    _Buffered_inplace_merge_unchecked(_Midn, _Lastn, _Last, static_cast<_Diff>(_Count1 - _Count1n),
        static_cast<_Diff>(_Count2 - _Count2n), _Temp_ptr, _Capacity, _Pred);
}
template <class _BidIt, class _Pr>
inline void _Buffered_inplace_merge_divide_and_conquer(_BidIt _First, _BidIt _Mid, _BidIt _Last,
    _Iter_diff_t<_BidIt> _Count1, _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr,
    const ptrdiff_t _Capacity, _Pr _Pred) { 
    if (_Count1 <= _Count2) {
        const _Iter_diff_t<_BidIt> _Count1n = _Count1 >> 1; 
        const _BidIt _Firstn                = ::std:: next(_First, _Count1n);
        const _BidIt _Lastn                 = ::std:: lower_bound(_Mid, _Last, *_Firstn, _Pred);
        _Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred,
            _Firstn, _Lastn, _Count1n, ::std:: distance(_Mid, _Lastn));
    } else {
        const _Iter_diff_t<_BidIt> _Count2n = _Count2 >> 1; 
        const _BidIt _Lastn                 = ::std:: next(_Mid, _Count2n);
        const _BidIt _Firstn                = ::std:: upper_bound(_First, _Mid, *_Lastn, _Pred);
        _Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred,
            _Firstn, _Lastn, ::std:: distance(_First, _Firstn), _Count2n);
    }
}
template <class _BidIt, class _Pr>
inline void _Buffered_inplace_merge_unchecked_impl(_BidIt _First, _BidIt _Mid, _BidIt _Last,
    _Iter_diff_t<_BidIt> _Count1, _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr,
    const ptrdiff_t _Capacity, _Pr _Pred) { 
    if (_Count1 <= _Count2 && _Count1 <= _Capacity) {
        _Inplace_merge_buffer_left(_First, _Mid, _Last, _Temp_ptr, _Pred);
    } else if (_Count2 <= _Capacity) {
        _Inplace_merge_buffer_right(_First, _Mid, _Last, _Temp_ptr, _Pred);
    } else {
        _Buffered_inplace_merge_divide_and_conquer(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred);
    }
}
template <class _BidIt, class _Pr>
inline void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity,
    _Pr _Pred) { 
    if (_Mid == _Last) {
        return;
    }
    for (;;) {
        if (_First == _Mid) {
            return;
        }
        if (_Pred(*_Mid, *_First)) {
            break;
        }
        ++_First;
        --_Count1;
    }
    const auto _Highest = _Prev_iter(_Mid);
    do {
        --_Last;
        --_Count2;
        if (_Mid == _Last) {
            _Rotate_one_right(_First, _Mid, ++_Last);
            return;
        }
    } while (!_Pred(*_Last, *_Highest));
    ++_Last;
    ++_Count2;
    if (_Count1 == 1) {
        _Rotate_one_left(_First, _Mid, _Last);
        return;
    }
    _Buffered_inplace_merge_unchecked_impl(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred);
}
template <class _BidIt, class _Pr>
inline void inplace_merge(
    _BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _UMid   = _Get_unwrapped(_Mid);
    auto _ULast  = _Get_unwrapped(_Last);
    _Debug_order_unchecked(_UFirst, _UMid, _Pred);
    if (_UMid == _ULast) {
        return;
    }
    for (;;) {
        if (_UFirst == _UMid) {
            return;
        }
        if (_Pred(*_UMid, *_UFirst)) { 
            break;
        }
        ++_UFirst;
    }
    const auto _Highest = _Prev_iter(_UMid);
    do {
        --_ULast;
        if (_UMid == _ULast) { 
            _Rotate_one_right(_UFirst, _UMid, ++_ULast);
            return;
        }
    } while (!_Pred(*_ULast, *_Highest)); 
    ++_ULast;
    const _Iter_diff_t<_BidIt> _Count1 = ::std:: distance(_UFirst, _UMid);
    if (_Count1 == 1) { 
        _Rotate_one_left(_UFirst, _UMid, _ULast);
        return;
    }
    const _Iter_diff_t<_BidIt> _Count2 = ::std:: distance(_UMid, _ULast);
    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Min_value(_Count1, _Count2)};
    _Buffered_inplace_merge_unchecked_impl(
        _UFirst, _UMid, _ULast, _Count1, _Count2, _Temp_buf._Data, _Temp_buf._Capacity, _Pass_fn(_Pred));
}
template <class _BidIt>
inline void inplace_merge(
    _BidIt _First, _BidIt _Mid, _BidIt _Last) { 
    ::std:: inplace_merge(_First, _Mid, _Last, less<>());
}
template <class _ExPo, class _BidIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void inplace_merge(_ExPo&&, _BidIt _First, _BidIt _Mid, _BidIt _Last,
    _Pr _Pred) noexcept { 
    ::std:: inplace_merge(_First, _Mid, _Last, _Pass_fn(_Pred));
}
template <class _ExPo, class _BidIt, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void inplace_merge(_ExPo&&, _BidIt _First, _BidIt _Mid,
    _BidIt _Last) noexcept { 
    ::std:: inplace_merge(_First, _Mid, _Last);
}
#line 3201 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _BidIt, class _Pr>
inline _BidIt _Insertion_sort_unchecked(
    _BidIt _First, const _BidIt _Last, _Pr _Pred) { 
    if (_First != _Last) {
        for (_BidIt _Next = _First; ++_Next != _Last;) { 
            _BidIt _Next1              = _Next;
            _Iter_value_t<_BidIt> _Val = ::std:: move(*_Next);
            if (_Debug_lt_pred(_Pred, _Val, *_First)) { 
                _Move_backward_unchecked(_First, _Next, ++_Next1);
                *_First = ::std:: move(_Val);
            } else { 
                for (_BidIt _First1 = _Next1; _Debug_lt_pred(_Pred, _Val, *--_First1); _Next1 = _First1) {
                    *_Next1 = ::std:: move(*_First1); 
                }
                *_Next1 = ::std:: move(_Val); 
            }
        }
    }
    return _Last;
}
template <class _RanIt, class _Pr>
inline void _Med3_unchecked(
    _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) { 
    if (_Debug_lt_pred(_Pred, *_Mid, *_First)) {
        ::std:: iter_swap(_Mid, _First);
    }
    if (_Debug_lt_pred(_Pred, *_Last, *_Mid)) { 
        ::std:: iter_swap(_Last, _Mid);
        if (_Debug_lt_pred(_Pred, *_Mid, *_First)) {
            ::std:: iter_swap(_Mid, _First);
        }
    }
}
template <class _RanIt, class _Pr>
inline void _Guess_median_unchecked(
    _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) { 
    using _Diff        = _Iter_diff_t<_RanIt>;
    const _Diff _Count = _Last - _First;
    if (40 < _Count) { 
        const _Diff _Step     = (_Count + 1) >> 3; 
        const _Diff _Two_step = _Step << 1; 
        _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);
        _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
        _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);
        _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
    } else {
        _Med3_unchecked(_First, _Mid, _Last, _Pred);
    }
}
template <class _RanIt, class _Pr>
inline pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(
    _RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _RanIt _Mid = _First + ((_Last - _First) >> 1); 
    _Guess_median_unchecked(_First, _Mid, _Last - 1, _Pred);
    _RanIt _Pfirst = _Mid;
    _RanIt _Plast  = _Pfirst + 1;
    while (_First < _Pfirst && !_Debug_lt_pred(_Pred, *(_Pfirst - 1), *_Pfirst) && !_Pred(*_Pfirst, *(_Pfirst - 1))) {
        --_Pfirst;
    }
    while (_Plast < _Last && !_Debug_lt_pred(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {
        ++_Plast;
    }
    _RanIt _Gfirst = _Plast;
    _RanIt _Glast  = _Pfirst;
    for (;;) { 
        for (; _Gfirst < _Last; ++_Gfirst) {
            if (_Debug_lt_pred(_Pred, *_Pfirst, *_Gfirst)) {
            } else if (_Pred(*_Gfirst, *_Pfirst)) {
                break;
            } else if (_Plast != _Gfirst) {
                ::std:: iter_swap(_Plast, _Gfirst);
                ++_Plast;
            } else {
                ++_Plast;
            }
        }
        for (; _First < _Glast; --_Glast) {
            if (_Debug_lt_pred(_Pred, *(_Glast - 1), *_Pfirst)) {
            } else if (_Pred(*_Pfirst, *(_Glast - 1))) {
                break;
            } else if (--_Pfirst != _Glast - 1) {
                ::std:: iter_swap(_Pfirst, _Glast - 1);
            }
        }
        if (_Glast == _First && _Gfirst == _Last) {
            return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
        }
        if (_Glast == _First) { 
            if (_Plast != _Gfirst) {
                ::std:: iter_swap(_Pfirst, _Plast);
            }
            ++_Plast;
            ::std:: iter_swap(_Pfirst, _Gfirst);
            ++_Pfirst;
            ++_Gfirst;
        } else if (_Gfirst == _Last) { 
            if (--_Glast != --_Pfirst) {
                ::std:: iter_swap(_Glast, _Pfirst);
            }
            ::std:: iter_swap(_Pfirst, --_Plast);
        } else {
            ::std:: iter_swap(_Gfirst, --_Glast);
            ++_Gfirst;
        }
    }
}
template <class _RanIt, class _Pr>
inline void _Sort_unchecked(
    _RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) { 
    _Iter_diff_t<_RanIt> _Count;
    while (_ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal) { 
        auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);
        _Ideal = (_Ideal >> 1) + (_Ideal >> 2); 
        if (_Mid.first - _First < _Last - _Mid.second) { 
            _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);
            _First = _Mid.second;
        } else { 
            _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);
            _Last = _Mid.first;
        }
    }
    if (_ISORT_MAX < _Count) { 
        _Make_heap_unchecked(_First, _Last, _Pred);
        _Sort_heap_unchecked(_First, _Last, _Pred);
    } else if (2 <= _Count) {
        _Insertion_sort_unchecked(_First, _Last, _Pred); 
    }
}
template <class _RanIt, class _Pr>
inline void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));
}
template <class _RanIt>
inline void sort(const _RanIt _First, const _RanIt _Last) { 
    ::std:: sort(_First, _Last, less<>());
}
template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void sort(_ExPo&& _Exec, _RanIt _First, _RanIt _Last, _Pr _Pred) noexcept;
template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void sort(
    _ExPo&& _Exec, const _RanIt _First, const _RanIt _Last) noexcept { 
    ::std:: sort(::std:: forward<_ExPo>(_Exec), _First, _Last, less<>{});
}
#line 3376 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Ty, class _Pr>
_Ty* _Uninitialized_merge_move(_FwdIt _First, const _FwdIt _Mid, const _FwdIt _Last, _Ty* const _Dest,
    _Pr _Pred) { 
    _Uninitialized_backout<_Ty*> _Backout{_Dest};
    _FwdIt _Next = _Mid;
    for (;;) {
        if (_Debug_lt_pred(_Pred, *_Next, *_First)) {
            _Backout._Emplace_back(::std:: move(*_Next));
            ++_Next;
            if (_Next == _Last) {
                _Backout._Last = _Uninitialized_move_unchecked(_First, _Mid, _Backout._Last);
                return _Backout._Release();
            }
        } else {
            _Backout._Emplace_back(::std:: move(*_First));
            ++_First;
            if (_First == _Mid) {
                _Backout._Last = _Uninitialized_move_unchecked(_Next, _Last, _Backout._Last);
                return _Backout._Release();
            }
        }
    }
}
template <class _InIt, class _OutIt, class _Pr>
inline _OutIt _Merge_move(_InIt _First, const _InIt _Mid, const _InIt _Last, _OutIt _Dest,
    _Pr _Pred) { 
    _InIt _Next = _Mid;
    for (;;) {
        if (_Debug_lt_pred(_Pred, *_Next, *_First)) {
            *_Dest = ::std:: move(*_Next);
            ++_Dest;
            ++_Next;
            if (_Next == _Last) {
                return _Move_unchecked(_First, _Mid, _Dest);
            }
        } else {
            *_Dest = ::std:: move(*_First);
            ++_Dest;
            ++_First;
            if (_First == _Mid) {
                return _Move_unchecked(_Next, _Last, _Dest);
            }
        }
    }
}
template <class _BidIt, class _Ty, class _Pr>
inline void _Uninitialized_chunked_merge_unchecked(_BidIt _First, const _BidIt _Last, _Ty* _Dest,
    const _Iter_diff_t<_BidIt> _Chunk, _Iter_diff_t<_BidIt> _Count,
    _Pr _Pred) { 
    _Uninitialized_backout<_Ty*> _Backout{_Dest};
    while (_Chunk < _Count) {
        _Count -= _Chunk;
        const _BidIt _Mid1 = ::std:: next(_First, _Chunk);
        const auto _Chunk2 = _Min_value(_Chunk, _Count);
        _Count -= _Chunk2;
        const _BidIt _Mid2 = ::std:: next(_Mid1, _Chunk2);
        _Backout._Last     = _Uninitialized_merge_move(_First, _Mid1, _Mid2, _Backout._Last, _Pred);
        _First             = _Mid2;
    }
    _Uninitialized_move_unchecked(_First, _Last, _Backout._Last); 
    _Backout._Release();
}
template <class _BidIt, class _OutIt, class _Pr>
inline void _Chunked_merge_unchecked(_BidIt _First, const _BidIt _Last, _OutIt _Dest, const _Iter_diff_t<_BidIt> _Chunk,
    _Iter_diff_t<_BidIt> _Count, _Pr _Pred) { 
    while (_Chunk < _Count) {
        _Count -= _Chunk;
        const _BidIt _Mid1 = ::std:: next(_First, _Chunk);
        const auto _Chunk2 = _Min_value(_Chunk, _Count);
        _Count -= _Chunk2;
        const _BidIt _Mid2 = ::std:: next(_Mid1, _Chunk2);
        _Dest              = _Merge_move(_First, _Mid1, _Mid2, _Dest, _Pred);
        _First             = _Mid2;
    }
    _Move_unchecked(_First, _Last, _Dest); 
}
template <class _BidIt, class _Pr>
void _Insertion_sort_isort_max_chunks(_BidIt _First, const _BidIt _Last, _Iter_diff_t<_BidIt> _Count,
    _Pr _Pred) { 
    constexpr auto _Diffsort_max = static_cast<_Iter_diff_t<_BidIt>>(_ISORT_MAX);
    for (; _Diffsort_max < _Count; _Count -= _Diffsort_max) { 
        _First = _Insertion_sort_unchecked(_First, ::std:: next(_First, _Diffsort_max), _Pred);
    }
    _Insertion_sort_unchecked(_First, _Last, _Pred); 
}
template <class _BidIt, class _Pr>
inline void _Buffered_merge_sort_unchecked(const _BidIt _First, const _BidIt _Last, const _Iter_diff_t<_BidIt> _Count,
    _Iter_value_t<_BidIt>* const _Temp_ptr,
    _Pr _Pred) { 
    _Insertion_sort_isort_max_chunks(_First, _Last, _Count, _Pred);
    auto _Chunk = static_cast<_Iter_diff_t<_BidIt>>(_ISORT_MAX);
    if (_Count <= _Chunk) {
        return;
    }
    _Uninitialized_chunked_merge_unchecked(_First, _Last, _Temp_ptr, _Chunk, _Count, _Pred);
    _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{_Temp_ptr, _Temp_ptr + _Count};
    for (;;) {
        _Chunk <<= 1;
        _Chunked_merge_unchecked(_Temp_ptr, _Temp_ptr + _Count, _First, static_cast<ptrdiff_t>(_Chunk),
            static_cast<ptrdiff_t>(_Count), _Pred);
        _Chunk <<= 1;
        if (_Count <= _Chunk) { 
            return;
        }
        _Chunked_merge_unchecked(_First, _Last, _Temp_ptr, _Chunk, _Count, _Pred);
    }
}
template <class _BidIt, class _Pr>
inline void _Stable_sort_unchecked(const _BidIt _First, const _BidIt _Last, const _Iter_diff_t<_BidIt> _Count,
    _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity,
    _Pr _Pred) { 
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count <= _ISORT_MAX) {
        _Insertion_sort_unchecked(_First, _Last, _Pred); 
    } else { 
        const auto _Half_count      = static_cast<_Diff>(_Count >> 1);
        const auto _Half_count_ceil = static_cast<_Diff>(_Count - _Half_count);
        const _BidIt _Mid           = ::std:: next(_First, _Half_count_ceil);
        if (_Half_count_ceil <= _Capacity) { 
            _Buffered_merge_sort_unchecked(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Pred);
            _Buffered_merge_sort_unchecked(_Mid, _Last, _Half_count, _Temp_ptr, _Pred);
        } else { 
            _Stable_sort_unchecked(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Capacity, _Pred);
            _Stable_sort_unchecked(_Mid, _Last, _Half_count, _Temp_ptr, _Capacity, _Pred);
        }
        _Buffered_inplace_merge_unchecked(
            _First, _Mid, _Last, _Half_count_ceil, _Half_count, _Temp_ptr, _Capacity, _Pred); 
    }
}
template <class _BidIt, class _Pr>
inline void stable_sort(
    const _BidIt _First, const _BidIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _Count  = ::std:: distance(_UFirst, _ULast);
    if (_Count <= _ISORT_MAX) {
        if (_Count > 1) {
            _Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
        }
        return;
    }
    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Count - (_Count >> 1)};
    _Stable_sort_unchecked(_UFirst, _ULast, _Count, _Temp_buf._Data, _Temp_buf._Capacity, _Pass_fn(_Pred));
}
template <class _ExPo, class _BidIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void stable_sort(_ExPo&& _Exec, const _BidIt _First, const _BidIt _Last, _Pr _Pred) noexcept;
#line 3560 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _BidIt>
inline void stable_sort(
    const _BidIt _First, const _BidIt _Last) { 
    ::std:: stable_sort(_First, _Last, less<>());
}
template <class _ExPo, class _BidIt, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void stable_sort(
    _ExPo&& _Exec, _BidIt _First, _BidIt _Last) noexcept { 
    ::std:: stable_sort(::std:: forward<_ExPo>(_Exec), _First, _Last, less<>());
}
#line 3574 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _RanIt, class _Pr>
inline void partial_sort(
    _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _UMid  = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return; 
    }
    _Make_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
    for (auto _UNext = _UMid; _UNext < _ULast; ++_UNext) {
        if (_Debug_lt_pred(_Pred, *_UNext, *_UFirst)) { 
            _Iter_value_t<_RanIt> _Val = ::std:: move(*_UNext);
            _Pop_heap_hole_unchecked(_UFirst, _UMid, _UNext, ::std:: move(_Val), _Pass_fn(_Pred));
        }
    }
    _Sort_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
}
template <class _RanIt>
inline void partial_sort(
    _RanIt _First, _RanIt _Mid, _RanIt _Last) { 
    ::std:: partial_sort(_First, _Mid, _Last, less<>());
}
template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void partial_sort(_ExPo&&, _RanIt _First, _RanIt _Mid, _RanIt _Last,
    _Pr _Pred) noexcept { 
    return ::std:: partial_sort(_First, _Mid, _Last, _Pass_fn(_Pred));
}
template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void partial_sort(
    _ExPo&&, _RanIt _First, _RanIt _Mid, _RanIt _Last) noexcept { 
    return ::std:: partial_sort(_First, _Mid, _Last);
}
#line 3621 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt, class _RanIt, class _Pr>
inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    auto _UMid2        = _UFirst2;
    if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        for (; _UFirst1 != _ULast1 && _UMid2 != _ULast2; ++_UFirst1, (void) ++_UMid2) {
            *_UMid2 = *_UFirst1; 
        }
        _Make_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
        for (; _UFirst1 != _ULast1; ++_UFirst1) {
            if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) {
                _Pop_heap_hole_by_index(_UFirst2, static_cast<_Iter_diff_t<_RanIt>>(0),
                    static_cast<_Iter_diff_t<_RanIt>>(_UMid2 - _UFirst2), static_cast<_Iter_value_t<_InIt>>(*_UFirst1),
                    _Pass_fn(_Pred));
            }
        }
        _Sort_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
    }
    _Seek_wrapped(_First2, _UMid2);
    return _First2;
}
template <class _InIt, class _RanIt>
inline _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2,
    _RanIt _Last2) { 
    return ::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2, less<>());
}
template <class _ExPo, class _FwdIt, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _RanIt partial_sort_copy(_ExPo&&, _FwdIt _First1, _FwdIt _Last1, _RanIt _First2, _RanIt _Last2,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _RanIt partial_sort_copy(_ExPo&&, _FwdIt _First1, _FwdIt _Last1, _RanIt _First2,
    _RanIt _Last2) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2);
}
#line 3678 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _RanIt, class _Pr>
inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Nth);
    _Adl_verify_range(_Nth, _Last);
    auto _UFirst     = _Get_unwrapped(_First);
    const auto _UNth = _Get_unwrapped(_Nth);
    auto _ULast      = _Get_unwrapped(_Last);
    if (_UNth == _ULast) {
        return; 
    }
    while (_ISORT_MAX < _ULast - _UFirst) { 
        auto _UMid = _Partition_by_median_guess_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
        if (_UMid.second <= _UNth) {
            _UFirst = _UMid.second;
        } else if (_UMid.first <= _UNth) {
            return; 
        } else {
            _ULast = _UMid.first;
        }
    }
    _Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred)); 
}
template <class _RanIt>
inline void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last) { 
    ::std:: nth_element(_First, _Nth, _Last, less<>());
}
template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void nth_element(_ExPo&&, _RanIt _First, _RanIt _Nth, _RanIt _Last,
    _Pr _Pred) noexcept { 
    ::std:: nth_element(_First, _Nth, _Last, _Pass_fn(_Pred));
}
template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
inline void nth_element(_ExPo&&, _RanIt _First, _RanIt _Nth,
    _RanIt _Last) noexcept { 
    ::std:: nth_element(_First, _Nth, _Last);
}
#line 3726 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1) {
        if (_Debug_lt_pred(_Pred, *_UFirst2, *_UFirst1)) {
            return false;
        }
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst2;
        }
    }
    return _UFirst2 == _ULast2;
}
template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2,
    _InIt2
        _Last2) { 
    return ::std:: includes(_First1, _Last1, _First2, _Last2, less<>());
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool includes(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: includes(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool includes(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _FwdIt2 _Last2) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: includes(_First1, _Last1, _First2, _Last2);
}
#line 3780 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UDest) {
        if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) { 
            *_UDest = *_UFirst1;
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) { 
            *_UDest = *_UFirst2;
            ++_UFirst2;
        } else { 
            *_UDest = *_UFirst1;
            ++_UFirst1;
            ++_UFirst2;
        }
    }
    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize, class _Pr>
inline _DestTy* set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) { 
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))
        ._Unwrapped();
}
#line 3821 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _OutIt _Dest) { 
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize>
inline _DestTy* set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
#line 3835 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 set_union(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt3>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* set_union(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest, _Pass_fn(_Pred));
}
#line 3859 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 set_union(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt3>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest);
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* set_union(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest);
}
#line 3882 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 3883 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) {
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            ++_UFirst2;
        } else {
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
            ++_UFirst2;
        }
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize, class _Pr>
inline _DestTy* set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _DestTy (&_Dest)[_DestSize], _Pr _Pred) { 
    return ::std:: set_intersection(
        _First1, _Last1, _First2, _Last2, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))
        ._Unwrapped();
}
#line 3923 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _OutIt _Dest) { 
    return ::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize>
inline _DestTy* set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
#line 3937 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 set_intersection(
    _ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest, _Pr _Pred) noexcept;
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* set_intersection(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize], _Pr _Pred) noexcept { 
    return ::std:: set_intersection(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2,
        _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))
        ._Unwrapped();
}
#line 3953 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 set_intersection(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest) noexcept { 
    return ::std:: set_intersection(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, _Dest, less{});
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* set_intersection(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    return ::std:: set_intersection(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, _Dest, less{});
}
#line 3968 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 3969 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) { 
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
        } else {
            if (!_Pred(*_UFirst2, *_UFirst1)) {
                ++_UFirst1;
            }
            ++_UFirst2;
        }
    }
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst1, _ULast1, _UDest));
    return _Dest;
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize, class _Pr>
inline _DestTy* set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _DestTy (&_Dest)[_DestSize], _Pr _Pred) { 
    return ::std:: set_difference(
        _First1, _Last1, _First2, _Last2, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))
        ._Unwrapped();
}
#line 4010 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _OutIt _Dest) { 
    return ::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize>
inline _DestTy* set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
#line 4024 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 set_difference(
    _ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest, _Pr _Pred) noexcept;
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* set_difference(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize], _Pr _Pred) noexcept { 
    return ::std:: set_difference(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2,
        _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))
        ._Unwrapped();
}
#line 4040 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 set_difference(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest) noexcept { 
    return ::std:: set_difference(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, _Dest, less{});
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* set_difference(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    return ::std:: set_difference(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, _Dest, less{});
}
#line 4055 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 4056 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
inline _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest,
    _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    _Debug_order_set_unchecked<_InIt2>(_UFirst1, _ULast1, _Pred);
    _Debug_order_set_unchecked<_InIt1>(_UFirst2, _ULast2, _Pred);
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (_Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) { 
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) { 
            *_UDest = *_UFirst2;
            ++_UDest;
            ++_UFirst2;
        } else { 
            ++_UFirst1;
            ++_UFirst2;
        }
    }
    _UDest = _Copy_unchecked(_UFirst1, _ULast1, _UDest);
    _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize, class _Pr>
inline _DestTy* set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _DestTy (&_Dest)[_DestSize], _Pr _Pred) { 
    return ::std:: set_symmetric_difference(
        _First1, _Last1, _First2, _Last2, _Array_iterator<_DestTy, _DestSize>(_Dest), _Pass_fn(_Pred))
        ._Unwrapped();
}
#line 4099 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _InIt1, class _InIt2, class _OutIt>
inline _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _OutIt _Dest) { 
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
template <class _InIt1, class _InIt2, class _DestTy, size_t _DestSize>
inline _DestTy* set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) { 
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>());
}
#line 4113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 set_symmetric_difference(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest,
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt3>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* set_symmetric_difference(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize],
    _Pr _Pred) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, _Pass_fn(_Pred));
}
#line 4138 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, _Enable_if_execution_policy_t<_ExPo> = 0>
inline _FwdIt3 set_symmetric_difference(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt3>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest);
}
template <class _ExPo, class _FwdIt1, class _FwdIt2, class _DestTy, size_t _DestSize,
    _Enable_if_execution_policy_t<_ExPo> = 0>
inline _DestTy* set_symmetric_difference(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _DestTy (&_Dest)[_DestSize]) noexcept { 
    static_assert(_Is_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest);
}
#line 4161 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 4162 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Pr>
constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (_Debug_lt_pred(_Pred, *_Found, *_First)) {
                _Found = _First;
            }
        }
    }
    return _Found;
}
template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Max_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}
template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: max_element(_First, _Last, less<>());
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt max_element(_ExPo&&, _FwdIt _First, _FwdIt _Last,
    _Pr _Pred) noexcept { 
    return ::std:: max_element(_First, _Last, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt max_element(_ExPo&&, _FwdIt _First,
    _FwdIt _Last) noexcept { 
    return ::std:: max_element(_First, _Last);
}
#line 4205 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Pr>
constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (_Debug_lt_pred(_Pred, *_First, *_Found)) {
                _Found = _First;
            }
        }
    }
    return _Found;
}
template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Min_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}
template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: min_element(_First, _Last, less<>());
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt min_element(_ExPo&&, _FwdIt _First, _FwdIt _Last,
    _Pr _Pred) noexcept { 
    return ::std:: min_element(_First, _Last, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt min_element(_ExPo&&, _FwdIt _First,
    _FwdIt _Last) noexcept { 
    return ::std:: min_element(_First, _Last);
}
#line 4248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _FwdIt, class _Pr>
constexpr pair<_FwdIt, _FwdIt> _Minmax_element_unchecked(
    _FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    pair<_FwdIt, _FwdIt> _Found(_First, _First);
    if (_First != _Last) {
        while (++_First != _Last) { 
            _FwdIt _Next = _First;
            if (++_Next == _Last) { 
                if (_Debug_lt_pred(_Pred, *_First, *_Found.first)) {
                    _Found.first = _First;
                } else if (!_Debug_lt_pred(_Pred, *_First, *_Found.second)) {
                    _Found.second = _First;
                }
            } else { 
                if (_Debug_lt_pred(_Pred, *_Next, *_First)) { 
                    if (_Debug_lt_pred(_Pred, *_Next, *_Found.first)) {
                        _Found.first = _Next;
                    }
                    if (!_Debug_lt_pred(_Pred, *_First, *_Found.second)) {
                        _Found.second = _First;
                    }
                } else { 
                    if (_Debug_lt_pred(_Pred, *_First, *_Found.first)) {
                        _Found.first = _First;
                    }
                    if (!_Debug_lt_pred(_Pred, *_Next, *_Found.second)) {
                        _Found.second = _Next;
                    }
                }
                _First = _Next;
            }
        }
    }
    return _Found;
}
template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> minmax_element(
    _FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _Result = _Minmax_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
    _Seek_wrapped(_Last, _Result.second);
    _Seek_wrapped(_First, _Result.first);
    return {_First, _Last};
}
template <class _FwdIt>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> minmax_element(
    _FwdIt _First, _FwdIt _Last) { 
    return ::std:: minmax_element(_First, _Last, less<>());
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline pair<_FwdIt, _FwdIt> minmax_element(_ExPo&&, _FwdIt _First, _FwdIt _Last,
    _Pr _Pred) noexcept { 
    return ::std:: minmax_element(_First, _Last, _Pass_fn(_Pred));
}
template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline pair<_FwdIt, _FwdIt> minmax_element(_ExPo&&, _FwdIt _First,
    _FwdIt _Last) noexcept { 
    return ::std:: minmax_element(_First, _Last);
}
#line 4319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(noexcept(_Debug_lt_pred(_Pred, _Left, _Right))) { 
#line 4324 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
    return _Debug_lt_pred(_Pred, _Left, _Right) ? _Right : _Left;
}
template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist, _Pr _Pred) { 
    const _Ty* _Res = _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}
#pragma warning(push)
#pragma warning(disable : 28285) 
template <class _Ty>
  [[nodiscard]] constexpr const _Ty&(max)(
    const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) { 
    if (_Left < _Right) {
        do { if (!(_Right < _Left)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 4339, 0, "%s", "invalid comparator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid comparator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 4339, 0); } while (false); } ; } while (false);
        return _Right;
    }
    return _Left;
}
#pragma warning(pop)
template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist) { 
    return (::std:: max)(_Ilist, less<>());
}
template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(noexcept(_Debug_lt_pred(_Pred, _Right, _Left))) { 
#line 4356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
    return _Debug_lt_pred(_Pred, _Right, _Left) ? _Right : _Left;
}
template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist, _Pr _Pred) { 
    const _Ty* _Res = _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}
#pragma warning(push)
#pragma warning(disable : 28285) 
template <class _Ty>
  [[nodiscard]] constexpr const _Ty&(min)(const _Ty& _Left,
    const _Ty& _Right) noexcept(noexcept(_Right < _Left)) { 
    if (_Right < _Left) {
        do { if (!(_Left < _Right)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 4371, 0, "%s", "invalid comparator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid comparator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 4371, 0); } while (false); } ; } while (false);
        return _Right;
    }
    return _Left;
}
#pragma warning(pop)
template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist) { 
    return (::std:: min)(_Ilist, less<>());
}
template <class _Ty, class _Pr>
[[nodiscard]] constexpr pair<const _Ty&, const _Ty&> minmax(const _Ty& _Left, const _Ty& _Right,
    _Pr _Pred) { 
    return _Pred(_Right, _Left) ? pair<const _Ty&, const _Ty&>(_Right, _Left)
                                : pair<const _Ty&, const _Ty&>(_Left, _Right);
}
template <class _Ty, class _Pr>
[[nodiscard]] constexpr pair<_Ty, _Ty> minmax(
    initializer_list<_Ty> _Ilist, _Pr _Pred) { 
    pair<const _Ty*, const _Ty*> _Res = _Minmax_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return pair<_Ty, _Ty>(*_Res.first, *_Res.second);
}
template <class _Ty>
[[nodiscard]] constexpr pair<const _Ty&, const _Ty&> minmax(
    const _Ty& _Left, const _Ty& _Right) { 
    return _Right < _Left ? pair<const _Ty&, const _Ty&>(_Right, _Left) : pair<const _Ty&, const _Ty&>(_Left, _Right);
}
template <class _Ty>
[[nodiscard]] constexpr pair<_Ty, _Ty> minmax(
    initializer_list<_Ty> _Ilist) { 
    return ::std:: minmax(_Ilist, less<>());
}
template <class _BidIt, class _Pr>
inline bool next_permutation(
    _BidIt _First, _BidIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UNext       = _ULast;
    if (_UFirst == _ULast || _UFirst == --_UNext) {
        return false;
    }
    for (;;) { 
        auto _UNext1 = _UNext;
        if (_Debug_lt_pred(_Pred, *--_UNext, *_UNext1)) { 
            auto _UMid = _ULast;
            do {
                --_UMid;
            } while (!_Debug_lt_pred(_Pred, *_UNext, *_UMid));
            ::std:: iter_swap(_UNext, _UMid);
            ::std:: reverse(_UNext1, _ULast);
            return true;
        }
        if (_UNext == _UFirst) { 
            ::std:: reverse(_UFirst, _ULast);
            return false;
        }
    }
}
template <class _BidIt>
inline bool next_permutation(_BidIt _First, _BidIt _Last) { 
    return ::std:: next_permutation(_First, _Last, less<>());
}
template <class _BidIt, class _Pr>
inline bool prev_permutation(
    _BidIt _First, _BidIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UNext       = _ULast;
    if (_UFirst == _ULast || _UFirst == --_UNext) {
        return false;
    }
    for (;;) { 
        auto _UNext1 = _UNext;
        if (_Debug_lt_pred(_Pred, *_UNext1, *--_UNext)) { 
            auto _UMid = _ULast;
            do {
                --_UMid;
            } while (!_Debug_lt_pred(_Pred, *_UMid, *_UNext));
            ::std:: iter_swap(_UNext, _UMid);
            ::std:: reverse(_UNext1, _ULast);
            return true;
        }
        if (_UNext == _UFirst) { 
            ::std:: reverse(_UFirst, _ULast);
            return false;
        }
    }
}
template <class _BidIt>
inline bool prev_permutation(
    _BidIt _First, _BidIt _Last) { 
    return ::std:: prev_permutation(_First, _Last, less<>());
}
template <class _FwdIt, class _Pr>
[[nodiscard]] inline _FwdIt is_sorted_until(
    const _FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UNext = _UFirst; ++_UNext != _ULast; ++_UFirst) {
            if (_Debug_lt_pred(_Pred, *_UNext, *_UFirst)) {
                _ULast = _UNext;
                break;
            }
        }
    }
    _Seek_wrapped(_Last, _ULast);
    return _Last;
}
template <class _FwdIt, class _Pr>
[[nodiscard]] inline bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    return ::std:: is_sorted_until(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast;
}
template <class _FwdIt>
[[nodiscard]] inline _FwdIt is_sorted_until(
    _FwdIt _First, _FwdIt _Last) { 
    return ::std:: is_sorted_until(_First, _Last, less<>());
}
template <class _FwdIt>
[[nodiscard]] inline bool is_sorted(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: is_sorted(_First, _Last, less<>());
}
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt is_sorted_until(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept;
template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool is_sorted(
    _ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept { 
    return ::std:: is_sorted_until(::std:: forward<_ExPo>(_Exec), _First, _Last, _Pass_fn(_Pred)) == _Last;
}
template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline _FwdIt is_sorted_until(
    _ExPo&& _Exec, _FwdIt _First, _FwdIt _Last) noexcept { 
    return ::std:: is_sorted_until(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}
template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] inline bool is_sorted(
    _ExPo&& _Exec, _FwdIt _First, _FwdIt _Last) noexcept { 
    return ::std:: is_sorted(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}
#line 4548 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty& clamp(const _Ty& _Val, const _Ty& _Min_val, const _Ty& _Max_val,
    _Pr _Pred) { 
    if (_Debug_lt_pred(_Pred, _Max_val, _Min_val)) {
        do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 4556, 0, "%s", "invalid bounds arguments passed to std::clamp")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid bounds arguments passed to std::clamp\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm", 4556, 0); } while (false);
        return _Val;
    }
#line 4560 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
    return _Debug_lt_pred(_Pred, _Max_val, _Val) ? _Max_val : _Debug_lt_pred(_Pred, _Val, _Min_val) ? _Min_val : _Val;
}
template <class _Ty>
[[nodiscard]] constexpr const _Ty& clamp(
    const _Ty& _Val, const _Ty& _Min_val, const _Ty& _Max_val) { 
    return ::std:: clamp(_Val, _Min_val, _Max_val, less<>());
}
#line 4570 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
}
#pragma warning(pop)
#pragma pack(pop)
#line 4577 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 4578 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\algorithm"
#line 6 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iosfwd"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iosfwd"
using streamoff  = long long;
using streamsize = long long;
template <class _Statetype>
class fpos { 
public:
     fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() { 
    }
    fpos(_Statetype _State, fpos_t _Fileposition)
        : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) { 
    }
    [[nodiscard]] _Statetype state() const { 
        return _Mystate;
    }
    void state(_Statetype _State) { 
        _Mystate = _State;
    }
    operator streamoff() const { 
        return _Myoff + _Fpos;
    }
    [[deprecated("warning STL4019: " "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with " "workarounds for old versions of Visual C++. It will be removed in a future release, and in this " "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as " "conversions to and from streamoff, or an integral type, instead. If you are receiving this message " "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use " "standards-conforming mechanisms, as it does for other compilers. You can define " "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to acknowledge that you have received this warning, " "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]] fpos_t seekpos() const noexcept {
        return {};
    }
#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iosfwd"
    [[nodiscard]] streamoff operator-(const fpos& _Right) const { 
        return static_cast<streamoff>(*this) - static_cast<streamoff>(_Right);
    }
    fpos& operator+=(streamoff _Off) { 
        _Myoff += _Off;
        return *this;
    }
    fpos& operator-=(streamoff _Off) { 
        _Myoff -= _Off;
        return *this;
    }
    [[nodiscard]] fpos operator+(streamoff _Off) const { 
        fpos _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }
    [[nodiscard]] fpos operator-(streamoff _Off) const { 
        fpos _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }
    [[nodiscard]] bool operator==(const fpos& _Right) const {
        return static_cast<streamoff>(*this) == static_cast<streamoff>(_Right);
    }
    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator==(const fpos& _Left, const _Int _Right) {
        return static_cast<streamoff>(_Left) == _Right;
    }
    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator==(const _Int _Left, const fpos& _Right) {
        return _Left == static_cast<streamoff>(_Right);
    }
    [[nodiscard]] bool operator!=(const fpos& _Right) const {
        return static_cast<streamoff>(*this) != static_cast<streamoff>(_Right);
    }
    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator!=(const fpos& _Left, const _Int _Right) {
        return static_cast<streamoff>(_Left) != _Right;
    }
    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator!=(const _Int _Left, const fpos& _Right) {
        return _Left != static_cast<streamoff>(_Right);
    }
private:
    streamoff _Myoff; 
    fpos_t _Fpos; 
    _Statetype _Mystate; 
};
using streampos  = fpos<_Mbstatet>;
using wstreampos = streampos;
class locale;
template <class _Facet>
const _Facet& __cdecl use_facet(const locale&);
template <class _Elem>
struct char_traits;
template <>
struct char_traits<char>;
template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;
template <>
struct char_traits<unsigned short>;
#line 160 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iosfwd"
template <class _Ty>
class allocator;
class ios_base;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ios;
template <class _Elem, class _Traits = char_traits<_Elem>>
class istreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class ostreambuf_iterator;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_streambuf;
#pragma vtordisp(push, 2) 
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_istream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ostream;
#pragma vtordisp(pop) 
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_iostream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringbuf;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_istringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_ostringstream;
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_filebuf;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ifstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ofstream;
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_fstream;
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iosfwd"
using ios           = basic_ios<char, char_traits<char>>;
using streambuf     = basic_streambuf<char, char_traits<char>>;
using istream       = basic_istream<char, char_traits<char>>;
using ostream       = basic_ostream<char, char_traits<char>>;
using iostream      = basic_iostream<char, char_traits<char>>;
using stringbuf     = basic_stringbuf<char, char_traits<char>, allocator<char>>;
using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
using stringstream  = basic_stringstream<char, char_traits<char>, allocator<char>>;
using filebuf       = basic_filebuf<char, char_traits<char>>;
using ifstream      = basic_ifstream<char, char_traits<char>>;
using ofstream      = basic_ofstream<char, char_traits<char>>;
using fstream       = basic_fstream<char, char_traits<char>>;
using wios           = basic_ios<wchar_t, char_traits<wchar_t>>;
using wstreambuf     = basic_streambuf<wchar_t, char_traits<wchar_t>>;
using wistream       = basic_istream<wchar_t, char_traits<wchar_t>>;
using wostream       = basic_ostream<wchar_t, char_traits<wchar_t>>;
using wiostream      = basic_iostream<wchar_t, char_traits<wchar_t>>;
using wstringbuf     = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wstringstream  = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wfilebuf       = basic_filebuf<wchar_t, char_traits<wchar_t>>;
using wifstream      = basic_ifstream<wchar_t, char_traits<wchar_t>>;
using wofstream      = basic_ofstream<wchar_t, char_traits<wchar_t>>;
using wfstream       = basic_fstream<wchar_t, char_traits<wchar_t>>;
#line 244 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iosfwd"
}
#pragma warning(pop)
#pragma pack(pop)
#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iosfwd"
#line 252 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iosfwd"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\typeinfo"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
#pragma warning(disable : 4275) 
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_typeinfo.h"
#pragma once
#pragma pack(push, 8)
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_typeinfo.h"
    extern __type_info_node __type_info_root_node;
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_typeinfo.h"
__pragma(pack(push, 8)) extern "C" {
struct __std_type_info_data
{
    const char * _UndecoratedName;
    const char   _DecoratedName[1];
    __std_type_info_data() = delete;
    __std_type_info_data(const __std_type_info_data&) = delete;
    __std_type_info_data(__std_type_info_data&&) = delete;
    __std_type_info_data& operator=(const __std_type_info_data&) = delete;
    __std_type_info_data& operator=(__std_type_info_data&&) = delete;
};
 int __cdecl __std_type_info_compare(
      const __std_type_info_data* _Lhs,
      const __std_type_info_data* _Rhs
    );
 size_t __cdecl __std_type_info_hash(
      const __std_type_info_data* _Data
    );
 const char* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );
} __pragma(pack(pop))
#pragma warning(push)
#pragma warning(disable: 4577) 
class type_info
{
public:
    type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;
    size_t hash_code() const noexcept
    {
        return __std_type_info_hash(&_Data);
    }
    bool operator==(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }
    bool operator!=(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }
    bool before(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }
    const char* name() const noexcept
    {
        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_typeinfo.h"
    }
    const char* raw_name() const noexcept
    {
        return _Data._DecoratedName;
    }
    virtual ~type_info() noexcept;
private:
    mutable __std_type_info_data _Data;
};
#pragma warning(pop)
namespace std {
	using ::type_info;
}
namespace std {
#pragma warning(push)
#pragma warning(disable: 4577) 
class bad_cast
    : public exception
{
public:
    bad_cast() noexcept
        : exception("bad cast", 1)
    {
    }
    static bad_cast __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_cast(_Message, 1);
    }
private:
    bad_cast(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};
class bad_typeid
    : public exception
{
public:
    bad_typeid() noexcept
        : exception("bad typeid", 1)
    {
    }
    static bad_typeid __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_typeid(_Message, 1);
    }
private:
    friend class __non_rtti_object;
    bad_typeid(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};
class __non_rtti_object
    : public bad_typeid
{
public:
    static __non_rtti_object __construct_from_string_literal(const char* const _Message) noexcept
    {
        return __non_rtti_object(_Message, 1);
    }
private:
    __non_rtti_object(const char* const _Message, int) noexcept
        : bad_typeid(_Message, 1)
    {
    }
};
#pragma warning(pop)
} 
#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_typeinfo.h"
#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vcruntime_typeinfo.h"
#pragma pack(pop)
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\typeinfo"
namespace std {
constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void*);
#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\typeinfo"
}
#pragma pack(pop)
#pragma warning(pop)
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\typeinfo"
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\typeinfo"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _InIt, class _NoThrowFwdIt>
inline _NoThrowFwdIt uninitialized_copy(
    const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
        _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);
    } else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};
        for (; _UFirst != _ULast; ++_UFirst) {
            _Backout._Emplace_back(*_UFirst);
        }
        _UDest = _Backout._Release();
    }
    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _InIt, class _OutTy, size_t _OutSize>
inline _OutTy* uninitialized_copy(const _InIt _First, const _InIt _Last,
    _OutTy (&_Dest)[_OutSize]) { 
    return ::std:: uninitialized_copy(_First, _Last, _Array_iterator<_OutTy, _OutSize>(_Dest))._Unwrapped();
}
#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _InIt, class _Diff, class _NoThrowFwdIt>
inline _NoThrowFwdIt uninitialized_copy_n(
    const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
            _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
        } else {
            _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};
            for (; 0 < _Count; --_Count, (void) ++_UFirst) {
                _Backout._Emplace_back(*_UFirst);
            }
            _UDest = _Backout._Release();
        }
        _Seek_wrapped(_Dest, _UDest);
    }
    return _Dest;
}
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _InTy, size_t _InSize, class _Diff, class _NoThrowFwdIt>
inline _NoThrowFwdIt uninitialized_copy_n(_InTy (&_First)[_InSize], const _Diff _Count_raw,
    _NoThrowFwdIt _Dest) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 147, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 147, 0); } while (false); } ; } while (false);
        return ::std:: uninitialized_copy_n(static_cast<_InTy*>(_First), _Count, _Dest);
    }
    return _Dest;
}
template <class _InIt, class _Diff, class _OutTy, size_t _OutSize>
inline _OutTy* uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw,
    _OutTy (&_Dest)[_OutSize]) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 159, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 159, 0); } while (false); } ; } while (false);
        return ::std:: uninitialized_copy_n(_Get_unwrapped_n(_First, _Count), _Count, static_cast<_OutTy*>(_Dest));
    }
    return _Dest;
}
template <class _InTy, size_t _InSize, class _Diff, class _OutTy, size_t _OutSize>
inline _OutTy* uninitialized_copy_n(_InTy (&_First)[_InSize], const _Diff _Count_raw,
    _OutTy (&_Dest)[_OutSize]) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 171, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 171, 0); } while (false); } ; } while (false);
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 172, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 172, 0); } while (false); } ; } while (false);
        return ::std:: uninitialized_copy_n(static_cast<_InTy*>(_First), _Count, static_cast<_OutTy*>(_Dest));
    }
    return _Dest;
}
#line 179 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _InIt, class _NoThrowFwdIt>
inline _NoThrowFwdIt uninitialized_move(
    const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Uninitialized_move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}
template <class _InIt, class _OutTy, size_t _OutSize>
inline _OutTy* uninitialized_move(
    const _InIt _First, const _InIt _Last, _OutTy (&_Dest)[_OutSize]) { 
    return ::std:: uninitialized_move(_First, _Last, _Array_iterator<_OutTy, _OutSize>(_Dest))._Unwrapped();
}
#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _InIt, class _Diff, class _NoThrowFwdIt>
inline pair<_InIt, _NoThrowFwdIt> uninitialized_move_n(
    _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Ptr_move_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
            _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
            _UFirst += _Count;
        } else {
            _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};
            for (; 0 < _Count; --_Count, (void) ++_UFirst) {
                _Backout._Emplace_back(::std:: move(*_UFirst));
            }
            _UDest = _Backout._Release();
        }
        _Seek_wrapped(_Dest, _UDest);
        _Seek_wrapped(_First, _UFirst);
    }
    return {_First, _Dest};
}
#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _InTy, size_t _InSize, class _Diff, class _NoThrowFwdIt>
inline pair<_InTy*, _NoThrowFwdIt> uninitialized_move_n(_InTy (&_First)[_InSize], const _Diff _Count_raw,
    _NoThrowFwdIt _Dest) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 275, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 275, 0); } while (false); } ; } while (false);
        return ::std:: uninitialized_move_n(static_cast<_InTy*>(_First), _Count, _Dest);
    }
    return {_First, _Dest};
}
template <class _InIt, class _Diff, class _OutTy, size_t _OutSize>
inline pair<_InIt, _OutTy*> uninitialized_move_n(_InIt _First, const _Diff _Count_raw,
    _OutTy (&_Dest)[_OutSize]) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 287, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 287, 0); } while (false); } ; } while (false);
        return ::std:: uninitialized_move_n(_First, _Count, static_cast<_OutTy*>(_Dest));
    }
    return {_First, _Dest};
}
template <class _InTy, size_t _InSize, class _Diff, class _OutTy, size_t _OutSize>
inline pair<_InTy*, _OutTy*> uninitialized_move_n(_InTy (&_First)[_InSize], const _Diff _Count_raw,
    _OutTy (&_Dest)[_OutSize]) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 299, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 299, 0); } while (false); } ; } while (false);
        do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 300, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory", 300, 0); } while (false); } ; } while (false);
        return ::std:: uninitialized_move_n(static_cast<_InTy*>(_First), _Count, static_cast<_OutTy*>(_Dest));
    }
    return {_First, _Dest};
}
#line 307 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
#line 309 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _NoThrowFwdIt, class _Tval>
inline void _Uninitialized_fill_unchecked(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val,
    false_type) { 
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_First};
    while (_Backout._Last != _Last) {
        _Backout._Emplace_back(_Val);
    }
    _Backout._Release();
}
template <class _NoThrowFwdIt, class _Tval>
inline void _Uninitialized_fill_unchecked(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val,
    true_type) { 
    :: memset(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First));
}
template <class _NoThrowFwdIt, class _Tval>
inline void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last,
    const _Tval& _Val) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    _Uninitialized_fill_unchecked(_UFirst, _Get_unwrapped(_Last), _Val, _Fill_memset_is_safe(_UFirst, _Val));
}
template <class _NoThrowFwdIt, class _Diff, class _Tval>
inline _NoThrowFwdIt _Uninitialized_fill_n_unchecked1(const _NoThrowFwdIt _First, _Diff _Count, const _Tval& _Val,
    false_type) { 
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_First};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }
    return _Backout._Release();
}
template <class _NoThrowFwdIt, class _Diff, class _Tval>
inline _NoThrowFwdIt _Uninitialized_fill_n_unchecked1(const _NoThrowFwdIt _First, const _Diff _Count, const _Tval& _Val,
    true_type) { 
    :: memset(_First, static_cast<unsigned char>(_Val), _Count);
    return _First + _Count;
}
template <class _NoThrowFwdIt, class _Diff, class _Tval>
inline _NoThrowFwdIt uninitialized_fill_n(
    _NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) { 
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        const auto _UFirst = _Get_unwrapped_n(_First, _Count);
        _Seek_wrapped(
            _First, _Uninitialized_fill_n_unchecked1(_UFirst, _Count, _Val, _Fill_memset_is_safe(_UFirst, _Val)));
    }
    return _First;
}
template <class _Ty>
inline void destroy_at(_Ty* const _Location) { 
    _Location->~_Ty();
}
template <class _NoThrowFwdIt>
inline void destroy(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) { 
    _Adl_verify_range(_First, _Last);
    _Destroy_range(_Get_unwrapped(_First), _Get_unwrapped(_Last));
}
template <class _NoThrowFwdIt, class _Diff>
inline _NoThrowFwdIt _Destroy_n1(
    _NoThrowFwdIt _First, _Diff _Count, false_type) { 
    for (; 0 < _Count; ++_First, (void) --_Count) {
        _Destroy_in_place(*_First);
    }
    return _First;
}
template <class _NoThrowFwdIt, class _Diff>
inline _NoThrowFwdIt _Destroy_n1(const _NoThrowFwdIt _First, const _Diff _Count,
    true_type) { 
    return ::std:: next(_First, _Count); 
}
template <class _NoThrowFwdIt, class _Diff>
inline _NoThrowFwdIt destroy_n(
    _NoThrowFwdIt _First, const _Diff _Count_raw) { 
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        const auto _UFirst = _Get_unwrapped_n(_First, _Count);
        _Seek_wrapped(_First, _Destroy_n1(_UFirst, _Count, is_trivially_destructible<_Iter_value_t<_NoThrowFwdIt>>()));
    }
    return _First;
}
template <class _NoThrowFwdIt>
inline void _Uninitialized_default_construct_unchecked(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last,
    false_type) { 
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_First};
    for (; _Backout._Last != _Last; ++_Backout._Last) {
        ::new (static_cast<void*>(_Unfancy(_Backout._Last))) _Iter_value_t<_NoThrowFwdIt>;
    }
    _Backout._Release();
}
template <class _NoThrowFwdIt>
inline void _Uninitialized_default_construct_unchecked(
    _NoThrowFwdIt, _NoThrowFwdIt, true_type) { 
}
template <class _NoThrowFwdIt>
inline void uninitialized_default_construct(
    const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) { 
    _Adl_verify_range(_First, _Last);
    _Uninitialized_default_construct_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last),
        is_trivially_default_constructible<_Iter_value_t<_NoThrowFwdIt>>());
}
template <class _NoThrowFwdIt, class _Diff>
inline _NoThrowFwdIt _Uninitialized_default_construct_n_unchecked(const _NoThrowFwdIt _First, _Diff _Count,
    false_type) { 
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_First};
    for (; 0 < _Count; ++_Backout._Last, (void) --_Count) {
        ::new (static_cast<void*>(_Unfancy(_Backout._Last))) _Iter_value_t<_NoThrowFwdIt>;
    }
    return _Backout._Release();
}
template <class _NoThrowFwdIt, class _Diff>
inline _NoThrowFwdIt _Uninitialized_default_construct_n_unchecked(const _NoThrowFwdIt _First, const _Diff _Count,
    true_type) { 
    return ::std:: next(_First, _Count);
}
template <class _NoThrowFwdIt, class _Diff>
inline _NoThrowFwdIt uninitialized_default_construct_n(
    _NoThrowFwdIt _First, const _Diff _Count_raw) { 
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        const auto _UFirst = _Get_unwrapped_n(_First, _Count);
        _Seek_wrapped(_First, _Uninitialized_default_construct_n_unchecked(
                                  _UFirst, _Count, is_trivially_default_constructible<_Iter_value_t<_NoThrowFwdIt>>()));
    }
    return _First;
}
template <class _NoThrowFwdIt>
inline void _Uninitialized_value_construct_unchecked(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last,
    false_type) { 
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_First};
    while (_Backout._Last != _Last) {
        _Backout._Emplace_back();
    }
    _Backout._Release();
}
template <class _NoThrowFwdIt>
inline void _Uninitialized_value_construct_unchecked(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last,
    true_type) { 
    _Zero_range(_First, _Last);
}
template <class _NoThrowFwdIt>
inline void uninitialized_value_construct(
    const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    _Uninitialized_value_construct_unchecked(
        _UFirst, _ULast, _Use_memset_value_construct_t<_Unwrapped_t<_NoThrowFwdIt>>());
}
template <class _NoThrowFwdIt, class _Diff>
inline _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(const _NoThrowFwdIt _First, _Diff _Count,
    false_type) { 
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_First};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back();
    }
    return _Backout._Release();
}
template <class _NoThrowFwdIt, class _Diff>
inline _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(const _NoThrowFwdIt _First, const _Diff _Count,
    true_type) { 
    return _Zero_range(_First, _First + _Count);
}
template <class _NoThrowFwdIt, class _Diff>
inline _NoThrowFwdIt uninitialized_value_construct_n(
    _NoThrowFwdIt _First, const _Diff _Count_raw) { 
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        const auto _UFirst = _Get_unwrapped_n(_First, _Count);
        _Seek_wrapped(_First, _Uninitialized_value_construct_n_unchecked1(
                                  _UFirst, _Count, _Use_memset_value_construct_t<_Unwrapped_n_t<_NoThrowFwdIt>>()));
    }
    return _First;
}
#line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _OutIt,
    class _Ty>
class [[deprecated("warning STL4011: " "std::raw_storage_iterator is deprecated in C++17. " "Consider using the std::uninitialized_copy() family of algorithms instead. " "You can define _SILENCE_CXX17_RAW_STORAGE_ITERATOR_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] raw_storage_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    explicit raw_storage_iterator(_OutIt _First) : _Next(_First) { 
    }
    [[nodiscard]] raw_storage_iterator& operator*() { 
        return *this;
    }
    raw_storage_iterator& operator=(const _Ty& _Val) { 
        _Construct_in_place(*_Next, _Val);
        return *this;
    }
    raw_storage_iterator& operator=(_Ty&& _Val) { 
        _Construct_in_place(*_Next, ::std:: move(_Val));
        return *this;
    }
    raw_storage_iterator& operator++() { 
        ++_Next;
        return *this;
    }
    raw_storage_iterator operator++(int) { 
        raw_storage_iterator _Ans = *this;
        ++_Next;
        return _Ans;
    }
    [[nodiscard]] _OutIt base() const { 
        return _Next;
    }
private:
    _OutIt _Next; 
};
#line 698 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
class bad_weak_ptr : public exception { 
public:
    bad_weak_ptr() noexcept { 
    }
    [[nodiscard]] virtual const char*  what() const
        noexcept override { 
        return "bad_weak_ptr";
    }
};
class __declspec(novtable) _Ref_count_base { 
private:
    virtual void _Destroy() noexcept     = 0;
    virtual void _Delete_this() noexcept = 0;
#line 729 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
    _Atomic_counter_t _Uses;
    _Atomic_counter_t _Weaks;
protected:
    _Ref_count_base()
        : _Uses(1), _Weaks(1) 
    { 
    }
public:
    virtual ~_Ref_count_base() noexcept { 
    }
    bool _Incref_nz() { 
        for (;;) { 
            const _Atomic_integral_t _Count = static_cast<volatile _Atomic_counter_t&>(_Uses);
            if (_Count == 0) {
                return false;
            }
            if (static_cast<_Atomic_integral_t>(_InterlockedCompareExchange(
                    reinterpret_cast<volatile long*>(&_Uses), static_cast<long>(_Count + 1), static_cast<long>(_Count)))
                == _Count) {
                return true;
            }
#line 769 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
        }
    }
    void _Incref() { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Uses));
    }
    void _Incwref() { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Weaks));
    }
    void _Decref() { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Uses)) == 0) { 
            _Destroy();
            _Decwref();
        }
    }
    void _Decwref() { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Weaks)) == 0) {
            _Delete_this();
        }
    }
    long _Use_count() const noexcept { 
        return static_cast<long>(_Get_atomic_count(_Uses));
    }
    virtual void* _Get_deleter(const type_info&) const noexcept { 
        return nullptr;
    }
};
template <class _Ty>
class _Ref_count : public _Ref_count_base { 
public:
    explicit _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) { 
    }
private:
    virtual void _Destroy() noexcept override { 
        delete _Ptr;
    }
    virtual void _Delete_this() noexcept override { 
        delete this;
    }
    _Ty* _Ptr;
};
template <class _Resource,
    class _Dx>
class _Ref_count_resource : public _Ref_count_base { 
public:
    _Ref_count_resource(_Resource _Px, _Dx _Dt)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), ::std:: move(_Dt), _Px) { 
    }
    virtual void* _Get_deleter(const type_info& _Typeid) const noexcept override { 
        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }
#line 838 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
        return nullptr;
    }
private:
    virtual void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Get_second());
    }
    virtual void _Delete_this() noexcept override { 
        delete this;
    }
    _Compressed_pair<_Dx, _Resource> _Mypair;
};
template <class _Resource, class _Dx,
    class _Alloc>
class _Ref_count_resource_alloc
    : public _Ref_count_base { 
public:
    _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
        : _Ref_count_base(),
          _Mypair(_One_then_variadic_args_t(), ::std:: move(_Dt), _One_then_variadic_args_t(), _Ax, _Px) { 
    }
    virtual void* _Get_deleter(const type_info& _Typeid) const noexcept override { 
        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }
#line 873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
        return nullptr;
    }
private:
    using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;
    virtual void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Get_second()._Get_second());
    }
    virtual void _Delete_this() noexcept override { 
        _Myalty _Al = _Mypair._Get_second()._Get_first();
        _Delete_plain(_Al, this);
    }
    _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
};
template <class _Ty>
struct default_delete;
template <class _Ty, class _Dx = default_delete<_Ty>>
class unique_ptr;
template <class _Ty>
class shared_ptr;
template <class _Ty>
class weak_ptr;
template <class _Yty,
    class = void>
struct _Can_enable_shared : false_type { 
};
template <class _Yty>
struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
    : is_convertible<remove_cv_t<_Yty>*,
          typename _Yty::_Esft_type*>::type { 
};
template <class _Other, class _Yty>
void _Enable_shared_from_this1(const shared_ptr<_Other>& _This, _Yty* _Ptr, true_type) { 
    if (_Ptr && _Ptr->_Wptr.expired()) {
        _Ptr->_Wptr = shared_ptr<remove_cv_t<_Yty>>(_This, const_cast<remove_cv_t<_Yty>*>(_Ptr));
    }
}
template <class _Other, class _Yty>
void _Enable_shared_from_this1(const shared_ptr<_Other>&, _Yty*, false_type) { 
}
template <class _Other, class _Yty>
void _Enable_shared_from_this(const shared_ptr<_Other>& _This, _Yty* _Ptr) { 
    _Enable_shared_from_this1(_This, _Ptr,
        bool_constant<
            conjunction_v<negation<is_array<_Other>>, negation<is_volatile<_Yty>>, _Can_enable_shared<_Yty>>>{});
}
template <class _Ty>
class _Ptr_base { 
public:
    using element_type = remove_extent_t<_Ty>;
    [[nodiscard]] long use_count() const noexcept { 
        return _Rep ? _Rep->_Use_count() : 0;
    }
    template <class _Ty2>
    [[nodiscard]] bool owner_before(const _Ptr_base<_Ty2>& _Right) const noexcept { 
        return _Rep < _Right._Rep;
    }
    _Ptr_base(const _Ptr_base&) = delete;
    _Ptr_base& operator=(const _Ptr_base&) = delete;
protected:
    [[nodiscard]] element_type* get() const noexcept { 
        return _Ptr;
    }
    constexpr _Ptr_base() noexcept = default;
    ~_Ptr_base() = default;
    template <class _Ty2>
    void _Move_construct_from(
        _Ptr_base<_Ty2>&& _Right) { 
        _Ptr = _Right._Ptr;
        _Rep = _Right._Rep;
        _Right._Ptr = nullptr;
        _Right._Rep = nullptr;
    }
    template <class _Ty2>
    void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) { 
        if (_Other._Rep) {
            _Other._Rep->_Incref();
        }
        _Ptr = _Other._Ptr;
        _Rep = _Other._Rep;
    }
    template <class _Ty2>
    void _Alias_construct_from(
        const shared_ptr<_Ty2>& _Other, element_type* _Px) { 
        if (_Other._Rep) {
            _Other._Rep->_Incref();
        }
        _Ptr = _Px;
        _Rep = _Other._Rep;
    }
    template <class _Ty0>
    friend class weak_ptr; 
    template <class _Ty2>
    bool _Construct_from_weak(
        const weak_ptr<_Ty2>& _Other) { 
        if (_Other._Rep && _Other._Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            return true;
        }
        return false;
    }
    void _Decref() { 
        if (_Rep) {
            _Rep->_Decref();
        }
    }
    void _Swap(_Ptr_base& _Right) noexcept { 
        ::std:: swap(_Ptr, _Right._Ptr);
        ::std:: swap(_Rep, _Right._Rep);
    }
    void _Set_ptr_rep(element_type* _Other_ptr, _Ref_count_base* _Other_rep) { 
        _Ptr = _Other_ptr;
        _Rep = _Other_rep;
    }
    template <class _Ty2>
    void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) { 
        if (_Other._Rep) {
            _Other._Rep->_Incwref();
        }
        _Ptr = _Other._Ptr;
        _Rep = _Other._Rep;
    }
    void _Decwref() { 
        if (_Rep) {
            _Rep->_Decwref();
        }
    }
private:
    element_type* _Ptr{nullptr};
    _Ref_count_base* _Rep{nullptr};
    template <class _Ty0>
    friend class _Ptr_base;
    template <class _Dx, class _Ty0>
    friend _Dx* get_deleter(const shared_ptr<_Ty0>& _Sx) noexcept;
#line 1050 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
};
template <class _Yty, class = void>
struct _Can_scalar_delete : false_type {};
template <class _Yty>
struct _Can_scalar_delete<_Yty, void_t<decltype(delete ::std:: declval<_Yty*>())>> : true_type {};
template <class _Yty, class = void>
struct _Can_array_delete : false_type {};
template <class _Yty>
struct _Can_array_delete<_Yty, void_t<decltype(delete[] ::std:: declval<_Yty*>())>> : true_type {};
template <class _Fx, class _Arg, class = void>
struct _Can_call_function_object : false_type {};
template <class _Fx, class _Arg>
struct _Can_call_function_object<_Fx, _Arg, void_t<decltype(::std:: declval<_Fx>()(::std:: declval<_Arg>()))>> : true_type {};
template <class _Yty, class _Ty>
struct _SP_convertible : is_convertible<_Yty*, _Ty*>::type {};
template <class _Yty, class _Uty>
struct _SP_convertible<_Yty, _Uty[]> : is_convertible<_Yty (*)[], _Uty (*)[]>::type {};
template <class _Yty, class _Uty, size_t _Ext>
struct _SP_convertible<_Yty, _Uty[_Ext]> : is_convertible<_Yty (*)[_Ext], _Uty (*)[_Ext]>::type {};
template <class _Yty, class _Ty>
struct _SP_pointer_compatible
    : is_convertible<_Yty*, _Ty*>::type { 
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]>
    : true_type { 
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]>
    : true_type { 
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]>
    : true_type { 
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]>
    : true_type { 
};
template <class _Ty>
class shared_ptr : public _Ptr_base<_Ty> { 
private:
    using _Mybase = _Ptr_base<_Ty>;
public:
    using typename _Mybase::element_type;
    using weak_type = weak_ptr<_Ty>;
#line 1113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
    constexpr shared_ptr() noexcept { 
    }
    constexpr shared_ptr(nullptr_t) noexcept { 
    }
    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    explicit shared_ptr(_Ux* _Px) { 
        _Setp(_Px, is_array<_Ty>{});
    }
    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt) { 
        _Setpd(_Px, ::std:: move(_Dt));
    }
    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(_Px, ::std:: move(_Dt), _Ax);
    }
    template <class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt) { 
        _Setpd(nullptr, ::std:: move(_Dt));
    }
    template <class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(nullptr, ::std:: move(_Dt), _Ax);
    }
    template <class _Ty2>
    shared_ptr(
        const shared_ptr<_Ty2>& _Right, element_type* _Px) noexcept { 
        this->_Alias_construct_from(_Right, _Px);
    }
    shared_ptr(const shared_ptr& _Other) noexcept { 
        this->_Copy_construct_from(_Other);
    }
    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(
        const shared_ptr<_Ty2>& _Other) noexcept { 
        this->_Copy_construct_from(_Other);
    }
    shared_ptr(shared_ptr&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }
    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }
    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    explicit shared_ptr(const weak_ptr<_Ty2>& _Other) { 
        if (!this->_Construct_from_weak(_Other)) {
            throw bad_weak_ptr{};
        }
    }
#line 1196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
                        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
            int> = 0>
    shared_ptr(unique_ptr<_Ux, _Dx>&& _Other) { 
        using _Fancy_t   = typename unique_ptr<_Ux, _Dx>::pointer;
        using _Raw_t     = typename unique_ptr<_Ux, _Dx>::element_type*;
        using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(::std:: ref(_Other.get_deleter())), _Dx>;
        const _Fancy_t _Fancy = _Other.get();
        if (_Fancy) {
            const _Raw_t _Raw = _Fancy;
            const auto _Rx    = new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, _Other.get_deleter());
            _Set_ptr_rep_and_enable_shared(_Raw, _Rx);
            _Other.release();
        }
    }
    ~shared_ptr() noexcept { 
        this->_Decref();
    }
    shared_ptr& operator=(const shared_ptr& _Right) noexcept { 
        shared_ptr(_Right).swap(*this);
        return *this;
    }
    template <class _Ty2>
    shared_ptr& operator=(
        const shared_ptr<_Ty2>& _Right) noexcept { 
        shared_ptr(_Right).swap(*this);
        return *this;
    }
    shared_ptr& operator=(shared_ptr&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }
    template <class _Ty2>
    shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }
#line 1250 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
    template <class _Ux, class _Dx>
    shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right) { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }
    void swap(shared_ptr& _Other) noexcept { 
        this->_Swap(_Other);
    }
    void reset() noexcept { 
        shared_ptr().swap(*this);
    }
    template <class _Ux>
    void reset(_Ux* _Px) { 
        shared_ptr(_Px).swap(*this);
    }
    template <class _Ux, class _Dx>
    void reset(_Ux* _Px, _Dx _Dt) { 
        shared_ptr(_Px, _Dt).swap(*this);
    }
    template <class _Ux, class _Dx, class _Alloc>
    void reset(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        shared_ptr(_Px, _Dt, _Ax).swap(*this);
    }
    using _Mybase::get;
    template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
    [[nodiscard]] _Ty2& operator*() const noexcept { 
        return *get();
    }
    template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Ty2* operator->() const noexcept { 
        return get();
    }
    template <class _Ty2 = _Ty, class _Elem = element_type, enable_if_t<is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Elem& operator[](ptrdiff_t _Idx) const { 
        return get()[_Idx];
    }
    [[nodiscard]] [[deprecated("warning STL4016: " "std::shared_ptr::unique() is deprecated in C++17. " "You can define _SILENCE_CXX17_SHARED_PTR_UNIQUE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] bool unique() const
        noexcept { 
        return this->use_count() == 1;
    }
    explicit operator bool() const noexcept { 
        return get() != nullptr;
    }
private:
    template <class _Ux>
    void _Setp(_Ux* _Px, true_type) { 
        _Setpd(_Px, default_delete<_Ux[]>{});
    }
    template <class _Ux>
    void _Setp(_Ux* _Px, false_type) { 
        try { 
            _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ux>(_Px));
        } catch (...) { 
            delete _Px;
        throw;
        }
    }
    template <class _UxptrOrNullptr, class _Dx>
    void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt) { 
        try { 
            _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Px, ::std:: move(_Dt)));
        } catch (...) { 
            _Dt(_Px);
        throw;
        }
    }
    template <class _UxptrOrNullptr, class _Dx, class _Alloc>
    void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax) { 
        using _Refd         = _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>;
        using _Alref_alloc  = _Rebind_alloc_t<_Alloc, _Refd>;
        using _Alref_traits = allocator_traits<_Alref_alloc>;
        _Alref_alloc _Alref(_Ax);
        try { 
            const auto _Pfancy = _Alref_traits::allocate(_Alref, 1);
        _Refd* const _Pref     = _Unfancy(_Pfancy);
        try {
        _Alref_traits::construct(_Alref, _Pref, _Px, ::std:: move(_Dt), _Ax);
        _Set_ptr_rep_and_enable_shared(_Px, _Pref);
        } catch (...) {
        _Alref_traits::deallocate(_Alref, _Pfancy, 1);
        throw;
        }
        } catch (...) { 
            _Dt(_Px);
        throw;
        }
    }
    template <class _Ty0, class... _Types>
    friend shared_ptr<_Ty0> make_shared(_Types&&... _Args);
    template <class _Ty0, class _Alloc, class... _Types>
    friend shared_ptr<_Ty0> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);
    template <class _Ux>
    void _Set_ptr_rep_and_enable_shared(_Ux* _Px, _Ref_count_base* _Rx) { 
        this->_Set_ptr_rep(_Px, _Rx);
        _Enable_shared_from_this(*this, _Px);
    }
    void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base* _Rx) { 
        this->_Set_ptr_rep(nullptr, _Rx);
    }
};
template <class _Ty>
shared_ptr(weak_ptr<_Ty>)->shared_ptr<_Ty>;
template <class _Ty, class _Dx>
shared_ptr(unique_ptr<_Ty, _Dx>)->shared_ptr<_Ty>;
#line 1379 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() == _Right.get();
}
template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() != _Right.get();
}
template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator<(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() < _Right.get();
}
template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator>=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() >= _Right.get();
}
template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() > _Right.get();
}
template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator<=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() <= _Right.get();
}
template <class _Ty>
[[nodiscard]] bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() == nullptr;
}
template <class _Ty>
[[nodiscard]] bool operator==(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr == _Right.get();
}
template <class _Ty>
[[nodiscard]] bool operator!=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() != nullptr;
}
template <class _Ty>
[[nodiscard]] bool operator!=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr != _Right.get();
}
template <class _Ty>
[[nodiscard]] bool operator<(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() < static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}
template <class _Ty>
[[nodiscard]] bool operator<(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) < _Right.get();
}
template <class _Ty>
[[nodiscard]] bool operator>=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() >= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}
template <class _Ty>
[[nodiscard]] bool operator>=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) >= _Right.get();
}
template <class _Ty>
[[nodiscard]] bool operator>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() > static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}
template <class _Ty>
[[nodiscard]] bool operator>(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) > _Right.get();
}
template <class _Ty>
[[nodiscard]] bool operator<=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() <= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}
template <class _Ty>
[[nodiscard]] bool operator<=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) <= _Right.get();
}
template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px) { 
    return _Out << _Px.get();
}
template <class _Ty>
void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept { 
    _Left.swap(_Right);
}
template <class _Ty1,
    class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>&
        _Other) noexcept { 
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}
template <class _Ty1,
    class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>&
        _Other) noexcept { 
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}
template <class _Ty1,
    class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>&
        _Other) noexcept { 
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}
template <class _Ty1,
    class _Ty2>
shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>&) noexcept = delete; 
#line 1523 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _Dx,
    class _Ty>
[[nodiscard]] _Dx* get_deleter(
    const shared_ptr<_Ty>& _Sx) noexcept { 
    if (_Sx._Rep) {
        return static_cast<_Dx*>(_Sx._Rep->_Get_deleter(typeid(_Dx)));
    }
    return nullptr;
}
#line 1540 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _Ty>
class _Ref_count_obj : public _Ref_count_base { 
public:
    template <class... _Types>
    explicit _Ref_count_obj(_Types&&... _Args) : _Ref_count_base() { 
        ::new (static_cast<void*>(&_Storage)) _Ty(::std:: forward<_Types>(_Args)...);
    }
    _Ty* _Getptr() { 
        return reinterpret_cast<_Ty*>(&_Storage);
    }
private:
    virtual void _Destroy() noexcept override { 
        _Getptr()->~_Ty();
    }
    virtual void _Delete_this() noexcept override { 
        delete this;
    }
    aligned_union_t<1, _Ty> _Storage;
};
template <class _Ty,
    class _Alloc>
class _Ref_count_obj_alloc
    : public _Ref_count_base { 
public:
    template <class... _Types>
    explicit _Ref_count_obj_alloc(const _Alloc& _Al_arg, _Types&&... _Args)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Al_arg) { 
        ::new (static_cast<void*>(&_Mypair._Get_second())) _Ty(::std:: forward<_Types>(_Args)...);
    }
    _Ty* _Getptr() { 
        return reinterpret_cast<_Ty*>(&_Mypair._Get_second());
    }
private:
    using _Myalty      = _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc>;
    using _Mystoragety = aligned_union_t<1, _Ty>;
    virtual void _Destroy() noexcept override { 
        _Getptr()->~_Ty();
    }
    virtual void _Delete_this() noexcept override { 
        _Myalty _Al = _Mypair._Get_first();
        _Delete_plain(_Al, this);
    }
    _Compressed_pair<_Myalty, _Mystoragety> _Mypair;
};
template <class _Ty,
    class... _Types>
[[nodiscard]] inline shared_ptr<_Ty> make_shared(_Types&&... _Args) { 
    const auto _Rx = new _Ref_count_obj<_Ty>(::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Getptr(), _Rx);
    return _Ret;
}
template <class _Ty, class _Alloc, class... _Types>
[[nodiscard]] inline shared_ptr<_Ty> allocate_shared(const _Alloc& _Al, _Types&&... _Args) { 
    using _Refoa   = _Ref_count_obj_alloc<_Ty, _Alloc>;
    const auto _Rx = _Alloc_rebound<_Refoa>(_Al, _Al, ::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Getptr(), _Unfancy(_Rx));
    return _Ret;
}
template <class _Ty>
class weak_ptr : public _Ptr_base<_Ty> { 
public:
    constexpr weak_ptr() noexcept { 
    }
    weak_ptr(const weak_ptr& _Other) noexcept { 
        this->_Weakly_construct_from(_Other);
    }
    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept { 
        this->_Weakly_construct_from(_Other);
    }
    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept { 
        this->_Weakly_construct_from(_Other.lock());
    }
    weak_ptr(weak_ptr&& _Other) noexcept { 
        this->_Move_construct_from(::std:: move(_Other));
    }
    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept { 
        this->_Weakly_construct_from(_Other.lock());
        _Other.reset();
    }
    ~weak_ptr() noexcept { 
        this->_Decwref();
    }
    weak_ptr& operator=(const weak_ptr& _Right) noexcept { 
        weak_ptr(_Right).swap(*this);
        return *this;
    }
    template <class _Ty2>
    weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept { 
        weak_ptr(_Right).swap(*this);
        return *this;
    }
    weak_ptr& operator=(weak_ptr&& _Right) noexcept { 
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }
    template <class _Ty2>
    weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) noexcept { 
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }
    template <class _Ty2>
    weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept { 
        weak_ptr(_Right).swap(*this);
        return *this;
    }
    void reset() noexcept { 
        weak_ptr().swap(*this);
    }
    void swap(weak_ptr& _Other) noexcept { 
        this->_Swap(_Other);
    }
    [[nodiscard]] bool expired() const noexcept { 
        return this->use_count() == 0;
    }
    [[nodiscard]] shared_ptr<_Ty> lock() const noexcept { 
        shared_ptr<_Ty> _Ret;
        (void) _Ret._Construct_from_weak(*this);
        return _Ret;
    }
};
template <class _Ty>
weak_ptr(shared_ptr<_Ty>)->weak_ptr<_Ty>;
#line 1705 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
template <class _Ty>
void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) noexcept { 
    _Left.swap(_Right);
}
template <class _Ty>
class enable_shared_from_this { 
public:
    using _Esft_type = enable_shared_from_this;
    [[nodiscard]] shared_ptr<_Ty> shared_from_this() { 
        return shared_ptr<_Ty>(_Wptr);
    }
    [[nodiscard]] shared_ptr<const _Ty> shared_from_this() const { 
        return shared_ptr<const _Ty>(_Wptr);
    }
    [[nodiscard]] weak_ptr<_Ty> weak_from_this() noexcept { 
        return _Wptr;
    }
    [[nodiscard]] weak_ptr<const _Ty> weak_from_this() const noexcept { 
        return _Wptr;
    }
protected:
    constexpr enable_shared_from_this() noexcept : _Wptr() { 
    }
    enable_shared_from_this(const enable_shared_from_this&) noexcept
        : _Wptr() { 
    }
    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept { 
        return *this;
    }
    ~enable_shared_from_this() = default;
private:
    template <class _Other, class _Yty>
    friend void _Enable_shared_from_this1(const shared_ptr<_Other>& _This, _Yty* _Ptr, true_type);
    mutable weak_ptr<_Ty> _Wptr;
};
template <class _Ty>
struct default_delete { 
    constexpr default_delete() noexcept = default;
    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    default_delete(const default_delete<_Ty2>&) noexcept { 
    }
    void operator()(_Ty* _Ptr) const noexcept { 
        static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
        delete _Ptr;
    }
};
template <class _Ty>
struct default_delete<_Ty[]> { 
    constexpr default_delete() noexcept = default;
    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    default_delete(const default_delete<_Uty[]>&) noexcept { 
    }
    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    void operator()(_Uty* _Ptr) const noexcept { 
        static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
        delete[] _Ptr;
    }
};
template <class _Ty, class _Dx_noref,
    class = void>
struct _Get_deleter_pointer_type { 
    using type = _Ty*;
};
template <class _Ty, class _Dx_noref>
struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>> { 
    using type = typename _Dx_noref::pointer;
};
template <class _Ty,
    class _Dx>
class _Unique_ptr_base { 
public:
    using _Dx_noref = remove_reference_t<_Dx>;
    using pointer   = typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type;
    template <class _Ptr2, class _Dx2>
    _Unique_ptr_base(_Ptr2 _Ptr, _Dx2&& _Dt)
        : _Mypair(_One_then_variadic_args_t(), ::std:: forward<_Dx2>(_Dt),
              _Ptr) { 
    }
    template <class _Ptr2>
    constexpr _Unique_ptr_base(_Ptr2 _Ptr)
        : _Mypair(_Zero_then_variadic_args_t(), _Ptr) { 
    }
    [[nodiscard]] _Dx& get_deleter() noexcept { 
        return _Mypair._Get_first();
    }
    [[nodiscard]] const _Dx& get_deleter() const noexcept { 
        return _Mypair._Get_first();
    }
    pointer& _Myptr() noexcept { 
        return _Mypair._Get_second();
    }
    const pointer& _Myptr() const noexcept { 
        return _Mypair._Get_second();
    }
    _Compressed_pair<_Dx, pointer> _Mypair;
};
template <class _Dx2>
using _Unique_ptr_enable_default_t =
    enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>, is_default_constructible<_Dx2>>, int>;
template <class _Ty,
    class _Dx> 
class unique_ptr : public _Unique_ptr_base<_Ty, _Dx> { 
public:
    using _Mybase      = _Unique_ptr_base<_Ty, _Dx>;
    using pointer      = typename _Mybase::pointer;
    using element_type = _Ty;
    using deleter_type = _Dx;
    using _Mybase::get_deleter;
    template <class _Dx2                   = _Dx,
        _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mybase(pointer()) { 
    }
    template <class _Dx2                   = _Dx,
        _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mybase(pointer()) { 
    }
    unique_ptr& operator=(nullptr_t) noexcept { 
        reset();
        return *this;
    }
    template <class _Dx2                   = _Dx,
        _Unique_ptr_enable_default_t<_Dx2> = 0>
    explicit unique_ptr(pointer _Ptr) noexcept : _Mybase(_Ptr) { 
    }
    template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
    unique_ptr(pointer _Ptr, const _Dx& _Dt) noexcept
        : _Mybase(_Ptr, _Dt) { 
    }
    template <class _Dx2                                                                            = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0>
    unique_ptr(pointer _Ptr, _Dx&& _Dt) noexcept : _Mybase(_Ptr, ::std:: move(_Dt)) { 
    }
    template <class _Dx2                                                                                      = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;
    unique_ptr(unique_ptr&& _Right) noexcept
        : _Mybase(_Right.release(),
              ::std:: forward<_Dx>(_Right.get_deleter())) { 
    }
    template <class _Ty2, class _Dx2,
        enable_if_t<
            conjunction_v<negation<is_array<_Ty2>>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
                conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>>,
            int> = 0>
    unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
        : _Mybase(_Right.release(),
              ::std:: forward<_Dx2>(_Right.get_deleter())) { 
    }
#line 1908 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
    template <class _Ty2, class _Dx2,
        enable_if_t<conjunction_v<negation<is_array<_Ty2>>, is_assignable<_Dx&, _Dx2>,
                        is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>>,
            int> = 0>
    unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept { 
        reset(_Right.release());
        this->get_deleter()= ::std:: forward<_Dx2>(_Right.get_deleter());
        return *this;
    }
    unique_ptr& operator=(unique_ptr&& _Right) noexcept { 
        if (this != ::std:: addressof(_Right)) { 
            reset(_Right.release());
            this->get_deleter()= ::std:: forward<_Dx>(_Right.get_deleter());
        }
        return *this;
    }
    void swap(unique_ptr& _Right) noexcept { 
        _Swap_adl(this->_Myptr(), _Right._Myptr());
        _Swap_adl(this->get_deleter(), _Right.get_deleter());
    }
    ~unique_ptr() noexcept { 
        if (get() != pointer()) {
            this->get_deleter()(get());
        }
    }
    [[nodiscard]] add_lvalue_reference_t<_Ty> operator*() const { 
        return *get();
    }
    [[nodiscard]] pointer operator->() const noexcept { 
        return this->_Myptr();
    }
    [[nodiscard]] pointer get() const noexcept { 
        return this->_Myptr();
    }
    explicit operator bool() const noexcept { 
        return get() != pointer();
    }
    pointer release() noexcept { 
        pointer _Ans   = get();
        this->_Myptr() = pointer();
        return _Ans;
    }
    void reset(pointer _Ptr = pointer()) noexcept { 
        pointer _Old   = get();
        this->_Myptr() = _Ptr;
        if (_Old != pointer()) {
            this->get_deleter()(_Old);
        }
    }
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
};
template <class _Ty, class _Dx>
class unique_ptr<_Ty[], _Dx> : public _Unique_ptr_base<_Ty, _Dx> { 
public:
    using _Mybase      = _Unique_ptr_base<_Ty, _Dx>;
    using pointer      = typename _Mybase::pointer;
    using element_type = _Ty;
    using deleter_type = _Dx;
    using _Mybase::get_deleter;
    template <class _Dx2                   = _Dx,
        _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mybase(pointer()) { 
    }
    template <class _Uty, class _Is_nullptr = is_same<_Uty, nullptr_t>>
    using _Enable_ctor_reset =
        enable_if_t<is_same_v<_Uty, pointer> 
                    || _Is_nullptr::value 
                    || (is_same_v<pointer, element_type*> 
                           && is_pointer_v<_Uty> 
                           && is_convertible_v<remove_pointer_t<_Uty> (*)[], element_type (*)[]>)>;
    template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0,
        class = _Enable_ctor_reset<_Uty>>
    explicit unique_ptr(_Uty _Ptr) noexcept : _Mybase(_Ptr) { 
    }
    template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0,
        class = _Enable_ctor_reset<_Uty>>
    unique_ptr(_Uty _Ptr, const _Dx& _Dt) noexcept
        : _Mybase(_Ptr, _Dt) { 
    }
    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0,
        class = _Enable_ctor_reset<_Uty>>
    unique_ptr(_Uty _Ptr, _Dx&& _Dt) noexcept : _Mybase(_Ptr, ::std:: move(_Dt)) { 
    }
    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;
    unique_ptr(unique_ptr&& _Right) noexcept
        : _Mybase(_Right.release(),
              ::std:: forward<_Dx>(_Right.get_deleter())) { 
    }
    unique_ptr& operator=(unique_ptr&& _Right) noexcept { 
        if (this != ::std:: addressof(_Right)) { 
            reset(_Right.release());
            this->get_deleter()= ::std:: move(_Right.get_deleter());
        }
        return *this;
    }
    template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
        class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
    using _Enable_conversion = enable_if_t<conjunction_v<is_array<_Uty>, is_same<pointer, element_type*>,
        is_same<_UP_pointer, _UP_element_type*>, is_convertible<_UP_element_type (*)[], element_type (*)[]>, _More>>;
    template <class _Uty, class _Ex,
        class = _Enable_conversion<_Uty, _Ex,
            conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx>>>>
    unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
        : _Mybase(_Right.release(),
              ::std:: forward<_Ex>(_Right.get_deleter())) { 
    }
    template <class _Uty, class _Ex, class = _Enable_conversion<_Uty, _Ex, is_assignable<_Dx&, _Ex>>>
    unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept { 
        reset(_Right.release());
        this->get_deleter()= ::std:: forward<_Ex>(_Right.get_deleter());
        return *this;
    }
    template <class _Dx2                   = _Dx,
        _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mybase(pointer()) { 
    }
    unique_ptr& operator=(nullptr_t) noexcept { 
        reset();
        return *this;
    }
    void reset(nullptr_t = nullptr) noexcept { 
        reset(pointer());
    }
    void swap(unique_ptr& _Right) noexcept { 
        _Swap_adl(this->_Myptr(), _Right._Myptr());
        _Swap_adl(this->get_deleter(), _Right.get_deleter());
    }
    ~unique_ptr() noexcept { 
        _Delete();
    }
    [[nodiscard]] _Ty& operator[](size_t _Idx) const { 
        return get()[_Idx];
    }
    [[nodiscard]] pointer get() const noexcept { 
        return this->_Myptr();
    }
    explicit operator bool() const noexcept { 
        return get() != pointer();
    }
    pointer release() noexcept { 
        pointer _Ans   = get();
        this->_Myptr() = pointer();
        return _Ans;
    }
    template <class _Uty, class = _Enable_ctor_reset<_Uty, false_type>>
    void reset(_Uty _Ptr) noexcept { 
        pointer _Old   = get();
        this->_Myptr() = _Ptr;
        if (_Old != pointer()) {
            this->get_deleter()(_Old);
        }
    }
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
private:
    void _Delete() { 
        if (get() != pointer()) {
            this->get_deleter()(get());
        }
    }
};
template <class _Ty, class... _Types, enable_if_t<!is_array_v<_Ty>, int> = 0>
[[nodiscard]] inline unique_ptr<_Ty> make_unique(_Types&&... _Args) { 
    return unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...));
}
template <class _Ty, enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0>
[[nodiscard]] inline unique_ptr<_Ty> make_unique(size_t _Size) { 
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]());
}
template <class _Ty, class... _Types, enable_if_t<extent_v<_Ty> != 0, int> = 0>
void make_unique(_Types&&...) = delete;
template <class _Alloc>
struct _Allocator_deleter {
    _Alloc _Al;
    using pointer = typename allocator_traits<_Alloc>::pointer;
    void operator()(pointer _Ptr) noexcept { 
        allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_Ptr));
        _Al.deallocate(_Ptr, 1);
    }
};
template <class _Alloc>
using _Unique_ptr_alloc = unique_ptr<typename _Alloc::value_type, _Allocator_deleter<_Alloc>>;
template <class _Alloc, class... _Args>
_Unique_ptr_alloc<_Alloc> _Make_unique_alloc(
    _Alloc& _Al, _Args&&... _Vals) { 
    return _Unique_ptr_alloc<_Alloc>(_Alloc_new(_Al, ::std:: forward<_Args>(_Vals)...), _Allocator_deleter<_Alloc>{_Al});
}
template <class _Ty, class _Dx, enable_if_t<_Is_swappable<_Dx>::value, int> = 0>
void swap(unique_ptr<_Ty, _Dx>& _Left, unique_ptr<_Ty, _Dx>& _Right) noexcept { 
    _Left.swap(_Right);
}
template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left,
    const unique_ptr<_Ty2, _Dx2>& _Right) { 
    return _Left.get() == _Right.get();
}
template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left,
    const unique_ptr<_Ty2, _Dx2>& _Right) { 
    return !(_Left == _Right);
}
template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left,
    const unique_ptr<_Ty2, _Dx2>& _Right) { 
    using _Ptr1   = typename unique_ptr<_Ty1, _Dx1>::pointer;
    using _Ptr2   = typename unique_ptr<_Ty2, _Dx2>::pointer;
    using _Common = common_type_t<_Ptr1, _Ptr2>;
    return less<_Common>()(_Left.get(), _Right.get());
}
template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left,
    const unique_ptr<_Ty2, _Dx2>& _Right) { 
    return !(_Left < _Right);
}
template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left,
    const unique_ptr<_Ty2, _Dx2>& _Right) { 
    return _Right < _Left;
}
template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left,
    const unique_ptr<_Ty2, _Dx2>& _Right) { 
    return !(_Right < _Left);
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept { 
    return !_Left;
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator==(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) noexcept { 
    return !_Right;
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator!=(
    const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) noexcept { 
    return !(_Left == _Right);
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator!=(
    nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) noexcept { 
    return !(_Left == _Right);
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) { 
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>()(_Left.get(), _Right);
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator<(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) { 
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>()(_Left, _Right.get());
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) { 
    return !(_Left < _Right);
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator>=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) { 
    return !(_Left < _Right);
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) { 
    return _Right < _Left;
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator>(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) { 
    return _Right < _Left;
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) { 
    return !(_Right < _Left);
}
template <class _Ty, class _Dx>
[[nodiscard]] bool operator<=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) { 
    return !(_Right < _Left);
}
template <class _OutTy, class _PxTy, class = void>
struct _Can_stream_unique_ptr : false_type {};
template <class _OutTy, class _PxTy>
struct _Can_stream_unique_ptr<_OutTy, _PxTy, void_t<decltype(::std:: declval<_OutTy>() << ::std:: declval<_PxTy>().get())>>
    : true_type {};
template <class _Elem, class _Traits, class _Yty, class _Dx,
    enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits>&, const unique_ptr<_Yty, _Dx>&>::value, int> = 0>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Out, const unique_ptr<_Yty, _Dx>& _Px) { 
    _Out << _Px.get();
    return _Out;
}
enum class pointer_safety { 
    relaxed,
    preferred,
    strict
};
inline void declare_reachable(void*) { 
}
template <class _Ty>
inline _Ty* undeclare_reachable(_Ty* _Ptr) { 
    return _Ptr;
}
inline void declare_no_pointers(char*, size_t) { 
}
inline void undeclare_no_pointers(char*, size_t) { 
}
inline pointer_safety get_pointer_safety() noexcept { 
    return pointer_safety::relaxed;
}
template <class _Ty = void>
struct owner_less; 
template <class _Ty>
struct owner_less<shared_ptr<_Ty>> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef shared_ptr<_Ty> first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef shared_ptr<_Ty> second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef bool result_type;
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
};
template <class _Ty>
struct owner_less<weak_ptr<_Ty>> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef weak_ptr<_Ty> first_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef weak_ptr<_Ty> second_argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef bool result_type;
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
};
template <>
struct owner_less<void> { 
    using is_transparent = int;
    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const
        noexcept { 
        return _Left.owner_before(_Right);
    }
};
template <class _Ty, class _Dx>
struct hash<unique_ptr<_Ty, _Dx>>
    : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>,
          is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>> { 
    static size_t _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval)
        noexcept(_Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value) 
    { 
        return hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get());
    }
};
template <class _Ty>
struct hash<shared_ptr<_Ty>> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef shared_ptr<_Ty> argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const shared_ptr<_Ty>& _Keyval) const
        noexcept { 
        return hash<typename shared_ptr<_Ty>::element_type*>()(_Keyval.get());
    }
};
inline void* align(size_t _Bound, size_t _Size, void*& _Ptr,
    size_t& _Space) noexcept { 
    size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
    if (_Off != 0) {
        _Off = _Bound - _Off; 
    }
    if (_Space < _Off || _Space - _Off < _Size) {
        return nullptr;
    }
    _Ptr = static_cast<char*>(_Ptr) + _Off;
    _Space -= _Off;
    return _Ptr;
}
extern "C" {
 void __cdecl _Lock_shared_ptr_spin_lock();
 void __cdecl _Unlock_shared_ptr_spin_lock();
}
struct _Shared_ptr_spin_lock { 
    _Shared_ptr_spin_lock() { 
        _Lock_shared_ptr_spin_lock();
    }
    ~_Shared_ptr_spin_lock() noexcept { 
        _Unlock_shared_ptr_spin_lock();
    }
};
template <class _Ty>
[[nodiscard]] inline bool atomic_is_lock_free(
    const shared_ptr<_Ty>*) { 
    return false;
}
template <class _Ty>
[[nodiscard]] inline shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty>* _Ptr,
    memory_order) { 
    _Shared_ptr_spin_lock _Lock;
    shared_ptr<_Ty> _Result = *_Ptr;
    return _Result;
}
template <class _Ty>
[[nodiscard]] inline shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty>* _Ptr) { 
    return ::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst);
}
template <class _Ty>
inline void atomic_store_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other,
    memory_order) { 
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
}
template <class _Ty>
inline void atomic_store(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) { 
    ::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}
template <class _Ty>
inline shared_ptr<_Ty> atomic_exchange_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other,
    memory_order) { 
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
    return _Other;
}
template <class _Ty>
inline shared_ptr<_Ty> atomic_exchange(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty> _Other) { 
    return ::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}
template <class _Ty>
inline bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value,
    memory_order, memory_order) { 
    shared_ptr<_Ty> _Old_exp; 
    _Shared_ptr_spin_lock _Lock;
    bool _Success = _Ptr->get() == _Exp->get() && !_Ptr->owner_before(*_Exp) && !_Exp->owner_before(*_Ptr);
    if (_Success) {
        _Ptr->swap(_Value);
    } else { 
        _Exp->swap(_Old_exp);
        *_Exp = *_Ptr;
    }
    return _Success;
}
template <class _Ty>
inline bool atomic_compare_exchange_weak(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp,
    shared_ptr<_Ty> _Value) { 
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}
template <class _Ty>
inline bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp,
    shared_ptr<_Ty> _Value, memory_order, memory_order) { 
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}
template <class _Ty>
inline bool atomic_compare_exchange_strong(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp,
    shared_ptr<_Ty> _Value) { 
    return ::std:: atomic_compare_exchange_strong_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}
#line 2528 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
}
#pragma warning(pop)
#pragma pack(pop)
#line 2535 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
#line 2536 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\memory"
#line 8 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/allocators.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 115 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 118 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 121 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 131 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 142 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 146 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 166 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
typedef struct
{
    intmax_t quot;
    intmax_t rem;
} _Lldiv_t;
typedef _Lldiv_t imaxdiv_t;
 intmax_t __cdecl imaxabs(
      intmax_t _Number
    );
 imaxdiv_t __cdecl imaxdiv(
      intmax_t _Numerator,
      intmax_t _Denominator
    );
 intmax_t __cdecl strtoimax(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );
 intmax_t __cdecl _strtoimax_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );
 uintmax_t __cdecl strtoumax(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );
 uintmax_t __cdecl _strtoumax_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );
 intmax_t __cdecl wcstoimax(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );
 intmax_t __cdecl _wcstoimax_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );
 uintmax_t __cdecl wcstoumax(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );
 uintmax_t __cdecl _wcstoumax_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
} __pragma(pack(pop))
#line 336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\inttypes.h"
#line 169 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 170 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 175 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 184 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 186 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 188 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 190 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 231 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 233 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 236 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 238 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 246 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 247 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 258 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 259 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 277 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 278 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 291 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 309 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 310 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 315 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 321 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 351 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
namespace rapidjson {
typedef unsigned SizeType;
}
#line 383 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
namespace rapidjson {
using std::size_t;
}
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
__pragma(pack(push, 8)) extern "C" {
     void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
} __pragma(pack(pop))
#line 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 402 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 404 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 413 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
namespace rapidjson {
template <bool x> struct STATIC_ASSERTION_FAILURE;
template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };
template<int x> struct StaticAssertTest {};
}
#line 426 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 428 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 431 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 442 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 455 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 457 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 458 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 468 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 470 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 471 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 492 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 510 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 526 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 539 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 545 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 546 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 551 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 554 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 556 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 557 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 560 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 562 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 567 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 572 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 577 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 578 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 588 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 592 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
namespace rapidjson {
enum Type {
    kNullType = 0,      
    kFalseType = 1,     
    kTrueType = 2,      
    kObjectType = 3,    
    kArrayType = 4,     
    kStringType = 5,    
    kNumberType = 6     
};
}
#line 616 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\rapidjson.h"
#line 19 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/allocators.h"
namespace rapidjson {
class CrtAllocator {
public:
    static const bool kNeedFree = true;
    void* Malloc(size_t size) { 
        if (size) 
            return std::malloc(size);
        else
            return 0; 
    }
    void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) {
        (void)originalSize;
        if (newSize == 0) {
            std::free(originalPtr);
            return 0;
        }
        return std::realloc(originalPtr, newSize);
    }
    static void Free(void *ptr) { std::free(ptr); }
};
template <typename BaseAllocator = CrtAllocator>
class MemoryPoolAllocator {
public:
    static const bool kNeedFree = false;    
    MemoryPoolAllocator(size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) : 
        chunkHead_(0), chunk_capacity_(chunkSize), userBuffer_(0), baseAllocator_(baseAllocator), ownBaseAllocator_(0)
    {
    }
    MemoryPoolAllocator(void *buffer, size_t size, size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) :
        chunkHead_(0), chunk_capacity_(chunkSize), userBuffer_(buffer), baseAllocator_(baseAllocator), ownBaseAllocator_(0)
    {
        (void)( (!!(buffer != 0)) || (_wassert(L"buffer != 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/allocators.h", (unsigned)(128)), 0) );
        (void)( (!!(size > sizeof(ChunkHeader))) || (_wassert(L"size > sizeof(ChunkHeader)", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/allocators.h", (unsigned)(129)), 0) );
        chunkHead_ = reinterpret_cast<ChunkHeader*>(buffer);
        chunkHead_->capacity = size - sizeof(ChunkHeader);
        chunkHead_->size = 0;
        chunkHead_->next = 0;
    }
    ~MemoryPoolAllocator() {
        Clear();
        delete ownBaseAllocator_;
    }
    void Clear() {
        while (chunkHead_ && chunkHead_ != userBuffer_) {
            ChunkHeader* next = chunkHead_->next;
            baseAllocator_->Free(chunkHead_);
            chunkHead_ = next;
        }
        if (chunkHead_ && chunkHead_ == userBuffer_)
            chunkHead_->size = 0; 
    }
    size_t Capacity() const {
        size_t capacity = 0;
        for (ChunkHeader* c = chunkHead_; c != 0; c = c->next)
            capacity += c->capacity;
        return capacity;
    }
    size_t Size() const {
        size_t size = 0;
        for (ChunkHeader* c = chunkHead_; c != 0; c = c->next)
            size += c->size;
        return size;
    }
    void* Malloc(size_t size) {
        if (!size)
            return 0;
        size = (((size) + static_cast<uint64_t>(7u)) & ~static_cast<uint64_t>(7u));
        if (chunkHead_ == 0 || chunkHead_->size + size > chunkHead_->capacity)
            if (!AddChunk(chunk_capacity_ > size ? chunk_capacity_ : size))
                return 0;
        void *buffer = reinterpret_cast<char *>(chunkHead_) + (((sizeof(ChunkHeader)) + static_cast<uint64_t>(7u)) & ~static_cast<uint64_t>(7u)) + chunkHead_->size;
        chunkHead_->size += size;
        return buffer;
    }
    void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) {
        if (originalPtr == 0)
            return Malloc(newSize);
        if (newSize == 0)
            return 0;
        originalSize = (((originalSize) + static_cast<uint64_t>(7u)) & ~static_cast<uint64_t>(7u));
        newSize = (((newSize) + static_cast<uint64_t>(7u)) & ~static_cast<uint64_t>(7u));
        if (originalSize >= newSize)
            return originalPtr;
        if (originalPtr == reinterpret_cast<char *>(chunkHead_) + (((sizeof(ChunkHeader)) + static_cast<uint64_t>(7u)) & ~static_cast<uint64_t>(7u)) + chunkHead_->size - originalSize) {
            size_t increment = static_cast<size_t>(newSize - originalSize);
            if (chunkHead_->size + increment <= chunkHead_->capacity) {
                chunkHead_->size += increment;
                return originalPtr;
            }
        }
        if (void* newBuffer = Malloc(newSize)) {
            if (originalSize)
                std::memcpy(newBuffer, originalPtr, originalSize);
            return newBuffer;
        }
        else
            return 0;
    }
    static void Free(void *ptr) { (void)ptr; } 
private:
    MemoryPoolAllocator(const MemoryPoolAllocator& rhs) ;
    MemoryPoolAllocator& operator=(const MemoryPoolAllocator& rhs) ;
    bool AddChunk(size_t capacity) {
        if (!baseAllocator_)
            ownBaseAllocator_ = baseAllocator_ = new BaseAllocator();
        if (ChunkHeader* chunk = reinterpret_cast<ChunkHeader*>(baseAllocator_->Malloc((((sizeof(ChunkHeader)) + static_cast<uint64_t>(7u)) & ~static_cast<uint64_t>(7u)) + capacity))) {
            chunk->capacity = capacity;
            chunk->size = 0;
            chunk->next = chunkHead_;
            chunkHead_ =  chunk;
            return true;
        }
        else
            return false;
    }
    static const int kDefaultChunkCapacity = 64 * 1024; 
    struct ChunkHeader {
        size_t capacity;    
        size_t size;        
        ChunkHeader *next;  
    };
    ChunkHeader *chunkHead_;    
    size_t chunk_capacity_;     
    void *userBuffer_;          
    BaseAllocator* baseAllocator_;  
    BaseAllocator* ownBaseAllocator_;   
};
}
#line 272 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/allocators.h"
#line 10 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.h"
namespace CubeWorld
{
class BindingProperty;
namespace RGBBinding
{
template<typename Data>
class Array {
public:
   static constexpr size_t INITIAL_SIZE = 4;
public:
   Array() : mSize(0), mCapacity(0), mData(nullptr)
   {
      reserve(INITIAL_SIZE);
   };
   Array(const Array& other) : mSize(0), mCapacity(0), mData(nullptr)
   {
      reserve(other.mSize);
      for (size_t i = 0; i < other.mSize; ++i)
      {
         new (&mData[i]) Data(other.mData[i]);
      }
      mSize = other.mSize;
   }
   Array(Array&& other)
   {
      mCapacity = other.mCapacity;
      mSize = other.mSize;
      mData = other.mData;
      other.mData = nullptr;
      other.mSize = other.mCapacity = 0;
   }
   ~Array()
   {
      clear();
      if (mData)
      {
         std::free(mData);
         mData = nullptr;
      }
      mCapacity = 0;
   }
   Array& operator=(const Array& other)
   {
      clear();
      reserve(other.mSize);
      for (size_t i = 0; i < other.mSize; ++i)
      {
         mData[i] = other.mData[i];
      }
      mSize = other.mSize;
      return *this;
   }
   Array& operator=(Array&& other)
   {
      clear();
      if (mData)
      {
         std::free(mData);
      }
      mCapacity = other.mCapacity;
      mSize = other.mSize;
      mData = other.mData;
      other.mData = nullptr;
      other.mSize = other.mCapacity = 0;
      return *this;
   }
   bool operator==(const Array& other) const
   {
      if (mSize != other.mSize) { return false; }
      for (size_t i = 0; i < mSize; ++i)
      {
         if (mData[i] != other.mData[i])
         {
            return false;
         }
      }
      return true;
   }
   inline bool operator!=(const Array& other) const
   {
      return !(*this == other);
   }
   void clear()
   {
      while (mSize > 0)
      {
         mData[--mSize].~Data();
      }
   }
   size_t size() const { return mSize; }
   size_t capacity() const { return mCapacity; }
   Data& operator[](size_t index)
   {
      (void)( (!!(index < mSize && "Index array out of bounds")) || (_wassert(L"index < mSize && \"Index array out of bounds\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.h", (unsigned)(123)), 0) );
      return mData[index];
   }
   const Data& operator[](size_t index) const
   {
      (void)( (!!(index < mSize && "Index array out of bounds")) || (_wassert(L"index < mSize && \"Index array out of bounds\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.h", (unsigned)(129)), 0) );
      return mData[index];
   }
   void push_back(const Data& data)
   {
      push_back(BindingProperty(data));
   }
   void push_back(Data&& data)
   {
      if (mSize >= mCapacity)
      {
         if (mCapacity * 2 < INITIAL_SIZE)
         {
            reserve(INITIAL_SIZE);
         }
         else
         {
            reserve(mCapacity * 2);
         }
      }
      memset(&mData[mSize], 0, sizeof(Data));
      mData[mSize] = std::move(data);
      mSize++;
   }
   void pop_back()
   {
      (void)( (!!(mSize > 0 && "Attempting to pop_back on an empty array")) || (_wassert(L"mSize > 0 && \"Attempting to pop_back on an empty array\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.h", (unsigned)(159)), 0) );
      mData[--mSize].~Data();
   }
   void resize(size_t size)
   {
      if (mSize >= size)
      {
         for (size_t i = mSize - 1; i >= size; --i)
         {
            mData[i].~Data();
         }
         mSize = size;
         return;
      }
      if (mCapacity < size)
      {
         reserve(std::max(mCapacity * 2, size));
      }
      while (mSize < size)
      {
         new (&mData[mSize++]) Data();
      }
   }
   void reserve(size_t size)
   {
      if (mCapacity >= size)
      {
         return;
      }
      size_t newCapacity = size;
      void* newData = std::malloc(newCapacity * sizeof(Data));
      if (newData != nullptr)
      {
         std::memcpy(newData, mData, mCapacity * sizeof(Data));
         if (mData != nullptr) { std::free(mData); }
         mData = static_cast<Data*>(newData);
         mCapacity = newCapacity;
      }
   }
public:
   template <typename Arr, typename D>
   class iterator_type {
   public:
      iterator_type& operator++()
      {
         ++mIndex;
         return *this;
      }
      bool operator==(const iterator_type& rhs) const
      {
         return mArray == rhs.mArray && mIndex == rhs.mIndex;
      }
      bool operator!=(const iterator_type& rhs) const
      {
         return !(*this == rhs);
      }
      D& operator*() const
      {
         (void)( (!!(mIndex < mArray->mSize && "Array index out of bounds")) || (_wassert(L"mIndex < mArray->mSize && \"Array index out of bounds\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.h", (unsigned)(230)), 0) );
         return mArray->mData[mIndex];
      }
      iterator_type& operator=(const iterator_type& other)
      {
         mArray = other.mArray;
         mIndex = other.mIndex;
         return *this;
      }
   private:
      friend class Array;
      iterator_type(Arr* array, size_t index)
         : mArray(array)
         , mIndex(index)
      {}
   private:
      Arr* mArray;
      size_t mIndex;
   };
   typedef iterator_type<Array, Data> iterator;
   typedef iterator_type<const Array, const Data> const_iterator;
   iterator begin() { return iterator(this, 0); }
   iterator end() { return iterator(this, mSize); }
   const_iterator begin() const { return const_iterator(this, 0); }
   const_iterator end() const { return const_iterator(this, mSize); }
private:
   size_t mSize;
   size_t mCapacity;
   Data* mData;
};
}; 
}; 
#line 4 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\Array.cpp"
namespace CubeWorld
{
}; 
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\tmp\\x64-Debug\\RGBBinding\\Unity1.cpp"
#pragma message( "C:/Users/Thomas/Code/CubeWorldC++/source/Library/RGBBinding/BindingProperty.cpp" )
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\istream"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ostream"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ios"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cmath"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
  inline double pow(  double _Xx,   int _Yx) noexcept {
    if (_Yx == 2) {
        return _Xx * _Xx;
    }
    return :: pow(_Xx, static_cast<double>(_Yx));
}
  inline float acos(  float _Xx) noexcept {
    return :: acosf(_Xx);
}
  inline float acosh(  float _Xx) noexcept {
    return :: acoshf(_Xx);
}
  inline float asin(  float _Xx) noexcept {
    return :: asinf(_Xx);
}
  inline float asinh(  float _Xx) noexcept {
    return :: asinhf(_Xx);
}
  inline float atan(  float _Xx) noexcept {
    return :: atanf(_Xx);
}
  inline float atanh(  float _Xx) noexcept {
    return :: atanhf(_Xx);
}
  inline float atan2(  float _Yx,   float _Xx) noexcept {
    return :: atan2f(_Yx, _Xx);
}
  inline float cbrt(  float _Xx) noexcept {
    return :: cbrtf(_Xx);
}
  inline float ceil(  float _Xx) noexcept {
    return :: ceilf(_Xx);
}
  inline float copysign(  float _Number,   float _Sign) noexcept {
    return :: copysignf(_Number, _Sign);
}
  inline float cos(  float _Xx) noexcept {
    return :: cosf(_Xx);
}
  inline float cosh(  float _Xx) noexcept {
    return :: coshf(_Xx);
}
  inline float erf(  float _Xx) noexcept {
    return :: erff(_Xx);
}
  inline float erfc(  float _Xx) noexcept {
    return :: erfcf(_Xx);
}
  inline float exp(  float _Xx) noexcept {
    return :: expf(_Xx);
}
  inline float exp2(  float _Xx) noexcept {
    return :: exp2f(_Xx);
}
  inline float expm1(  float _Xx) noexcept {
    return :: expm1f(_Xx);
}
  inline float fabs(  float _Xx) noexcept {
    return :: fabsf(_Xx);
}
  inline float fdim(  float _Xx,   float _Yx) noexcept {
    return :: fdimf(_Xx, _Yx);
}
  inline float floor(  float _Xx) noexcept {
    return :: floorf(_Xx);
}
  inline float fma(  float _Xx,   float _Yx,   float _Zx) noexcept {
    return :: fmaf(_Xx, _Yx, _Zx);
}
  inline float fmax(  float _Xx,   float _Yx) noexcept {
    return :: fmaxf(_Xx, _Yx);
}
  inline float fmin(  float _Xx,   float _Yx) noexcept {
    return :: fminf(_Xx, _Yx);
}
  inline float fmod(  float _Xx,   float _Yx) noexcept {
    return :: fmodf(_Xx, _Yx);
}
  inline float frexp(  float _Xx,   int* _Yx) noexcept {
    return :: frexpf(_Xx, _Yx);
}
  inline float hypot(  float _Xx,   float _Yx) noexcept {
    return :: hypotf(_Xx, _Yx);
}
  inline int ilogb(  float _Xx) noexcept {
    return :: ilogbf(_Xx);
}
  inline float ldexp(  float _Xx,   int _Yx) noexcept {
    return :: ldexpf(_Xx, _Yx);
}
  inline float lgamma(  float _Xx) noexcept {
    return :: lgammaf(_Xx);
}
  inline long long llrint(  float _Xx) noexcept {
    return :: llrintf(_Xx);
}
  inline long long llround(  float _Xx) noexcept {
    return :: llroundf(_Xx);
}
  inline float log(  float _Xx) noexcept {
    return :: logf(_Xx);
}
  inline float log10(  float _Xx) noexcept {
    return :: log10f(_Xx);
}
  inline float log1p(  float _Xx) noexcept {
    return :: log1pf(_Xx);
}
  inline float log2(  float _Xx) noexcept {
    return :: log2f(_Xx);
}
  inline float logb(  float _Xx) noexcept {
    return :: logbf(_Xx);
}
  inline long lrint(  float _Xx) noexcept {
    return :: lrintf(_Xx);
}
  inline long lround(  float _Xx) noexcept {
    return :: lroundf(_Xx);
}
  inline float modf(  float _Xx,   float* _Yx) noexcept {
    return :: modff(_Xx, _Yx);
}
  inline float nearbyint(  float _Xx) noexcept {
    return :: nearbyintf(_Xx);
}
  inline float nextafter(  float _Xx,   float _Yx) noexcept {
    return :: nextafterf(_Xx, _Yx);
}
  inline float nexttoward(  float _Xx,   long double _Yx) noexcept {
    return :: nexttowardf(_Xx, _Yx);
}
  inline float pow(  float _Xx,   float _Yx) noexcept {
    return :: powf(_Xx, _Yx);
}
  inline float pow(  float _Xx,   int _Yx) noexcept {
    if (_Yx == 2) {
        return _Xx * _Xx;
    }
    return :: powf(_Xx, static_cast<float>(_Yx));
}
  inline float remainder(  float _Xx,   float _Yx) noexcept {
    return :: remainderf(_Xx, _Yx);
}
  inline float remquo(  float _Xx,   float _Yx,   int* _Zx) noexcept {
    return :: remquof(_Xx, _Yx, _Zx);
}
  inline float rint(  float _Xx) noexcept {
    return :: rintf(_Xx);
}
  inline float round(  float _Xx) noexcept {
    return :: roundf(_Xx);
}
  inline float scalbln(  float _Xx,   long _Yx) noexcept {
    return :: scalblnf(_Xx, _Yx);
}
  inline float scalbn(  float _Xx,   int _Yx) noexcept {
    return :: scalbnf(_Xx, _Yx);
}
  inline float sin(  float _Xx) noexcept {
    return :: sinf(_Xx);
}
  inline float sinh(  float _Xx) noexcept {
    return :: sinhf(_Xx);
}
  inline float sqrt(  float _Xx) noexcept {
    return :: sqrtf(_Xx);
}
  inline float tan(  float _Xx) noexcept {
    return :: tanf(_Xx);
}
  inline float tanh(  float _Xx) noexcept {
    return :: tanhf(_Xx);
}
  inline float tgamma(  float _Xx) noexcept {
    return :: tgammaf(_Xx);
}
  inline float trunc(  float _Xx) noexcept {
    return :: truncf(_Xx);
}
  inline long double acos(  long double _Xx) noexcept {
    return :: acosl(_Xx);
}
  inline long double acosh(  long double _Xx) noexcept {
    return :: acoshl(_Xx);
}
  inline long double asin(  long double _Xx) noexcept {
    return :: asinl(_Xx);
}
  inline long double asinh(  long double _Xx) noexcept {
    return :: asinhl(_Xx);
}
  inline long double atan(  long double _Xx) noexcept {
    return :: atanl(_Xx);
}
  inline long double atanh(  long double _Xx) noexcept {
    return :: atanhl(_Xx);
}
  inline long double atan2(  long double _Yx,   long double _Xx) noexcept {
    return :: atan2l(_Yx, _Xx);
}
  inline long double cbrt(  long double _Xx) noexcept {
    return :: cbrtl(_Xx);
}
  inline long double ceil(  long double _Xx) noexcept {
    return :: ceill(_Xx);
}
  inline long double copysign(  long double _Number,   long double _Sign) noexcept {
    return :: copysignl(_Number, _Sign);
}
  inline long double cos(  long double _Xx) noexcept {
    return :: cosl(_Xx);
}
  inline long double cosh(  long double _Xx) noexcept {
    return :: coshl(_Xx);
}
  inline long double erf(  long double _Xx) noexcept {
    return :: erfl(_Xx);
}
  inline long double erfc(  long double _Xx) noexcept {
    return :: erfcl(_Xx);
}
  inline long double exp(  long double _Xx) noexcept {
    return :: expl(_Xx);
}
  inline long double exp2(  long double _Xx) noexcept {
    return :: exp2l(_Xx);
}
  inline long double expm1(  long double _Xx) noexcept {
    return :: expm1l(_Xx);
}
  inline long double fabs(  long double _Xx) noexcept {
    return :: fabsl(_Xx);
}
  inline long double fdim(  long double _Xx,   long double _Yx) noexcept {
    return :: fdiml(_Xx, _Yx);
}
  inline long double floor(  long double _Xx) noexcept {
    return :: floorl(_Xx);
}
  inline long double fma(  long double _Xx,   long double _Yx,   long double _Zx) noexcept {
    return :: fmal(_Xx, _Yx, _Zx);
}
  inline long double fmax(  long double _Xx,   long double _Yx) noexcept {
    return :: fmaxl(_Xx, _Yx);
}
  inline long double fmin(  long double _Xx,   long double _Yx) noexcept {
    return :: fminl(_Xx, _Yx);
}
  inline long double fmod(  long double _Xx,   long double _Yx) noexcept {
    return :: fmodl(_Xx, _Yx);
}
  inline long double frexp(  long double _Xx,   int* _Yx) noexcept {
    return :: frexpl(_Xx, _Yx);
}
  inline long double hypot(  long double _Xx,   long double _Yx) noexcept {
    return :: hypotl(_Xx, _Yx);
}
  inline int ilogb(  long double _Xx) noexcept {
    return :: ilogbl(_Xx);
}
  inline long double ldexp(  long double _Xx,   int _Yx) noexcept {
    return :: ldexpl(_Xx, _Yx);
}
  inline long double lgamma(  long double _Xx) noexcept {
    return :: lgammal(_Xx);
}
  inline long long llrint(  long double _Xx) noexcept {
    return :: llrintl(_Xx);
}
  inline long long llround(  long double _Xx) noexcept {
    return :: llroundl(_Xx);
}
  inline long double log(  long double _Xx) noexcept {
    return :: logl(_Xx);
}
  inline long double log10(  long double _Xx) noexcept {
    return :: log10l(_Xx);
}
  inline long double log1p(  long double _Xx) noexcept {
    return :: log1pl(_Xx);
}
  inline long double log2(  long double _Xx) noexcept {
    return :: log2l(_Xx);
}
  inline long double logb(  long double _Xx) noexcept {
    return :: logbl(_Xx);
}
  inline long lrint(  long double _Xx) noexcept {
    return :: lrintl(_Xx);
}
  inline long lround(  long double _Xx) noexcept {
    return :: lroundl(_Xx);
}
  inline long double modf(  long double _Xx,   long double* _Yx) noexcept {
    return :: modfl(_Xx, _Yx);
}
  inline long double nearbyint(  long double _Xx) noexcept {
    return :: nearbyintl(_Xx);
}
  inline long double nextafter(  long double _Xx,   long double _Yx) noexcept {
    return :: nextafterl(_Xx, _Yx);
}
  inline long double nexttoward(  long double _Xx,   long double _Yx) noexcept {
    return :: nexttowardl(_Xx, _Yx);
}
  inline long double pow(  long double _Xx,   long double _Yx) noexcept {
    return :: powl(_Xx, _Yx);
}
  inline long double pow(  long double _Xx,   int _Yx) noexcept {
    if (_Yx == 2) {
        return _Xx * _Xx;
    }
    return :: powl(_Xx, static_cast<long double>(_Yx));
}
  inline long double remainder(  long double _Xx,   long double _Yx) noexcept {
    return :: remainderl(_Xx, _Yx);
}
  inline long double remquo(  long double _Xx,   long double _Yx,   int* _Zx) noexcept {
    return :: remquol(_Xx, _Yx, _Zx);
}
  inline long double rint(  long double _Xx) noexcept {
    return :: rintl(_Xx);
}
  inline long double round(  long double _Xx) noexcept {
    return :: roundl(_Xx);
}
  inline long double scalbln(  long double _Xx,   long _Yx) noexcept {
    return :: scalblnl(_Xx, _Yx);
}
  inline long double scalbn(  long double _Xx,   int _Yx) noexcept {
    return :: scalbnl(_Xx, _Yx);
}
  inline long double sin(  long double _Xx) noexcept {
    return :: sinl(_Xx);
}
  inline long double sinh(  long double _Xx) noexcept {
    return :: sinhl(_Xx);
}
  inline long double sqrt(  long double _Xx) noexcept {
    return :: sqrtl(_Xx);
}
  inline long double tan(  long double _Xx) noexcept {
    return :: tanl(_Xx);
}
  inline long double tanh(  long double _Xx) noexcept {
    return :: tanhl(_Xx);
}
  inline long double tgamma(  long double _Xx) noexcept {
    return :: tgammal(_Xx);
}
  inline long double trunc(  long double _Xx) noexcept {
    return :: truncl(_Xx);
}
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtgmath.h"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Ty1, class _Ty2>
using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
    conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
        double>>; 
}
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>
[[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> pow(
    const _Ty1 _Left, const _Ty2 _Right) { 
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
    return :: pow(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}
extern "C"    double __cdecl acos(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double acos(_Ty _Left) { return :: acos(static_cast<double>(_Left)); }
extern "C"    double __cdecl asin(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double asin(_Ty _Left) { return :: asin(static_cast<double>(_Left)); }
extern "C"    double __cdecl atan(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double atan(_Ty _Left) { return :: atan(static_cast<double>(_Left)); }
extern "C"    double __cdecl atan2(  double,   double); template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: atan2(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
extern "C"    double __cdecl ceil(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double ceil(_Ty _Left) { return :: ceil(static_cast<double>(_Left)); }
extern "C"    double __cdecl cos(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double cos(_Ty _Left) { return :: cos(static_cast<double>(_Left)); }
extern "C"    double __cdecl cosh(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double cosh(_Ty _Left) { return :: cosh(static_cast<double>(_Left)); }
extern "C"    double __cdecl exp(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double exp(_Ty _Left) { return :: exp(static_cast<double>(_Left)); }
extern "C"    double __cdecl fabs(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double fabs(_Ty _Left) { return :: fabs(static_cast<double>(_Left)); }
extern "C"    double __cdecl floor(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double floor(_Ty _Left) { return :: floor(static_cast<double>(_Left)); }
extern "C"    double __cdecl fmod(  double,   double); template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmod(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
extern "C"    double __cdecl frexp(  double,   int*); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double frexp(_Ty _Left,   int* _Arg2) { return :: frexp(static_cast<double>(_Left), _Arg2); }
extern "C"    double __cdecl ldexp(  double,   int); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double ldexp(_Ty _Left,   int _Arg2) { return :: ldexp(static_cast<double>(_Left), _Arg2); }
extern "C"    double __cdecl log(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double log(_Ty _Left) { return :: log(static_cast<double>(_Left)); }
extern "C"    double __cdecl log10(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double log10(_Ty _Left) { return :: log10(static_cast<double>(_Left)); }
extern "C"    double __cdecl sin(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double sin(_Ty _Left) { return :: sin(static_cast<double>(_Left)); }
extern "C"    double __cdecl sinh(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double sinh(_Ty _Left) { return :: sinh(static_cast<double>(_Left)); }
extern "C"    double __cdecl sqrt(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double sqrt(_Ty _Left) { return :: sqrt(static_cast<double>(_Left)); }
extern "C"    double __cdecl tan(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double tan(_Ty _Left) { return :: tan(static_cast<double>(_Left)); }
extern "C"    double __cdecl tanh(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double tanh(_Ty _Left) { return :: tanh(static_cast<double>(_Left)); }
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtgmath.h"
template <class _Ty1, class _Ty2, class _Ty3,
    class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2> && ::std:: is_arithmetic_v<_Ty3>>>
[[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>> fma(
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) { 
    using _Common = ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else {
        return :: fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
#line 124 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtgmath.h"
}
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtgmath.h"
template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>
inline ::std:: _Common_float_type_t<_Ty1, _Ty2> remquo(
    _Ty1 _Left, _Ty2 _Right, int* _Pquo) { 
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else {
        return :: remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
#line 156 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtgmath.h"
}
extern "C"    double __cdecl acosh(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double acosh(_Ty _Left) { return :: acosh(static_cast<double>(_Left)); }
extern "C"    double __cdecl asinh(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double asinh(_Ty _Left) { return :: asinh(static_cast<double>(_Left)); }
extern "C"    double __cdecl atanh(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double atanh(_Ty _Left) { return :: atanh(static_cast<double>(_Left)); }
extern "C"    double __cdecl cbrt(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double cbrt(_Ty _Left) { return :: cbrt(static_cast<double>(_Left)); }
extern "C"    double __cdecl copysign(  double,   double); template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: copysign(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
extern "C"    double __cdecl erf(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double erf(_Ty _Left) { return :: erf(static_cast<double>(_Left)); }
extern "C"    double __cdecl erfc(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double erfc(_Ty _Left) { return :: erfc(static_cast<double>(_Left)); }
extern "C"    double __cdecl expm1(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double expm1(_Ty _Left) { return :: expm1(static_cast<double>(_Left)); }
extern "C"    double __cdecl exp2(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double exp2(_Ty _Left) { return :: exp2(static_cast<double>(_Left)); }
extern "C"    double __cdecl fdim(  double,   double); template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fdim(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
extern "C"    double __cdecl fmax(  double,   double); template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmax(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
extern "C"    double __cdecl fmin(  double,   double); template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: fmin(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
extern "C"    double __cdecl hypot(  double,   double); template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: hypot(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
extern "C"    int __cdecl ilogb(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline int ilogb(_Ty _Left) { return :: ilogb(static_cast<double>(_Left)); }
extern "C"    double __cdecl lgamma(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double lgamma(_Ty _Left) { return :: lgamma(static_cast<double>(_Left)); }
extern "C"    long long __cdecl llrint(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline long long llrint(_Ty _Left) { return :: llrint(static_cast<double>(_Left)); }
extern "C"    long long __cdecl llround(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline long long llround(_Ty _Left) { return :: llround(static_cast<double>(_Left)); }
extern "C"    double __cdecl log1p(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double log1p(_Ty _Left) { return :: log1p(static_cast<double>(_Left)); }
extern "C"    double __cdecl log2(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double log2(_Ty _Left) { return :: log2(static_cast<double>(_Left)); }
extern "C"    double __cdecl logb(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double logb(_Ty _Left) { return :: logb(static_cast<double>(_Left)); }
extern "C"    long __cdecl lrint(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline long lrint(_Ty _Left) { return :: lrint(static_cast<double>(_Left)); }
extern "C"    long __cdecl lround(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline long lround(_Ty _Left) { return :: lround(static_cast<double>(_Left)); }
extern "C"    double __cdecl nearbyint(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double nearbyint(_Ty _Left) { return :: nearbyint(static_cast<double>(_Left)); }
extern "C"    double __cdecl nextafter(  double,   double); template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: nextafter(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
extern "C"    double __cdecl nexttoward(  double,   long double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double nexttoward(_Ty _Left,   long double _Arg2) { return :: nexttoward(static_cast<double>(_Left), _Arg2); }
extern "C"    double __cdecl remainder(  double,   double); template <class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> [[nodiscard]] inline ::std:: _Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return :: remainder(static_cast<_Common>(_Left), static_cast<_Common>(_Right)); }
extern "C"    double __cdecl rint(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double rint(_Ty _Left) { return :: rint(static_cast<double>(_Left)); }
extern "C"    double __cdecl round(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double round(_Ty _Left) { return :: round(static_cast<double>(_Left)); }
extern "C"    double __cdecl scalbln(  double,   long); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double scalbln(_Ty _Left,   long _Arg2) { return :: scalbln(static_cast<double>(_Left), _Arg2); }
extern "C"    double __cdecl scalbn(  double,   int); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double scalbn(_Ty _Left,   int _Arg2) { return :: scalbn(static_cast<double>(_Left), _Arg2); }
extern "C"    double __cdecl tgamma(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double tgamma(_Ty _Left) { return :: tgamma(static_cast<double>(_Left)); }
extern "C"    double __cdecl trunc(  double); template <class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>> [[nodiscard]] inline double trunc(_Ty _Left) { return :: trunc(static_cast<double>(_Left)); }
#pragma warning(pop)
#pragma pack(pop)
#line 206 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtgmath.h"
#line 207 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtgmath.h"
#line 208 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xtgmath.h"
#line 491 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cmath"
namespace std {
using :: abs;
using :: acos;
using :: asin;
using :: atan;
using :: atan2;
using :: ceil;
using :: cos;
using :: cosh;
using :: exp;
using :: fabs;
using :: floor;
using :: fmod;
using :: frexp;
using :: ldexp;
using :: log;
using :: log10;
using :: modf;
using :: pow;
using :: sin;
using :: sinh;
using :: sqrt;
using :: tan;
using :: tanh;
using :: acosf;
using :: asinf;
using :: atanf;
using :: atan2f;
using :: ceilf;
using :: cosf;
using :: coshf;
using :: expf;
using :: fabsf;
using :: floorf;
using :: fmodf;
using :: frexpf;
using :: ldexpf;
using :: logf;
using :: log10f;
using :: modff;
using :: powf;
using :: sinf;
using :: sinhf;
using :: sqrtf;
using :: tanf;
using :: tanhf;
using :: acosl;
using :: asinl;
using :: atanl;
using :: atan2l;
using :: ceill;
using :: cosl;
using :: coshl;
using :: expl;
using :: fabsl;
using :: floorl;
using :: fmodl;
using :: frexpl;
using :: ldexpl;
using :: logl;
using :: log10l;
using :: modfl;
using :: powl;
using :: sinl;
using :: sinhl;
using :: sqrtl;
using :: tanl;
using :: tanhl;
using :: float_t;
using :: double_t;
using :: acosh;
using :: asinh;
using :: atanh;
using :: cbrt;
using :: erf;
using :: erfc;
using :: expm1;
using :: exp2;
using :: hypot;
using :: ilogb;
using :: lgamma;
using :: log1p;
using :: log2;
using :: logb;
using :: llrint;
using :: lrint;
using :: nearbyint;
using :: rint;
using :: llround;
using :: lround;
using :: fdim;
using :: fma;
using :: fmax;
using :: fmin;
using :: round;
using :: trunc;
using :: remainder;
using :: remquo;
using :: copysign;
using :: nan;
using :: nextafter;
using :: scalbn;
using :: scalbln;
using :: nexttoward;
using :: tgamma;
using :: acoshf;
using :: asinhf;
using :: atanhf;
using :: cbrtf;
using :: erff;
using :: erfcf;
using :: expm1f;
using :: exp2f;
using :: hypotf;
using :: ilogbf;
using :: lgammaf;
using :: log1pf;
using :: log2f;
using :: logbf;
using :: llrintf;
using :: lrintf;
using :: nearbyintf;
using :: rintf;
using :: llroundf;
using :: lroundf;
using :: fdimf;
using :: fmaf;
using :: fmaxf;
using :: fminf;
using :: roundf;
using :: truncf;
using :: remainderf;
using :: remquof;
using :: copysignf;
using :: nanf;
using :: nextafterf;
using :: scalbnf;
using :: scalblnf;
using :: nexttowardf;
using :: tgammaf;
using :: acoshl;
using :: asinhl;
using :: atanhl;
using :: cbrtl;
using :: erfl;
using :: erfcl;
using :: expm1l;
using :: exp2l;
using :: hypotl;
using :: ilogbl;
using :: lgammal;
using :: log1pl;
using :: log2l;
using :: logbl;
using :: llrintl;
using :: lrintl;
using :: nearbyintl;
using :: rintl;
using :: llroundl;
using :: lroundl;
using :: fdiml;
using :: fmal;
using :: fmaxl;
using :: fminl;
using :: roundl;
using :: truncl;
using :: remainderl;
using :: remquol;
using :: copysignl;
using :: nanl;
using :: nextafterl;
using :: scalbnl;
using :: scalblnl;
using :: nexttowardl;
using :: tgammal;
using :: fpclassify;
using :: signbit;
using :: isfinite;
using :: isinf;
using :: isnan;
using :: isnormal;
using :: isgreater;
using :: isgreaterequal;
using :: isless;
using :: islessequal;
using :: islessgreater;
using :: isunordered;
}
extern "C" {
 [[nodiscard]] double __stdcall __std_smf_assoc_laguerre(unsigned int, unsigned int, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_assoc_laguerref(unsigned int, unsigned int, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_assoc_legendre(unsigned int, unsigned int, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_assoc_legendref(unsigned int, unsigned int, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_beta(double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_betaf(float, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_comp_ellint_1(double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_comp_ellint_1f(float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_comp_ellint_2(double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_comp_ellint_2f(float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_comp_ellint_3(double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_comp_ellint_3f(float, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_cyl_bessel_i(double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_cyl_bessel_if(float, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_cyl_bessel_j(double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_cyl_bessel_jf(float, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_cyl_bessel_k(double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_cyl_bessel_kf(float, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_cyl_neumann(double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_cyl_neumannf(float, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_ellint_1(double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_ellint_1f(float, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_ellint_2(double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_ellint_2f(float, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_ellint_3(double, double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_ellint_3f(float, float, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_expint(double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_expintf(float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_hermite(unsigned int, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_hermitef(unsigned int, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_laguerre(unsigned int, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_laguerref(unsigned int, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_legendre(unsigned int, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_legendref(unsigned int, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_riemann_zeta(double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_riemann_zetaf(float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_sph_bessel(unsigned int, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_sph_besself(unsigned int, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_sph_legendre(unsigned int, unsigned int, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_sph_legendref(unsigned int, unsigned int, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_sph_neumann(unsigned int, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_sph_neumannf(unsigned int, float) noexcept;
 [[nodiscard]] double __stdcall __std_smf_hypot3(double, double, double) noexcept;
 [[nodiscard]] float __stdcall __std_smf_hypot3f(float, float, float) noexcept;
}
namespace std {
[[nodiscard]] inline double assoc_laguerre(const unsigned int _Degree, const unsigned int _Order, const double _Value) {
    return __std_smf_assoc_laguerre(_Degree, _Order, _Value);
}
[[nodiscard]] inline float assoc_laguerref(const unsigned int _Degree, const unsigned int _Order, const float _Value) {
    return __std_smf_assoc_laguerref(_Degree, _Order, _Value);
}
[[nodiscard]] inline long double assoc_laguerrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) {
    return __std_smf_assoc_laguerre(_Degree, _Order, static_cast<double>(_Value));
}
[[nodiscard]] inline double assoc_legendre(const unsigned int _Degree, const unsigned int _Order, const double _Value) {
    return __std_smf_assoc_legendre(_Degree, _Order, _Value);
}
[[nodiscard]] inline float assoc_legendref(const unsigned int _Degree, const unsigned int _Order, const float _Value) {
    return __std_smf_assoc_legendref(_Degree, _Order, _Value);
}
[[nodiscard]] inline long double assoc_legendrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) {
    return __std_smf_assoc_legendre(_Degree, _Order, static_cast<double>(_Value));
}
[[nodiscard]] inline double beta(const double _Arg1, const double _Arg2) {
    return __std_smf_beta(_Arg1, _Arg2);
}
[[nodiscard]] inline float betaf(const float _Arg1, const float _Arg2) {
    return __std_smf_betaf(_Arg1, _Arg2);
}
[[nodiscard]] inline long double betal(const long double _Arg1, const long double _Arg2) {
    return __std_smf_beta(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}
[[nodiscard]] inline double comp_ellint_1(const double _Arg) {
    return __std_smf_comp_ellint_1(_Arg);
}
[[nodiscard]] inline float comp_ellint_1f(const float _Arg) {
    return __std_smf_comp_ellint_1f(_Arg);
}
[[nodiscard]] inline long double comp_ellint_1l(const long double _Arg) {
    return __std_smf_comp_ellint_1(static_cast<double>(_Arg));
}
[[nodiscard]] inline double comp_ellint_2(const double _Arg) {
    return __std_smf_comp_ellint_2(_Arg);
}
[[nodiscard]] inline float comp_ellint_2f(const float _Arg) {
    return __std_smf_comp_ellint_2f(_Arg);
}
[[nodiscard]] inline long double comp_ellint_2l(const long double _Arg) {
    return __std_smf_comp_ellint_2(static_cast<double>(_Arg));
}
[[nodiscard]] inline double comp_ellint_3(const double _Arg1, const double _Arg2) {
    return __std_smf_comp_ellint_3(_Arg1, _Arg2);
}
[[nodiscard]] inline float comp_ellint_3f(const float _Arg1, const float _Arg2) {
    return __std_smf_comp_ellint_3f(_Arg1, _Arg2);
}
[[nodiscard]] inline long double comp_ellint_3l(const long double _Arg1, const long double _Arg2) {
    return __std_smf_comp_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}
[[nodiscard]] inline double cyl_bessel_i(const double _Arg1, const double _Arg2) {
    return __std_smf_cyl_bessel_i(_Arg1, _Arg2);
}
[[nodiscard]] inline float cyl_bessel_if(const float _Arg1, const float _Arg2) {
    return __std_smf_cyl_bessel_if(_Arg1, _Arg2);
}
[[nodiscard]] inline long double cyl_bessel_il(const long double _Arg1, const long double _Arg2) {
    return __std_smf_cyl_bessel_i(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}
[[nodiscard]] inline double cyl_bessel_j(const double _Arg1, const double _Arg2) {
    return __std_smf_cyl_bessel_j(_Arg1, _Arg2);
}
[[nodiscard]] inline float cyl_bessel_jf(const float _Arg1, const float _Arg2) {
    return __std_smf_cyl_bessel_jf(_Arg1, _Arg2);
}
[[nodiscard]] inline long double cyl_bessel_jl(const long double _Arg1, const long double _Arg2) {
    return __std_smf_cyl_bessel_j(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}
[[nodiscard]] inline double cyl_bessel_k(const double _Arg1, const double _Arg2) {
    return __std_smf_cyl_bessel_k(_Arg1, _Arg2);
}
[[nodiscard]] inline float cyl_bessel_kf(const float _Arg1, const float _Arg2) {
    return __std_smf_cyl_bessel_kf(_Arg1, _Arg2);
}
[[nodiscard]] inline long double cyl_bessel_kl(const long double _Arg1, const long double _Arg2) {
    return __std_smf_cyl_bessel_k(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}
[[nodiscard]] inline double cyl_neumann(const double _Arg1, const double _Arg2) {
    return __std_smf_cyl_neumann(_Arg1, _Arg2);
}
[[nodiscard]] inline float cyl_neumannf(const float _Arg1, const float _Arg2) {
    return __std_smf_cyl_neumannf(_Arg1, _Arg2);
}
[[nodiscard]] inline long double cyl_neumannl(const long double _Arg1, const long double _Arg2) {
    return __std_smf_cyl_neumann(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}
[[nodiscard]] inline double ellint_1(const double _Arg1, const double _Arg2) {
    return __std_smf_ellint_1(_Arg1, _Arg2);
}
[[nodiscard]] inline float ellint_1f(const float _Arg1, const float _Arg2) {
    return __std_smf_ellint_1f(_Arg1, _Arg2);
}
[[nodiscard]] inline long double ellint_1l(const long double _Arg1, const long double _Arg2) {
    return __std_smf_ellint_1(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}
[[nodiscard]] inline double ellint_2(const double _Arg1, const double _Arg2) {
    return __std_smf_ellint_2(_Arg1, _Arg2);
}
[[nodiscard]] inline float ellint_2f(const float _Arg1, const float _Arg2) {
    return __std_smf_ellint_2f(_Arg1, _Arg2);
}
[[nodiscard]] inline long double ellint_2l(const long double _Arg1, const long double _Arg2) {
    return __std_smf_ellint_2(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}
[[nodiscard]] inline double ellint_3(const double _Arg1, const double _Arg2, const double _Arg3) {
    return __std_smf_ellint_3(_Arg1, _Arg2, _Arg3);
}
[[nodiscard]] inline float ellint_3f(const float _Arg1, const float _Arg2, const float _Arg3) {
    return __std_smf_ellint_3f(_Arg1, _Arg2, _Arg3);
}
[[nodiscard]] inline long double ellint_3l(const long double _Arg1, const long double _Arg2, const long double _Arg3) {
    return __std_smf_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3));
}
[[nodiscard]] inline double expint(const double _Arg) {
    return __std_smf_expint(_Arg);
}
[[nodiscard]] inline float expintf(const float _Arg) {
    return __std_smf_expintf(_Arg);
}
[[nodiscard]] inline long double expintl(const long double _Arg) {
    return __std_smf_expint(static_cast<double>(_Arg));
}
[[nodiscard]] inline double hermite(const unsigned int _Arg1, const double _Arg2) {
    return __std_smf_hermite(_Arg1, _Arg2);
}
[[nodiscard]] inline float hermitef(const unsigned int _Arg1, const float _Arg2) {
    return __std_smf_hermitef(_Arg1, _Arg2);
}
[[nodiscard]] inline long double hermitel(const unsigned int _Arg1, const long double _Arg2) {
    return __std_smf_hermite(_Arg1, static_cast<double>(_Arg2));
}
[[nodiscard]] inline double laguerre(const unsigned int _Arg1, const double _Arg2) {
    return __std_smf_laguerre(_Arg1, _Arg2);
}
[[nodiscard]] inline float laguerref(const unsigned int _Arg1, const float _Arg2) {
    return __std_smf_laguerref(_Arg1, _Arg2);
}
[[nodiscard]] inline long double laguerrel(const unsigned int _Arg1, const long double _Arg2) {
    return __std_smf_laguerre(_Arg1, static_cast<double>(_Arg2));
}
[[nodiscard]] inline double legendre(const unsigned int _Degree, const double _Value) {
    return __std_smf_legendre(_Degree, _Value);
}
[[nodiscard]] inline float legendref(const unsigned int _Degree, const float _Value) {
    return __std_smf_legendref(_Degree, _Value);
}
[[nodiscard]] inline long double legendrel(const unsigned int _Degree, const long double _Value) {
    return __std_smf_legendre(_Degree, static_cast<double>(_Value));
}
[[nodiscard]] inline double riemann_zeta(const double _Arg) {
    return __std_smf_riemann_zeta(_Arg);
}
[[nodiscard]] inline float riemann_zetaf(const float _Arg) {
    return __std_smf_riemann_zetaf(_Arg);
}
[[nodiscard]] inline long double riemann_zetal(const long double _Arg) {
    return __std_smf_riemann_zeta(static_cast<double>(_Arg));
}
[[nodiscard]] inline double sph_bessel(const unsigned int _Arg1, const double _Arg2) {
    return __std_smf_sph_bessel(_Arg1, _Arg2);
}
[[nodiscard]] inline float sph_besself(const unsigned int _Arg1, const float _Arg2) {
    return __std_smf_sph_besself(_Arg1, _Arg2);
}
[[nodiscard]] inline long double sph_bessell(const unsigned int _Arg1, const long double _Arg2) {
    return __std_smf_sph_bessel(_Arg1, static_cast<double>(_Arg2));
}
[[nodiscard]] inline double sph_legendre(const unsigned int _Arg1, const unsigned int _Arg2, const double _Theta) {
    return __std_smf_sph_legendre(_Arg1, _Arg2, _Theta);
}
[[nodiscard]] inline float sph_legendref(const unsigned int _Arg1, const unsigned int _Arg2, const float _Theta) {
    return __std_smf_sph_legendref(_Arg1, _Arg2, _Theta);
}
[[nodiscard]] inline long double sph_legendrel(
    const unsigned int _Arg1, const unsigned int _Arg2, const long double _Theta) {
    return __std_smf_sph_legendre(_Arg1, _Arg2, static_cast<double>(_Theta));
}
[[nodiscard]] inline double sph_neumann(const unsigned int _Arg1, const double _Arg2) {
    return __std_smf_sph_neumann(_Arg1, _Arg2);
}
[[nodiscard]] inline float sph_neumannf(const unsigned int _Arg1, const float _Arg2) {
    return __std_smf_sph_neumannf(_Arg1, _Arg2);
}
[[nodiscard]] inline long double sph_neumannl(const unsigned int _Arg1, const long double _Arg2) {
    return __std_smf_sph_neumann(_Arg1, static_cast<double>(_Arg2));
}
#line 1056 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cmath"
[[nodiscard]] inline double hypot(const double _Dx, const double _Dy, const double _Dz) {
    return __std_smf_hypot3(_Dx, _Dy, _Dz);
}
[[nodiscard]] inline float hypot(const float _Dx, const float _Dy, const float _Dz) {
    return __std_smf_hypot3f(_Dx, _Dy, _Dz);
}
[[nodiscard]] inline long double hypot(const long double _Dx, const long double _Dy, const long double _Dz) {
    return __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
}
template <class _Ty1, class _Ty2, class _Ty3,
    enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] inline auto hypot(const _Ty1 _Dx, const _Ty2 _Dy,
    const _Ty3 _Dz) { 
    using _Common      = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>; 
    const auto _Result = __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
    return static_cast<_Common>(_Result);
}
}
#line 1082 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cmath"
#pragma warning(pop)
#pragma pack(pop)
#line 1089 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cmath"
#line 1090 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cmath"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\share.h"
#pragma once
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\share.h"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\system_error"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cerrno"
#pragma once
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cerrno"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cerrno"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\system_error"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <bool _Same, class _Dest,
    class... _Srcs>
struct _Tuple_implicit_val0 : false_type { 
};
template <class... _Dests, class... _Srcs>
struct _Tuple_implicit_val0<true, tuple<_Dests...>, _Srcs...>
    : bool_constant<conjunction_v<is_constructible<_Dests, _Srcs>...,
          is_convertible<_Srcs, _Dests>...>> { 
};
template <class _Dest, class... _Srcs>
struct _Tuple_implicit_val : _Tuple_implicit_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest,
                                 _Srcs...>::type { 
};
template <bool _Same, class _Dest,
    class... _Srcs>
struct _Tuple_explicit_val0 : false_type { 
};
template <class... _Dests, class... _Srcs>
struct _Tuple_explicit_val0<true, tuple<_Dests...>, _Srcs...>
    : bool_constant<conjunction_v<is_constructible<_Dests, _Srcs>...,
          negation<conjunction<is_convertible<_Srcs, _Dests>...>>>> { 
};
template <class _Dest, class... _Srcs>
struct _Tuple_explicit_val : _Tuple_explicit_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest,
                                 _Srcs...>::type { 
};
template <bool _Same, class _Dest, class... _Srcs>
struct _Tuple_constructible_val0 : false_type {};
template <class... _Dests, class... _Srcs>
struct _Tuple_constructible_val0<true, tuple<_Dests...>, _Srcs...>
    : bool_constant<conjunction_v<is_constructible<_Dests, _Srcs>...>> {};
template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_constructible_v =
    _Tuple_constructible_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::value;
template <bool _Same, class _Dest, class... _Srcs>
struct _Tuple_nothrow_constructible_val0 : false_type {};
template <class... _Dests, class... _Srcs>
struct _Tuple_nothrow_constructible_val0<true, tuple<_Dests...>, _Srcs...>
    : bool_constant<conjunction_v<is_nothrow_constructible<_Dests, _Srcs>...>> {};
template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_constructible_v =
    _Tuple_nothrow_constructible_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::value;
template <bool _Same, class _Dest, class... _Srcs>
struct _Tuple_assignable_val0 : false_type {};
template <class... _Dests, class... _Srcs>
struct _Tuple_assignable_val0<true, tuple<_Dests...>, _Srcs...>
    : bool_constant<conjunction_v<is_assignable<_Dests&, _Srcs>...>> 
{};
template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_assignable_v =
    _Tuple_assignable_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::value;
template <class _Dest, class... _Srcs>
struct _Tuple_assignable_val : bool_constant<_Tuple_assignable_v<_Dest, _Srcs...>> {};
template <bool _Same, class _Dest, class... _Srcs>
struct _Tuple_nothrow_assignable_val0 : false_type {};
template <class... _Dests, class... _Srcs>
struct _Tuple_nothrow_assignable_val0<true, tuple<_Dests...>, _Srcs...>
    : bool_constant<conjunction_v<is_nothrow_assignable<_Dests&, _Srcs>...>> 
{};
template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_assignable_v =
    _Tuple_nothrow_assignable_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::value;
template <class _Myself,
    class... _Other>
struct _Tuple_convert_copy_val : true_type { 
};
template <class _This, class _Uty>
struct _Tuple_convert_copy_val<tuple<_This>, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, const tuple<_Uty>&>,
          is_convertible<const tuple<_Uty>&, _This>>> { 
};
template <class _Myself,
    class... _Other>
struct _Tuple_convert_move_val : true_type { 
};
template <class _This, class _Uty>
struct _Tuple_convert_move_val<tuple<_This>, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, tuple<_Uty>>,
          is_convertible<tuple<_Uty>, _This>>> { 
};
template <class _Myself, class _This2,
    class... _Rest2>
struct _Tuple_perfect_val : true_type { 
};
template <class _Myself, class _This2>
struct _Tuple_perfect_val<_Myself, _This2>
    : bool_constant<!is_same_v<_Myself, remove_const_t<remove_reference_t<_This2>>>> { 
};
struct _Ignore { 
    template <class _Ty>
    constexpr const _Ignore& operator=(const _Ty&) const noexcept { 
        return *this;
    }
};
inline constexpr _Ignore ignore{};
template <class _Ty>
struct _Tuple_val { 
    constexpr _Tuple_val() : _Val() { 
    }
    template <class _Other>
    constexpr _Tuple_val(_Other&& _Arg) : _Val(::std:: forward<_Other>(_Arg)) { 
    }
    template <class _Alloc, class... _Other, enable_if_t<!uses_allocator_v<_Ty, _Alloc>, int> = 0>
    _Tuple_val(const _Alloc&, allocator_arg_t, _Other&&... _Arg)
        : _Val(::std:: forward<_Other>(_Arg)...) { 
    }
    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<uses_allocator<_Ty, _Alloc>,
                        is_constructible<_Ty, allocator_arg_t, const _Alloc&, _Other...>>,
            int> = 0>
    _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(allocator_arg, _Al,
              ::std:: forward<_Other>(_Arg)...) { 
    }
    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<uses_allocator<_Ty, _Alloc>,
                        negation<is_constructible<_Ty, allocator_arg_t, const _Alloc&, _Other...>>>,
            int> = 0>
    _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(::std:: forward<_Other>(_Arg)..., _Al) { 
    }
    _Ty _Val;
};
struct _Exact_args_t { 
};
struct _Unpack_tuple_t { 
};
struct _Alloc_exact_args_t { 
};
struct _Alloc_unpack_tuple_t { 
};
template <class... _Types>
class tuple;
template <>
class tuple<> { 
public:
    constexpr tuple() noexcept { 
    }
    constexpr tuple(const tuple&) noexcept { 
    }
    template <class _Alloc>
    tuple(allocator_arg_t, const _Alloc&) noexcept { 
    }
    template <class _Alloc>
    tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { 
    }
    template <class _Tag, enable_if_t<is_same_v<_Tag, _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag) noexcept { 
    }
    template <class _Tag, class _Alloc, enable_if_t<is_same_v<_Tag, _Alloc_exact_args_t>, int> = 0>
    tuple(_Tag, const _Alloc&) noexcept { 
    }
    void swap(tuple&) noexcept { 
    }
    constexpr bool _Equals(const tuple&) const noexcept { 
        return true;
    }
    constexpr bool _Less(const tuple&) const noexcept { 
        return false;
    }
};
template <class _This, class... _Rest>
class tuple<_This, _Rest...> : private tuple<_Rest...> { 
public:
    using _This_type = _This;
    using _Mybase    = tuple<_Rest...>;
    template <class _Tag, class _This2, class... _Rest2, enable_if_t<is_same_v<_Tag, _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...),
          _Myfirst(::std:: forward<_This2>(_This_arg)) { 
    }
    template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);
    template <class _Tag, class _Tpl, enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right)
        : tuple(_Unpack_tuple_t{}, ::std:: forward<_Tpl>(_Right),
              make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) { 
    }
    template <class _Tag, class _Alloc, class _This2, class... _Rest2,
        enable_if_t<is_same_v<_Tag, _Alloc_exact_args_t>, int> = 0>
    tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Alloc_exact_args_t{}, _Al, ::std:: forward<_Rest2>(_Rest_arg)...),
          _Myfirst(_Al, allocator_arg,
              ::std:: forward<_This2>(_This_arg)) { 
    }
    template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
        enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int> = 0>
    inline tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);
    template <class _Tag, class _Alloc, class _Tpl, enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int> = 0>
    tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Tpl>(_Right),
              make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) { 
    }
    template <class _This2 = _This,
        enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...,
                        _Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>,
            int>           = 0>
    constexpr tuple() noexcept(conjunction_v<is_nothrow_default_constructible<_This2>, is_nothrow_default_constructible<_Rest>...>) 
#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
        : _Mybase(), _Myfirst() {}
    template <class _This2 = _This,
        enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...,
                        negation<conjunction<_Is_implicitly_default_constructible<_This2>,
                            _Is_implicitly_default_constructible<_Rest>...>>>,
            int>           = 0>
    constexpr explicit tuple() noexcept(conjunction_v<is_nothrow_default_constructible<_This2>, is_nothrow_default_constructible<_Rest>...>) 
#line 297 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
        : _Mybase(), _Myfirst() {}
    template <class _This2                                                                  = _This,
        enable_if_t<_Tuple_implicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
    constexpr tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
        noexcept(conjunction_v<is_nothrow_copy_constructible<_This2>, is_nothrow_copy_constructible<_Rest>...>) 
#line 304 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
        : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}
    template <class _This2                                                                  = _This,
        enable_if_t<_Tuple_explicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
    constexpr explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
        noexcept(conjunction_v<is_nothrow_copy_constructible<_This2>, is_nothrow_copy_constructible<_Rest>...>) 
#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
        : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}
    template <class _This2, class... _Rest2,
        enable_if_t<
            conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_implicit_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    constexpr tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
        noexcept(_Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>) 
        : tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}
    template <class _This2, class... _Rest2,
        enable_if_t<
            conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_explicit_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
        noexcept(_Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>) 
        : tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}
    tuple(const tuple&) = default;
    tuple(tuple&&)      = default;
    template <class... _Other, enable_if_t<conjunction_v<_Tuple_implicit_val<tuple, const _Other&...>,
                                               _Tuple_convert_copy_val<tuple, _Other...>>,
                                   int> = 0>
    constexpr tuple(const tuple<_Other...>& _Right)
        noexcept(_Tuple_nothrow_constructible_v<tuple, const _Other&...>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}
    template <class... _Other, enable_if_t<conjunction_v<_Tuple_explicit_val<tuple, const _Other&...>,
                                               _Tuple_convert_copy_val<tuple, _Other...>>,
                                   int> = 0>
    constexpr explicit tuple(const tuple<_Other...>& _Right)
        noexcept(_Tuple_nothrow_constructible_v<tuple, const _Other&...>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}
    template <class... _Other,
        enable_if_t<conjunction_v<_Tuple_implicit_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>,
            int> = 0>
    constexpr tuple(tuple<_Other...>&& _Right)
        noexcept(_Tuple_nothrow_constructible_v<tuple, _Other...>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}
    template <class... _Other,
        enable_if_t<conjunction_v<_Tuple_explicit_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>,
            int> = 0>
    constexpr explicit tuple(tuple<_Other...>&& _Right)
        noexcept(_Tuple_nothrow_constructible_v<tuple, _Other...>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}
    template <class _First, class _Second,
        enable_if_t<_Tuple_implicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
    constexpr tuple(const pair<_First, _Second>& _Right)
        noexcept(_Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}
    template <class _First, class _Second,
        enable_if_t<_Tuple_explicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
    constexpr explicit tuple(const pair<_First, _Second>& _Right)
        noexcept(_Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}
    template <class _First, class _Second, enable_if_t<_Tuple_implicit_val<tuple, _First, _Second>::value, int> = 0>
    constexpr tuple(pair<_First, _Second>&& _Right)
        noexcept(_Tuple_nothrow_constructible_v<tuple, _First, _Second>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}
    template <class _First, class _Second, enable_if_t<_Tuple_explicit_val<tuple, _First, _Second>::value, int> = 0>
    constexpr explicit tuple(pair<_First, _Second>&& _Right)
        noexcept(_Tuple_nothrow_constructible_v<tuple, _First, _Second>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}
    template <class _Alloc, class _This2 = _This,
        enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...>, int> = 0>
    tuple(allocator_arg_t, const _Alloc& _Al) : _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg) {}
    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_implicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
    tuple(allocator_arg_t, const _Alloc& _Al, const _This& _This_arg, const _Rest&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...) {}
    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_explicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
    explicit tuple(allocator_arg_t, const _Alloc& _Al, const _This& _This_arg, const _Rest&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...) {}
    template <class _Alloc, class _This2, class... _Rest2,
        enable_if_t<
            conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_implicit_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    tuple(allocator_arg_t, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}
    template <class _Alloc, class _This2, class... _Rest2,
        enable_if_t<
            conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_explicit_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    explicit tuple(allocator_arg_t, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}
    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    tuple(allocator_arg_t, const _Alloc& _Al, const tuple& _Right) : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
    template <class _Alloc, class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, _This2, _Rest...>, int> = 0>
    tuple(allocator_arg_t, const _Alloc& _Al, tuple&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}
    template <class _Alloc, class... _Other,
        enable_if_t<
            conjunction_v<_Tuple_implicit_val<tuple, const _Other&...>, _Tuple_convert_copy_val<tuple, _Other...>>,
            int> = 0>
    tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
    template <class _Alloc, class... _Other,
        enable_if_t<
            conjunction_v<_Tuple_explicit_val<tuple, const _Other&...>, _Tuple_convert_copy_val<tuple, _Other...>>,
            int> = 0>
    explicit tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_Tuple_implicit_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>,
            int> = 0>
    tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}
    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_Tuple_explicit_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>,
            int> = 0>
    explicit tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}
    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_implicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
    tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_explicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
    explicit tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_implicit_val<tuple, _First, _Second>::value, int> = 0>
    tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}
    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_explicit_val<tuple, _First, _Second>::value, int> = 0>
    explicit tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}
    tuple& operator=(const volatile tuple&) = delete;
    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<_This2>,
                        _Is_copy_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    tuple& operator=(_Identity_t<const _Myself&> _Right)
        noexcept(conjunction_v<is_nothrow_copy_assignable<_This2>, is_nothrow_copy_assignable<_Rest>...>) { 
#line 473 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }
    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<_This2>,
                        _Is_move_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    tuple& operator=(_Identity_t<_Myself&&> _Right)
        noexcept(conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {
        _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<_Mybase>(_Right._Get_rest());
        return *this;
    }
    template <class... _Other, enable_if_t<conjunction_v<negation<is_same<tuple, tuple<_Other...>>>,
                                               _Tuple_assignable_val<tuple, const _Other&...>>,
                                   int> = 0>
    tuple& operator=(const tuple<_Other...>& _Right)
        noexcept(_Tuple_nothrow_assignable_v<tuple, const _Other&...>) { 
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }
    template <class... _Other,
        enable_if_t<conjunction_v<negation<is_same<tuple, tuple<_Other...>>>, _Tuple_assignable_val<tuple, _Other...>>,
            int> = 0>
    tuple& operator=(tuple<_Other...>&& _Right)
        noexcept(_Tuple_nothrow_assignable_v<tuple, _Other...>) { 
        _Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
        return *this;
    }
    template <class _First, class _Second,
        enable_if_t<_Tuple_assignable_v<tuple, const _First&, const _Second&>, int> = 0>
    tuple& operator=(const pair<_First, _Second>& _Right)
        noexcept(_Tuple_nothrow_assignable_v<tuple, const _First&, const _Second&>) { 
        _Myfirst._Val             = _Right.first;
        _Get_rest()._Myfirst._Val = _Right.second;
        return *this;
    }
    template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<tuple, _First, _Second>, int> = 0>
    tuple& operator=(pair<_First, _Second>&& _Right)
        noexcept(_Tuple_nothrow_assignable_v<tuple, _First, _Second>) { 
        _Myfirst._Val             = ::std:: forward<_First>(_Right.first);
        _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
        return *this;
    }
    void swap(tuple& _Right)
        noexcept(conjunction_v<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>) {
        _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
        _Mybase::swap(_Right._Get_rest());
    }
    _Mybase& _Get_rest() noexcept { 
        return *this;
    }
    constexpr const _Mybase& _Get_rest() const noexcept { 
        return *this;
    }
    template <class... _Other>
    constexpr bool _Equals(const tuple<_Other...>& _Right) const { 
        return _Myfirst._Val == _Right._Myfirst._Val && _Mybase::_Equals(_Right._Get_rest());
    }
    template <class... _Other>
    constexpr bool _Less(const tuple<_Other...>& _Right) const { 
        return _Myfirst._Val < _Right._Myfirst._Val
               || (!(_Right._Myfirst._Val < _Myfirst._Val) && _Mybase::_Less(_Right._Get_rest()));
    }
    _Tuple_val<_This> _Myfirst; 
};
template <class... _Types>
tuple(_Types...)->tuple<_Types...>;
template <class _Ty1, class _Ty2>
tuple(pair<_Ty1, _Ty2>)->tuple<_Ty1, _Ty2>;
template <class _Alloc, class... _Types>
tuple(allocator_arg_t, _Alloc, _Types...)->tuple<_Types...>;
template <class _Alloc, class _Ty1, class _Ty2>
tuple(allocator_arg_t, _Alloc, pair<_Ty1, _Ty2>)->tuple<_Ty1, _Ty2>;
template <class _Alloc, class... _Types>
tuple(allocator_arg_t, _Alloc, tuple<_Types...>)->tuple<_Types...>;
#line 570 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator==(
    const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) { 
    static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
    return _Left._Equals(_Right);
}
template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator!=(
    const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) { 
    return !(_Left == _Right);
}
template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator<(
    const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) { 
    static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
    return _Left._Less(_Right);
}
template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator>=(
    const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) { 
    return !(_Left < _Right);
}
template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator>(
    const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) { 
    return _Right < _Left;
}
template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator<=(
    const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) { 
    return !(_Right < _Left);
}
template <class... _Types, enable_if_t<conjunction_v<_Is_swappable<_Types>...>, int> = 0>
inline void swap(tuple<_Types...>& _Left, tuple<_Types...>& _Right)
    noexcept(noexcept(_Left.swap(_Right))) { 
    return _Left.swap(_Right);
}
template <class _Ty, class _Tuple>
struct _Tuple_element;
template <class _This, class... _Rest>
struct _Tuple_element<_This, tuple<_This, _Rest...>> { 
    using _Check_type = int;
    static_assert(
        is_void_v<typename _Tuple_element<_This, tuple<_Rest...>>::_Check_type>, "duplicate type T in get<T>(tuple)");
    using type   = _This;
    using _Ttype = tuple<_This, _Rest...>;
};
template <class _Ty, class _This, class... _Rest>
struct _Tuple_element<_Ty, tuple<_This, _Rest...>>
    : _Tuple_element<_Ty, tuple<_Rest...>> { 
};
template <class _Ty>
struct _Tuple_element<_Ty, tuple<>> { 
    using _Check_type = void; 
};
template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(
    tuple<_Types...>& _Tuple) noexcept { 
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return ((_Ttype&) _Tuple)._Myfirst._Val;
}
template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(
    const tuple<_Types...>& _Tuple) noexcept { 
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return ((_Ttype&) _Tuple)._Myfirst._Val;
}
template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(
    tuple<_Types...>&& _Tuple) noexcept { 
    using _Ttype  = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    using _RRtype = tuple_element_t<_Index, tuple<_Types...>>&&;
    return ::std:: forward<_RRtype>(((_Ttype&) _Tuple)._Myfirst._Val);
}
template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(
    const tuple<_Types...>&& _Tuple) noexcept { 
    using _Ttype  = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    using _RRtype = const tuple_element_t<_Index, tuple<_Types...>>&&;
    return ::std:: forward<_RRtype>(((_Ttype&) _Tuple)._Myfirst._Val);
}
template <class _Ty,
    class... _Types>
[[nodiscard]] constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept { 
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return ((_Ttype&) _Tuple)._Myfirst._Val;
}
template <class _Ty,
    class... _Types>
[[nodiscard]] constexpr const _Ty& get(
    const tuple<_Types...>& _Tuple) noexcept { 
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return ((_Ttype&) _Tuple)._Myfirst._Val;
}
template <class _Ty,
    class... _Types>
[[nodiscard]] constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept { 
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return ::std:: forward<_Ty&&>(((_Ttype&) _Tuple)._Myfirst._Val);
}
template <class _Ty,
    class... _Types>
[[nodiscard]] constexpr const _Ty&& get(
    const tuple<_Types...>&& _Tuple) noexcept { 
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return ::std:: forward<const _Ty&&>(((_Ttype&) _Tuple)._Myfirst._Val);
}
template <class _This, class... _Rest>
template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int>>
constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Exact_args_t{},
          ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...) { 
}
template <class _This, class... _Rest>
template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
    enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int>>
inline tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Alloc_exact_args_t{}, _Al,
          ::std:: get<_Indices>(::std:: forward<_Tpl>(
              _Right))...) { 
}
template <class... _Types>
[[nodiscard]] constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { 
    using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
    return _Ttype(::std:: forward<_Types>(_Args)...);
}
template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&...> tie(_Types&... _Args) noexcept { 
    using _Ttype = tuple<_Types&...>;
    return _Ttype(_Args...);
}
template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { 
    return tuple<_Types&&...>(::std:: forward<_Types>(_Args)...);
}
template <class _Seq_type1, class _Seq_type2>
struct _Cat_sequences;
template <size_t... _Indexes1, size_t... _Indexes2>
struct _Cat_sequences<index_sequence<_Indexes1...>,
    index_sequence<_Indexes2...>> { 
    using type = index_sequence<_Indexes1..., _Indexes2...>;
};
template <class _Ty, size_t _Size>
class array;
template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;
template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;
template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;
template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;
template <class _Ty,
    class... _For_array>
struct _View_as_tuple { 
    static_assert(_Always_false<_Ty>, "Unsupported tuple_cat arguments.");
};
template <class... _Types>
struct _View_as_tuple<tuple<_Types...>> { 
    using type = tuple<_Types...>;
};
template <class _Ty1, class _Ty2>
struct _View_as_tuple<pair<_Ty1, _Ty2>> { 
    using type = tuple<_Ty1, _Ty2>;
};
template <class _Ty, class... _Types>
struct _View_as_tuple<array<_Ty, 0>, _Types...> { 
    using type = tuple<_Types...>;
};
template <class _Ty, size_t _Size, class... _Types>
struct _View_as_tuple<array<_Ty, _Size>, _Types...>
    : _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...> { 
};
template <size_t _Nx, class _Ty>
struct _Repeat_for : integral_constant<size_t, _Nx> { 
};
template <class _Ret, class _Kx_arg, class _Ix_arg, size_t _Ix_next,
    class... _Tuples>
struct _Tuple_cat2 { 
    static_assert(sizeof...(_Tuples) == 0, "Unsupported tuple_cat arguments.");
    using type        = _Ret;
    using _Kx_arg_seq = _Kx_arg;
    using _Ix_arg_seq = _Ix_arg;
};
template <class... _Types1, class _Kx_arg, size_t... _Ix, size_t _Ix_next, class... _Types2, class... _Rest>
struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, index_sequence<_Ix...>, _Ix_next, tuple<_Types2...>, _Rest...>
    : _Tuple_cat2<tuple<_Types1..., _Types2...>, typename _Cat_sequences<_Kx_arg, index_sequence_for<_Types2...>>::type,
          index_sequence<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>, _Ix_next + 1,
          _Rest...> { 
};
template <class... _Tuples>
struct _Tuple_cat1 : _Tuple_cat2<tuple<>, index_sequence<>, index_sequence<>, 0,
                         typename _View_as_tuple<decay_t<_Tuples>>::type...> { 
};
#pragma warning(push)
#pragma warning(disable : 4100) 
template <class _Ret, size_t... _Kx, size_t... _Ix, class _Ty>
constexpr _Ret _Tuple_cat(index_sequence<_Kx...>, index_sequence<_Ix...>, _Ty&& _Arg) { 
    return _Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...);
}
#pragma warning(pop)
template <class... _Tuples>
[[nodiscard]] constexpr typename _Tuple_cat1<_Tuples...>::type tuple_cat(_Tuples&&... _Tpls) { 
    using _Cat1 = _Tuple_cat1<_Tuples...>;
    return _Tuple_cat<typename _Cat1::type>(typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
        ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...));
}
#pragma warning(push)
#pragma warning(disable : 4100) 
template <class _Callable, class _Tuple, size_t... _Indices>
constexpr decltype(auto) _Apply_impl(
    _Callable&& _Obj, _Tuple&& _Tpl, index_sequence<_Indices...>) { 
    return _C_invoke(::std:: forward<_Callable>(_Obj), ::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...);
}
#pragma warning(pop)
template <class _Callable, class _Tuple>
constexpr decltype(auto) apply(_Callable&& _Obj, _Tuple&& _Tpl) { 
    return _Apply_impl(::std:: forward<_Callable>(_Obj), ::std:: forward<_Tuple>(_Tpl),
        make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
}
#pragma warning(push)
#pragma warning(disable : 4100) 
template <class _Ty, class _Tuple, size_t... _Indices>
constexpr _Ty _Make_from_tuple_impl(
    _Tuple&& _Tpl, index_sequence<_Indices...>) { 
    return _Ty(::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...);
}
#pragma warning(pop)
template <class _Ty,
    class _Tuple>
[[nodiscard]] constexpr _Ty make_from_tuple(_Tuple&& _Tpl) { 
    return _Make_from_tuple_impl<_Ty>(
        ::std:: forward<_Tuple>(_Tpl), make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
}
#line 870 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
template <class _Tpl, class _Fx, size_t... _Indices>
inline void _For_each_tuple_element_impl(
    _Tpl&& _Tuple, _Fx _Func, index_sequence<_Indices...>) { 
    int _Ignored[] = {(static_cast<void>(_Func(::std:: get<_Indices>(::std:: forward<_Tpl>(_Tuple)))), 0)...};
    (void) _Ignored;
}
template <class _Tpl, class _Fx>
inline void _For_each_tuple_element(_Tpl&& _Tuple, _Fx _Func) { 
    _For_each_tuple_element_impl(
        ::std:: forward<_Tpl>(_Tuple), _Func, make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>());
}
#pragma warning(push)
#pragma warning(disable : 4100) 
template <class _Ty1, class _Ty2>
template <class _Tuple1, class _Tuple2, size_t... _Indexes1, size_t... _Indexes2>
inline pair<_Ty1, _Ty2>::pair(
    _Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>)
    : first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
      second(::std:: get<_Indexes2>(::std:: move(_Val2))...) { 
}
#pragma warning(pop)
template <class _Ty1, class _Ty2>
template <class... _Types1, class... _Types2>
inline pair<_Ty1, _Ty2>::pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
    : pair(_Val1, _Val2, index_sequence_for<_Types1...>(),
          index_sequence_for<_Types2...>()) { 
}
template <class... _Types, class _Alloc>
struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { 
};
#line 921 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
}
#pragma warning(pop)
#pragma pack(pop)
#line 929 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
#line 930 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tuple"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Ty, class _Outer_alloc, class _Inner_alloc, class... _Types>
inline void _Uses_allocator_construct2(true_type, _Ty* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    _Types&&... _Args) { 
    allocator_traits<_Outer_alloc>::construct(_Outer, _Ptr, allocator_arg, _Inner, ::std:: forward<_Types>(_Args)...);
}
template <class _Ty, class _Outer_alloc, class _Inner_alloc, class... _Types>
inline void _Uses_allocator_construct2(false_type, _Ty* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    _Types&&... _Args) { 
    static_assert(is_constructible_v<_Ty, _Types..., _Inner_alloc&>,
        "N4700 23.10.7.2 [allocator.uses.construction]/1 requires "
        "is_constructible_v<T, Args..., Alloc&> when uses_allocator_v<T, Alloc> is true and "
        "is_constructible_v<T, allocator_arg_t, Alloc&, Args...> is false");
    allocator_traits<_Outer_alloc>::construct(_Outer, _Ptr, ::std:: forward<_Types>(_Args)..., _Inner);
}
template <class _Ty, class _Outer_alloc, class _Inner_alloc, class... _Types>
inline void _Uses_allocator_construct1(true_type, _Ty* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    _Types&&... _Args) { 
    using _IsConstructible = typename is_constructible<_Ty, allocator_arg_t, _Inner_alloc&, _Types...>::type;
    _Uses_allocator_construct2(_IsConstructible{}, _Ptr, _Outer, _Inner, ::std:: forward<_Types>(_Args)...);
}
template <class _Ty, class _Outer_alloc, class _Inner_alloc, class... _Types>
inline void _Uses_allocator_construct1(false_type, _Ty* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc&,
    _Types&&... _Args) { 
    static_assert(is_constructible_v<_Ty, _Types...>,
        "N4700 23.10.7.2 [allocator.uses.construction]/1 requires "
        "is_constructible_v<T, Args...> when uses_allocator_v<T, Alloc> is false");
    allocator_traits<_Outer_alloc>::construct(_Outer, _Ptr, ::std:: forward<_Types>(_Args)...);
}
template <class _Ty, class _Outer_alloc, class _Inner_alloc, class... _Types,
    enable_if_t<!_Is_specialization_v<_Ty, pair>, int> = 0>
inline void _Uses_allocator_construct(_Ty* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    _Types&&... _Args) { 
    _Uses_allocator_construct1(uses_allocator<_Ty, _Inner_alloc>(), _Ptr, _Outer, _Inner,
        ::std:: forward<_Types>(_Args)...); 
}
template <class _Alloc, class... _Types>
inline auto _Uses_allocator_piecewise2(true_type, _Alloc& _Al, tuple<_Types...>&& _Tuple) {
    return ::std:: tuple_cat(tuple<allocator_arg_t, _Alloc&>(allocator_arg, _Al), ::std:: move(_Tuple));
}
template <class _Alloc, class... _Types>
inline auto _Uses_allocator_piecewise2(false_type, _Alloc& _Al, tuple<_Types...>&& _Tuple) {
    return ::std:: tuple_cat(::std:: move(_Tuple), tuple<_Alloc&>(_Al));
}
template <class _Ty, class _Alloc, class... _Types>
inline auto _Uses_allocator_piecewise(true_type, _Alloc& _Al, tuple<_Types...>&& _Tuple) {
    return _Uses_allocator_piecewise2(
        is_constructible<_Ty, allocator_arg_t, _Alloc&, _Types...>(), _Al, ::std:: move(_Tuple));
}
template <class, class _Alloc, class... _Types>
inline tuple<_Types...>&& _Uses_allocator_piecewise(false_type, _Alloc&, tuple<_Types...>&& _Tuple) {
    return ::std:: move(_Tuple);
}
template <class _Ty1, class _Ty2, class _Outer_alloc, class _Inner_alloc, class... _Types1, class... _Types2>
inline void _Uses_allocator_construct_pair(pair<_Ty1, _Ty2>* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    tuple<_Types1...>&& _Val1,
    tuple<_Types2...>&&
        _Val2) { 
    allocator_traits<_Outer_alloc>::construct(_Outer, _Ptr, piecewise_construct,
        _Uses_allocator_piecewise<_Ty1>(uses_allocator<_Ty1, _Inner_alloc>(), _Inner, ::std:: move(_Val1)),
        _Uses_allocator_piecewise<_Ty2>(uses_allocator<_Ty2, _Inner_alloc>(), _Inner, ::std:: move(_Val2)));
}
template <class _Ty1, class _Ty2, class _Outer_alloc, class _Inner_alloc, class... _Types1, class... _Types2>
inline void _Uses_allocator_construct(pair<_Ty1, _Ty2>* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    piecewise_construct_t, tuple<_Types1...> _Val1,
    tuple<_Types2...>
        _Val2) { 
    _Uses_allocator_construct_pair(_Ptr, _Outer, _Inner, ::std:: move(_Val1), ::std:: move(_Val2));
}
template <class _Ty1, class _Ty2, class _Outer_alloc, class _Inner_alloc>
inline void _Uses_allocator_construct(pair<_Ty1, _Ty2>* const _Ptr, _Outer_alloc& _Outer,
    _Inner_alloc&
        _Inner) { 
    _Uses_allocator_construct_pair(_Ptr, _Outer, _Inner, tuple<>{}, tuple<>{});
}
template <class _Ty1, class _Ty2, class _Outer_alloc, class _Inner_alloc, class _Uty, class _Vty>
inline void _Uses_allocator_construct(pair<_Ty1, _Ty2>* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    _Uty&& _Arg1,
    _Vty&& _Arg2) { 
    _Uses_allocator_construct_pair(_Ptr, _Outer, _Inner, ::std:: forward_as_tuple(::std:: forward<_Uty>(_Arg1)),
        ::std:: forward_as_tuple(::std:: forward<_Vty>(_Arg2)));
}
template <class _Ty1, class _Ty2, class _Outer_alloc, class _Inner_alloc, class _Uty, class _Vty>
inline void _Uses_allocator_construct(pair<_Ty1, _Ty2>* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    const pair<_Uty, _Vty>&
        _Pair) { 
    _Uses_allocator_construct_pair(
        _Ptr, _Outer, _Inner, ::std:: forward_as_tuple(_Pair.first), ::std:: forward_as_tuple(_Pair.second));
}
template <class _Ty1, class _Ty2, class _Outer_alloc, class _Inner_alloc, class _Uty, class _Vty>
inline void _Uses_allocator_construct(pair<_Ty1, _Ty2>* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    pair<_Uty, _Vty>&&
        _Pair) { 
    _Uses_allocator_construct_pair(_Ptr, _Outer, _Inner, ::std:: forward_as_tuple(::std:: forward<_Uty>(_Pair.first)),
        ::std:: forward_as_tuple(::std:: forward<_Vty>(_Pair.second)));
}
namespace pmr {
    class __declspec(novtable) memory_resource {
    public:
        virtual ~memory_resource() noexcept {}
        [[nodiscard]] __declspec(allocator) void* allocate( const size_t _Bytes,
            const size_t _Align = alignof(max_align_t)) { 
            do { if (_Is_pow_2(_Align)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h", 146, 0, "%s", "memory_resource::allocate(): Alignment must be a power of two.")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"memory_resource::allocate(): Alignment must be a power of two.\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h", 146, 0); } while (false); } ; } while (false);
            return do_allocate(_Bytes, _Align);
        }
        void deallocate(void* const _Ptr, const size_t _Bytes,
            const size_t _Align = alignof(
                max_align_t)) { 
            do { if (_Is_pow_2(_Align)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h", 153, 0, "%s", "memory_resource::deallocate(): Alignment must be a power of two.")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"memory_resource::deallocate(): Alignment must be a power of two.\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h", 153, 0); } while (false); } ; } while (false);
            return do_deallocate(_Ptr, _Bytes, _Align);
        }
        [[nodiscard]] bool is_equal(const memory_resource& _That) const
            noexcept { 
            return do_is_equal(_That);
        }
    private:
        virtual void* do_allocate(size_t _Bytes, size_t _Align)               = 0;
        virtual void do_deallocate(void* _Ptr, size_t _Bytes, size_t _Align)  = 0;
        virtual bool do_is_equal(const memory_resource& _That) const noexcept = 0;
    };
    [[nodiscard]] inline bool operator==(const memory_resource& _Left, const memory_resource& _Right) noexcept {
        return &_Left == &_Right || _Left.is_equal(_Right);
    }
    [[nodiscard]] inline bool operator!=(const memory_resource& _Left, const memory_resource& _Right) noexcept {
        return !(_Left == _Right);
    }
    extern "C"  memory_resource* __cdecl _Aligned_get_default_resource() noexcept;
    extern "C"  memory_resource* __cdecl _Unaligned_get_default_resource() noexcept;
    [[nodiscard]] inline memory_resource* get_default_resource() noexcept {
        return _Aligned_get_default_resource();
#line 186 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h"
    }
    template <class _Ty>
    class polymorphic_allocator {
    public:
        template <class>
        friend class polymorphic_allocator;
        using value_type = _Ty;
        polymorphic_allocator() noexcept = default;
         polymorphic_allocator(memory_resource* const _Resource_) noexcept 
            : _Resource{_Resource_} { 
            do { if (_Resource != nullptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h", 202, 0, "%s", "Cannot initialize polymorphic_allocator with null resource " "(N4700 23.12.3.1 [mem.poly.allocator.ctor]/2)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"Cannot initialize polymorphic_allocator with null resource \" \"(N4700 23.12.3.1 [mem.poly.allocator.ctor]/2)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h", 202, 0); } while (false); } ; } while (false);
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h"
        }
        polymorphic_allocator(const polymorphic_allocator&) = default;
        template <class _Uty>
        polymorphic_allocator(const polymorphic_allocator<_Uty>& _That) noexcept
            : _Resource{_That._Resource} { 
        }
        polymorphic_allocator& operator=(const polymorphic_allocator&) = delete;
        [[nodiscard]] __declspec(allocator) _Ty* allocate(
             const size_t _Count) { 
            void* const _Vp = _Resource->allocate(_Get_size_of_n<sizeof(_Ty)>(_Count), alignof(_Ty));
            return static_cast<_Ty*>(_Vp);
        }
        void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept { 
            _Resource->deallocate(_Ptr, _Get_size_of_n<sizeof(_Ty)>(_Count), alignof(_Ty));
        }
        template <class _Uty, class... _Types>
        void construct(_Uty* const _Ptr,
            _Types&&... _Args) { 
            allocator<char> _Al{};
            _Uses_allocator_construct(_Ptr, _Al, *this, ::std:: forward<_Types>(_Args)...);
        }
        [[nodiscard]] polymorphic_allocator select_on_container_copy_construction() const noexcept { 
            return {};
        }
        [[nodiscard]] memory_resource* resource() const noexcept { 
            return _Resource;
        }
    private:
        memory_resource* _Resource = ::std:: pmr::get_default_resource();
    };
    template <class _Ty1, class _Ty2>
    [[nodiscard]] inline bool operator==(const polymorphic_allocator<_Ty1>& _Left,
        const polymorphic_allocator<_Ty2>&
            _Right) noexcept { 
        return *_Left.resource() == *_Right.resource();
    }
    template <class _Ty1, class _Ty2>
    [[nodiscard]] inline bool operator!=(
        const polymorphic_allocator<_Ty1>& _Left, const polymorphic_allocator<_Ty2>& _Right) noexcept {
        return !(_Left == _Right);
    }
} 
#line 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h"
}
#pragma warning(pop)
#pragma pack(pop)
#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h"
#line 271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xpolymorphic_allocator.h"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Elem, class _Int_type>
struct _Char_traits { 
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = _Mbstatet;
    [[nodiscard]] static constexpr int compare(  const _Elem* _First1,
          const _Elem* _First2, size_t _Count) noexcept { 
        for (; 0 < _Count; --_Count, ++_First1, ++_First2) {
            if (*_First1 != *_First2) {
                return *_First1 < *_First2 ? -1 : +1;
            }
        }
        return 0;
    }
    [[nodiscard]] static constexpr size_t length(  const _Elem* _First) noexcept { 
        size_t _Count = 0;
        while (*_First != _Elem()) {
            ++_Count;
            ++_First;
        }
        return _Count;
    }
    static _Elem* copy(  _Elem* const _First1,   const _Elem* _First2,
        size_t _Count) noexcept { 
        return static_cast<_Elem*>(:: memcpy(_First1, _First2, _Count * sizeof(_Elem)));
    }
      static _Elem* _Copy_s(  _Elem* const _First1,
        const size_t _Dest_size,   const _Elem* const _First2,
        const size_t _Count) noexcept { 
        do { if (_Count <= _Dest_size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 62, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 62, 0); } while (false); } ; } while (false);
        return copy(_First1, _First2, _Count);
    }
    [[nodiscard]] static constexpr const _Elem* find(
          const _Elem* _First, size_t _Count, const _Elem& _Ch) noexcept { 
        for (; 0 < _Count; --_Count, ++_First) {
            if (*_First == _Ch) {
                return _First;
            }
        }
        return nullptr;
    }
    static _Elem* move(  _Elem* const _First1,   const _Elem* _First2,
        size_t _Count) noexcept { 
        return static_cast<_Elem*>(:: memmove(_First1, _First2, _Count * sizeof(_Elem)));
    }
    static _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept { 
        _Elem* _Next = _First;
        for (; 0 < _Count; --_Count, ++_Next) {
            *_Next = _Ch;
        }
        return _First;
    }
    static constexpr void assign(_Elem& _Left, const _Elem& _Right) noexcept { 
        _Left = _Right;
    }
    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept { 
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr bool lt(
        const _Elem& _Left, const _Elem& _Right) noexcept { 
        return _Left < _Right;
    }
    [[nodiscard]] static constexpr _Elem to_char_type(
        const int_type& _Meta) noexcept { 
        return static_cast<_Elem>(_Meta);
    }
    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept { 
        return static_cast<int_type>(_Ch);
    }
    [[nodiscard]] static constexpr bool eq_int_type(
        const int_type& _Left, const int_type& _Right) noexcept { 
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept { 
        return _Meta != eof() ? _Meta : !eof();
    }
    [[nodiscard]] static constexpr int_type eof() noexcept { 
        return static_cast<int_type>((-1));
    }
};
template <class _Elem>
struct _WChar_traits { 
    using char_type  = _Elem;
    using int_type   = unsigned short;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = _Mbstatet;
    [[nodiscard]] static constexpr int compare(  const _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept { 
        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wmemcmp(_First1, _First2, _Count);
        } else {
            return _Char_traits<_Elem, unsigned short>::compare(_First1, _First2, _Count);
        }
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    [[nodiscard]] static constexpr size_t length(  const _Elem* _First) noexcept { 
        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wcslen(_First);
        } else {
            return _Char_traits<_Elem, unsigned short>::length(_First);
        }
#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    static _Elem* copy(  _Elem* const _First1,   const _Elem* const _First2,
        const size_t _Count) noexcept { 
        return reinterpret_cast<_Elem*>(
            :: wmemcpy(reinterpret_cast<wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count));
    }
      static _Elem* _Copy_s( 
                                                                        _Elem* const _First1,
        const size_t _Size_in_words,   const _Elem* const _First2,
        const size_t _Count) noexcept { 
        do { if (_Count <= _Size_in_words) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 179, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 179, 0); } while (false); } ; } while (false);
        return copy(_First1, _First2, _Count);
    }
    [[nodiscard]] static constexpr const _Elem* find(
          const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept { 
        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wmemchr(_First, _Ch, _Count);
        } else {
            return _Char_traits<_Elem, unsigned short>::find(_First, _Count, _Ch);
        }
#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    static _Elem* move(  _Elem* const _First1,   const _Elem* const _First2,
        const size_t _Count) noexcept { 
        return reinterpret_cast<_Elem*>(
            :: wmemmove(reinterpret_cast<wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count));
    }
    static _Elem* assign(
          _Elem* const _First, size_t _Count, _Elem _Ch) noexcept { 
        return reinterpret_cast<_Elem*>(:: wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));
    }
    static constexpr void assign(_Elem& _Left, const _Elem& _Right) noexcept { 
        _Left = _Right;
    }
    [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept { 
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr bool lt(
        const _Elem& _Left, const _Elem& _Right) noexcept { 
        return _Left < _Right;
    }
    [[nodiscard]] static constexpr _Elem to_char_type(
        const int_type& _Meta) noexcept { 
        return _Meta;
    }
    [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept { 
        return _Ch;
    }
    [[nodiscard]] static constexpr bool eq_int_type(
        const int_type& _Left, const int_type& _Right) noexcept { 
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept { 
        return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());
    }
    [[nodiscard]] static constexpr int_type eof() noexcept { 
        return ((wint_t)(0xFFFF));
    }
};
template <class _Elem>
struct char_traits : _Char_traits<_Elem, long> { 
};
template <>
struct char_traits<char16_t> : _WChar_traits<char16_t> { 
};
using u16streampos = streampos;
template <>
struct char_traits<char32_t>
    : _Char_traits<char32_t, unsigned int> { 
};
using u32streampos = streampos;
template <>
struct char_traits<wchar_t> : _WChar_traits<wchar_t> { 
};
template <>
struct char_traits<unsigned short>
    : _WChar_traits<unsigned short> { 
};
#line 278 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
template <>
struct char_traits<char> { 
    using char_type  = char;
    using int_type   = int;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = _Mbstatet;
    [[nodiscard]] static constexpr int compare(  const char* const _First1,
          const char* const _First2, const size_t _Count) noexcept { 
        return __builtin_memcmp(_First1, _First2, _Count);
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    [[nodiscard]] static constexpr size_t length(  const char* const _First) noexcept { 
        return __builtin_strlen(_First);
#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    static char* copy(  char* const _First1,   const char* const _First2,
        const size_t _Count) noexcept { 
        return static_cast<char*>(:: memcpy(_First1, _First2, _Count));
    }
      static char* _Copy_s(  char* const _First1,
        const size_t _Size_in_bytes,   const char* const _First2,
        const size_t _Count) noexcept { 
        do { if (_Count <= _Size_in_bytes) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 316, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 316, 0); } while (false); } ; } while (false);
        return copy(_First1, _First2, _Count);
    }
    [[nodiscard]] static constexpr const char* find(
          const char* const _First, const size_t _Count, const char& _Ch) noexcept { 
        return __builtin_char_memchr(_First, _Ch, _Count);
#line 328 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    static char* move(  char* const _First1,   const char* const _First2,
        const size_t _Count) noexcept { 
        return static_cast<char*>(:: memmove(_First1, _First2, _Count));
    }
    static char* assign(
          char* const _First, const size_t _Count, const char _Ch) noexcept { 
        return static_cast<char*>(:: memset(_First, _Ch, _Count));
    }
    static constexpr void assign(char& _Left, const char& _Right) noexcept { 
        _Left = _Right;
    }
    [[nodiscard]] static constexpr bool eq(const char& _Left, const char& _Right) noexcept { 
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr bool lt(
        const char& _Left, const char& _Right) noexcept { 
        return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
    }
    [[nodiscard]] static constexpr char to_char_type(
        const int_type& _Meta) noexcept { 
        return static_cast<char>(_Meta);
    }
    [[nodiscard]] static constexpr int_type to_int_type(const char& _Ch) noexcept { 
        return static_cast<unsigned char>(_Ch);
    }
    [[nodiscard]] static constexpr bool eq_int_type(
        const int_type& _Left, const int_type& _Right) noexcept { 
        return _Left == _Right;
    }
    [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept { 
        return _Meta != eof() ? _Meta : !eof();
    }
    [[nodiscard]] static constexpr int_type eof() noexcept { 
        return (-1);
    }
};
template <class _Elem, class _Traits, class _SizeT>
inline basic_ostream<_Elem, _Traits>& _Insert_string(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data,
    const _SizeT _Size) { 
    using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
    typename _Ostr_t::iostate _State = _Ostr_t::goodbit;
    _SizeT _Pad                      = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size
                      ? 0
                      : static_cast<_SizeT>(_Ostr.width()) - _Size;
    const typename _Ostr_t::sentry _Ok(_Ostr);
    if (!_Ok) {
        _State |= _Ostr_t::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }
        if (_State == _Ostr_t::goodbit && _Ostr.rdbuf()->sputn(_Data, (streamsize) _Size) != (streamsize) _Size) {
            _State |= _Ostr_t::badbit;
        } else {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }
        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(_Ostr_t::badbit, true); }
    }
    _Ostr.setstate(_State);
    return _Ostr;
}
template <class _Traits>
struct _Char_traits_eq {
    using _Elem = typename _Traits::char_type;
    bool operator()(_Elem _Left, _Elem _Right) const {
        return _Traits::eq(_Left, _Right);
    }
};
template <class _Traits>
struct _Char_traits_lt {
    using _Elem = typename _Traits::char_type;
    bool operator()(_Elem _Left, _Elem _Right) const {
        return _Traits::lt(_Left, _Right);
    }
};
template <class _Elem>
struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
    : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { 
};
template <class _Traits>
using _Traits_ch_t = typename _Traits::char_type;
template <class _Traits>
using _Traits_ptr_t = const typename _Traits::char_type*;
template <class _Traits>
constexpr bool _Traits_equal(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right,
    const size_t _Right_size) noexcept { 
    return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
}
template <class _Traits>
constexpr int _Traits_compare(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right,
    const size_t
        _Right_size) noexcept { 
    const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));
    if (_Ans != 0) {
        return _Ans;
    }
    if (_Left_size < _Right_size) {
        return -1;
    }
    if (_Left_size > _Right_size) {
        return 1;
    }
    return 0;
}
template <class _Traits>
constexpr size_t _Traits_find(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept { 
    if (_Needle_size > _Hay_size
        || _Start_at > _Hay_size - _Needle_size) { 
        return static_cast<size_t>(-1);
    }
    if (_Needle_size == 0) { 
        return _Start_at;
    }
    const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
    for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
        _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
        if (!_Match_try) { 
            return static_cast<size_t>(-1);
        }
        if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { 
            return static_cast<size_t>(_Match_try - _Haystack);
        }
    }
}
template <class _Traits>
constexpr size_t _Traits_find_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,
    const _Traits_ch_t<_Traits> _Ch) noexcept { 
    if (_Start_at < _Hay_size) {
        const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
        if (_Found_at) {
            return static_cast<size_t>(_Found_at - _Haystack);
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_rfind(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept { 
    if (_Needle_size == 0) {
        return _Min_value(_Start_at, _Hay_size); 
    }
    if (_Needle_size <= _Hay_size) { 
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
            if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_rfind_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,
    const _Traits_ch_t<_Traits> _Ch) noexcept { 
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Elem,
    bool = _Is_character<_Elem>::value>
class _String_bitmap { 
public:
    constexpr bool _Mark(const _Elem* _First,
        const _Elem* const _Last) { 
        for (; _First != _Last; ++_First) {
            _Matches[static_cast<unsigned char>(*_First)] = true;
        }
        return true;
    }
    constexpr bool _Match(const _Elem _Ch) const { 
        return _Matches[static_cast<unsigned char>(_Ch)];
    }
private:
    bool _Matches[256] = {};
};
template <class _Elem>
class _String_bitmap<_Elem, false> { 
public:
    static_assert(is_unsigned_v<_Elem>,
        "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
        "Visual C++ accepts other unsigned integral types as an extension.");
    constexpr bool _Mark(const _Elem* _First,
        const _Elem* const _Last) { 
        for (; _First != _Last; ++_First) {
            const auto _Ch = *_First;
            if (_Ch >= 256U) {
                return false;
            }
            _Matches[static_cast<unsigned char>(_Ch)] = true;
        }
        return true;
    }
    constexpr bool _Match(const _Elem _Ch) const { 
        return _Ch < 256U && _Matches[_Ch];
    }
private:
    bool _Matches[256] = {};
};
template <class _Traits>
constexpr size_t _Traits_find_first_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size,
    false_type) noexcept { 
    if (_Needle_size != 0 && _Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_find_first_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size,
    true_type) noexcept { 
    if (_Needle_size != 0 && _Start_at < _Hay_size) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
            return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_find_last_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size,
    false_type) noexcept { 
    if (_Needle_size != 0 && _Hay_size != 0) { 
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_find_last_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size,
    true_type) noexcept { 
    if (_Needle_size != 0 && _Hay_size != 0) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
            return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_find_first_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size,
    false_type) noexcept { 
    if (_Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_find_first_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size,
    true_type) noexcept { 
    if (_Start_at < _Hay_size) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
            return _Traits_find_first_not_of<_Traits>(
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_find_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ch_t<_Traits>
        _Ch) noexcept { 
    if (_Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_find_last_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size,
    false_type) noexcept { 
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_find_last_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size,
    true_type) noexcept { 
    if (_Hay_size != 0) { 
        _String_bitmap<typename _Traits::char_type> _Matches;
        if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
            return _Traits_find_last_not_of<_Traits>(
                _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
        }
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Matches._Match(*_Match_try)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Traits>
constexpr size_t _Traits_rfind_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ch_t<_Traits>
        _Ch) noexcept { 
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }
    return static_cast<size_t>(-1); 
}
template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_string_view;
template <class _Traits>
class _String_view_iterator { 
public:
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Traits::char_type;
    using difference_type   = ptrdiff_t;
    using pointer           = const value_type*;
    using reference         = const value_type&;
    constexpr _String_view_iterator() noexcept
        : _Mydata(), _Mysize(0), _Myoff(0)
#line 865 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    { 
    }
private:
    friend basic_string_view<value_type, _Traits>;
    constexpr _String_view_iterator(const pointer _Data, const size_t _Size, const size_t _Off) noexcept
        : _Mydata(_Data), _Mysize(_Size), _Myoff(_Off) { 
    }
#line 880 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
public:
    [[nodiscard]] constexpr reference operator*() const noexcept { 
        do { if (_Mydata) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 884, 0, "%s", "cannot dereference value-initialized string_view iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized string_view iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 884, 0); } while (false); } ; } while (false);
        do { if (_Myoff < _Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 885, 0, "%s", "cannot dereference end string_view iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference end string_view iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 885, 0); } while (false); } ; } while (false);
        return _Mydata[_Myoff];
#line 890 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    [[nodiscard]] constexpr pointer operator->() const noexcept { 
        do { if (_Mydata) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 894, 0, "%s", "cannot dereference value-initialized string_view iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized string_view iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 894, 0); } while (false); } ; } while (false);
        do { if (_Myoff < _Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 895, 0, "%s", "cannot dereference end string_view iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference end string_view iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 895, 0); } while (false); } ; } while (false);
        return _Mydata + _Myoff;
#line 900 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    constexpr _String_view_iterator& operator++() noexcept { 
        do { if (_Mydata) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 904, 0, "%s", "cannot increment value-initialized string_view iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized string_view iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 904, 0); } while (false); } ; } while (false);
        do { if (_Myoff < _Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 905, 0, "%s", "cannot increment string_view iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment string_view iterator past end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 905, 0); } while (false); } ; } while (false);
        ++_Myoff;
#line 910 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return *this;
    }
    constexpr _String_view_iterator operator++(int) noexcept { 
        _String_view_iterator _Tmp{*this};
        ++*this;
        return _Tmp;
    }
    constexpr _String_view_iterator& operator--() noexcept { 
        do { if (_Mydata) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 921, 0, "%s", "cannot decrement value-initialized string_view iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized string_view iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 921, 0); } while (false); } ; } while (false);
        do { if (_Myoff != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 922, 0, "%s", "cannot decrement string_view iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement string_view iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 922, 0); } while (false); } ; } while (false);
        --_Myoff;
#line 927 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return *this;
    }
    constexpr _String_view_iterator operator--(int) noexcept { 
        _String_view_iterator _Tmp{*this};
        --*this;
        return _Tmp;
    }
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        if (_Off != 0) {
            do { if (_Mydata) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 939, 0, "%s", "cannot seek value-initialized string_view iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized string_view iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 939, 0); } while (false); } ; } while (false);
        }
        if (_Off < 0) {
#pragma warning(suppress : 4146) 
            do { if (_Myoff >= -static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 944, 0, "%s", "cannot seek string_view iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string_view iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 944, 0); } while (false); } ; } while (false);
        }
        if (_Off > 0) {
            do { if (_Mysize - _Myoff >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 948, 0, "%s", "cannot seek string_view iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string_view iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 948, 0); } while (false); } ; } while (false);
        }
#line 953 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept { 
        _Verify_offset(_Off);
        _Myoff += _Off;
#line 962 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return *this;
    }
    [[nodiscard]] constexpr _String_view_iterator operator+(const difference_type _Off) const
        noexcept { 
        _String_view_iterator _Tmp{*this};
        _Tmp += _Off;
        return _Tmp;
    }
    constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept { 
        if (_Off != 0) {
            do { if (_Mydata) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 976, 0, "%s", "cannot seek value-initialized string_view iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized string_view iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 976, 0); } while (false); } ; } while (false);
        }
        if (_Off > 0) {
            do { if (_Myoff >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 980, 0, "%s", "cannot seek string_view iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string_view iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 980, 0); } while (false); } ; } while (false);
        }
        if (_Off < 0) {
#pragma warning(suppress : 4146) 
            do { if (_Mysize - _Myoff >= -static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 985, 0, "%s", "cannot seek string_view iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string_view iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 985, 0); } while (false); } ; } while (false);
        }
        _Myoff -= _Off;
#line 992 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return *this;
    }
    [[nodiscard]] constexpr _String_view_iterator operator-(const difference_type _Off) const
        noexcept { 
        _String_view_iterator _Tmp{*this};
        _Tmp -= _Off;
        return _Tmp;
    }
    [[nodiscard]] constexpr difference_type operator-(const _String_view_iterator& _Right) const
        noexcept { 
        do { if (_Mydata == _Right._Mydata && _Mysize == _Right._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1007, 0, "%s", "cannot subtract incompatible string_view iterators")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot subtract incompatible string_view iterators\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1007, 0); } while (false); } ; } while (false);
#line 1008 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return static_cast<difference_type>(_Myoff - _Right._Myoff);
#line 1012 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept { 
        return *(*this + _Off);
    }
    [[nodiscard]] constexpr bool operator==(const _String_view_iterator& _Right) const
        noexcept { 
        do { if (_Mydata == _Right._Mydata && _Mysize == _Right._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1022, 0, "%s", "cannot compare incompatible string_view iterators for equality")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot compare incompatible string_view iterators for equality\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1022, 0); } while (false); } ; } while (false);
#line 1023 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return _Myoff == _Right._Myoff;
#line 1027 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    [[nodiscard]] constexpr bool operator!=(const _String_view_iterator& _Right) const
        noexcept { 
        return !(*this == _Right);
    }
    [[nodiscard]] constexpr bool operator<(const _String_view_iterator& _Right) const noexcept { 
        do { if (_Mydata == _Right._Mydata && _Mysize == _Right._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1037, 0, "%s", "cannot compare incompatible string_view iterators")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot compare incompatible string_view iterators\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1037, 0); } while (false); } ; } while (false);
#line 1038 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return _Myoff < _Right._Myoff;
#line 1042 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    [[nodiscard]] constexpr bool operator>(const _String_view_iterator& _Right) const noexcept { 
        return _Right < *this;
    }
    [[nodiscard]] constexpr bool operator<=(const _String_view_iterator& _Right) const noexcept { 
        return !(_Right < *this);
    }
    [[nodiscard]] constexpr bool operator>=(const _String_view_iterator& _Right) const noexcept { 
        return !(*this < _Right);
    }
    friend constexpr void _Verify_range(const _String_view_iterator& _First, const _String_view_iterator& _Last) {
        do { if (_First._Mydata == _Last._Mydata && _First._Mysize == _Last._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1059, 0, "%s", "string_view iterators in range are from different views")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string_view iterators in range are from different views\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1059, 0); } while (false); } ; } while (false);
#line 1060 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        do { if (_First._Myoff <= _Last._Myoff) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1060, 0, "%s", "string_view iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string_view iterator range transposed\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1060, 0); } while (false); } ; } while (false);
    }
#line 1063 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    using _Prevent_inheriting_unwrap = _String_view_iterator;
    [[nodiscard]] constexpr pointer _Unwrapped() const noexcept {
        return _Mydata + _Myoff;
#line 1072 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    static constexpr bool _Unwrap_when_unverified = 2 == 0;
    constexpr void _Seek_to(pointer _It) noexcept {
        _Myoff = static_cast<size_t>(_It - _Mydata);
#line 1082 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
private:
    pointer _Mydata;
    size_t _Mysize;
    size_t _Myoff;
#line 1092 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
};
template <class _Traits>
[[nodiscard]] constexpr _String_view_iterator<_Traits> operator+(
    const typename _String_view_iterator<_Traits>::difference_type _Off,
    _String_view_iterator<_Traits> _Right) noexcept { 
    _Right += _Off;
    return _Right;
}
template <class _Elem, class _Traits>
class basic_string_view { 
public:
    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "Bad char_traits for basic_string_view; "
        "N4659 24.4.2 [string.view.template]/1 \"the type traits::char_type shall name the same type as charT.\"");
    using traits_type            = _Traits;
    using value_type             = _Elem;
    using pointer                = _Elem*;
    using const_pointer          = const _Elem*;
    using reference              = _Elem&;
    using const_reference        = const _Elem&;
    using const_iterator         = _String_view_iterator<_Traits>;
    using iterator               = const_iterator;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
    using reverse_iterator       = const_reverse_iterator;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    static constexpr auto npos{static_cast<size_type>(-1)};
    constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) { 
    }
    constexpr basic_string_view(const basic_string_view&) noexcept = default;
    constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;
     constexpr basic_string_view(  const const_pointer _Ntcts) noexcept 
        : _Mydata(_Ntcts),
          _Mysize(
              _Traits::length(_Ntcts)) { 
    }
    constexpr basic_string_view(
          const const_pointer _Cts, const size_type _Count) noexcept 
        : _Mydata(_Cts),
          _Mysize(_Count) { 
        do { if (_Count == 0 || _Cts) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1143, 0, "%s", "non-zero size null string_view")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"non-zero size null string_view\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1143, 0); } while (false); } ; } while (false);
#line 1145 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    [[nodiscard]] constexpr const_iterator begin() const noexcept { 
        return const_iterator(_Mydata, _Mysize, 0);
#line 1153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    [[nodiscard]] constexpr const_iterator end() const noexcept { 
        return const_iterator(_Mydata, _Mysize, _Mysize);
#line 1161 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    [[nodiscard]] constexpr const_iterator cbegin() const noexcept { 
        return begin();
    }
    [[nodiscard]] constexpr const_iterator cend() const noexcept { 
        return end();
    }
    [[nodiscard]] constexpr const_reverse_iterator rbegin() const noexcept { 
        return const_reverse_iterator{end()};
    }
    [[nodiscard]] constexpr const_reverse_iterator rend() const noexcept { 
        return const_reverse_iterator{begin()};
    }
    [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept { 
        return rbegin();
    }
    [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept { 
        return rend();
    }
    constexpr const_pointer _Unchecked_begin() const noexcept { 
        return _Mydata;
    }
    constexpr const_pointer _Unchecked_end() const noexcept { 
        return _Mydata + _Mysize;
    }
    [[nodiscard]] constexpr size_type size() const noexcept { 
        return _Mysize;
    }
    [[nodiscard]] constexpr size_type length() const noexcept { 
        return _Mysize;
    }
    [[nodiscard]] constexpr bool empty() const noexcept { 
        return _Mysize == 0;
    }
    [[nodiscard]] constexpr const_pointer data() const noexcept { 
        return _Mydata;
    }
    [[nodiscard]] constexpr size_type max_size() const
        noexcept { 
        return _Min_value(static_cast<size_t>(9223372036854775807i64), static_cast<size_t>(-1) / sizeof(_Elem));
    }
    [[nodiscard]] constexpr const_reference operator[](const size_type _Off) const noexcept { 
        do { if (_Off < _Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1221, 0, "%s", "string_view subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string_view subscript out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1221, 0); } while (false); } ; } while (false);
#line 1223 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return _Mydata[_Off];
    }
    [[nodiscard]] constexpr const_reference at(
        const size_type _Off) const { 
        _Check_offset_exclusive(_Off);
        return _Mydata[_Off];
    }
    [[nodiscard]] constexpr const_reference front() const noexcept { 
        do { if (_Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1235, 0, "%s", "cannot call front on empty string_view")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot call front on empty string_view\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1235, 0); } while (false); } ; } while (false);
#line 1237 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return _Mydata[0];
    }
    [[nodiscard]] constexpr const_reference back() const noexcept { 
        do { if (_Mysize != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1243, 0, "%s", "cannot call back on empty string_view")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot call back on empty string_view\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1243, 0); } while (false); } ; } while (false);
#line 1245 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return _Mydata[_Mysize - 1];
    }
    constexpr void remove_prefix(const size_type _Count) noexcept { 
        do { if (_Mysize >= _Count) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1251, 0, "%s", "cannot remove prefix longer than total size")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot remove prefix longer than total size\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1251, 0); } while (false); } ; } while (false);
#line 1253 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        _Mydata += _Count;
        _Mysize -= _Count;
    }
    constexpr void remove_suffix(const size_type _Count) noexcept { 
        do { if (_Mysize >= _Count) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1260, 0, "%s", "cannot remove suffix longer than total size")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot remove suffix longer than total size\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1260, 0); } while (false); } ; } while (false);
#line 1262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        _Mysize -= _Count;
    }
    constexpr void swap(basic_string_view& _Other) noexcept { 
        const basic_string_view _Tmp{_Other}; 
        _Other = *this;
        *this  = _Tmp;
    }
    constexpr size_type copy(  _Elem* const _Ptr, size_type _Count,
        const size_type _Off = 0) const { 
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mydata + _Off, _Count);
        return _Count;
    }
      constexpr size_type
        _Copy_s(  _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0) const { 
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
        return _Count;
    }
    [[nodiscard]] constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos)
        const { 
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        return basic_string_view(_Mydata + _Off, _Count);
    }
    constexpr bool _Equal(const basic_string_view _Right) const noexcept { 
        return _Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
    }
    [[nodiscard]] constexpr int compare(const basic_string_view _Right) const
        noexcept { 
        return _Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
    }
    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _N0,
        const basic_string_view _Right) const { 
        return substr(_Off, _N0).compare(_Right);
    }
    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _N0, const basic_string_view _Right,
        const size_type _Roff,
        const size_type _Count) const { 
        return substr(_Off, _N0).compare(_Right.substr(_Roff, _Count));
    }
    [[nodiscard]] constexpr int compare(  const _Elem* const _Ptr) const { 
        return compare(basic_string_view(_Ptr));
    }
    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _N0,
          const _Elem* const _Ptr) const { 
        return substr(_Off, _N0).compare(basic_string_view(_Ptr));
    }
    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _N0,
          const _Elem* const _Ptr,
        const size_type _Count) const { 
        return substr(_Off, _N0).compare(basic_string_view(_Ptr, _Count));
    }
    [[nodiscard]] constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const
        noexcept { 
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }
    [[nodiscard]] constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const
        noexcept { 
        return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }
    [[nodiscard]] constexpr size_type find(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }
    [[nodiscard]] constexpr size_type find(  const _Elem* const _Ptr, const size_type _Off = 0) const
        noexcept { 
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }
    [[nodiscard]] constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const
        noexcept { 
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }
    [[nodiscard]] constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const
        noexcept { 
        return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }
    [[nodiscard]] constexpr size_type rfind(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }
    [[nodiscard]] constexpr size_type rfind(  const _Elem* const _Ptr, const size_type _Off = npos) const
        noexcept { 
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }
    [[nodiscard]] constexpr size_type find_first_of(const basic_string_view _Right,
        const size_type _Off = 0) const noexcept { 
        return _Traits_find_first_of<_Traits>(
            _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const
        noexcept { 
        return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }
    [[nodiscard]] constexpr size_type find_first_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        return _Traits_find_first_of<_Traits>(
            _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_first_of(  const _Elem* const _Ptr,
        const size_type _Off = 0) const noexcept { 
        return _Traits_find_first_of<_Traits>(
            _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_last_of(const basic_string_view _Right, const size_type _Off = npos) const
        noexcept { 
        return _Traits_find_last_of<_Traits>(
            _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const
        noexcept { 
        return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }
    [[nodiscard]] constexpr size_type find_last_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        return _Traits_find_last_of<_Traits>(
            _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_last_of(  const _Elem* const _Ptr, const size_type _Off = npos) const
        noexcept { 
        return _Traits_find_last_of<_Traits>(
            _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_first_not_of(const basic_string_view _Right,
        const size_type _Off = 0) const noexcept { 
        return _Traits_find_first_not_of<_Traits>(
            _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const
        noexcept { 
        return _Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }
    [[nodiscard]] constexpr size_type find_first_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        return _Traits_find_first_not_of<_Traits>(
            _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_first_not_of(  const _Elem* const _Ptr, const size_type _Off = 0) const
        noexcept { 
        return _Traits_find_first_not_of<_Traits>(
            _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_last_not_of(const basic_string_view _Right,
        const size_type _Off = npos) const noexcept { 
        return _Traits_find_last_not_of<_Traits>(
            _Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize, _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const
        noexcept { 
        return _Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }
    [[nodiscard]] constexpr size_type find_last_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        return _Traits_find_last_not_of<_Traits>(
            _Mydata, _Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr size_type find_last_not_of(  const _Elem* const _Ptr, const size_type _Off = npos) const
        noexcept { 
        return _Traits_find_last_not_of<_Traits>(
            _Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{});
    }
    [[nodiscard]] constexpr bool _Starts_with(const basic_string_view _View) const
        noexcept { 
        return _Mysize >= _View._Mysize && _Traits::compare(_Mydata, _View._Mydata, _View._Mysize) == 0;
    }
private:
    constexpr void _Check_offset(const size_type _Off) const { 
        if (_Mysize < _Off) {
            _Xran();
        }
    }
    constexpr void _Check_offset_exclusive(
        const size_type _Off) const { 
        if (_Mysize <= _Off) {
            _Xran();
        }
    }
    constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const
        noexcept { 
        return _Min_value(_Size, _Mysize - _Off);
    }
    [[noreturn]] static void _Xran() { 
        _Xout_of_range("invalid string_view position");
    }
    const_pointer _Mydata;
    size_type _Mysize;
};
template <class _Elem, class _Traits>
[[nodiscard]] constexpr bool operator==(const basic_string_view<_Elem, _Traits> _Lhs,
    const basic_string_view<_Elem, _Traits> _Rhs) noexcept { 
    return _Lhs._Equal(_Rhs);
}
template <class _Elem, class _Traits, int = 1> 
[[nodiscard]] constexpr bool operator==(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
    const basic_string_view<_Elem, _Traits>
        _Rhs) noexcept { 
    return _Lhs._Equal(_Rhs);
}
template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr bool operator==(const basic_string_view<_Elem, _Traits> _Lhs,
    const _Identity_t<basic_string_view<_Elem, _Traits>>
        _Rhs) noexcept { 
    return _Lhs._Equal(_Rhs);
}
template <class _Elem, class _Traits>
[[nodiscard]] constexpr bool operator!=(const basic_string_view<_Elem, _Traits> _Lhs,
    const basic_string_view<_Elem, _Traits> _Rhs) noexcept { 
    return !_Lhs._Equal(_Rhs);
}
template <class _Elem, class _Traits, int = 1> 
[[nodiscard]] constexpr bool operator!=(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
    const basic_string_view<_Elem, _Traits>
        _Rhs) noexcept { 
    return !_Lhs._Equal(_Rhs);
}
template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr bool operator!=(const basic_string_view<_Elem, _Traits> _Lhs,
    const _Identity_t<basic_string_view<_Elem, _Traits>>
        _Rhs) noexcept { 
    return !_Lhs._Equal(_Rhs);
}
template <class _Elem, class _Traits>
[[nodiscard]] constexpr bool operator<(const basic_string_view<_Elem, _Traits> _Lhs,
    const basic_string_view<_Elem, _Traits> _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) < 0;
}
template <class _Elem, class _Traits, int = 1> 
[[nodiscard]] constexpr bool operator<(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
    const basic_string_view<_Elem, _Traits>
        _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) < 0;
}
template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr bool operator<(const basic_string_view<_Elem, _Traits> _Lhs,
    const _Identity_t<basic_string_view<_Elem, _Traits>>
        _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) < 0;
}
template <class _Elem, class _Traits>
[[nodiscard]] constexpr bool operator>(const basic_string_view<_Elem, _Traits> _Lhs,
    const basic_string_view<_Elem, _Traits> _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) > 0;
}
template <class _Elem, class _Traits, int = 1> 
[[nodiscard]] constexpr bool operator>(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
    const basic_string_view<_Elem, _Traits>
        _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) > 0;
}
template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr bool operator>(const basic_string_view<_Elem, _Traits> _Lhs,
    const _Identity_t<basic_string_view<_Elem, _Traits>>
        _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) > 0;
}
template <class _Elem, class _Traits>
[[nodiscard]] constexpr bool operator<=(const basic_string_view<_Elem, _Traits> _Lhs,
    const basic_string_view<_Elem, _Traits> _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) <= 0;
}
template <class _Elem, class _Traits, int = 1> 
[[nodiscard]] constexpr bool operator<=(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
    const basic_string_view<_Elem, _Traits>
        _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) <= 0;
}
template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr bool operator<=(const basic_string_view<_Elem, _Traits> _Lhs,
    const _Identity_t<basic_string_view<_Elem, _Traits>>
        _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) <= 0;
}
template <class _Elem, class _Traits>
[[nodiscard]] constexpr bool operator>=(const basic_string_view<_Elem, _Traits> _Lhs,
    const basic_string_view<_Elem, _Traits>
        _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) >= 0;
}
template <class _Elem, class _Traits, int = 1> 
[[nodiscard]] constexpr bool operator>=(const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs,
    const basic_string_view<_Elem, _Traits>
        _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) >= 0;
}
template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr bool operator>=(const basic_string_view<_Elem, _Traits> _Lhs,
    const _Identity_t<basic_string_view<_Elem, _Traits>>
        _Rhs) noexcept { 
    return _Lhs.compare(_Rhs) >= 0;
}
using string_view    = basic_string_view<char>;
using u16string_view = basic_string_view<char16_t>;
using u32string_view = basic_string_view<char32_t>;
using wstring_view   = basic_string_view<wchar_t>;
template <class _Elem, class _Traits>
struct hash<basic_string_view<_Elem, _Traits>> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef basic_string_view<_Elem, _Traits> argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const basic_string_view<_Elem, _Traits> _Keyval) const
        noexcept { 
        return _Hash_array_representation(_Keyval.data(), _Keyval.size());
    }
};
template <class _Elem, class _Traits>
inline basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string_view<_Elem, _Traits> _Str) { 
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}
inline namespace literals {
    inline namespace string_view_literals {
        [[nodiscard]] constexpr string_view operator"" sv(
            const char* _Str, size_t _Len) noexcept { 
            return string_view(_Str, _Len);
        }
        [[nodiscard]] constexpr wstring_view operator"" sv(
            const wchar_t* _Str, size_t _Len) noexcept { 
            return wstring_view(_Str, _Len);
        }
        [[nodiscard]] constexpr u16string_view operator"" sv(
            const char16_t* _Str, size_t _Len) noexcept { 
            return u16string_view(_Str, _Len);
        }
        [[nodiscard]] constexpr u32string_view operator"" sv(
            const char32_t* _Str, size_t _Len) noexcept { 
            return u32string_view(_Str, _Len);
        }
    } 
} 
#line 1691 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
template <class _Mystr>
class _String_const_iterator : public _Iterator_base { 
public:
    using iterator_category = random_access_iterator_tag;
    using value_type      = typename _Mystr::value_type;
    using difference_type = typename _Mystr::difference_type;
    using pointer         = typename _Mystr::const_pointer;
    using reference       = const value_type&;
    _String_const_iterator() : _Ptr() { 
    }
    _String_const_iterator(pointer _Parg, const _Container_base* _Pstring)
        : _Ptr(_Parg) { 
        this->_Adopt(_Pstring);
    }
    [[nodiscard]] reference operator*() const { 
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1713, 0, "%s", "cannot dereference value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1713, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1716, 0, "%s", "cannot dereference string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1716, 0); } while (false); } ; } while (false);
#line 1717 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr  = _Unfancy(_Ptr);
        do { if (_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1720, 0, "%s", "cannot dereference string iterator because it is out of range (e.g. an end iterator)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference string iterator because it is out of range (e.g. an end iterator)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1720, 0); } while (false); } ; } while (false);
#line 1721 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
#line 1722 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        ;
        return *_Ptr;
    }
    [[nodiscard]] pointer operator->() const { 
        return pointer_traits<pointer>::pointer_to(**this);
    }
    _String_const_iterator& operator++() { 
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1733, 0, "%s", "cannot increment value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1733, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1736, 0, "%s", "cannot increment string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1736, 0); } while (false); } ; } while (false);
#line 1737 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        do { if (_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1737, 0, "%s", "cannot increment string iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment string iterator past end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1737, 0); } while (false); } ; } while (false);
#line 1739 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        ++_Ptr;
        return *this;
    }
    _String_const_iterator operator++(int) { 
        _String_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _String_const_iterator& operator--() { 
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1752, 0, "%s", "cannot decrement value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1752, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1755, 0, "%s", "cannot decrement string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1755, 0); } while (false); } ; } while (false);
#line 1756 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        do { if (_Mycont->_Myptr() < _Unfancy(_Ptr)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1756, 0, "%s", "cannot decrement string iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement string iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1756, 0); } while (false); } ; } while (false);
#line 1758 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        --_Ptr;
        return *this;
    }
    _String_const_iterator operator--(int) { 
        _String_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    void _Verify_offset(const difference_type _Off) const noexcept {
        if (_Off == 0) {
            return;
        }
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1775, 0, "%s", "cannot seek value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1775, 0); } while (false); } ; } while (false);
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1778, 0, "%s", "cannot seek string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1778, 0); } while (false); } ; } while (false);
#line 1779 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr  = _Unfancy(_Ptr);
        if (_Off < 0) {
#pragma warning(suppress : 4146) 
            do { if (_Contptr - _Rawptr <= _Off) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1784, 0, "%s", "cannot seek string iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1784, 0); } while (false); } ; } while (false);
        }
        if (_Off > 0) {
            using _Size_type = typename _Mystr::size_type;
            const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
            do { if (static_cast<_Size_type>(_Off) <= _Left) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1790, 0, "%s", "cannot seek string iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1790, 0); } while (false); } ; } while (false);
        }
#line 1795 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    _String_const_iterator& operator+=(const difference_type _Off) { 
        _Verify_offset(_Off);
#line 1801 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        _Ptr += _Off;
        return *this;
    }
    [[nodiscard]] _String_const_iterator operator+(const difference_type _Off) const { 
        _String_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _String_const_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _String_const_iterator operator-(const difference_type _Off) const { 
        _String_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(const _String_const_iterator& _Right) const { 
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }
    [[nodiscard]] reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    [[nodiscard]] bool operator==(const _String_const_iterator& _Right) const { 
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }
    [[nodiscard]] bool operator!=(const _String_const_iterator& _Right) const { 
        return !(*this == _Right);
    }
    [[nodiscard]] bool operator<(const _String_const_iterator& _Right) const { 
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }
    [[nodiscard]] bool operator>(const _String_const_iterator& _Right) const { 
        return _Right < *this;
    }
    [[nodiscard]] bool operator<=(const _String_const_iterator& _Right) const { 
        return !(_Right < *this);
    }
    [[nodiscard]] bool operator>=(const _String_const_iterator& _Right) const { 
        return !(*this < _Right);
    }
    void _Compat(const _String_const_iterator& _Right) const { 
        do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1857, 0, "%s", "string iterators incompatible (e.g." " point to different string instances)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible (e.g.\" \" point to different string instances)\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1857, 0); } while (false); } ; } while (false);
#line 1858 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
#line 1861 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    friend void _Verify_range(const _String_const_iterator& _First, const _String_const_iterator& _Last) {
        do { if (_First._Getcont() == _Last._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1865, 0, "%s", "string iterators in range are from different containers")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators in range are from different containers\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1865, 0); } while (false); } ; } while (false);
        do { if (_First._Ptr <= _Last._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1866, 0, "%s", "string iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator range transposed\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 1866, 0); } while (false); } ; } while (false);
    }
#line 1869 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    using _Prevent_inheriting_unwrap = _String_const_iterator;
    [[nodiscard]] pointer _Unwrapped() const {
        return _Ptr;
    }
    void _Seek_to(pointer _It) {
        _Ptr = _It;
    }
    pointer _Ptr; 
};
template <class _Mystr>
[[nodiscard]] inline _String_const_iterator<_Mystr> operator+(
    typename _String_const_iterator<_Mystr>::difference_type _Off,
    _String_const_iterator<_Mystr> _Next) { 
    return _Next += _Off;
}
template <class _Mystr>
class _String_iterator : public _String_const_iterator<_Mystr> { 
public:
    using _Mybase           = _String_const_iterator<_Mystr>;
    using iterator_category = random_access_iterator_tag;
    using value_type      = typename _Mystr::value_type;
    using difference_type = typename _Mystr::difference_type;
    using pointer         = typename _Mystr::pointer;
    using reference       = value_type&;
    _String_iterator() { 
    }
    _String_iterator(pointer _Parg, const _Container_base* _Pstring)
        : _Mybase(_Parg, _Pstring) { 
    }
    [[nodiscard]] reference operator*() const { 
        return const_cast<reference>(_Mybase::operator*());
    }
    [[nodiscard]] pointer operator->() const { 
        return pointer_traits<pointer>::pointer_to(**this);
    }
    _String_iterator& operator++() { 
        ++*(_Mybase*) this;
        return *this;
    }
    _String_iterator operator++(int) { 
        _String_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _String_iterator& operator--() { 
        --*(_Mybase*) this;
        return *this;
    }
    _String_iterator operator--(int) { 
        _String_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    _String_iterator& operator+=(const difference_type _Off) { 
        *(_Mybase*) this += _Off;
        return *this;
    }
    [[nodiscard]] _String_iterator operator+(const difference_type _Off) const { 
        _String_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _String_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _String_iterator operator-(const difference_type _Off) const { 
        _String_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(const _Mybase& _Right) const { 
        return *(_Mybase*) this - _Right;
    }
    [[nodiscard]] reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    using _Prevent_inheriting_unwrap = _String_iterator;
    [[nodiscard]] pointer _Unwrapped() const {
        return _Const_cast(this->_Ptr);
    }
};
template <class _Mystr>
[[nodiscard]] inline _String_iterator<_Mystr> operator+(typename _String_iterator<_Mystr>::difference_type _Off,
    _String_iterator<_Mystr> _Next) { 
    return _Next += _Off;
}
template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference>
struct _String_iter_types { 
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};
template <class _Val_types>
class _String_val : public _Container_base { 
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;
    _String_val() : _Bx(), _Mysize(0), _Myres(0) { 
    }
    static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
    static constexpr size_type _ALLOC_MASK =
        sizeof(value_type) <= 1
            ? 15
            : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
    value_type* _Myptr() { 
        value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }
        return _Result;
    }
    const value_type* _Myptr() const { 
        const value_type* _Result = _Bx._Buf;
        if (_Large_string_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }
        return _Result;
    }
    bool _Large_string_engaged() const { 
        return _BUF_SIZE <= _Myres;
    }
    void _Check_offset(const size_type _Off) const { 
        if (_Mysize < _Off) {
            _Xran();
        }
    }
    void _Check_offset_exclusive(const size_type _Off) const { 
        if (_Mysize <= _Off) {
            _Xran();
        }
    }
    [[noreturn]] static void _Xran() { 
        _Xout_of_range("invalid string position");
    }
    size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const
        noexcept { 
        return _Min_value(_Size, _Mysize - _Off);
    }
    union _Bxty { 
        _Bxty() { 
        }
        ~_Bxty() noexcept { 
        }
        value_type _Buf[_BUF_SIZE];
        pointer _Ptr;
        char _Alias[_BUF_SIZE]; 
    } _Bx;
    size_type _Mysize; 
    size_type _Myres; 
};
template <class _Ty>
constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); 
template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_string { 
private:
    friend _Tidy_deallocate_guard<basic_string>;
    using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
    using _Alty_traits = allocator_traits<_Alty>;
    using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
    static_assert(!1 || is_same_v<_Elem, typename _Alloc::value_type>,
        "basic_string<T, Traits, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");
    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
        "char_traits character type match the string's character type.");
public:
    using traits_type    = _Traits;
    using allocator_type = _Alloc;
    using value_type      = _Elem;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;
    using iterator       = _String_iterator<_Scary_val>;
    using const_iterator = _String_const_iterator<_Scary_val>;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
private:
    static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
    static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
    using _Use_memcpy_move = bool_constant<_Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>>;
    static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<_Container_base>;
    static constexpr size_t _Memcpy_move_size   = sizeof(_Scary_val) - _Memcpy_move_offset;
    template <class _Iter>
    using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
    template <class _StringViewIsh>
    using _Is_string_view_ish =
        enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
            negation<is_convertible<const _StringViewIsh&, const _Elem*>>>>;
#line 2141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
public:
    basic_string(const basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t(),
              _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Construct_lv_contents(_Right);
        _Proxy._Release();
    }
    basic_string(const basic_string& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Construct_lv_contents(_Right);
        _Proxy._Release();
    }
    basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>)
        : _Mypair(_Zero_then_variadic_args_t()) { 
        _Get_data()._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Tidy_init();
    }
    explicit basic_string(const _Alloc& _Al) noexcept
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Get_data()._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Tidy_init();
    }
    basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Right, _Roff, npos);
        _Proxy._Release();
    }
    basic_string(
        const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Right, _Roff, _Count);
        _Proxy._Release();
    }
    basic_string(  const _Elem* const _Ptr,  const size_type _Count)
        : _Mypair(_Zero_then_variadic_args_t()) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Ptr, _Count);
        _Proxy._Release();
    }
    basic_string(
          const _Elem* const _Ptr,  const size_type _Count, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Ptr, _Count);
        _Proxy._Release();
    }
    basic_string(  const _Elem* const _Ptr)
        : _Mypair(_Zero_then_variadic_args_t()) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Ptr);
        _Proxy._Release();
    }
    template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
#line 2222 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    basic_string(  const _Elem* const _Ptr, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Ptr);
        _Proxy._Release();
    }
    basic_string( const size_type _Count, const _Elem _Ch)
        : _Mypair(_Zero_then_variadic_args_t()) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Count, _Ch);
        _Proxy._Release();
    }
    template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
#line 2243 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    basic_string( const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Count, _Ch);
        _Proxy._Release();
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        _Adl_verify_range(_First, _Last);
        _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
        _Proxy._Release();
    }
    template <class _Iter>
    void _Construct(
        _Iter _First, const _Iter _Last, input_iterator_tag) { 
        _Tidy_deallocate_guard<basic_string> _Guard{this};
        for (; _First != _Last; ++_First) {
            push_back(*_First);
        }
        _Guard._Target = nullptr;
    }
    template <class _Iter>
    void _Construct(const _Iter _First, const _Iter _Last,
        forward_iterator_tag) { 
        const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        reserve(_Count);
        _Construct(_First, _Last, input_iterator_tag());
    }
    void _Construct(_Elem* const _First, _Elem* const _Last,
        random_access_iterator_tag) { 
        if (_First != _Last) {
            assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
        }
    }
    void _Construct(const _Elem* const _First, const _Elem* const _Last,
        random_access_iterator_tag) { 
        if (_First != _Last) {
            assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
        }
    }
    basic_string(basic_string&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std:: move(_Right._Getal())) { 
        _Get_data()._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Take_contents(_Right, _Use_memcpy_move{});
    }
    basic_string(basic_string&& _Right, const _Alloc& _Al)
        noexcept(_Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        if
            constexpr(!_Alty_traits::is_always_equal::value) {
                if (_Getal() != _Right._Getal()) {
                    _Construct_lv_contents(_Right);
                    _Proxy._Release();
                    return;
                }
            }
        _Take_contents(_Right, _Use_memcpy_move{});
        _Proxy._Release();
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Right);
        _Proxy._Release();
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string(
        const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Right, _Roff, _Count);
        _Proxy._Release();
    }
#line 2343 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
private:
    void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {
        _Tidy_deallocate();
        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right, _Use_memcpy_move{});
    }
    void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            auto& _My_data = _Get_data();
            _My_data._Orphan_all();
            _My_data._Reload_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right._Getal()));
            _Pocma(_Getal(), _Right._Getal());
            _Take_contents(_Right, _Use_memcpy_move{});
        }
    }
    void _Move_assign(basic_string& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            auto& _Right_data = _Right._Get_data();
            assign(_Right_data._Myptr(), _Right_data._Mysize);
        }
    }
public:
    basic_string& operator=(basic_string&& _Right)
        noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
        if (this != ::std:: addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma<_Alty>{});
        }
        return *this;
    }
    basic_string& assign(basic_string&& _Right)
        noexcept(noexcept(*this = ::std:: move(_Right))) { 
        *this = ::std:: move(_Right);
        return *this;
    }
    void _Take_contents(basic_string& _Right, true_type) noexcept {
        auto& _Right_data = _Right._Get_data();
        if (_Right_data._Large_string_engaged()) { 
            _Swap_proxy_and_iterators(_Right);
        } else {
            _Right._Orphan_all();
        }
#line 2404 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        const auto _My_data_mem = reinterpret_cast<unsigned char*>(::std:: addressof(_Get_data())) + _Memcpy_move_offset;
        const auto _Right_data_mem =
            reinterpret_cast<unsigned char*>(::std:: addressof(_Right_data)) + _Memcpy_move_offset;
        :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
        _Right._Tidy_init();
    }
    void _Take_contents(basic_string& _Right, false_type) noexcept {
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        if (_Right_data._Large_string_engaged()) { 
            _Alty_traits::construct(_Getal(), ::std:: addressof(_My_data._Bx._Ptr), _Right_data._Bx._Ptr);
            _Right_data._Bx._Ptr = pointer();
            _Swap_proxy_and_iterators(_Right);
        } else { 
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Right._Orphan_all();
        }
        _My_data._Mysize = _Right_data._Mysize;
        _My_data._Myres  = _Right_data._Myres;
        _Right._Tidy_init();
    }
    void _Construct_lv_contents(const basic_string& _Right) {
        auto& _My_data                = _Get_data();
        auto& _Right_data             = _Right._Get_data();
        const size_type _Right_size   = _Right_data._Mysize;
        const _Elem* const _Right_ptr = _Right_data._Myptr();
        if (_Right_size < _BUF_SIZE) { 
            _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
            _My_data._Mysize = _Right_size;
            _My_data._Myres  = _BUF_SIZE - 1;
            return;
        }
        auto& _Al                     = _Getal();
        const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());
        const pointer _New_array      = _Al.allocate(_New_capacity + 1); 
        _Alty_traits::construct(_Al, ::std:: addressof(_My_data._Bx._Ptr), _New_array);
        _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
        _My_data._Mysize = _Right_size;
        _My_data._Myres  = _New_capacity;
    }
    basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t(), _Al) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Tidy_init();
        assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        _Proxy._Release();
    }
    basic_string& operator=(initializer_list<_Elem> _Ilist) { 
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }
    basic_string& operator+=(initializer_list<_Elem> _Ilist) { 
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }
    basic_string& assign(initializer_list<_Elem> _Ilist) { 
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }
    basic_string& append(initializer_list<_Elem> _Ilist) { 
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }
    iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) { 
        const difference_type _Off = _Where - begin();
        insert(static_cast<size_type>(_Off), _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        return begin() + _Off;
    }
    basic_string& replace(const const_iterator _First, const const_iterator _Last,
        const initializer_list<_Elem> _Ilist) { 
        return replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Ilist.begin(),
            _Convert_size<size_type>(_Ilist.size()));
    }
    ~basic_string() noexcept { 
        _Tidy_deallocate();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Delete_plain(_Alproxy, ::std:: exchange(_Myproxy(), nullptr));
#line 2503 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    }
    static constexpr auto npos{static_cast<size_type>(-1)};
private:
    void _Copy_assign(const basic_string& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        auto& _Right_data = _Right._Get_data();
        assign(_Right_data._Myptr(), _Right_data._Mysize);
    }
    void _Copy_assign(const basic_string& _Right, true_type) {
        if (_Getal() == _Right._Getal()) {
            _Copy_assign(_Right, false_type{});
        } else {
            _Tidy_deallocate();
            _Get_data()._Reload_proxy(
                static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right._Getal()));
            _Pocca(_Getal(), _Right._Getal());
            auto& _Right_data = _Right._Get_data();
            assign(_Right_data._Myptr(), _Right_data._Mysize);
        }
    }
public:
    basic_string& operator=(const basic_string& _Right) { 
        if (this != ::std:: addressof(_Right)) { 
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }
        return *this;
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& operator=(const _StringViewIsh& _Right) { 
        return assign(_Right);
    }
#line 2542 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    basic_string& operator=(  const _Elem* const _Ptr) { 
        return assign(_Ptr);
    }
    basic_string& operator=(const _Elem _Ch) { 
        auto& _My_data    = _Get_data();
        _My_data._Mysize  = 1;
        _Elem* const _Ptr = _My_data._Myptr();
        _Traits::assign(_Ptr[0], _Ch);
        _Traits::assign(_Ptr[1], _Elem());
        return *this;
    }
    basic_string& operator+=(const basic_string& _Right) { 
        return append(_Right);
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& operator+=(const _StringViewIsh& _Right) { 
        return append(_Right);
    }
#line 2566 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    basic_string& operator+=(  const _Elem* const _Ptr) { 
        return append(_Ptr);
    }
    basic_string& operator+=(_Elem _Ch) { 
        push_back(_Ch);
        return *this;
    }
    basic_string& append(const basic_string& _Right) { 
        auto& _Right_data = _Right._Get_data();
        return append(_Right_data._Myptr(), _Right_data._Mysize);
    }
    basic_string& append(const basic_string& _Right, const size_type _Roff,
        size_type _Count = npos) { 
        auto& _Right_data = _Right._Get_data();
        _Right_data._Check_offset(_Roff);
        _Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
        return append(_Right_data._Myptr() + _Roff, _Count);
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& append(const _StringViewIsh& _Right) { 
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& append(const _StringViewIsh& _Right, const size_type _Roff,
        const size_type _Count = npos) { 
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return append(_As_view.substr(_Roff, _Count));
    }
#line 2603 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    basic_string& append(  const _Elem* const _Ptr,  const size_type _Count) {
        auto& _My_data            = _Get_data();
        const size_type _Old_size = _My_data._Mysize;
        if (_Count <= _My_data._Myres - _Old_size) {
            _My_data._Mysize      = _Old_size + _Count;
            _Elem* const _Old_ptr = _My_data._Myptr();
            _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }
        return _Reallocate_grow_by(_Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
                const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Ptr, _Count);
    }
    basic_string& append(  const _Elem* const _Ptr) { 
        return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    basic_string& append( const size_type _Count, const _Elem _Ch) { 
        auto& _My_data            = _Get_data();
        const size_type _Old_size = _My_data._Mysize;
        if (_Count <= _My_data._Myres - _Old_size) {
            _My_data._Mysize      = _Old_size + _Count;
            _Elem* const _Old_ptr = _My_data._Myptr();
            _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }
        return _Reallocate_grow_by(_Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Count, _Ch);
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    basic_string& append(const _Iter _First, const _Iter _Last) { 
        return replace(end(), end(), _First, _Last);
    }
    basic_string& assign(const basic_string& _Right) { 
        *this = _Right;
        return *this;
    }
    basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        auto& _Right_data = _Right._Get_data();
        _Right_data._Check_offset(_Roff);
        _Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
        return assign(_Right_data._Myptr() + _Roff, _Count);
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& assign(const _StringViewIsh& _Right) { 
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return assign(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& assign(const _StringViewIsh& _Right, const size_type _Roff,
        const size_type _Count = npos) { 
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return assign(_As_view.substr(_Roff, _Count));
    }
#line 2683 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    basic_string& assign(  const _Elem* const _Ptr,  const size_type _Count) {
        auto& _My_data = _Get_data();
        if (_Count <= _My_data._Myres) {
            _Elem* const _Old_ptr = _My_data._Myptr();
            _My_data._Mysize      = _Count;
            _Traits::move(_Old_ptr, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }
        return _Reallocate_for(_Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
                _Traits::copy(_New_ptr, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ptr);
    }
    basic_string& assign(  const _Elem* const _Ptr) { 
        return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    basic_string& assign( const size_type _Count, const _Elem _Ch) { 
        auto& _My_data = _Get_data();
        if (_Count <= _My_data._Myres) {
            _Elem* const _Old_ptr = _My_data._Myptr();
            _My_data._Mysize      = _Count;
            _Traits::assign(_Old_ptr, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }
        return _Reallocate_for(_Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
                _Traits::assign(_New_ptr, _Count, _Ch);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ch);
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    basic_string& assign(const _Iter _First, const _Iter _Last) { 
        return replace(begin(), end(), _First, _Last);
    }
    basic_string& insert(const size_type _Off, const basic_string& _Right) { 
        auto& _Right_data = _Right._Get_data();
        return insert(_Off, _Right_data._Myptr(), _Right_data._Mysize);
    }
    basic_string& insert(const size_type _Off, const basic_string& _Right, const size_type _Roff,
        size_type _Count = npos) { 
        auto& _Right_data = _Right._Get_data();
        _Right_data._Check_offset(_Roff);
        _Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
        return insert(_Off, _Right_data._Myptr() + _Roff, _Count);
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& insert(const size_type _Off, const _StringViewIsh& _Right) { 
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return insert(_Off, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& insert(const size_type _Off, const _StringViewIsh& _Right, const size_type _Roff,
        const size_type _Count = npos) { 
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return insert(_Off, _As_view.substr(_Roff, _Count));
    }
#line 2757 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    basic_string& insert(
        const size_type _Off,   const _Elem* const _Ptr,  const size_type _Count) {
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        const size_type _Old_size = _My_data._Mysize;
        if (_Count <= _My_data._Myres - _Old_size) {
            _My_data._Mysize        = _Old_size + _Count;
            _Elem* const _Old_ptr   = _My_data._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            size_type _Ptr_shifted_after;
            if (_Ptr + _Count <= _Insert_at
                || _Ptr > _Old_ptr + _Old_size) { 
                _Ptr_shifted_after = _Count; 
            } else if (_Insert_at <= _Ptr) { 
                _Ptr_shifted_after = 0;
            } else { 
                _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
            }
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }
        return _Reallocate_grow_by(_Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Ptr, _Count);
    }
    basic_string& insert(const size_type _Off,   const _Elem* const _Ptr) { 
        return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    basic_string& insert(const size_type _Off,  const size_type _Count, const _Elem _Ch) {
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        const size_type _Old_size = _My_data._Mysize;
        if (_Count <= _My_data._Myres - _Old_size) {
            _My_data._Mysize        = _Old_size + _Count;
            _Elem* const _Old_ptr   = _My_data._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::assign(_Insert_at, _Count, _Ch); 
            return *this;
        }
        return _Reallocate_grow_by(_Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Count, _Ch);
    }
    iterator insert(const const_iterator _Where, const _Elem _Ch) { 
        const difference_type _Off = _Where - begin();
        insert(static_cast<size_type>(_Off), 1, _Ch);
        return begin() + _Off;
    }
    iterator insert(const const_iterator _Where,  const size_type _Count, const _Elem _Ch) {
        const difference_type _Off = _Where - begin();
        insert(static_cast<size_type>(_Off), _Count, _Ch);
        return begin() + _Off;
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
        const difference_type _Off = _Where - begin();
        replace(_Where, _Where, _First, _Last);
        return begin() + _Off;
    }
    basic_string& erase(const size_type _Off = 0) { 
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        _Eos(_Off);
        return *this;
    }
    basic_string& erase(const size_type _Off, size_type _Count) { 
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        _Count                    = _My_data._Clamp_suffix_size(_Off, _Count);
        const size_type _Old_size = _My_data._Mysize;
        _Elem* const _My_ptr      = _My_data._Myptr();
        _Elem* const _Erase_at    = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _My_data._Mysize          = _New_size;
        _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); 
        return *this;
    }
    iterator erase(const const_iterator _Where) { 
        const difference_type _Off = _Where - begin();
        erase(static_cast<size_type>(_Off), 1);
        return begin() + _Off;
    }
    iterator erase(const const_iterator _First, const const_iterator _Last) { 
        _Adl_verify_range(_First, _Last);
        const difference_type _Off = _First - begin();
        erase(static_cast<size_type>(_Off), static_cast<size_type>(_Last - _First));
        return begin() + _Off;
    }
    void clear() noexcept { 
        _Eos(0);
    }
    basic_string& replace(const size_type _Off, const size_type _N0,
        const basic_string& _Right) { 
        auto& _Right_data = _Right._Get_data();
        return replace(_Off, _N0, _Right_data._Myptr(), _Right_data._Mysize);
    }
    basic_string& replace(const size_type _Off, size_type _N0, const basic_string& _Right, const size_type _Roff,
        size_type _Count = npos) { 
        auto& _Right_data = _Right._Get_data();
        _Right_data._Check_offset(_Roff);
        _Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
        return replace(_Off, _N0, _Right_data._Myptr() + _Roff, _Count);
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& replace(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right) {
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return replace(_Off, _N0, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& replace(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right,
        const size_type _Roff, const size_type _Count = npos) {
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return replace(_Off, _N0, _As_view.substr(_Roff, _Count));
    }
#line 2913 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    basic_string& replace(
        const size_type _Off, size_type _N0,   const _Elem* const _Ptr, const size_type _Count) {
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        _N0 = _My_data._Clamp_suffix_size(_Off, _N0);
        if (_N0 == _Count) { 
            _Traits::move(_My_data._Myptr() + _Off, _Ptr, _Count);
            return *this;
        }
        const size_type _Old_size    = _My_data._Mysize;
        const size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
        if (_Count < _N0) { 
            _My_data._Mysize        = _Old_size - (_N0 - _Count);
            _Elem* const _Old_ptr   = _My_data._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at, _Ptr, _Count);
            _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Suffix_size);
            return *this;
        }
        const size_type _Growth = static_cast<size_type>(_Count - _N0);
        if (_Growth <= _My_data._Myres - _Old_size) { 
            _My_data._Mysize        = _Old_size + _Growth;
            _Elem* const _Old_ptr   = _My_data._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Elem* const _Suffix_at = _Insert_at + _N0;
            size_type _Ptr_shifted_after; 
            if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                _Ptr_shifted_after = _Count;
            } else if (_Suffix_at <= _Ptr) {
                _Ptr_shifted_after = 0;
            } else {
                _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
            }
            _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
            _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }
        return _Reallocate_grow_by(_Growth,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _N0, const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
            },
            _Off, _N0, _Ptr, _Count);
    }
    basic_string& replace(const size_type _Off, const size_type _N0,
          const _Elem* const _Ptr) { 
        return replace(_Off, _N0, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }
    basic_string& replace(const size_type _Off, size_type _N0, const size_type _Count,
        const _Elem _Ch) { 
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        _N0 = _My_data._Clamp_suffix_size(_Off, _N0);
        if (_Count == _N0) {
            _Traits::assign(_My_data._Myptr() + _Off, _Count, _Ch);
            return *this;
        }
        const size_type _Old_size = _My_data._Mysize;
        if (_Count < _N0
            || _Count - _N0 <= _My_data._Myres - _Old_size) { 
            _My_data._Mysize = _Old_size + _Count - _N0; 
            _Elem* const _Old_ptr   = _My_data._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1);
            _Traits::assign(_Insert_at, _Count, _Ch);
            return *this;
        }
        return _Reallocate_grow_by(_Count - _N0,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _N0, const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
            },
            _Off, _N0, _Count, _Ch);
    }
    basic_string& replace(const const_iterator _First, const const_iterator _Last,
        const basic_string& _Right) { 
        return replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Right);
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    basic_string& replace(const const_iterator _First, const const_iterator _Last,
        const _StringViewIsh& _Right) { 
        return replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Right);
    }
#line 3023 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    basic_string& replace(const const_iterator _First, const const_iterator _Last,
          const _Elem* const _Ptr,
        const size_type _Count) { 
        return replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Ptr, _Count);
    }
    basic_string& replace(const const_iterator _First, const const_iterator _Last,
          const _Elem* const _Ptr) { 
        return replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Ptr);
    }
    basic_string& replace(const const_iterator _First, const const_iterator _Last, const size_type _Count,
        const _Elem _Ch) { 
        return replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Count, _Ch);
    }
    template <class _Iter>
    basic_string& _Replace_range(
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2, false_type) {
        const basic_string _Right(_First2, _Last2, get_allocator());
        replace(_First, _Last, _Right);
        return *this;
    }
    template <class _Ptr>
    basic_string& _Replace_range(
        const const_iterator _First, const const_iterator _Last, const _Ptr _First2, const _Ptr _Last2, true_type) {
        return replace(static_cast<size_type>(_First - cbegin()), static_cast<size_type>(_Last - _First), _First2,
            static_cast<size_type>(_Last2 - _First2));
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
        _Adl_verify_range(_First2, _Last2);
        const auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2  = _Get_unwrapped(_Last2);
        return _Replace_range(_First, _Last, _UFirst2, _ULast2, _Is_elem_cptr<decltype(_UFirst2)>());
    }
    [[nodiscard]] iterator begin() noexcept { 
        auto _My_data = ::std:: addressof(_Get_data());
        return iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data);
    }
    [[nodiscard]] const_iterator begin() const noexcept { 
        auto _My_data = ::std:: addressof(_Get_data());
        return const_iterator(_Refancy<const_pointer>(_My_data->_Myptr()), _My_data);
    }
    [[nodiscard]] iterator end() noexcept { 
        auto _My_data = ::std:: addressof(_Get_data());
        return iterator(
            _Refancy<pointer>(_My_data->_Myptr()) + static_cast<difference_type>(_My_data->_Mysize), _My_data);
    }
    [[nodiscard]] const_iterator end() const noexcept { 
        auto _My_data = ::std:: addressof(_Get_data());
        return const_iterator(
            _Refancy<const_pointer>(_My_data->_Myptr()) + static_cast<difference_type>(_My_data->_Mysize), _My_data);
    }
    _Elem* _Unchecked_begin() noexcept { 
        return _Get_data()._Myptr();
    }
    const _Elem* _Unchecked_begin() const noexcept { 
        return _Get_data()._Myptr();
    }
    _Elem* _Unchecked_end() noexcept { 
        auto& _My_data = _Get_data();
        return _My_data._Myptr() + _My_data._Mysize;
    }
    const _Elem* _Unchecked_end() const noexcept { 
        const auto& _My_data = _Get_data();
        return _My_data._Myptr() + _My_data._Mysize;
    }
    [[nodiscard]] reverse_iterator rbegin() noexcept { 
        return reverse_iterator(end());
    }
    [[nodiscard]] const_reverse_iterator rbegin() const
        noexcept { 
        return const_reverse_iterator(end());
    }
    [[nodiscard]] reverse_iterator rend() noexcept { 
        return reverse_iterator(begin());
    }
    [[nodiscard]] const_reverse_iterator rend() const noexcept { 
        return const_reverse_iterator(begin());
    }
    [[nodiscard]] const_iterator cbegin() const noexcept { 
        return begin();
    }
    [[nodiscard]] const_iterator cend() const noexcept { 
        return end();
    }
    [[nodiscard]] const_reverse_iterator crbegin() const
        noexcept { 
        return rbegin();
    }
    [[nodiscard]] const_reverse_iterator crend() const noexcept { 
        return rend();
    }
    void shrink_to_fit() { 
        auto& _My_data = _Get_data();
        if (!_My_data._Large_string_engaged()) { 
            return;
        }
        if (_My_data._Mysize < _BUF_SIZE) {
            _Become_small();
            return;
        }
        const size_type _Target_capacity = _Min_value(_My_data._Mysize | _ALLOC_MASK, max_size());
        if (_Target_capacity < _My_data._Myres) { 
            auto& _Al              = _Getal();
            const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); 
            _Orphan_all();
            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
            _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
            _My_data._Bx._Ptr = _New_ptr;
            _My_data._Myres   = _Target_capacity;
        }
    }
    [[nodiscard]] reference at(const size_type _Off) { 
        auto& _My_data = _Get_data();
        _My_data._Check_offset_exclusive(_Off);
        return _My_data._Myptr()[_Off];
    }
    [[nodiscard]] const_reference at(const size_type _Off) const { 
        auto& _My_data = _Get_data();
        _My_data._Check_offset_exclusive(_Off);
        return _My_data._Myptr()[_Off];
    }
    [[nodiscard]] reference operator[](const size_type _Off) { 
        auto& _My_data = _Get_data();
        do { if (_Off <= _My_data._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 3179, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string subscript out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 3179, 0); } while (false); } ; } while (false);
#line 3181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return _My_data._Myptr()[_Off];
    }
    [[nodiscard]] const_reference operator[](const size_type _Off) const { 
        auto& _My_data = _Get_data();
        do { if (_Off <= _My_data._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 3187, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string subscript out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 3187, 0); } while (false); } ; } while (false);
#line 3189 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        return _My_data._Myptr()[_Off];
    }
     operator basic_string_view<_Elem, _Traits>() const
        noexcept { 
        auto& _My_data = _Get_data();
        return basic_string_view<_Elem, _Traits>(_My_data._Myptr(), _My_data._Mysize);
    }
#line 3199 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    void push_back(const _Elem _Ch) { 
        auto& _My_data            = _Get_data();
        const size_type _Old_size = _My_data._Mysize;
        if (_Old_size < _My_data._Myres) {
            _My_data._Mysize  = _Old_size + 1;
            _Elem* const _Ptr = _My_data._Myptr();
            _Traits::assign(_Ptr[_Old_size], _Ch);
            _Traits::assign(_Ptr[_Old_size + 1], _Elem());
            return;
        }
        _Reallocate_grow_by(1,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr[_Old_size], _Ch);
                _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
            },
            _Ch);
    }
    void pop_back() { 
        auto& _My_data            = _Get_data();
        const size_type _Old_size = _My_data._Mysize;
        do { if (_Old_size != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 3224, 0, "%s", "invalid to pop_back empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid to pop_back empty string\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring", 3224, 0); } while (false); } ; } while (false);
#line 3226 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        _Eos(_Old_size - 1);
    }
    [[nodiscard]] reference front() { 
        return *begin();
    }
    [[nodiscard]] const_reference front() const { 
        return *begin();
    }
    [[nodiscard]] reference back() { 
        return *(end() - 1);
    }
    [[nodiscard]] const_reference back() const { 
        return *(end() - 1);
    }
    [[nodiscard]]   const _Elem* c_str() const noexcept { 
        return _Get_data()._Myptr();
    }
    [[nodiscard]]   const _Elem* data() const noexcept { 
        return _Get_data()._Myptr();
    }
    [[nodiscard]]   _Elem* data() noexcept { 
        return _Get_data()._Myptr();
    }
#line 3258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    [[nodiscard]] size_type length() const noexcept { 
        return _Get_data()._Mysize;
    }
    [[nodiscard]] size_type size() const noexcept { 
        return _Get_data()._Mysize;
    }
    [[nodiscard]] size_type max_size() const noexcept { 
        const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
        const size_type _Storage_max = 
            _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
        return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),
            _Storage_max - 1 
        );
    }
    void resize( const size_type _Newsize, const _Elem _Ch = _Elem()) {
        const size_type _Old_size = size();
        if (_Newsize <= _Old_size) {
            _Eos(_Newsize);
        } else {
            append(_Newsize - _Old_size, _Ch);
        }
    }
    [[nodiscard]] size_type capacity() const noexcept { 
        return _Get_data()._Myres;
    }
    void reserve( const size_type _Newcap = 0) { 
        auto& _My_data = _Get_data();
        if (_My_data._Mysize > _Newcap) { 
            return; 
        }
        if (_My_data._Myres == _Newcap) { 
            return; 
        }
        if (_My_data._Myres < _Newcap) { 
            const size_type _Old_size = _My_data._Mysize;
            _Reallocate_grow_by(
                _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
                    _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
                });
            _My_data._Mysize = _Old_size;
            return;
        }
        if (_BUF_SIZE > _Newcap
            && _My_data._Large_string_engaged()) { 
            _Become_small();
            return;
        }
    }
    [[nodiscard]] bool empty() const noexcept { 
        return size() == 0;
    }
    size_type copy(  _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        _Count = _My_data._Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _My_data._Myptr() + _Off, _Count);
        return _Count;
    }
      size_type _Copy_s(  _Elem* const _Dest,
        const size_type _Dest_size, size_type _Count, const size_type _Off = 0) const {
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        _Count = _My_data._Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _My_data._Myptr() + _Off, _Count);
        return _Count;
    }
    void _Swap_data(basic_string& _Right, true_type) {
        const auto _My_data_mem = reinterpret_cast<unsigned char*>(::std:: addressof(_Get_data())) + _Memcpy_move_offset;
        const auto _Right_data_mem =
            reinterpret_cast<unsigned char*>(::std:: addressof(_Right._Get_data())) + _Memcpy_move_offset;
        unsigned char _Temp_mem[_Memcpy_move_size];
        :: memcpy(_Temp_mem, _My_data_mem, _Memcpy_move_size);
        :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
        :: memcpy(_Right_data_mem, _Temp_mem, _Memcpy_move_size);
    }
    void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small) {
        const pointer _Ptr = _Starts_large._Bx._Ptr;
        auto& _Al          = _Getal();
        _Alty_traits::destroy(_Al, ::std:: addressof(_Starts_large._Bx._Ptr));
        _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);
        _Alty_traits::construct(_Al, ::std:: addressof(_Starts_small._Bx._Ptr), _Ptr);
    }
    void _Swap_data(basic_string& _Right, false_type) {
        auto& _My_data          = _Get_data();
        auto& _Right_data       = _Right._Get_data();
        const bool _My_large    = _My_data._Large_string_engaged();
        const bool _Right_large = _Right_data._Large_string_engaged();
        if (_My_large) {
            if (_Right_large) { 
                _Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            } else { 
                _Swap_bx_large_with_small(_My_data, _Right_data);
            }
        } else {
            if (_Right_large) { 
                _Swap_bx_large_with_small(_Right_data, _My_data);
            } else {
                _Elem _Temp_buf[_BUF_SIZE];
                _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _BUF_SIZE);
                _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _BUF_SIZE);
                _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _BUF_SIZE);
            }
        }
        ::std:: swap(_My_data._Mysize, _Right_data._Mysize);
        ::std:: swap(_My_data._Myres, _Right_data._Myres);
    }
    void swap(basic_string& _Right) noexcept { 
        if (this != ::std:: addressof(_Right)) { 
            _Pocs(_Getal(), _Right._Getal());
            auto& _My_data          = _Get_data();
            auto& _Right_data       = _Right._Get_data();
            const bool _My_large    = _My_data._Large_string_engaged();
            const bool _Right_large = _Right_data._Large_string_engaged();
            if (!_My_large) {
                _My_data._Orphan_all();
            }
            if (!_Right_large) {
                _Right_data._Orphan_all();
            }
            if (_My_large || _Right_large) {
                _My_data._Swap_proxy_and_iterators(_Right_data);
            }
#line 3412 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
        }
        _Swap_data(_Right, _Use_memcpy_move{});
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    [[nodiscard]] size_type find(
        const _StringViewIsh& _Right, const size_type _Off = 0) const { 
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        auto& _My_data                             = _Get_data();
        return static_cast<size_type>(
            _Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 3427 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    [[nodiscard]] size_type find(const basic_string& _Right, const size_type _Off = 0) const
        noexcept { 
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        return static_cast<size_type>(_Traits_find<_Traits>(
            _My_data._Myptr(), _My_data._Mysize, _Off, _Right_data._Myptr(), _Right_data._Mysize));
    }
    [[nodiscard]] size_type find(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count));
    }
    [[nodiscard]] size_type find(  const _Elem* const _Ptr, const size_type _Off = 0) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(
            _Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }
    [[nodiscard]] size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    [[nodiscard]] size_type rfind(const _StringViewIsh& _Right, const size_type _Off = npos) const {
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        auto& _My_data                             = _Get_data();
        return static_cast<size_type>(
            _Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 3466 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    [[nodiscard]] size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept {
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _My_data._Myptr(), _My_data._Mysize, _Off, _Right_data._Myptr(), _Right_data._Mysize));
    }
    [[nodiscard]] size_type rfind(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count));
    }
    [[nodiscard]] size_type rfind(  const _Elem* const _Ptr, const size_type _Off = npos) const
        noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(
            _Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }
    [[nodiscard]] size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_rfind_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    [[nodiscard]] size_type find_first_of(const _StringViewIsh& _Right, const size_type _Off = 0) const {
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        auto& _My_data                             = _Get_data();
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
            _As_view.data(), _As_view.size(), _Is_specialization<_Traits, char_traits>{}));
    }
#line 3506 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    [[nodiscard]] size_type find_first_of(const basic_string& _Right, const size_type _Off = 0) const noexcept {
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
            _Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_first_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_first_of(  const _Elem* const _Ptr, const size_type _Off = 0) const
        noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr,
            _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    [[nodiscard]] size_type find_last_of(const _StringViewIsh& _Right, const size_type _Off = npos) const {
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        auto& _My_data                             = _Get_data();
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
            _As_view.data(), _As_view.size(), _Is_specialization<_Traits, char_traits>{}));
    }
#line 3547 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    [[nodiscard]] size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept {
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
            _Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_last_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_last_of(  const _Elem* const _Ptr, const size_type _Off = npos) const
        noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr,
            _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_rfind_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    [[nodiscard]] size_type find_first_not_of(const _StringViewIsh& _Right, const size_type _Off = 0) const {
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        auto& _My_data                             = _Get_data();
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
            _As_view.data(), _As_view.size(), _Is_specialization<_Traits, char_traits>{}));
    }
#line 3588 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    [[nodiscard]] size_type find_first_not_of(const basic_string& _Right, const size_type _Off = 0) const
        noexcept { 
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
            _Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_first_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_first_not_of(  const _Elem* const _Ptr, size_type _Off = 0) const
        noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
            _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_not_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    [[nodiscard]] size_type find_last_not_of(const _StringViewIsh& _Right, const size_type _Off = npos) const {
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        auto& _My_data                             = _Get_data();
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
            _As_view.data(), _As_view.size(), _Is_specialization<_Traits, char_traits>{}));
    }
#line 3629 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    [[nodiscard]] size_type find_last_not_of(const basic_string& _Right, const size_type _Off = npos) const noexcept {
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
            _Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_last_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_last_not_of(  const _Elem* const _Ptr, const size_type _Off = npos) const
        noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr,
            _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
    }
    [[nodiscard]] size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept { 
        auto& _My_data = _Get_data();
        return static_cast<size_type>(_Traits_rfind_not_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch));
    }
    [[nodiscard]] bool _Starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>(*this)._Starts_with(_Right);
    }
#line 3666 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    [[nodiscard]] basic_string substr(const size_type _Off = 0, const size_type _Count = npos) const {
        return basic_string(*this, _Off, _Count, get_allocator());
    }
    bool _Equal(const basic_string& _Right) const noexcept { 
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        return _Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Right_data._Myptr(), _Right_data._Mysize);
    }
    bool _Equal(  const _Elem* const _Ptr) const noexcept { 
        auto& _My_data = _Get_data();
        return _Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr));
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    [[nodiscard]] int compare(const _StringViewIsh& _Right) const { 
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        auto& _My_data                             = _Get_data();
        return _Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize, _As_view.data(), _As_view.size());
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    [[nodiscard]] int compare(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right) const {
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        auto& _My_data                             = _Get_data();
        _My_data._Check_offset(_Off);
        return _Traits_compare<_Traits>(
            _My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0), _As_view.data(), _As_view.size());
    }
    template <class _StringViewIsh, class = _Is_string_view_ish<_StringViewIsh>>
    [[nodiscard]] int compare(const size_type _Off, const size_type _N0, const _StringViewIsh& _Right,
        const size_type _Roff, const size_type _Count = npos) const {
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        auto& _My_data                             = _Get_data();
        _My_data._Check_offset(_Off);
        const auto _With_substr = _As_view.substr(_Roff, _Count);
        return _Traits_compare<_Traits>(
            _My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0), _With_substr.data(), _With_substr.size());
    }
#line 3713 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    [[nodiscard]] int compare(const basic_string& _Right) const noexcept { 
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        return _Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Right_data._Myptr(), _Right_data._Mysize);
    }
    [[nodiscard]] int compare(size_type _Off, size_type _N0, const basic_string& _Right) const {
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        auto& _Right_data = _Right._Get_data();
        return _Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
            _Right_data._Myptr(), _Right_data._Mysize);
    }
    [[nodiscard]] int compare(const size_type _Off, const size_type _N0, const basic_string& _Right, const size_type _Roff,
        const size_type _Count = npos) const { 
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        _My_data._Check_offset(_Off);
        _Right_data._Check_offset(_Roff);
        return _Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
            _Right_data._Myptr() + _Roff, _Right_data._Clamp_suffix_size(_Roff, _Count));
    }
    [[nodiscard]] int compare(  const _Elem* const _Ptr) const noexcept { 
        auto& _My_data = _Get_data();
        return _Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr));
    }
    [[nodiscard]] int compare(const size_type _Off, const size_type _N0,   const _Elem* const _Ptr) const {
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        return _Traits_compare<_Traits>(
            _My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0), _Ptr, _Traits::length(_Ptr));
    }
    [[nodiscard]] int compare(const size_type _Off, const size_type _N0,   const _Elem* const _Ptr,
        const size_type _Count) const { 
        auto& _My_data = _Get_data();
        _My_data._Check_offset(_Off);
        return _Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0), _Ptr, _Count);
    }
    [[nodiscard]] allocator_type get_allocator() const noexcept { 
        return static_cast<allocator_type>(_Getal());
    }
private:
    size_type _Calculate_growth(const size_type _Requested) const { 
        const size_type _Max    = max_size();
        auto& _My_data          = _Get_data();
        const size_type _Masked = _Requested | _ALLOC_MASK;
        if (_Masked > _Max) { 
            return _Max;
        }
        const size_type _Old = _My_data._Myres;
        if (_Old > _Max - _Old / 2) { 
            return _Max;
        }
        return _Max_value(_Masked, _Old + _Old / 2);
    }
    template <class _Fty, class... _ArgTys>
    basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {
        if (_New_size > max_size()) {
            _Xlen(); 
        }
        auto& _My_data                = _Get_data();
        const size_type _Old_capacity = _My_data._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 
        _My_data._Orphan_all();
        _My_data._Mysize = _New_size;
        _My_data._Myres  = _New_capacity;
        _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
        if (_BUF_SIZE <= _Old_capacity) {
            _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);
            _My_data._Bx._Ptr = _New_ptr;
        } else {
            _Alty_traits::construct(_Al, ::std:: addressof(_My_data._Bx._Ptr), _New_ptr);
        }
        return *this;
    }
    template <class _Fty, class... _ArgTys>
    basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {
        auto& _My_data            = _Get_data();
        const size_type _Old_size = _My_data._Mysize;
        if (max_size() - _Old_size < _Size_increase) {
            _Xlen(); 
        }
        const size_type _New_size     = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data._Myres;
        const size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); 
        _My_data._Orphan_all();
        _My_data._Mysize      = _New_size;
        _My_data._Myres       = _New_capacity;
        _Elem* const _Raw_new = _Unfancy(_New_ptr);
        if (_BUF_SIZE <= _Old_capacity) {
            const pointer _Old_ptr = _My_data._Bx._Ptr;
            _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
            _Al.deallocate(_Old_ptr, _Old_capacity + 1);
            _My_data._Bx._Ptr = _New_ptr;
        } else {
            _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
            _Alty_traits::construct(_Al, ::std:: addressof(_My_data._Bx._Ptr), _New_ptr);
        }
        return *this;
    }
    void _Become_small() {
        auto& _My_data = _Get_data();
        _My_data._Orphan_all();
        const pointer _Ptr = _My_data._Bx._Ptr;
        auto& _Al          = _Getal();
        _Alty_traits::destroy(_Al, ::std:: addressof(_My_data._Bx._Ptr));
        _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
        _Al.deallocate(_Ptr, _My_data._Myres + 1);
        _My_data._Myres = _BUF_SIZE - 1;
    }
    void _Eos(const size_type _Newsize) { 
        auto& _My_data = _Get_data();
        _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());
    }
    void _Tidy_init() noexcept { 
        auto& _My_data   = _Get_data();
        _My_data._Mysize = 0;
        _My_data._Myres  = _BUF_SIZE - 1;
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    }
    void _Tidy_deallocate() noexcept { 
        _Orphan_all();
        auto& _My_data = _Get_data();
        if (_My_data._Large_string_engaged()) {
            const pointer _Ptr = _My_data._Bx._Ptr;
            auto& _Al          = _Getal();
            _Alty_traits::destroy(_Al, ::std:: addressof(_My_data._Bx._Ptr));
            _Al.deallocate(_Ptr, _My_data._Myres + 1);
        }
        _My_data._Mysize = 0;
        _My_data._Myres  = _BUF_SIZE - 1;
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    }
    [[noreturn]] static void _Xlen() { 
        _Xlength_error("string too long");
    }
public:
    void _Orphan_all() noexcept { 
        _Get_data()._Orphan_all();
    }
private:
    void _Swap_proxy_and_iterators(basic_string& _Right) { 
        _Get_data()._Swap_proxy_and_iterators(_Right._Get_data());
    }
    _Alty& _Getal() noexcept { 
        return _Mypair._Get_first();
    }
    const _Alty& _Getal() const noexcept { 
        return _Mypair._Get_first();
    }
    _Scary_val& _Get_data() noexcept { 
        return _Mypair._Get_second();
    }
    const _Scary_val& _Get_data() const noexcept { 
        return _Mypair._Get_second();
    }
    _Iterator_base12** _Getpfirst() const { 
        return _Get_data()._Getpfirst();
    }
    _Container_proxy*& _Myproxy() noexcept { 
        return _Get_data()._Myproxy;
    }
    _Container_proxy* const& _Myproxy() const noexcept { 
        return _Get_data()._Myproxy;
    }
#line 3928 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};
template <class _Iter, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
basic_string(_Iter, _Iter, _Alloc = _Alloc())
    ->basic_string<_Iter_value_t<_Iter>, char_traits<_Iter_value_t<_Iter>>, _Alloc>;
template <class _Elem, class _Traits, class _Alloc = allocator<_Elem>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
explicit basic_string(basic_string_view<_Elem, _Traits>, const _Alloc& = _Alloc())
    ->basic_string<_Elem, _Traits, _Alloc>;
template <class _Elem, class _Traits, class _Alloc = allocator<_Elem>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
basic_string(
    basic_string_view<_Elem, _Traits>, _Guide_size_type_t<_Alloc>, _Guide_size_type_t<_Alloc>, const _Alloc& = _Alloc())
    ->basic_string<_Elem, _Traits, _Alloc>;
#line 3949 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
template <class _Elem, class _Traits, class _Alloc>
inline void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { 
    _Left.swap(_Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    basic_string<_Elem, _Traits, _Alloc> _Ans;
    _Ans.reserve(_Left.size() + _Right.size());
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    using _String_type = basic_string<_Elem, _Traits, _Alloc>;
    using _Size_type   = typename _String_type::size_type;
    _String_type _Ans;
    _Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    basic_string<_Elem, _Traits, _Alloc> _Ans;
    _Ans.reserve(1 + _Right.size());
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left,
      const _Elem* const _Right) { 
    using _String_type = basic_string<_Elem, _Traits, _Alloc>;
    using _Size_type   = typename _String_type::size_type;
    _String_type _Ans;
    _Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const _Elem _Right) { 
    basic_string<_Elem, _Traits, _Alloc> _Ans;
    _Ans.reserve(_Left.size() + 1);
    _Ans += _Left;
    _Ans += _Right;
    return _Ans;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>&& _Right) { 
    return ::std:: move(_Right.insert(0, _Left));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    return ::std:: move(_Left.append(_Right));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left,
    basic_string<_Elem, _Traits, _Alloc>&& _Right) { 
    if (_Right.size() <= _Left.capacity() - _Left.size() || _Right.capacity() - _Right.size() < _Left.size()) {
        return ::std:: move(_Left.append(_Right));
    } else {
        return ::std:: move(_Right.insert(0, _Left));
    }
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) { 
    return ::std:: move(_Right.insert(0, _Left));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) { 
    using size_type = typename allocator_traits<_Alloc>::size_type;
    return ::std:: move(_Right.insert(static_cast<size_type>(0), static_cast<size_type>(1), _Left));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left,
      const _Elem* const _Right) { 
    return ::std:: move(_Left.append(_Right));
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left,
    const _Elem _Right) { 
    _Left.push_back(_Right);
    return ::std:: move(_Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator==(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { 
    return _Left._Equal(_Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator==(  const _Elem* const _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    return _Right._Equal(_Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator==(const basic_string<_Elem, _Traits, _Alloc>& _Left,
      const _Elem* const _Right) { 
    return _Left._Equal(_Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { 
    return !(_Left == _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator!=(  const _Elem* const _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    return !(_Left == _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left,
      const _Elem* const _Right) { 
    return !(_Left == _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { 
    return _Left.compare(_Right) < 0;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator<(
      const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    return _Right.compare(_Left) > 0;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left,
      const _Elem* const _Right) { 
    return _Left.compare(_Right) < 0;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { 
    return _Right < _Left;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator>(
      const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    return _Right < _Left;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left,
      const _Elem* const _Right) { 
    return _Right < _Left;
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { 
    return !(_Right < _Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator<=(
      const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    return !(_Right < _Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left,
      const _Elem* const _Right) { 
    return !(_Right < _Left);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left,
    const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept { 
    return !(_Left < _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator>=(
      const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) { 
    return !(_Left < _Right);
}
template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] inline bool operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left,
      const _Elem* const _Right) { 
    return !(_Left < _Right);
}
using string    = basic_string<char, char_traits<char>, allocator<char>>;
using wstring   = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;
template <class _Elem, class _Traits, class _Alloc>
struct hash<basic_string<_Elem, _Traits, _Alloc>> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const basic_string<_Elem, _Traits, _Alloc>& _Keyval) const
        noexcept { 
        return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());
    }
};
template <class _Elem, class _Traits, class _Alloc>
inline basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) { 
    using _Myis   = basic_istream<_Elem, _Traits>;
    using _Ctype  = typename _Myis::_Ctype;
    using _Mystr  = basic_string<_Elem, _Traits, _Alloc>;
    using _Mysizt = typename _Mystr::size_type;
    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed                  = false;
    const typename _Myis::sentry _Ok(_Istr);
    if (_Ok) { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());
        _Str.erase();
        try {
        _Mysizt _Size =
            0 < _Istr.width() && (_Mysizt) _Istr.width() < _Str.max_size() ? (_Mysizt) _Istr.width() : _Str.max_size();
        typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();
        for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= _Myis::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                break; 
            } else { 
                _Str.push_back(_Traits::to_char_type(_Meta));
                _Changed = true;
            }
        }
        } catch (...) { (_Istr) .setstate(_Myis::badbit, true); }
    }
    _Istr.width(0);
    if (!_Changed) {
        _State |= _Myis::failbit;
    }
    _Istr.setstate(_State);
    return _Istr;
}
template <class _Elem, class _Traits, class _Alloc>
inline basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) { 
    return ::std:: move(_Istr) >> _Str;
}
template <class _Elem, class _Traits, class _Alloc>
inline basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) { 
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}
inline namespace literals {
    inline namespace string_literals {
        [[nodiscard]] inline string operator"" s(
            const char* _Str, size_t _Len) { 
            return string(_Str, _Len);
        }
        [[nodiscard]] inline wstring operator"" s(
            const wchar_t* _Str, size_t _Len) { 
            return wstring(_Str, _Len);
        }
        [[nodiscard]] inline u16string operator"" s(
            const char16_t* _Str, size_t _Len) { 
            return u16string(_Str, _Len);
        }
        [[nodiscard]] inline u32string operator"" s(
            const char32_t* _Str, size_t _Len) { 
            return u32string(_Str, _Len);
        }
    } 
} 
namespace pmr {
    template <class _Elem, class _Traits = char_traits<_Elem>>
    using basic_string = ::std:: basic_string<_Elem, _Traits, polymorphic_allocator<_Elem>>;
    using string    = basic_string<char>;
    using u16string = basic_string<char16_t>;
    using u32string = basic_string<char32_t>;
    using wstring   = basic_string<wchar_t>;
} 
#line 4277 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
}
#pragma warning(pop)
#pragma pack(pop)
#line 4284 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
#line 4285 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xstring"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
class logic_error : public exception { 
public:
    using _Mybase = exception;
    explicit logic_error(const string& _Message) : _Mybase(_Message.c_str()) { 
    }
    explicit logic_error(const char* _Message) : _Mybase(_Message) { 
    }
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
};
class domain_error : public logic_error { 
public:
    using _Mybase = logic_error;
    explicit domain_error(const string& _Message) : _Mybase(_Message.c_str()) { 
    }
    explicit domain_error(const char* _Message) : _Mybase(_Message) { 
    }
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
};
class invalid_argument : public logic_error { 
public:
    using _Mybase = logic_error;
    explicit invalid_argument(const string& _Message) : _Mybase(_Message.c_str()) { 
    }
    explicit invalid_argument(const char* _Message) : _Mybase(_Message) { 
    }
#line 77 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
};
class length_error : public logic_error { 
public:
    using _Mybase = logic_error;
    explicit length_error(const string& _Message) : _Mybase(_Message.c_str()) { 
    }
    explicit length_error(const char* _Message) : _Mybase(_Message) { 
    }
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
};
class out_of_range : public logic_error { 
public:
    using _Mybase = logic_error;
    explicit out_of_range(const string& _Message) : _Mybase(_Message.c_str()) { 
    }
    explicit out_of_range(const char* _Message) : _Mybase(_Message) { 
    }
#line 119 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
};
class runtime_error : public exception { 
public:
    using _Mybase = exception;
    explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { 
    }
    explicit runtime_error(const char* _Message) : _Mybase(_Message) { 
    }
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
};
class overflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;
    explicit overflow_error(const string& _Message) : _Mybase(_Message.c_str()) { 
    }
    explicit overflow_error(const char* _Message) : _Mybase(_Message) { 
    }
#line 161 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
};
class underflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;
    explicit underflow_error(const string& _Message) : _Mybase(_Message.c_str()) { 
    }
    explicit underflow_error(const char* _Message) : _Mybase(_Message) { 
    }
#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
};
class range_error : public runtime_error { 
public:
    using _Mybase = runtime_error;
    explicit range_error(const string& _Message) : _Mybase(_Message.c_str()) { 
    }
    explicit range_error(const char* _Message) : _Mybase(_Message) { 
    }
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
};
}
#pragma warning(pop)
#pragma pack(pop)
#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stdexcept"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\system_error"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xcall_once.h"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
struct once_flag { 
    constexpr once_flag() noexcept : _Opaque(nullptr) { 
    }
    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;
    void* _Opaque;
};
using _Execute_once_fp_t = int(__stdcall*)(void*, void*, void**);
 int __cdecl _Execute_once(
    once_flag& _Flag, _Execute_once_fp_t _Callback, void* _Pv) noexcept;
}
#pragma warning(pop)
#pragma pack(pop)
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xcall_once.h"
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xcall_once.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\system_error"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xerrc.h"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
enum class errc { 
    address_family_not_supported       = 102, 
    address_in_use                     = 100, 
    address_not_available              = 101, 
    already_connected                  = 113, 
    argument_list_too_long             = 7, 
    argument_out_of_domain             = 33, 
    bad_address                        = 14, 
    bad_file_descriptor                = 9, 
    bad_message                        = 104, 
    broken_pipe                        = 32, 
    connection_aborted                 = 106, 
    connection_already_in_progress     = 103, 
    connection_refused                 = 107, 
    connection_reset                   = 108, 
    cross_device_link                  = 18, 
    destination_address_required       = 109, 
    device_or_resource_busy            = 16, 
    directory_not_empty                = 41, 
    executable_format_error            = 8, 
    file_exists                        = 17, 
    file_too_large                     = 27, 
    filename_too_long                  = 38, 
    function_not_supported             = 40, 
    host_unreachable                   = 110, 
    identifier_removed                 = 111, 
    illegal_byte_sequence              = 42, 
    inappropriate_io_control_operation = 25, 
    interrupted                        = 4, 
    invalid_argument                   = 22, 
    invalid_seek                       = 29, 
    io_error                           = 5, 
    is_a_directory                     = 21, 
    message_size                       = 115, 
    network_down                       = 116, 
    network_reset                      = 117, 
    network_unreachable                = 118, 
    no_buffer_space                    = 119, 
    no_child_process                   = 10, 
    no_link                            = 121, 
    no_lock_available                  = 39, 
    no_message_available               = 120, 
    no_message                         = 122, 
    no_protocol_option                 = 123, 
    no_space_on_device                 = 28, 
    no_stream_resources                = 124, 
    no_such_device_or_address          = 6, 
    no_such_device                     = 19, 
    no_such_file_or_directory          = 2, 
    no_such_process                    = 3, 
    not_a_directory                    = 20, 
    not_a_socket                       = 128, 
    not_a_stream                       = 125, 
    not_connected                      = 126, 
    not_enough_memory                  = 12, 
    not_supported                      = 129, 
    operation_canceled                 = 105, 
    operation_in_progress              = 112, 
    operation_not_permitted            = 1, 
    operation_not_supported            = 130, 
    operation_would_block              = 140, 
    owner_dead                         = 133, 
    permission_denied                  = 13, 
    protocol_error                     = 134, 
    protocol_not_supported             = 135, 
    read_only_file_system              = 30, 
    resource_deadlock_would_occur      = 36, 
    resource_unavailable_try_again     = 11, 
    result_out_of_range                = 34, 
    state_not_recoverable              = 127, 
    stream_timeout                     = 137, 
    text_file_busy                     = 139, 
    timed_out                          = 138, 
    too_many_files_open_in_system      = 23, 
    too_many_files_open                = 24, 
    too_many_links                     = 31, 
    too_many_symbolic_link_levels      = 114, 
    value_too_large                    = 132, 
    wrong_protocol_type                = 136 
};
}
#pragma warning(pop)
#pragma pack(pop)
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xerrc.h"
#line 108 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xerrc.h"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\system_error"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
enum class io_errc { 
    stream = 1
};
template <class _Enum>
struct is_error_code_enum : false_type { 
};
template <>
struct is_error_code_enum<io_errc> : true_type { 
};
template <class _Ty>
inline constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;
template <class _Enum>
struct is_error_condition_enum : false_type { 
};
template <>
struct is_error_condition_enum<errc> : true_type { 
};
template <class _Ty>
inline constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;
class error_code;
class error_condition;
[[nodiscard]] error_code make_error_code(errc) noexcept;
[[nodiscard]] error_code make_error_code(io_errc) noexcept;
[[nodiscard]] error_condition make_error_condition(errc) noexcept;
[[nodiscard]] error_condition make_error_condition(io_errc) noexcept;
class error_category;
[[nodiscard]] const error_category& generic_category() noexcept;
[[nodiscard]] const error_category& iostream_category() noexcept;
[[nodiscard]] const error_category& system_category() noexcept;
class __declspec(novtable) error_category { 
public:
     error_category() noexcept { 
        _Addr = reinterpret_cast<uintptr_t>(this);
    }
    virtual ~error_category() noexcept {}
    [[nodiscard]] virtual const char* name() const noexcept = 0;
    [[nodiscard]] virtual string message(int _Errval) const = 0;
    [[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept;
    [[nodiscard]] virtual bool equivalent(int _Errval, const error_condition& _Cond) const noexcept;
    [[nodiscard]] virtual bool equivalent(const error_code& _Code, int _Errval) const noexcept;
    [[nodiscard]] bool operator==(const error_category& _Right) const noexcept { 
        return _Addr == _Right._Addr;
    }
    [[nodiscard]] bool operator!=(const error_category& _Right) const noexcept { 
        return !(*this == _Right);
    }
    [[nodiscard]] bool operator<(const error_category& _Right) const noexcept { 
        return _Addr < _Right._Addr;
    }
    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;
protected:
    uintptr_t _Addr;
    enum : uintptr_t { 
        _Future_addr   = 1,
        _Generic_addr  = 3,
        _Iostream_addr = 5,
        _System_addr   = 7
    };
};
class error_code { 
public:
    error_code() noexcept : _Myval(0), _Mycat(&system_category()) { 
    }
    error_code(int _Val, const error_category& _Cat) noexcept
        : _Myval(_Val), _Mycat(&_Cat) { 
    }
    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) { 
        *this = make_error_code(_Errcode); 
    }
    void assign(int _Val, const error_category& _Cat) noexcept { 
        _Myval = _Val;
        _Mycat = &_Cat;
    }
    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code& operator=(_Enum _Errcode) noexcept { 
        *this = make_error_code(_Errcode); 
        return *this;
    }
    void clear() noexcept { 
        _Myval = 0;
        _Mycat = &system_category();
    }
    [[nodiscard]] int value() const noexcept { 
        return _Myval;
    }
    [[nodiscard]] const error_category& category() const noexcept { 
        return *_Mycat;
    }
    [[nodiscard]] error_condition default_error_condition() const noexcept;
    [[nodiscard]] string message() const { 
        return category().message(value());
    }
    explicit operator bool() const noexcept { 
        return value() != 0;
    }
private:
    int _Myval; 
    const error_category* _Mycat; 
};
class error_condition { 
public:
    error_condition() noexcept : _Myval(0), _Mycat(&generic_category()) { 
    }
    error_condition(int _Val, const error_category& _Cat) noexcept
        : _Myval(_Val), _Mycat(&_Cat) { 
    }
    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) { 
        *this = make_error_condition(_Errcode); 
    }
    void assign(int _Val, const error_category& _Cat) noexcept { 
        _Myval = _Val;
        _Mycat = &_Cat;
    }
    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition& operator=(_Enum _Errcode) noexcept { 
        *this = make_error_condition(_Errcode); 
        return *this;
    }
    void clear() noexcept { 
        _Myval = 0;
        _Mycat = &generic_category();
    }
    [[nodiscard]] int value() const noexcept { 
        return _Myval;
    }
    [[nodiscard]] const error_category& category() const noexcept { 
        return *_Mycat;
    }
    [[nodiscard]] string message() const { 
        return category().message(value());
    }
    explicit operator bool() const noexcept { 
        return value() != 0;
    }
private:
    int _Myval; 
    const error_category* _Mycat; 
};
[[nodiscard]] inline bool operator==(
    const error_code& _Left, const error_code& _Right) noexcept { 
    return _Left.category() == _Right.category() && _Left.value() == _Right.value();
}
[[nodiscard]] inline bool operator==(
    const error_code& _Left, const error_condition& _Right) noexcept { 
    return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value());
}
[[nodiscard]] inline bool operator==(
    const error_condition& _Left, const error_code& _Right) noexcept { 
    return _Right.category().equivalent(_Right.value(), _Left) || _Left.category().equivalent(_Right, _Left.value());
}
[[nodiscard]] inline bool operator==(
    const error_condition& _Left, const error_condition& _Right) noexcept { 
    return _Left.category() == _Right.category() && _Left.value() == _Right.value();
}
[[nodiscard]] inline bool operator!=(
    const error_code& _Left, const error_code& _Right) noexcept { 
    return !(_Left == _Right);
}
[[nodiscard]] inline bool operator!=(
    const error_code& _Left, const error_condition& _Right) noexcept { 
    return !(_Left == _Right);
}
[[nodiscard]] inline bool operator!=(
    const error_condition& _Left, const error_code& _Right) noexcept { 
    return !(_Left == _Right);
}
[[nodiscard]] inline bool operator!=(
    const error_condition& _Left, const error_condition& _Right) noexcept { 
    return !(_Left == _Right);
}
[[nodiscard]] inline bool operator<(const error_code& _Left, const error_code& _Right) noexcept { 
    return _Left.category() < _Right.category()
           || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
}
[[nodiscard]] inline bool operator<(
    const error_condition& _Left, const error_condition& _Right) noexcept { 
    return _Left.category() < _Right.category()
           || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
}
[[nodiscard]] inline error_condition error_category::default_error_condition(int _Errval) const
    noexcept { 
    return error_condition(_Errval, *this);
}
[[nodiscard]] inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const
    noexcept { 
    return default_error_condition(_Errval) == _Cond;
}
[[nodiscard]] inline bool error_category::equivalent(const error_code& _Code, int _Errval) const
    noexcept { 
    return *this == _Code.category() && _Code.value() == _Errval;
}
[[nodiscard]] inline error_condition error_code::default_error_condition() const
    noexcept { 
    return category().default_error_condition(value());
}
[[nodiscard]] inline error_code make_error_code(errc _Errno) noexcept { 
    return error_code((int) _Errno, generic_category());
}
[[nodiscard]] inline error_code make_error_code(io_errc _Errno) noexcept { 
    return error_code((int) _Errno, iostream_category());
}
[[nodiscard]] inline error_condition make_error_condition(errc _Errno) noexcept { 
    return error_condition((int) _Errno, generic_category());
}
[[nodiscard]] inline error_condition make_error_condition(io_errc _Errno) noexcept { 
    return error_condition((int) _Errno, iostream_category());
}
template <>
struct hash<error_code> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef error_code argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const error_code& _Keyval) const
        noexcept { 
        return hash<int>{}(_Keyval.value());
    }
};
template <>
struct hash<error_condition> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef error_condition argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const error_condition& _Keyval) const
        noexcept { 
        return hash<int>{}(_Keyval.value());
    }
};
class _System_error : public runtime_error { 
private:
    static string _Makestr(error_code _Errcode, string _Message) { 
        if (!_Message.empty()) {
            _Message.append(": ");
        }
        _Message.append(_Errcode.message());
        return _Message;
    }
protected:
    _System_error(error_code _Errcode, const string& _Message)
        : runtime_error(_Makestr(_Errcode, _Message)),
          _Mycode(_Errcode) { 
    }
    error_code _Mycode; 
};
class system_error : public _System_error { 
private:
    using _Mybase = _System_error;
public:
    system_error(error_code _Errcode) : _Mybase(_Errcode, "") { 
    }
    system_error(error_code _Errcode, const string& _Message)
        : _Mybase(_Errcode, _Message) { 
    }
    system_error(error_code _Errcode, const char* _Message)
        : _Mybase(_Errcode, _Message) { 
    }
    system_error(int _Errval, const error_category& _Errcat)
        : _Mybase(error_code(_Errval, _Errcat), "") { 
    }
    system_error(int _Errval, const error_category& _Errcat, const string& _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) { 
    }
    system_error(int _Errval, const error_category& _Errcat, const char* _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) { 
    }
    [[nodiscard]] const error_code& code() const noexcept { 
        return _Mycode;
    }
#line 394 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\system_error"
};
 const char* __cdecl _Syserror_map(int);
 int __cdecl _Winerror_map(int);
 unsigned long __cdecl _Winerror_message(
    unsigned long _Message_id, char* _Narrow, unsigned long _Size);
class _Generic_error_category : public error_category { 
public:
    _Generic_error_category() noexcept { 
        _Addr = _Generic_addr;
    }
    [[nodiscard]] virtual const char* name() const noexcept override { 
        return "generic";
    }
    [[nodiscard]] virtual string message(int _Errcode) const override { 
        return _Syserror_map(_Errcode);
    }
};
class _Iostream_error_category : public _Generic_error_category { 
public:
    _Iostream_error_category() noexcept { 
        _Addr = _Iostream_addr;
    }
    [[nodiscard]] virtual const char* name() const noexcept override { 
        return "iostream";
    }
    [[nodiscard]] virtual string message(int _Errcode) const override { 
        if (_Errcode == (int) io_errc::stream) {
            return "iostream stream error";
        } else {
            return _Generic_error_category::message(_Errcode);
        }
    }
};
class _System_error_category : public error_category { 
public:
    _System_error_category() noexcept { 
        _Addr = _System_addr;
    }
    [[nodiscard]] virtual const char* name() const noexcept override { 
        return "system";
    }
    [[nodiscard]] virtual string message(int _Errcode) const override { 
        const unsigned long _Size = 32767;
        string _Narrow(_Size, '\0');
        const unsigned long _Val = _Winerror_message(static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);
        if (_Val == 0) {
            _Narrow = "unknown error";
        } else {
            _Narrow.resize(_Val);
        }
        _Narrow.shrink_to_fit();
        return _Narrow;
    }
    [[nodiscard]] virtual error_condition default_error_condition(int _Errval) const
        noexcept override { 
        const int _Posv = _Winerror_map(_Errval);
        if (_Posv == 0) {
            return error_condition(_Errval, system_category());
        } else {
            return error_condition(_Posv, generic_category());
        }
    }
};
template <class _Ty>
inline int __stdcall _Immortalize_impl(
    void*, void* _Storage_ptr, void**) noexcept { 
    ::new (_Storage_ptr) _Ty();
    return 1;
}
template <class _Ty>
inline _Ty& _Immortalize() { 
    static_assert(sizeof(void*) == sizeof(once_flag), "TRANSITION, VSO#406237");
    static_assert(alignof(void*) == alignof(once_flag), "TRANSITION, VSO#406237");
    static void* _Flag = nullptr;
    static aligned_union_t<1, _Ty> _Storage;
    if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage)
        == 0) { 
        ::std:: terminate();
    }
    return reinterpret_cast<_Ty&>(_Storage);
}
#line 514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\system_error"
[[nodiscard]] inline const error_category& generic_category() noexcept { 
    return _Immortalize<_Generic_error_category>();
}
[[nodiscard]] inline const error_category& iostream_category() noexcept { 
    return _Immortalize<_Iostream_error_category>();
}
[[nodiscard]] inline const error_category& system_category() noexcept { 
    return _Immortalize<_System_error_category>();
}
}
#pragma warning(pop)
#pragma pack(pop)
#line 532 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\system_error"
#line 533 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\system_error"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xfacet"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
class  _Facet_base { 
public:
    virtual  ~_Facet_base() noexcept { 
    }
    virtual void  _Incref() noexcept = 0;
    virtual _Facet_base*  _Decref() noexcept = 0;
};
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base*);
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xfacet"
}
#pragma warning(pop)
#pragma pack(pop)
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xfacet"
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xfacet"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
   int __cdecl _isctype(  int _C,   int _Type);
   int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
    int __cdecl isalpha(  int _C);
   int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
    int __cdecl isupper(  int _C);
   int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
    int __cdecl islower(  int _C);
   int __cdecl _islower_l(  int _C,   _locale_t _Locale);
    int __cdecl isdigit(  int _C);
   int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
   int __cdecl isxdigit(  int _C);
   int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);
    int __cdecl isspace(  int _C);
   int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
   int __cdecl ispunct(  int _C);
   int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
   int __cdecl isblank(  int _C);
   int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
    int __cdecl isalnum(  int _C);
   int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
   int __cdecl isprint(  int _C);
   int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
   int __cdecl isgraph(  int _C);
   int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
   int __cdecl iscntrl(  int _C);
   int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);
    int __cdecl toupper(  int _C);
    int __cdecl tolower(  int _C);
    int __cdecl _tolower(  int _C);
   int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
    int __cdecl _toupper(  int _C);
   int __cdecl _toupper_l(  int _C,   _locale_t _Locale);
   int __cdecl __isascii(  int _C);
   int __cdecl __toascii(  int _C);
   int __cdecl __iscsymf(  int _C);
   int __cdecl __iscsym(  int _C);
__inline int __cdecl __acrt_locale_get_ctype_array_value(
      unsigned short const * const _Locale_pctype_array,
              int                    const _Char_value,
                             int                    const _Mask
    )
{
    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }
    return 0;
}
         int __cdecl _chvalidator(  int _Ch,   int _Mask);
#line 133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }
     int __cdecl _chvalidator_l(  _locale_t,   int _Ch,   int _Mask);
    #line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        return _chvalidator_l(_Locale, _C, _Mask);
#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
    }
    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }
        return _chvalidchk_l(_C, _Mask, _Locale);
    }
#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
} __pragma(pack(pop))
#line 253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\locale.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};
struct tm;
     void __cdecl _lock_locales(void);
     void __cdecl _unlock_locales(void);
     int __cdecl _configthreadlocale(
          int _Flag
        );
     char* __cdecl setlocale(
                int         _Category,
          char const* _Locale
        );
     struct lconv* __cdecl localeconv(void);
     _locale_t __cdecl _get_current_locale(void);
     _locale_t __cdecl _create_locale(
            int         _Category,
          char const* _Locale
        );
     void __cdecl _free_locale(
          _locale_t _Locale
        );
     wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );
     _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );
     wchar_t**    __cdecl ___lc_locale_name_func(void);
     unsigned int __cdecl ___lc_codepage_func   (void);
     unsigned int __cdecl ___lc_collate_cp_func (void);
     char*    __cdecl _Getdays(void);
     char*    __cdecl _Getmonths(void);
     void*    __cdecl _Gettnames(void);
     wchar_t* __cdecl _W_Getdays(void);
     wchar_t* __cdecl _W_Getmonths(void);
     void*    __cdecl _W_Gettnames(void);
     size_t __cdecl _Strftime(
          char*           _Buffer,
                              size_t           _Max_size,
                            char const*      _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg);
     size_t __cdecl _Wcsftime(
          wchar_t*        _Buffer,
                              size_t           _Max_size,
                            wchar_t const*   _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg
        );
#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\locale.h"
} __pragma(pack(pop))
#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\locale.h"
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
extern "C" {
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
typedef struct _Collvec { 
    unsigned int _Page; 
    wchar_t* _LocaleName;
} _Collvec;
typedef struct _Ctypevec { 
    unsigned int _Page; 
    const short* _Table;
    int _Delfl;
    wchar_t* _LocaleName;
} _Ctypevec;
typedef struct _Cvtvec { 
    unsigned int _Page; 
    unsigned int _Mbcurmax;
    int _Isclocale; 
    unsigned char _Isleadbyte[32]; 
} _Cvtvec;
 _Collvec __cdecl _Getcoll(void);
 _Ctypevec __cdecl _Getctype(void);
 _Cvtvec __cdecl _Getcvt(void);
extern "C"
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
     int __cdecl
    _Getdateorder(void);
#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
 int __cdecl _Mbrtowc(  wchar_t*, const char*, size_t, mbstate_t*, const _Cvtvec*);
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
 float __cdecl _Stof(const char*,     char**, long);
 double __cdecl _Stod(const char*,     char**, long);
 long double __cdecl _Stold(const char*,     char**, long);
 int __cdecl _Strcoll(const char*, const char*, const char*, const char*, const _Collvec*);
 size_t __cdecl _Strxfrm( 
                                                            char* _String1,
      char* _End1, const char*, const char*, const _Collvec*);
 int __cdecl _Tolower(int, const _Ctypevec*);
 int __cdecl _Toupper(int, const _Ctypevec*);
 int __cdecl _Wcrtomb(  char*, wchar_t, mbstate_t*, const _Cvtvec*);
 int __cdecl _Wcscoll(
    const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*);
 size_t __cdecl _Wcsxfrm(   
                                                          wchar_t* _String1,
      wchar_t* _End1, const wchar_t*, const wchar_t*, const _Collvec*);
 short __cdecl _Getwctype(wchar_t, const _Ctypevec*);
 const wchar_t* __cdecl _Getwctypes(
    const wchar_t*, const wchar_t*, short*, const _Ctypevec*);
 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec*);
 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec*);
}
#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
extern "C" {
     char* __cdecl _Getdays(void);
     char* __cdecl _Getmonths(void);
 void* __cdecl _Gettnames(void);
   size_t __cdecl _Strftime(
      char*,   size_t _Maxsize,   const char*,   const struct tm*,   void*);
     wchar_t* __cdecl _W_Getdays(void);
     wchar_t* __cdecl _W_Getmonths(void);
 void* __cdecl _W_Gettnames(void);
   size_t __cdecl _Wcsftime(  wchar_t*,   size_t _Maxsize,
      const wchar_t*,   const struct tm*,   void*);
}
 _locale_t __cdecl _GetLocaleForCP(unsigned int);
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
#pragma warning(pop)
#pragma pack(pop)
#line 163 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo.h"
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
class  _Timevec { 
public:
     _Timevec(void* _Ptr = nullptr) : _Timeptr(_Ptr) { 
    }
     _Timevec(const _Timevec& _Right) { 
        *this = _Right;
    }
     ~_Timevec() noexcept { 
        free(_Timeptr);
    }
    _Timevec&  operator=(const _Timevec& _Right) { 
        _Timeptr                        = _Right._Timeptr;
        ((_Timevec*) &_Right)->_Timeptr = nullptr;
        return *this;
    }
    void*  _Getptr() const { 
        return _Timeptr;
    }
private:
    void* _Timeptr; 
};
class  _Locinfo { 
public:
    using _Collvec  = ::_Collvec;
    using _Ctypevec = ::_Ctypevec;
    using _Cvtvec   = ::_Cvtvec;
    using _Timevec  = ::std:: _Timevec;
    static  void __cdecl _Locinfo_ctor(_Locinfo*, const char*);
    static  void __cdecl _Locinfo_ctor(_Locinfo*, int, const char*);
    static  void __cdecl _Locinfo_dtor(_Locinfo*);
    static  _Locinfo& __cdecl _Locinfo_Addcats(_Locinfo*, int, const char*);
     _Locinfo(const char* _Pch = "C")
        : _Lock(0)
#line 65 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo"
    { 
        if (_Pch == nullptr) {
            _Xruntime_error("bad locale name");
        }
        _Locinfo_ctor(this, _Pch);
    }
     _Locinfo(int _Cat, const char* _Pch)
        : _Lock(0)
#line 78 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo"
    { 
        if (_Pch == nullptr) {
            _Xruntime_error("bad locale name");
        }
        _Locinfo_ctor(this, _Cat, _Pch);
    }
     ~_Locinfo() noexcept { 
        _Locinfo_dtor(this);
    }
    _Locinfo&  _Addcats(int _Cat, const char* _Pch) { 
        if (_Pch == nullptr) {
            _Xruntime_error("bad locale name");
        }
        return _Locinfo_Addcats(this, _Cat, _Pch);
    }
    const char*  _Getname() const { 
        return _Newlocname._C_str();
    }
    _Collvec  _Getcoll() const { 
        return ::_Getcoll();
    }
    _Ctypevec  _Getctype() const { 
        return ::_Getctype();
    }
    _Cvtvec  _Getcvt() const { 
        return ::_Getcvt();
    }
    const lconv*  _Getlconv() const { 
        return localeconv();
    }
    _Timevec  _Gettnames() const { 
        return _Timevec(::_Gettnames());
    }
    const char*  _Getdays() const { 
        const char* _Ptr = ::_Getdays();
        if (_Ptr != nullptr) { 
            ((_Locinfo*) this)->_Days = _Ptr;
            free((void*) _Ptr);
        }
        return !_Days._Empty() ? _Days._C_str()
                               : ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
                                 ":Thu:Thursday:Fri:Friday:Sat:Saturday";
    }
    const char*  _Getmonths() const { 
        const char* _Ptr = ::_Getmonths();
        if (_Ptr != nullptr) { 
            ((_Locinfo*) this)->_Months = _Ptr;
            free((void*) _Ptr);
        }
        return !_Months._Empty() ? _Months._C_str()
                                 : ":Jan:January:Feb:February:Mar:March"
                                   ":Apr:April:May:May:Jun:June"
                                   ":Jul:July:Aug:August:Sep:September"
                                   ":Oct:October:Nov:November:Dec:December";
    }
    const char*  _Getfalse() const { 
        return "false";
    }
    const char*  _Gettrue() const { 
        return "true";
    }
    int  _Getdateorder() const { 
        return ::_Getdateorder();
    }
    _Timevec  _W_Gettnames() const { 
        return _Timevec(::_W_Gettnames());
    }
    const unsigned short*  _W_Getdays() const { 
        const wchar_t* _Ptr = ::_W_Getdays();
        if (_Ptr != nullptr) { 
            ((_Locinfo*) this)->_W_Days = _Ptr;
            free((void*) _Ptr);
        }
        return (const unsigned short*) (!_W_Days._Empty() ? _W_Days._C_str()
                                                          : L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
                                                            L":Thu:Thursday:Fri:Friday:Sat:Saturday");
    }
    const unsigned short*  _W_Getmonths() const { 
        const wchar_t* _Ptr = ::_W_Getmonths();
        if (_Ptr != nullptr) { 
            ((_Locinfo*) this)->_W_Months = _Ptr;
            free((void*) _Ptr);
        }
        return (const unsigned short*) (!_W_Months._Empty() ? _W_Months._C_str()
                                                            : L":Jan:January:Feb:February:Mar:March"
                                                              L":Apr:April:May:May:Jun:June"
                                                              L":Jul:July:Aug:August:Sep:September"
                                                              L":Oct:October:Nov:November:Dec:December");
    }
    _Locinfo(const _Locinfo&) = delete;
    _Locinfo& operator=(const _Locinfo&) = delete;
private:
    _Lockit _Lock; 
#line 201 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo"
    _Yarn<char> _Days; 
    _Yarn<char> _Months; 
    _Yarn<wchar_t> _W_Days; 
    _Yarn<wchar_t> _W_Months; 
    _Yarn<char> _Oldlocname; 
    _Yarn<char> _Newlocname; 
};
template <class _Elem>
inline int __cdecl _LStrcoll(const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { 
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2) {
        if (*_First1 < *_First2) {
            return -1; 
        } else if (*_First2 < *_First1) {
            return +1; 
        }
    }
    return _First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0;
}
template <>
inline int __cdecl _LStrcoll(const char* _First1, const char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector);
}
template <>
inline int __cdecl _LStrcoll(const wchar_t* _First1, const wchar_t* _Last1, const wchar_t* _First2,
    const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector);
}
template <class _Elem>
inline size_t __cdecl _LStrxfrm(_Elem* _First1, _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { 
    const ptrdiff_t _Count = _Last2 - _First2;
    if (_Count <= _Last1 - _First1) {
        :: memcpy(_First1, _First2, _Count * sizeof(_Elem));
    }
    return _Count;
}
template <>
inline size_t __cdecl _LStrxfrm(    char* _First1,
      char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}
template <>
inline size_t __cdecl _LStrxfrm(    wchar_t* _First1,
      wchar_t* _Last1, const wchar_t* _First2, const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}
}
#pragma warning(pop)
#pragma pack(pop)
#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo"
#line 270 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocinfo"
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Dummy>
class _Locbase { 
public:
     static const int collate  = ((1 << (1)) >> 1);
     static const int ctype    = ((1 << (2)) >> 1);
     static const int monetary = ((1 << (3)) >> 1);
     static const int numeric  = ((1 << (4)) >> 1);
     static const int time     = ((1 << (5)) >> 1);
     static const int messages = ((1 << (6)) >> 1);
     static const int all      = (((1 << ((6 + 1))) >> 1) - 1);
     static const int none     = 0;
};
template <class _Dummy>
const int _Locbase<_Dummy>::collate;
template <class _Dummy>
const int _Locbase<_Dummy>::ctype;
template <class _Dummy>
const int _Locbase<_Dummy>::monetary;
template <class _Dummy>
const int _Locbase<_Dummy>::numeric;
template <class _Dummy>
const int _Locbase<_Dummy>::time;
template <class _Dummy>
const int _Locbase<_Dummy>::messages;
template <class _Dummy>
const int _Locbase<_Dummy>::all;
template <class _Dummy>
const int _Locbase<_Dummy>::none;
template <class _Elem>
class collate;
struct  _Crt_new_delete { 
    void* __cdecl operator new(size_t _Size) { 
        void* _Ptr = operator new(_Size, nothrow);
        if (!_Ptr) {
            _Xbad_alloc();
        }
        return _Ptr;
    }
    void* __cdecl operator new(size_t _Size, const nothrow_t&) noexcept { 
        return _malloc_dbg(_Size > 0 ? _Size : 1, 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale", 68);
    }
    void __cdecl operator delete(void* _Ptr) noexcept { 
        :: free(_Ptr);
    }
    void __cdecl operator delete(void* _Ptr, const nothrow_t&) noexcept { 
        operator delete(_Ptr);
    }
    void* __cdecl operator new(size_t, void* _Ptr) noexcept { 
        return _Ptr;
    }
    void __cdecl operator delete(void*, void*) noexcept { 
    }
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
};
class locale : public _Locbase<int>, public _Crt_new_delete { 
public:
    using category = int;
    class  id { 
    public:
         id(size_t _Val = 0) : _Id(_Val) { 
        }
         operator size_t() { 
            if (_Id == 0) { 
                { ::std:: _Lockit _Lock(0);
                if (_Id == 0) {
                    _Id = static_cast<size_t>(++_Id_cnt);
                }
                }
            }
            return _Id;
        }
    private:
        size_t _Id; 
         static int _Id_cnt;
    public:
         id(const id&) = delete;
        id&  operator=(const id&) = delete;
    };
    class _Locimp;
    class  facet
        : public _Facet_base,
          public _Crt_new_delete { 
    private:
        friend struct _Facet_guard;
    public:
        static size_t __cdecl _Getcat(const facet** = nullptr,
            const locale* = nullptr) { 
            return static_cast<size_t>(-1);
        }
        virtual void  _Incref() noexcept override { 
            _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Myrefs));
        }
        virtual _Facet_base*  _Decref() noexcept override { 
            if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Myrefs)) == 0) {
                return this;
            }
            return nullptr;
        }
    private:
        _Atomic_counter_t _Myrefs; 
    protected:
        explicit  facet(size_t _Initrefs = 0)
            : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) 
        { 
        }
        virtual  ~facet() noexcept { 
        }
    public:
         facet(const facet&) = delete;
        facet&  operator=(const facet&) = delete;
    };
    struct _Facet_guard {
        facet* _Target;
        ~_Facet_guard() {
            if (_Target) {
                delete _Target->_Decref();
            }
        }
    };
    class  _Locimp : public facet { 
    protected:
         ~_Locimp() noexcept { 
            _Locimp_dtor(this);
        }
    private:
        static  _Locimp* __cdecl _New_Locimp(bool _Transparent = false);
        static  _Locimp* __cdecl _New_Locimp(const _Locimp& _Right);
        static  void __cdecl _Locimp_dtor(_Locimp*);
        static  void __cdecl _Locimp_Addfac(_Locimp*, facet*, size_t); 
        static void __cdecl _Locimp_ctor(_Locimp*, const _Locimp&);
        friend locale;
         _Locimp(bool _Transparent)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent),
              _Name("*") { 
        }
         _Locimp(const _Locimp& _Right)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
              _Xparent(_Right._Xparent), _Name(_Right._Name.c_str()) { 
            _Locimp_ctor(this, _Right);
        }
        void  _Addfac(facet* _Pfacet, size_t _Id) { 
            _Locimp_Addfac(this, _Pfacet, _Id);
        }
        static _Locimp* __cdecl _Makeloc(
            const _Locinfo&, category, _Locimp*, const locale*); 
        static void __cdecl _Makewloc(
            const _Locinfo&, category, _Locimp*, const locale*); 
        static void __cdecl _Makeushloc(
            const _Locinfo&, category, _Locimp*, const locale*); 
#line 214 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
        static void __cdecl _Makexloc(
            const _Locinfo&, category, _Locimp*, const locale*); 
        facet** _Facetvec; 
        size_t _Facetcount; 
        category _Catmask; 
        bool _Xparent; 
        _Yarn<char> _Name; 
         static _Locimp* _Clocptr;
    public:
        _Locimp&  operator=(const _Locimp&) = delete;
    };
    template <class _Elem, class _Traits, class _Alloc>
    bool operator()(
        const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
        const { 
        const auto& _Coll_fac = use_facet<::std:: collate<_Elem>>(*this);
        return _Coll_fac.compare(
                   _Left.c_str(), _Left.c_str() + _Left.size(), _Right.c_str(), _Right.c_str() + _Right.size())
               < 0;
    }
    template <class _Facet>
    locale combine(const locale& _Loc) const { 
        _Facet* _Facptr;
        try {
        _Facptr = (_Facet*) &use_facet<_Facet>(_Loc);
        } catch (...) {
        _Xruntime_error("locale::combine facet missing");
        }
        _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
        _Newimp->_Addfac(_Facptr, _Facet::id);
        _Newimp->_Catmask = none;
        _Newimp->_Name    = "*";
        return locale(_Newimp);
    }
    template <class _Facet>
    locale(const locale& _Loc, const _Facet* _Facptr)
        : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) { 
        if (_Facptr != nullptr) { 
            _Ptr->_Addfac((_Facet*) _Facptr, _Facet::id);
            _Ptr->_Catmask = none;
            _Ptr->_Name    = "*";
        }
    }
    locale(_Uninitialized) { 
    }
    locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { 
        _Ptr->_Incref();
    }
    locale() noexcept : _Ptr(_Init(true)) { 
    }
    locale(const locale& _Loc, const locale& _Other,
        category _Cat)
        : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) { 
        if (_Cat != none) { 
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj;
            _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
            _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
            _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
            _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
            _Ptr->_Name    = _Lobj._Getname();
            }
            _Guard._Target = nullptr;
        }
    }
private:
    void _Construct(const string& _Str,
        category _Cat) { 
        bool _Bad = false;
        _Init();
        if (_Cat != none) { 
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj(_Cat, _Str.c_str());
            if (_Badname(_Lobj)) {
                _Bad = true;
            } else { 
                _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
                _Ptr->_Catmask = _Cat;
                _Ptr->_Name    = _Str.c_str();
            }
            }
            _Guard._Target = nullptr;
        }
        if (_Bad) { 
            delete _Ptr->_Decref();
            _Xruntime_error("bad locale name");
        }
    }
public:
    explicit locale(const char* _Locname,
        category _Cat = all)
        : _Ptr(_Locimp::_New_Locimp()) { 
        if (_Locname == nullptr) {
            _Xruntime_error("bad locale name");
        }
        _Construct(_Locname, _Cat);
    }
    locale(const locale& _Loc, const char* _Locname,
        category _Cat)
        : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) { 
        if (_Locname == nullptr) {
            _Xruntime_error("bad locale name");
        }
        _Construct(_Locname, _Cat);
    }
    explicit locale(const string& _Str,
        category _Cat = all)
        : _Ptr(_Locimp::_New_Locimp()) { 
        _Construct(_Str, _Cat);
    }
    locale(const locale& _Loc, const string& _Str,
        category _Cat)
        : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) { 
        _Construct(_Str, _Cat);
    }
#line 357 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
    ~locale() noexcept { 
        if (_Ptr != nullptr) {
            delete _Ptr->_Decref();
        }
    }
    locale& operator=(const locale& _Right) noexcept { 
        if (_Ptr != _Right._Ptr) { 
            delete _Ptr->_Decref();
            _Ptr = _Right._Ptr;
            _Ptr->_Incref();
        }
        return *this;
    }
    string name() const { 
        return _Ptr == nullptr ? string() : _Ptr->_Name.c_str();
    }
      const char* c_str() const { 
        return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();
    }
    const facet* _Getfacet(size_t _Id) const { 
        const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; 
        if (_Facptr != nullptr || !_Ptr->_Xparent) {
            return _Facptr; 
        } else { 
            locale::_Locimp* _Ptr0 = _Getgloballocale();
            return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] 
                                            : nullptr; 
        }
    }
    [[nodiscard]] bool operator==(const locale& _Loc) const { 
        return _Ptr == _Loc._Ptr || (name().compare("*") != 0 && name().compare(_Loc.name()) == 0);
    }
    [[nodiscard]] bool operator!=(const locale& _Right) const { 
        return !(*this == _Right);
    }
    static  const locale& __cdecl classic(); 
    static  locale __cdecl global(const locale&); 
    static  locale __cdecl empty(); 
private:
    locale(_Locimp* _Ptrimp) : _Ptr(_Ptrimp) { 
    }
    static  _Locimp* __cdecl _Init(bool _Do_incref = false); 
    static  _Locimp* __cdecl _Getgloballocale();
    static  void __cdecl _Setgloballocale(void*);
    bool _Badname(const _Locinfo& _Lobj) { 
        return :: strcmp(_Lobj._Getname(), "*") == 0;
    }
    _Locimp* _Ptr; 
};
template <class _Facet>
struct _Facetptr { 
     static const locale::facet* _Psave;
};
template <class _Facet>
 const locale::facet* _Facetptr<_Facet>::_Psave = nullptr;
template <class _Facet>
inline const _Facet& __cdecl use_facet(const locale& _Loc)
{ 
    { ::std:: _Lockit _Lock(0); 
    const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; 
    const size_t _Id         = _Facet::id;
    const locale::facet* _Pf = _Loc._Getfacet(_Id);
    if (_Pf == nullptr) {
        if (_Psave != nullptr) {
            _Pf = _Psave; 
        } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {
            throw bad_cast{}; 
#line 450 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
        } else { 
            auto _Pfmod = const_cast<locale::facet*>(_Psave);
            unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));
#line 457 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
            _Facet_Register(_Pfmod);
#line 459 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
            _Pfmod->_Incref();
            _Facetptr<_Facet>::_Psave = _Psave;
            _Pf                       = _Psave;
            (void) _Psave_guard.release();
        }
    }
    return static_cast<const _Facet&>(*_Pf); 
    }
} 
template <class _Elem, class _InIt>
inline int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
    const _Elem* _Ptr) { 
    for (size_t _Off = 0; _Ptr[_Off] != (_Elem) 0; ++_Off) {
        if (_Ptr[_Off] == _Ptr[0]) {
            ++_Numfields; 
        }
    }
    string _Str(_Numfields, '\0'); 
    int _Ans = -2; 
    for (size_t _Column = 1;; ++_Column, (void) ++_First, _Ans = -1) { 
        bool _Prefix  = false; 
        size_t _Off   = 0; 
        size_t _Field = 0; 
        for (; _Field < _Numfields; ++_Field) { 
            while (_Ptr[_Off] != (_Elem) 0 && _Ptr[_Off] != _Ptr[0]) { 
                ++_Off;
            }
            if (_Str[_Field] != '\0') {
                _Off += _Str[_Field]; 
            } else if (_Ptr[_Off += _Column] == _Ptr[0]
                       || _Ptr[_Off] == (_Elem) 0) { 
                _Str[_Field] = (char) (_Column < 127 ? _Column : 127); 
                _Ans         = (int) _Field; 
            } else if (_First == _Last || _Ptr[_Off] != *_First) {
                _Str[_Field] = (char) (_Column < 127 ? _Column : 127); 
            } else {
                _Prefix = true; 
            }
        }
        if (!_Prefix || _First == _Last) {
            break; 
        }
    }
    return _Ans; 
}
template <class _Elem>
inline char __cdecl _Maklocbyte(_Elem _Char,
    const _Locinfo::_Cvtvec&) { 
    return (char) (unsigned char) _Char;
}
template <>
inline char __cdecl _Maklocbyte(wchar_t _Char,
    const _Locinfo::_Cvtvec& _Cvt) { 
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
    return _Byte;
}
template <>
inline char __cdecl _Maklocbyte(unsigned short _Char,
    const _Locinfo::_Cvtvec& _Cvt) { 
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, (wchar_t) _Char, &_Mbst1, &_Cvt);
    return _Byte;
}
#line 541 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
template <class _Elem>
inline _Elem __cdecl _Maklocchr(char _Byte, _Elem*,
    const _Locinfo::_Cvtvec&) { 
    return (_Elem)(unsigned char) _Byte;
}
template <>
inline wchar_t __cdecl _Maklocchr(char _Byte, wchar_t*,
    const _Locinfo::_Cvtvec& _Cvt) { 
    wchar_t _Wc      = L'\0';
    mbstate_t _Mbst1 = {};
    _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}
template <>
inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short*,
    const _Locinfo::_Cvtvec& _Cvt) { 
    unsigned short _Wc = (unsigned short) 0;
    mbstate_t _Mbst1   = {};
    _Mbrtowc((wchar_t*) &_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}
#line 568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
template <class _Elem>
inline _Elem* __cdecl _Maklocstr(const char* _Ptr, _Elem*,
    const _Locinfo::_Cvtvec&) { 
    size_t _Count = :: strlen(_Ptr) + 1;
    _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale", 575);
    if (!_Ptrdest) {
        _Xbad_alloc();
    }
    for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {
        *_Ptrnext = (_Elem)(unsigned char) *_Ptr;
    }
    return _Ptrdest;
}
template <>
inline wchar_t* __cdecl _Maklocstr(const char* _Ptr, wchar_t*,
    const _Locinfo::_Cvtvec& _Cvt) { 
    size_t _Count, _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    wchar_t _Wc;
    mbstate_t _Mbst1 = {};
    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }
    ++_Wchars; 
    wchar_t* _Ptrdest = (wchar_t*) _calloc_dbg(_Wchars, sizeof(wchar_t), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale", 607);
    if (!_Ptrdest) {
        _Xbad_alloc();
    }
    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};
    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }
    *_Ptrnext = L'\0';
    return _Ptrdest;
}
template <>
inline unsigned short* __cdecl _Maklocstr(const char* _Ptr, unsigned short*,
    const _Locinfo::_Cvtvec& _Cvt) { 
    size_t _Count, _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    unsigned short _Wc;
    mbstate_t _Mbst1 = {};
    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc((wchar_t*) &_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }
    ++_Wchars; 
    wchar_t* _Ptrdest = (wchar_t*) _calloc_dbg(_Wchars, sizeof(wchar_t), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale", 647);
    if (!_Ptrdest) {
        _Xbad_alloc();
    }
    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};
    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }
    *_Ptrnext = L'\0';
    return (unsigned short*) _Ptrdest;
}
#line 665 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
class  codecvt_base : public locale::facet { 
public:
    enum { 
        ok,
        partial,
        error,
        noconv
    };
    using result = int;
     codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) { 
    }
    bool  always_noconv() const
        noexcept { 
        return do_always_noconv();
    }
    int  max_length() const
        noexcept { 
        return do_max_length();
    }
    int  encoding() const noexcept { 
        return do_encoding();
    }
     ~codecvt_base() noexcept { 
    }
protected:
    virtual bool  do_always_noconv() const
        noexcept { 
        return false;
    }
    virtual int  do_max_length() const
        noexcept { 
        return 1;
    }
    virtual int  do_encoding() const noexcept { 
        return 1; 
    }
};
template <class _Elem, class _Byte,
    class _Statype>
class codecvt : public codecvt_base { 
public:
    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type  = _Statype;
    result  in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }
    int  length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        return do_length(_State, _First1, _Last1, _Count);
    }
     static locale::id id; 
    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { 
        _Init(_Locinfo());
    }
     codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs) { 
        _Init(_Lobj);
    }
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Ploc->c_str()));
        }
        return 2;
    }
protected:
    virtual  ~codecvt() noexcept { 
    }
    void  _Init(const _Locinfo&) { 
    }
    virtual bool  do_always_noconv() const
        noexcept { 
        return is_same_v<_Byte, _Elem>;
    }
    virtual result  do_in(_Statype&, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        _Mid1 = _First1;
        _Mid2 = _First2;
        if (is_same_v<_Byte, _Elem>) {
            return noconv; 
        }
        for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2) {
            *_Mid2 = (_Elem) *_Mid1;
        }
        return ok;
    }
    virtual result  do_out(_Statype&, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        _Mid1 = _First1;
        _Mid2 = _First2;
        if (is_same_v<_Byte, _Elem>) {
            return noconv; 
        }
        for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2) {
            *_Mid2 = (_Byte) *_Mid1;
        }
        return ok;
    }
    virtual result  do_unshift(
        _Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const { 
        _Mid2 = _First2;
        return noconv; 
    }
    virtual int  do_length(_Statype&, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        return static_cast<int>(_Min_value(_Count, static_cast<size_t>(_Last1 - _First1))); 
    }
};
template <class _Elem, class _Byte, class _Statype>
 locale::id codecvt<_Elem, _Byte, _Statype>::id;
enum _Codecvt_mode { _Consume_header = 4, _Generate_header = 2 };
template <>
class  codecvt<char16_t, char, _Mbstatet>
    : public codecvt_base { 
public:
    using _Mybase     = codecvt<char16_t, char, _Mbstatet>;
    using _Elem       = char16_t;
    using _Byte       = char;
    using _Statype    = _Mbstatet;
    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type  = _Statype;
    result  in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }
    int  length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        return do_length(_State, _First1, _Last1, _Count);
    }
     static locale::id id;
    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }
     codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) { 
        _Init(_Lobj);
    }
     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg),
          _Mode(_Mode_arg) { 
        _Init(_Lobj);
    }
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Ploc->c_str()));
        }
        return 2;
    }
protected:
    virtual  ~codecvt() noexcept { 
    }
    void  _Init(const _Locinfo&) { 
    }
    virtual result  do_in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1,
        const _Byte*& _Mid1, _Elem* _First2, _Elem* _Last2,
        _Elem*& _Mid2) const { 
        unsigned short* _Pstate = (unsigned short*) &_State;
        _Mid1                   = _First1;
        _Mid2                   = _First2;
        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned char _By = (unsigned char) *_Mid1;
            unsigned long _Ch;
            int _Nextra, _Nskip;
            if (*_Pstate > 1) {
                if (_By < 0x80 || 0xc0 <= _By) {
                    return _Mybase::error; 
                }
                ++_Mid1;
                *_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
                *_Pstate = 1;
                continue;
            }
            if (_By < 0x80) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0) { 
                ++_Mid1;
                return _Mybase::error;
            } else if (_By < 0xe0) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }
            _Nskip  = _Nextra < 3 ? 0 : 1; 
            _First1 = _Mid1; 
            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip) {
                break; 
            } else {
                for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = (unsigned char) *_Mid1) < 0x80 || 0xc0 <= _By) {
                        return _Mybase::error; 
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }
            if (0 < _Nskip) {
                _Ch <<= 6; 
            }
            if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch) {
                return _Mybase::error; 
            }
            if (0xffff < _Ch) { 
                unsigned short _Ch0 = (unsigned short) (0xd800 | (_Ch >> 10) - 0x0040);
                *_Mid2++ = (_Elem) _Ch0;
                *_Pstate = (unsigned short) (0xdc00 | (_Ch & 0x03ff));
                continue;
            }
            if (_Nskip != 0) {
                if (_Mid1 == _Last1) { 
                    _Mid1 = _First1;
                    break;
                }
                if ((_By = (unsigned char) *_Mid1++) < 0x80 || 0xc0 <= _By) {
                    return _Mybase::error; 
                }
                _Ch |= _By & 0x3f; 
            }
            if (*_Pstate == 0) { 
                *_Pstate = 1;
                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff) { 
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);
                    if (_Ans == _Mybase::partial) { 
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }
                    return _Ans;
                }
            }
            *_Mid2++ = (_Elem) _Ch;
        }
        return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
    }
    virtual result  do_out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1,
        const _Elem*& _Mid1, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        unsigned short* _Pstate = (unsigned short*) &_State;
        _Mid1                   = _First1;
        _Mid2                   = _First2;
        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned long _Ch;
            const unsigned short _Ch1 = (unsigned short) *_Mid1;
            bool _Save                = false;
            if (1 < *_Pstate) { 
                if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1) {
                    return _Mybase::error; 
                }
                _Ch = static_cast<unsigned long>((*_Pstate << 10) | (_Ch1 - 0xdc00));
            } else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00) { 
                _Ch   = static_cast<unsigned long>((_Ch1 - 0xd800 + 0x0040) << 10);
                _Save = true; 
            } else {
                _Ch = _Ch1; 
            }
            _Byte _By;
            int _Nextra;
            if (_Ch < 0x0080) {
                _By     = (_Byte) _Ch;
                _Nextra = 0;
            } else if (_Ch < 0x0800) {
                _By     = (_Byte)(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x10000) {
                _By     = (_Byte)(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else {
                _By     = (_Byte)(0xf0 | _Ch >> 18);
                _Nextra = 3;
            }
            int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;
            if (_Last2 - _Mid2 < _Nput) {
                break; 
            }
            if (*_Pstate == 0 && (_Mode & _Generate_header) != 0) {
                if (_Last2 - _Mid2 < 3 + _Nput) {
                    break; 
                }
                *_Mid2++ = (_Byte)(unsigned char) 0xef;
                *_Mid2++ = (_Byte)(unsigned char) 0xbb;
                *_Mid2++ = (_Byte)(unsigned char) 0xbf;
            }
            ++_Mid1;
            if (_Save || _Nextra < 3) { 
                *_Mid2++ = _By;
                --_Nput;
            }
            for (; 0 < _Nput; --_Nput) {
                *_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }
            *_Pstate = (unsigned short) (_Save ? _Ch >> 10 : 1);
        }
        return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
    }
    virtual result  do_unshift(_Statype& _State, _Byte* _First2, _Byte*,
        _Byte*& _Mid2) const { 
        unsigned short* _Pstate = (unsigned short*) &_State;
        _Mid2                   = _First2;
        return 1 < *_Pstate ? _Mybase::error : _Mybase::ok; 
    }
    virtual int  do_length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        size_t _Wchars    = 0;
        _Statype _Mystate = _State;
        while (_Wchars < _Count && _First1 != _Last1) { 
            const _Byte* _Mid1;
            _Elem* _Mid2;
            _Elem _Ch;
            const auto _Result = do_in(_Mystate, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
            if (_Result == _Mybase::noconv) {
                _Wchars += static_cast<size_t>(_Last1 - _First1);
                break;
            }
            if (_Result == _Mybase::ok) {
                if (_Mid2 == &_Ch + 1) {
                    ++_Wchars; 
                }
                _First1 = _Mid1;
                continue;
            }
            break; 
        }
        return static_cast<int>(_Min_value(static_cast<size_t>(2147483647), _Wchars));
    }
    virtual bool  do_always_noconv() const
        noexcept override { 
        return false;
    }
    virtual int  do_max_length() const
        noexcept override { 
        return (_Mode & _Consume_header) != 0
                   ? 9 
                   : (_Mode & _Generate_header) != 0 ? 7 
                                                     : 6; 
    }
    virtual int do_encoding() const noexcept override { 
        return 0; 
    }
private:
    unsigned long _Maxcode; 
    _Codecvt_mode _Mode; 
};
template <>
class  codecvt<char32_t, char, _Mbstatet>
    : public codecvt_base { 
public:
    using _Mybase     = codecvt<char32_t, char, _Mbstatet>;
    using _Elem       = char32_t;
    using _Byte       = char;
    using _Statype    = _Mbstatet;
    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type  = _Statype;
    result  in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }
    int  length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        return do_length(_State, _First1, _Last1, _Count);
    }
     static locale::id id;
    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }
     codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) { 
        _Init(_Lobj);
    }
     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg),
          _Mode(_Mode_arg) { 
        _Init(_Lobj);
    }
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Ploc->c_str()));
        }
        return 2;
    }
protected:
    virtual  ~codecvt() noexcept { 
    }
    void  _Init(const _Locinfo&) { 
    }
    virtual result  do_in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1,
        const _Byte*& _Mid1, _Elem* _First2, _Elem* _Last2,
        _Elem*& _Mid2) const { 
        char* _Pstate = (char*) &_State;
        _Mid1         = _First1;
        _Mid2         = _First2;
        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned char _By = (unsigned char) *_Mid1;
            unsigned long _Ch;
            int _Nextra;
            if (_By < 0x80) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0) { 
                ++_Mid1;
                return _Mybase::error;
            } else if (_By < 0xe0) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }
            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1) {
                break; 
            } else {
                for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = (unsigned char) *_Mid1) < 0x80 || 0xc0 <= _By) {
                        return _Mybase::error; 
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }
            if (*_Pstate == 0) { 
                *_Pstate = 1;
                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff) { 
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);
                    if (_Ans == _Mybase::partial) { 
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }
                    return _Ans;
                }
            }
            if (_Maxcode < _Ch) {
                return _Mybase::error; 
            }
            *_Mid2++ = (_Elem) _Ch;
        }
        return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
    }
    virtual result  do_out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1,
        const _Elem*& _Mid1, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        char* _Pstate = (char*) &_State;
        _Mid1         = _First1;
        _Mid2         = _First2;
        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            _Byte _By;
            int _Nextra;
            unsigned long _Ch = (unsigned long) *_Mid1;
            if (_Maxcode < _Ch) {
                return _Mybase::error;
            }
            if (_Ch < 0x0080) {
                _By     = (_Byte) _Ch;
                _Nextra = 0;
            } else if (_Ch < 0x0800) {
                _By     = (_Byte)(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x00010000) {
                _By     = (_Byte)(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else if (_Ch < 0x00200000) {
                _By     = (_Byte)(0xf0 | _Ch >> 18);
                _Nextra = 3;
            } else if (_Ch < 0x04000000) {
                _By     = (_Byte)(0xf8 | _Ch >> 24);
                _Nextra = 4;
            } else {
                _By     = (_Byte)(0xfc | (_Ch >> 30 & 0x03));
                _Nextra = 5;
            }
            if (*_Pstate == 0) { 
                *_Pstate = 1;
                if ((_Mode & _Generate_header) != 0) {
                    if (_Last2 - _Mid2 < 3 + 1 + _Nextra) {
                        return _Mybase::partial; 
                    }
                    *_Mid2++ = (_Byte)(unsigned char) 0xef;
                    *_Mid2++ = (_Byte)(unsigned char) 0xbb;
                    *_Mid2++ = (_Byte)(unsigned char) 0xbf;
                }
            }
            if (_Last2 - _Mid2 < 1 + _Nextra) {
                break; 
            }
            ++_Mid1;
            for (*_Mid2++ = _By; 0 < _Nextra;) {
                *_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }
        }
        return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
    }
    virtual result  do_unshift(
        _Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const { 
        _Mid2 = _First2;
        return _Mybase::noconv;
    }
    virtual int  do_length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        size_t _Wchars    = 0;
        _Statype _Mystate = _State;
        while (_Wchars < _Count && _First1 != _Last1) { 
            const _Byte* _Mid1;
            _Elem* _Mid2;
            _Elem _Ch;
            const auto _Result = do_in(_Mystate, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
            if (_Result == _Mybase::noconv) {
                _Wchars += static_cast<size_t>(_Last1 - _First1);
                break;
            }
            if (_Result == _Mybase::ok) {
                if (_Mid2 == &_Ch + 1) {
                    ++_Wchars; 
                }
                _First1 = _Mid1;
                continue;
            }
            break; 
        }
        return static_cast<int>(_Min_value(static_cast<size_t>(2147483647), _Wchars));
    }
    virtual bool  do_always_noconv() const
        noexcept override { 
        return false;
    }
    virtual int  do_max_length() const
        noexcept override { 
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? 9 : 6;
    }
    virtual int  do_encoding() const
        noexcept override { 
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? -1
                                                                   : 0; 
    }
private:
    unsigned long _Maxcode; 
    _Codecvt_mode _Mode; 
};
template <>
class  codecvt<wchar_t, char, _Mbstatet>
    : public codecvt_base { 
public:
    using _Elem       = wchar_t;
    using _Byte       = char;
    using _Statype    = _Mbstatet;
    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type  = _Statype;
    result  in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }
    int  length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        return do_length(_State, _First1, _Last1, _Count);
    }
     static locale::id id;
    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }
     codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs) { 
        _Init(_Lobj);
    }
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Ploc->c_str()));
        }
        return 2;
    }
protected:
    virtual  ~codecvt() noexcept { 
    }
    void  _Init(const _Locinfo& _Lobj) { 
        _Cvt = _Lobj._Getcvt();
    }
    virtual result  do_in(_Statype&, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        _Statype _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }
            if (_Mid2 == _Last2) {
                return partial;
            }
            int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: 
                return partial;
            case -1: 
                return error;
            case 0: 
                _Bytes = 1;
            default: 
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }
    virtual result  do_out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1,
        const _Elem*& _Mid1, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;
        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if ((int) 5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { 
                _Byte _Buf[5];
                _Statype _Stsave = _State;
                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else if (_Last2 - _Mid2 < _Bytes) { 
                    _State = _Stsave;
                    break;
                } else { 
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }
        return _Mid1 == _Last1 ? ok : partial;
    }
    virtual result  do_unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        _Byte _Buf[5];
        _Statype _Stsave = _State;
        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; 
        } else if (_Last2 - _Mid2 < --_Bytes) { 
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { 
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }
        return _Ans;
    }
    virtual int  do_length(_Statype&, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        _Adl_verify_range(_First1, _Last1);
        size_t _Wchars = 0;
        _Statype _Mystate{};
        while (_Wchars < _Count && _First1 != _Last1) {
            _Elem _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_Mystate, &_Cvt);
            if (_Bytes < 0) { 
                break;
            }
            if (_Bytes == 0) { 
                _Bytes = 1;
            }
            _First1 += _Bytes;
            ++_Wchars;
        }
        return static_cast<int>(_Min_value(static_cast<size_t>(2147483647), _Wchars));
    }
    virtual bool  do_always_noconv() const
        noexcept override { 
        return false;
    }
    virtual int  do_max_length() const
        noexcept override { 
        return static_cast<int>(_Cvt._Mbcurmax);
    }
    virtual int  do_encoding() const
        noexcept override { 
        return _Cvt._Mbcurmax == 1; 
    }
private:
    _Locinfo::_Cvtvec _Cvt; 
};
template <>
class  codecvt<unsigned short, char, _Mbstatet>
    : public codecvt_base { 
public:
    using _Elem       = unsigned short;
    using _Byte       = char;
    using _Statype    = _Mbstatet;
    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type  = _Statype;
    result  in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }
    result  unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }
    int  length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        return do_length(_State, _First1, _Last1, _Count);
    }
     static locale::id id;
    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }
     codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs) { 
        _Init(_Lobj);
    }
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Ploc->c_str()));
        }
        return 2;
    }
protected:
    virtual  ~codecvt() noexcept { 
    }
    void  _Init(const _Locinfo& _Lobj) { 
        _Cvt = _Lobj._Getcvt();
    }
    virtual result  do_in(_Statype&, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        _Statype _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }
            if (_Mid2 == _Last2) {
                return partial;
            }
            int _Bytes = _Mbrtowc(
                reinterpret_cast<wchar_t*>(_Mid2), _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: 
                return partial;
            case -1: 
                return error;
            case 0: 
                _Bytes = 1;
            default: 
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }
    virtual result  do_out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1,
        const _Elem*& _Mid1, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;
        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if ((int) 5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { 
                _Byte _Buf[5];
                _Statype _Stsave = _State;
                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else if (_Last2 - _Mid2 < _Bytes) { 
                    _State = _Stsave;
                    break;
                } else { 
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }
        return _Mid1 == _Last1 ? ok : partial;
    }
    virtual result  do_unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2,
        _Byte*& _Mid2) const { 
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        _Byte _Buf[5];
        _Statype _Stsave = _State;
        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; 
        } else if (_Last2 - _Mid2 < --_Bytes) { 
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { 
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }
        return _Ans;
    }
    virtual int  do_length(_Statype&, const _Byte* _First1, const _Byte* _Last1,
        size_t _Count) const { 
        _Adl_verify_range(_First1, _Last1);
        size_t _Wchars = 0;
        _Statype _Mystate{};
        while (_Wchars < _Count && _First1 != _Last1) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_Mystate, &_Cvt);
            if (_Bytes < 0) { 
                break;
            }
            if (_Bytes == 0) { 
                _Bytes = 1;
            }
            _First1 += _Bytes;
            ++_Wchars;
        }
        return static_cast<int>(_Min_value(static_cast<size_t>(2147483647), _Wchars));
    }
    virtual bool  do_always_noconv() const
        noexcept override { 
        return false;
    }
    virtual int  do_max_length() const
        noexcept override { 
        return static_cast<int>(_Cvt._Mbcurmax);
    }
    virtual int  do_encoding() const
        noexcept override { 
        return _Cvt._Mbcurmax == 1; 
    }
private:
    _Locinfo::_Cvtvec _Cvt; 
};
#line 1813 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
template <class _Elem, class _Byte, class _Statype>
class codecvt_byname : public codecvt<_Elem, _Byte, _Statype> { 
public:
    explicit  codecvt_byname(const char* _Locname, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs) { 
    }
    explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs) { 
    }
protected:
    virtual  ~codecvt_byname() noexcept { 
    }
};
struct  ctype_base : public locale::facet { 
    enum { 
        alnum  = 0x04 | 0x02 | 0x01 | 0x100,
        alpha  = 0x02 | 0x01 | 0x100,
        cntrl  = 0x20,
        digit  = 0x04,
        graph  = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
        lower  = 0x02,
        print  = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
        punct  = 0x10,
        space  = 0x08 | 0x40 | 0x000,
        upper  = 0x01,
        xdigit = 0x80,
        blank  = 0x08 | 0x40 | 0x000 | 0x000
    };
    using mask = short; 
     ctype_base(size_t _Refs = 0) : locale::facet(_Refs) { 
    }
     ~ctype_base() noexcept { 
    }
};
template <class _Elem>
class ctype : public ctype_base { 
public:
    using char_type = _Elem;
    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }
    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }
    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }
    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }
    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }
    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }
    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }
    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }
    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }
    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }
    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }
    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }
     static locale::id id;
    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }
     ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
        : ctype_base(_Refs) { 
        _Init(_Lobj);
    }
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }
        return 2;
    }
protected:
    virtual  ~ctype() noexcept { 
        if (_Ctype._Delfl) {
            :: free((void*) _Ctype._Table);
        }
        :: free(_Ctype._LocaleName);
    }
    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }
    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (_Ctype._Table[(unsigned char) narrow(_Ch)] & _Maskval) != 0;
    }
    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[(unsigned char) narrow(*_First)];
        }
        return _First;
    }
    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }
        return _First;
    }
    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }
        return _First;
    }
    virtual _Elem  do_tolower(_Elem _Ch) const { 
        unsigned char _Byte = (unsigned char) narrow(_Ch, '\0');
        if (_Byte == '\0') {
            return _Ch;
        }
        return widen((char) _Tolower(_Byte, &_Ctype));
    }
    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range((const _Elem*) _First, _Last);
        for (; _First != _Last; ++_First) { 
            unsigned char _Byte = (unsigned char) narrow(*_First, '\0');
            if (_Byte != '\0') {
                *_First = (widen((char) _Tolower(_Byte, &_Ctype)));
            }
        }
        return (const _Elem*) _First;
    }
    virtual _Elem  do_toupper(_Elem _Ch) const { 
        unsigned char _Byte = (unsigned char) narrow(_Ch, '\0');
        if (_Byte == '\0') {
            return _Ch;
        }
        return widen((char) _Toupper(_Byte, &_Ctype));
    }
    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range((const _Elem*) _First, _Last);
        for (; _First != _Last; ++_First) { 
            unsigned char _Byte = (unsigned char) narrow(*_First, '\0');
            if (_Byte != '\0') {
                *_First = (widen((char) _Toupper(_Byte, &_Ctype)));
            }
        }
        return (const _Elem*) _First;
    }
    virtual _Elem  do_widen(char _Byte) const { 
        return _Maklocchr(_Byte, static_cast<_Elem*>(nullptr), _Cvt);
    }
    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Maklocchr(*_First, static_cast<_Elem*>(nullptr), _Cvt);
        }
        return _First;
    }
    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Byte;
        if (_Ch == (_Elem) 0) {
            return '\0';
        }
        if ((_Byte = _Maklocbyte(_Ch, _Cvt)) == '\0') {
            return _Dflt;
        }
        return _Byte;
    }
    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }
    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }
        return _First;
    }
private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};
template <class _Elem>
locale::id ctype<_Elem>::id;
template <>
class  ctype<char> : public ctype_base { 
public:
    using _Elem     = char;
    using char_type = _Elem;
    bool  is(mask _Maskval, _Elem _Ch) const { 
        return (_Ctype._Table[(unsigned char) _Ch] & _Maskval) != 0;
    }
    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[(unsigned char) *_First];
        }
        return _First;
    }
    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }
        return _First;
    }
    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }
        return _First;
    }
    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }
    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }
    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }
    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }
    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }
    const _Elem*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }
    _Elem  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }
    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }
     static locale::id id;
    explicit  ctype(const mask* _Table = nullptr, bool _Deletetable = false,
        size_t _Refs = 0)
        : ctype_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
        _Tidy(); 
        if (_Table != nullptr) { 
            _Ctype._Table = _Table;
            _Ctype._Delfl = _Deletetable ? -1 : 0;
        } else { 
            _Ctype._Table = classic_table();
            _Ctype._Delfl = 0;
        }
    }
     ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
        : ctype_base(_Refs) { 
        _Init(_Lobj);
    }
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }
        return 2;
    }
    const mask*  table() const noexcept { 
        return _Ctype._Table;
    }
    static const mask* __cdecl
        classic_table() noexcept { 
        return ::std:: use_facet<ctype>(locale::classic()).table();
    }
     static const size_t table_size = 1 << 8; 
protected:
    virtual  ~ctype() noexcept { 
        _Tidy();
    }
    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
    }
    void  _Tidy() noexcept { 
        if (0 < _Ctype._Delfl) {
            :: free((void*) _Ctype._Table);
        } else if (_Ctype._Delfl < 0) {
            delete[] _Ctype._Table;
        }
        :: free(_Ctype._LocaleName);
    }
    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return (_Elem) _Tolower((unsigned char) _Ch, &_Ctype);
    }
    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range((const _Elem*) _First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = (_Elem) _Tolower((unsigned char) *_First, &_Ctype);
        }
        return (const _Elem*) _First;
    }
    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return (_Elem) _Toupper((unsigned char) _Ch, &_Ctype);
    }
    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range((const _Elem*) _First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = (_Elem) _Toupper((unsigned char) *_First, &_Ctype);
        }
        return (const _Elem*) _First;
    }
    virtual _Elem  do_widen(char _Byte) const { 
        return _Byte;
    }
    virtual const _Elem*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }
    virtual _Elem  do_narrow(_Elem _Ch, char) const { 
        return _Ch;
    }
    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }
private:
    _Locinfo::_Ctypevec _Ctype; 
};
template <>
class  ctype<wchar_t>
    : public ctype_base { 
public:
    using _Elem     = wchar_t;
    using char_type = _Elem;
    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }
    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }
    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }
    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }
    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }
    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }
    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }
    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }
    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }
    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }
    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }
    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }
     static locale::id id;
    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }
     ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
        : ctype_base(_Refs) { 
        _Init(_Lobj);
    }
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }
        return 2;
    }
protected:
    virtual  ~ctype() noexcept { 
        if (_Ctype._Delfl) {
            :: free((void*) _Ctype._Table);
        }
        :: free(_Ctype._LocaleName);
    }
    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }
    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }
    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        return :: _Getwctypes(_First, _Last, _Dest, &_Ctype);
    }
    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }
        return _First;
    }
    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }
        return _First;
    }
    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return _Towlower(_Ch, &_Ctype);
    }
    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range((const _Elem*) _First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }
        return (const _Elem*) _First;
    }
    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return _Towupper(_Ch, &_Ctype);
    }
    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range((const _Elem*) _First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }
        return (const _Elem*) _First;
    }
    _Elem  _Dowiden(char _Byte) const { 
        mbstate_t _Mbst = {};
        wchar_t _Wc;
        return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? (wchar_t) ((wint_t)(0xFFFF)) : _Wc;
    }
    virtual _Elem  do_widen(char _Byte) const { 
        return _Dowiden(_Byte);
    }
    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }
        return _First;
    }
    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Buf[5];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }
    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }
    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }
        return _First;
    }
private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};
template <>
class  ctype<unsigned short>
    : public ctype_base { 
public:
    using _Elem     = unsigned short;
    using char_type = _Elem;
    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }
    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }
    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }
    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }
    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }
    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }
    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }
    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }
    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }
    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }
    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }
    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }
     static locale::id id;
    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }
     ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
        : ctype_base(_Refs) { 
        _Init(_Lobj);
    }
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
        }
        return 2;
    }
protected:
    virtual  ~ctype() noexcept { 
        if (_Ctype._Delfl) {
            :: free((void*) _Ctype._Table);
        }
        :: free(_Ctype._LocaleName);
    }
    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }
    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }
    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        return (const _Elem*) :: _Getwctypes((const wchar_t*) _First, (const wchar_t*) _Last, _Dest, &_Ctype);
    }
    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }
        return _First;
    }
    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }
        return _First;
    }
    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return _Towlower(_Ch, &_Ctype);
    }
    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range((const _Elem*) _First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }
        return (const _Elem*) _First;
    }
    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return _Towupper(_Ch, &_Ctype);
    }
    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range((const _Elem*) _First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }
        return (const _Elem*) _First;
    }
    _Elem  _Dowiden(char _Byte) const { 
        mbstate_t _Mbst = {};
        unsigned short _Wc;
        return _Mbrtowc((wchar_t*) &_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? (unsigned short) ((wint_t)(0xFFFF)) : _Wc;
    }
    virtual _Elem  do_widen(char _Byte) const { 
        return _Dowiden(_Byte);
    }
    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }
        return _First;
    }
    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Buf[5];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }
    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }
    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }
        return _First;
    }
private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};
#line 2691 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
template <class _Elem>
class ctype_byname : public ctype<_Elem> { 
public:
    explicit  ctype_byname(const char* _Locname, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Locname), _Refs) { 
    }
    explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs) { 
    }
protected:
    virtual  ~ctype_byname() noexcept { 
    }
};
template <>
class ctype_byname<char> : public ctype<char> { 
public:
    explicit  ctype_byname(const char* _Locname, size_t _Refs = 0)
        : ctype<char>(_Locinfo(_Locname), _Refs) { 
    }
    explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
        : ctype<char>(_Locinfo(_Str.c_str()), _Refs) { 
    }
protected:
    virtual  ~ctype_byname() noexcept { 
    }
};
#line 2732 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
}
#pragma warning(pop)
#pragma pack(pop)
#line 2738 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
#line 2739 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocale"
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Dummy>
class _Iosb { 
public:
    enum _Dummy_enum { _Dummy_enum_val = 1 }; 
    enum _Fmtflags { 
        _Fmtmask = 0xffff,
        _Fmtzero = 0
    };
    static constexpr _Fmtflags skipws     = (_Fmtflags) 0x0001;
    static constexpr _Fmtflags unitbuf    = (_Fmtflags) 0x0002;
    static constexpr _Fmtflags uppercase  = (_Fmtflags) 0x0004;
    static constexpr _Fmtflags showbase   = (_Fmtflags) 0x0008;
    static constexpr _Fmtflags showpoint  = (_Fmtflags) 0x0010;
    static constexpr _Fmtflags showpos    = (_Fmtflags) 0x0020;
    static constexpr _Fmtflags left       = (_Fmtflags) 0x0040;
    static constexpr _Fmtflags right      = (_Fmtflags) 0x0080;
    static constexpr _Fmtflags internal   = (_Fmtflags) 0x0100;
    static constexpr _Fmtflags dec        = (_Fmtflags) 0x0200;
    static constexpr _Fmtflags oct        = (_Fmtflags) 0x0400;
    static constexpr _Fmtflags hex        = (_Fmtflags) 0x0800;
    static constexpr _Fmtflags scientific = (_Fmtflags) 0x1000;
    static constexpr _Fmtflags fixed      = (_Fmtflags) 0x2000;
    static constexpr _Fmtflags hexfloat = (_Fmtflags) 0x3000; 
    static constexpr _Fmtflags boolalpha   = (_Fmtflags) 0x4000;
    static constexpr _Fmtflags _Stdio      = (_Fmtflags) 0x8000;
    static constexpr _Fmtflags adjustfield = (_Fmtflags)(0x0040 | 0x0080 | 0x0100);
    static constexpr _Fmtflags basefield   = (_Fmtflags)(0x0200 | 0x0400 | 0x0800);
    static constexpr _Fmtflags floatfield  = (_Fmtflags)(0x1000 | 0x2000);
    enum _Iostate { 
        _Statmask = 0x17
    };
    static constexpr _Iostate goodbit = (_Iostate) 0x0;
    static constexpr _Iostate eofbit  = (_Iostate) 0x1;
    static constexpr _Iostate failbit = (_Iostate) 0x2;
    static constexpr _Iostate badbit  = (_Iostate) 0x4;
    enum _Openmode { 
        _Openmask = 0xff
    };
    static constexpr _Openmode in         = (_Openmode) 0x01;
    static constexpr _Openmode out        = (_Openmode) 0x02;
    static constexpr _Openmode ate        = (_Openmode) 0x04;
    static constexpr _Openmode app        = (_Openmode) 0x08;
    static constexpr _Openmode trunc      = (_Openmode) 0x10;
    static constexpr _Openmode _Nocreate  = (_Openmode) 0x40;
    static constexpr _Openmode _Noreplace = (_Openmode) 0x80;
    static constexpr _Openmode binary     = (_Openmode) 0x20;
    enum _Seekdir { 
        _Seekbeg,
        _Seekcur,
        _Seekend
    };
    static constexpr _Seekdir beg = _Seekbeg;
    static constexpr _Seekdir cur = _Seekcur;
    static constexpr _Seekdir end = _Seekend;
    enum { 
        _Openprot = 0x40
    };
};
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hexfloat; 
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template <class _Dummy>
const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;
class  ios_base : public _Iosb<int> { 
public:
    using fmtflags = int;
    using iostate  = int;
    using openmode = int;
    using seekdir  = int;
#line 202 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
    enum event { 
        erase_event,
        imbue_event,
        copyfmt_event
    };
    using event_callback = void(__cdecl*)(event, ios_base&, int);
#line 216 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
    class failure
        : public system_error { 
    public:
        explicit failure(const string& _Message, const error_code& _Errcode = make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) { 
        }
        explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) { 
        }
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
    };
    class  Init { 
    public:
         Init() { 
            _Init_ctor(this);
        }
         ~Init() noexcept { 
            _Init_dtor(this);
        }
    private:
        static  void __cdecl _Init_ctor(Init*);
        static  void __cdecl _Init_dtor(Init*);
         static int _Init_cnt; 
        static  int& __cdecl _Init_cnt_func();
    };
    explicit  operator bool() const { 
        return !fail();
    }
    [[nodiscard]] bool  operator!() const { 
        return fail();
    }
    void  clear(iostate _State, bool _Reraise) { 
        _State &= _Statmask;
        _Mystate             = _State;
        const auto _Filtered = _State & _Except;
        if (_Filtered) {
            if (_Reraise) {
                throw;
            }
            const char* _Msg;
            if (_Filtered & ios_base::badbit) {
                _Msg = "ios_base::badbit set";
            } else if (_Filtered & ios_base::failbit) {
                _Msg = "ios_base::failbit set";
            } else {
                _Msg = "ios_base::eofbit set";
            }
            throw failure(_Msg);
        }
    }
    void  clear(iostate _State = goodbit) { 
        clear(_State, false);
    }
#line 300 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
    [[nodiscard]] iostate  rdstate() const { 
        return _Mystate;
    }
    void  setstate(
        iostate _State, bool _Exreraise) { 
        clear(rdstate() | _State, _Exreraise);
    }
    void  setstate(iostate _State) { 
        clear(rdstate() | _State, false);
    }
#line 319 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
    [[nodiscard]] bool  good() const { 
        return rdstate() == ios_base::goodbit;
    }
    [[nodiscard]] bool  eof() const { 
        return rdstate() & ios_base::eofbit;
    }
    [[nodiscard]] bool  fail() const { 
        return rdstate() & (ios_base::badbit | ios_base::failbit);
    }
    [[nodiscard]] bool  bad() const { 
        return rdstate() & ios_base::badbit;
    }
    [[nodiscard]] iostate  exceptions() const { 
        return _Except;
    }
    void  exceptions(iostate _Newexcept) { 
        _Except = _Newexcept & _Statmask;
        clear(rdstate());
    }
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
    [[nodiscard]] fmtflags  flags() const { 
        return _Fmtfl;
    }
    fmtflags  flags(fmtflags _Newfmtflags) { 
        const fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                      = _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }
    fmtflags  setf(fmtflags _Newfmtflags) { 
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl |= _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }
    fmtflags  setf(
        fmtflags _Newfmtflags, fmtflags _Mask) { 
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                                = (_Oldfmtflags & ~_Mask) | (_Newfmtflags & _Mask & _Fmtmask);
        return _Oldfmtflags;
    }
    void  unsetf(fmtflags _Mask) { 
        _Fmtfl &= ~_Mask;
    }
    [[nodiscard]] streamsize  precision() const { 
        return _Prec;
    }
    streamsize  precision(streamsize _Newprecision) { 
        const streamsize _Oldprecision = _Prec;
        _Prec                          = _Newprecision;
        return _Oldprecision;
    }
    [[nodiscard]] streamsize  width() const { 
        return _Wide;
    }
    streamsize  width(streamsize _Newwidth) { 
        const streamsize _Oldwidth = _Wide;
        _Wide                      = _Newwidth;
        return _Oldwidth;
    }
    [[nodiscard]] locale  getloc() const { 
        return *_Ploc;
    }
    locale  imbue(const locale& _Loc) { 
        locale _Oldlocale = *_Ploc;
        *_Ploc            = _Loc;
        _Callfns(imbue_event);
        return _Oldlocale;
    }
    [[nodiscard]] static int __cdecl xalloc() { 
        { ::std:: _Lockit _Lock(2); 
        return _Index++;
        }
    }
    [[nodiscard]] long&  iword(int _Idx) { 
        return _Findarr(_Idx)._Lo;
    }
    [[nodiscard]] void*&  pword(int _Idx) { 
        return _Findarr(_Idx)._Vp;
    }
    void  register_callback(event_callback _Pfn,
        int _Idx) { 
        _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
    }
    ios_base&  copyfmt(const ios_base& _Other) { 
        if (this != ::std:: addressof(_Other)) { 
            _Tidy();
            *_Ploc          = *_Other._Ploc;
            _Fmtfl          = _Other._Fmtfl;
            _Prec           = _Other._Prec;
            _Wide           = _Other._Wide;
            _Iosarray* _Ptr = _Other._Arr;
            for (_Arr = nullptr; _Ptr != nullptr; _Ptr = _Ptr->_Next) {
                if (_Ptr->_Lo != 0 || _Ptr->_Vp != nullptr) { 
                    iword(_Ptr->_Index) = _Ptr->_Lo;
                    pword(_Ptr->_Index) = _Ptr->_Vp;
                }
            }
            for (_Fnarray* _Pfa = _Other._Calls; _Pfa != nullptr; _Pfa = _Pfa->_Next) {
                register_callback(_Pfa->_Pfn, _Pfa->_Index);
            }
            _Callfns(copyfmt_event); 
            exceptions(_Other._Except); 
        }
        return *this;
    }
    static bool __cdecl sync_with_stdio(
        bool _Newsync = true) { 
        { ::std:: _Lockit _Lock(2); 
        const bool _Oldsync = _Sync;
        _Sync               = _Newsync;
        return _Oldsync;
        }
    }
    void  swap(ios_base& _Right) { 
        if (this != ::std:: addressof(_Right)) { 
            ::std:: swap(_Mystate, _Right._Mystate);
            ::std:: swap(_Except, _Right._Except);
            ::std:: swap(_Fmtfl, _Right._Fmtfl);
            ::std:: swap(_Prec, _Right._Prec);
            ::std:: swap(_Wide, _Right._Wide);
            ::std:: swap(_Arr, _Right._Arr);
            ::std:: swap(_Calls, _Right._Calls);
            ::std:: swap(_Ploc, _Right._Ploc);
        }
    }
    virtual  ~ios_base() noexcept { 
        _Ios_base_dtor(this);
    }
    static  void __cdecl _Addstd(ios_base*); 
    size_t _Stdstr; 
protected:
     ios_base() { 
    }
    void  _Init() { 
        _Ploc   = nullptr;
        _Stdstr = 0;
        _Except = goodbit;
        _Fmtfl  = (fmtflags)(skipws | dec);
        _Prec   = 6;
        _Wide   = 0;
        _Arr    = nullptr;
        _Calls  = nullptr;
        clear(goodbit);
        _Ploc = new locale;
    }
private:
    struct _Iosarray : public _Crt_new_delete { 
    public:
         _Iosarray(int _Idx, _Iosarray* _Link)
            : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr) { 
        }
        _Iosarray* _Next; 
        int _Index; 
        long _Lo; 
        void* _Vp; 
    };
    struct _Fnarray : public _Crt_new_delete { 
         _Fnarray(int _Idx, event_callback _Pnew, _Fnarray* _Link)
            : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) { 
        }
        _Fnarray* _Next; 
        int _Index; 
        event_callback _Pfn; 
    };
    void  _Callfns(event _Ev) { 
        for (_Fnarray* _Pfa = _Calls; _Pfa != nullptr; _Pfa = _Pfa->_Next) {
            (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
        }
    }
    _Iosarray&  _Findarr(int _Idx) { 
        _Iosarray *_Ptr1, *_Ptr2;
        for (_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1 != nullptr; _Ptr1 = _Ptr1->_Next) {
            if (_Ptr1->_Index == _Idx) {
                return *_Ptr1; 
            } else if (_Ptr2 == nullptr && _Ptr1->_Lo == 0 && _Ptr1->_Vp == nullptr) {
                _Ptr2 = _Ptr1; 
            }
        }
        if (_Ptr2 != nullptr) { 
            _Ptr2->_Index = _Idx;
            return *_Ptr2;
        }
        _Arr = new _Iosarray(_Idx, _Arr); 
        return *_Arr;
    }
    void  _Tidy() noexcept { 
        _Callfns(erase_event);
        _Iosarray *_Ptr1, *_Ptr2;
        for (_Ptr1 = _Arr; _Ptr1 != nullptr; _Ptr1 = _Ptr2) { 
            _Ptr2 = _Ptr1->_Next;
            delete _Ptr1;
        }
        _Arr = nullptr;
        _Fnarray *_Pfa1, *_Pfa2;
        for (_Pfa1 = _Calls; _Pfa1 != nullptr; _Pfa1 = _Pfa2) { 
            _Pfa2 = _Pfa1->_Next;
            delete _Pfa1;
        }
        _Calls = nullptr;
    }
    iostate _Mystate; 
    iostate _Except; 
    fmtflags _Fmtfl; 
    streamsize _Prec; 
    streamsize _Wide; 
    _Iosarray* _Arr; 
    _Fnarray* _Calls; 
    locale* _Ploc; 
     static int _Index;
     static bool _Sync;
    static  void __cdecl _Ios_base_dtor(ios_base*);
public:
    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;
};
}
#pragma warning(pop)
#pragma pack(pop)
#line 595 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
#line 596 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xiosbase"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Elem,
    class _Traits>
class basic_streambuf { 
protected:
     basic_streambuf() : _Plocale(new locale) { 
        _Init();
    }
     basic_streambuf(_Uninitialized) { 
    }
     basic_streambuf(const basic_streambuf& _Right)
        : _Plocale(new locale(_Right.getloc())) { 
        _Init();
        setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
        setg(_Right.eback(), _Right.gptr(), _Right.egptr());
    }
    basic_streambuf&  operator=(const basic_streambuf& _Right) { 
        if (this != ::std:: addressof(_Right)) { 
            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            pubimbue(_Right.getloc());
        }
        return *this;
    }
    void  swap(basic_streambuf& _Right) { 
        if (this != ::std:: addressof(_Right)) { 
            _Elem* _Pfirst0 = pbase();
            _Elem* _Pnext0  = pptr();
            _Elem* _Pend    = epptr();
            _Elem* _Gfirst0 = eback();
            _Elem* _Gnext0  = gptr();
            _Elem* _Gend    = egptr();
            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            _Right.setp(_Pfirst0, _Pnext0, _Pend);
            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            _Right.setg(_Gfirst0, _Gnext0, _Gend);
            ::std:: swap(_Plocale, _Right._Plocale);
        }
    }
public:
    using char_type   = _Elem;
    using traits_type = _Traits;
    virtual  ~basic_streambuf() noexcept { 
        delete _Plocale;
    }
    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;
    pos_type  pubseekoff(off_type _Off, ios_base::seekdir _Way,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { 
        return seekoff(_Off, _Way, _Mode);
    }
#line 86 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
    pos_type  pubseekpos(pos_type _Pos,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { 
        return seekpos(_Pos, _Mode);
    }
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
    basic_streambuf*  pubsetbuf(_Elem* _Buffer,
        streamsize _Count) { 
        return setbuf(_Buffer, _Count);
    }
    locale  pubimbue(const locale& _Newlocale) { 
        locale _Oldlocale = *_Plocale;
        imbue(_Newlocale);
        *_Plocale = _Newlocale;
        return _Oldlocale;
    }
    locale  getloc() const { 
        return *_Plocale;
    }
    streamsize  in_avail() { 
        streamsize _Res = _Gnavail();
        return 0 < _Res ? _Res : showmanyc();
    }
    int  pubsync() { 
        return sync();
    }
    int_type  sbumpc() { 
        return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();
    }
    int_type  sgetc() { 
        return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();
    }
    streamsize  sgetn(_Elem* _Ptr,
        streamsize _Count) { 
        return xsgetn(_Ptr, _Count);
    }
    int_type  snextc() { 
        return 1 < _Gnavail() ? _Traits::to_int_type(*_Gnpreinc())
                              : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof() : sgetc();
    }
    int_type  sputbackc(_Elem _Ch) { 
        return gptr() != nullptr && eback() < gptr() && _Traits::eq(_Ch, gptr()[-1])
                   ? _Traits::to_int_type(*_Gndec())
                   : pbackfail(_Traits::to_int_type(_Ch));
    }
#line 157 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
    int_type  sungetc() { 
        return gptr() != nullptr && eback() < gptr() ? _Traits::to_int_type(*_Gndec()) : pbackfail();
    }
    int_type  sputc(_Elem _Ch) { 
        return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));
    }
    streamsize  sputn(const _Elem* _Ptr,
        streamsize _Count) { 
        return xsputn(_Ptr, _Count);
    }
    virtual void  _Lock() { 
    }
    virtual void  _Unlock() { 
    }
protected:
    _Elem*  eback() const { 
        return *_IGfirst;
    }
    _Elem*  gptr() const { 
        return *_IGnext;
    }
    _Elem*  pbase() const { 
        return *_IPfirst;
    }
    _Elem*  pptr() const { 
        return *_IPnext;
    }
    _Elem*  egptr() const { 
        return *_IGnext + *_IGcount;
    }
    void  gbump(int _Off) { 
        *_IGcount -= _Off;
        *_IGnext += _Off;
    }
    void  setg(_Elem* _First, _Elem* _Next, _Elem* _Last) { 
        *_IGfirst = _First;
        *_IGnext  = _Next;
        *_IGcount = (int) (_Last - _Next);
    }
    _Elem*  epptr() const { 
        return *_IPnext + *_IPcount;
    }
    _Elem*  _Gndec() { 
        ++*_IGcount;
        return --*_IGnext;
    }
    _Elem*  _Gninc() { 
        --*_IGcount;
        return (*_IGnext)++;
    }
    _Elem*  _Gnpreinc() { 
        --*_IGcount;
        return ++(*_IGnext);
    }
    streamsize  _Gnavail() const { 
        return *_IGnext != nullptr ? *_IGcount : 0;
    }
    void  pbump(int _Off) { 
        *_IPcount -= _Off;
        *_IPnext += _Off;
    }
    void  setp(_Elem* _First, _Elem* _Last) { 
        *_IPfirst = _First;
        *_IPnext  = _First;
        *_IPcount = (int) (_Last - _First);
    }
    void  setp(
        _Elem* _First, _Elem* _Next, _Elem* _Last) { 
        *_IPfirst = _First;
        *_IPnext  = _Next;
        *_IPcount = (int) (_Last - _Next);
    }
    _Elem*  _Pninc() { 
        --*_IPcount;
        return (*_IPnext)++;
    }
    streamsize  _Pnavail() const { 
        return *_IPnext != nullptr ? *_IPcount : 0;
    }
    void  _Init() { 
        _IGfirst = &_Gfirst;
        _IPfirst = &_Pfirst;
        _IGnext  = &_Gnext;
        _IPnext  = &_Pnext;
        _IGcount = &_Gcount;
        _IPcount = &_Pcount;
        setp(nullptr, nullptr);
        setg(nullptr, nullptr, nullptr);
    }
    void  _Init(_Elem** _Gf, _Elem** _Gn, int* _Gc, _Elem** _Pf, _Elem** _Pn,
        int* _Pc) { 
        _IGfirst = _Gf;
        _IPfirst = _Pf;
        _IGnext  = _Gn;
        _IPnext  = _Pn;
        _IGcount = _Gc;
        _IPcount = _Pc;
    }
    virtual int_type  overflow(int_type = _Traits::eof()) { 
        return _Traits::eof();
    }
    virtual int_type  pbackfail(
        int_type = _Traits::eof()) { 
        return _Traits::eof();
    }
    virtual streamsize  showmanyc() { 
        return 0;
    }
    virtual int_type  underflow() { 
        return _Traits::eof();
    }
    virtual int_type  uflow() { 
        return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());
    }
    virtual streamsize  xsgetn(_Elem* _Ptr, streamsize _Count) { 
        const streamsize _Start_count = _Count;
        while (0 < _Count) {
            streamsize _Size = _Gnavail();
            if (0 < _Size) { 
                if (_Count < _Size) {
                    _Size = _Count;
                }
                _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                gbump(static_cast<int>(_Size));
            } else {
                const int_type _Meta = uflow();
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; 
                }
                *_Ptr++ = _Traits::to_char_type(_Meta);
                --_Count;
            }
        }
        return _Start_count - _Count;
    }
    virtual streamsize  xsputn(
        const _Elem* _Ptr, streamsize _Count) { 
        const streamsize _Start_count = _Count;
        while (0 < _Count) {
            streamsize _Size = _Pnavail();
            if (0 < _Size) { 
                if (_Count < _Size) {
                    _Size = _Count;
                }
                _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                pbump(static_cast<int>(_Size));
            } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {
                break; 
            } else { 
                ++_Ptr;
                --_Count;
            }
        }
        return _Start_count - _Count;
    }
    virtual pos_type  seekoff(off_type, ios_base::seekdir,
        ios_base::openmode = ios_base::in | ios_base::out) { 
        return streampos(-1);
    }
    virtual pos_type  seekpos(pos_type,
        ios_base::openmode = ios_base::in | ios_base::out) { 
        return streampos(-1);
    }
    virtual basic_streambuf*  setbuf(
        _Elem*, streamsize) { 
        return this;
    }
    virtual int  sync() { 
        return 0;
    }
    virtual void  imbue(const locale&) { 
    }
private:
    _Elem* _Gfirst; 
    _Elem* _Pfirst; 
    _Elem** _IGfirst; 
    _Elem** _IPfirst; 
    _Elem* _Gnext; 
    _Elem* _Pnext; 
    _Elem** _IGnext; 
    _Elem** _IPnext; 
    int _Gcount; 
    int _Pcount; 
    int* _IGcount; 
    int* _IPcount; 
protected:
    locale* _Plocale; 
};
#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
template <class _Elem,
    class _Traits>
class istreambuf_iterator { 
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Elem;
    using difference_type   = typename _Traits::off_type;
    using pointer           = const _Elem*;
    using reference         = _Elem;
    using char_type      = _Elem;
    using traits_type    = _Traits;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using istream_type   = basic_istream<_Elem, _Traits>;
    using int_type = typename traits_type::int_type;
    constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}
    istreambuf_iterator(streambuf_type* _Sb) noexcept
        : _Strbuf(_Sb), _Got(_Sb == nullptr), _Val() { 
    }
    istreambuf_iterator(istream_type& _Istr) noexcept
        : _Strbuf(_Istr.rdbuf()), _Got(_Strbuf == nullptr), _Val() { 
    }
private:
    class _Istreambuf_proxy {
    public:
        [[nodiscard]] _Elem operator*() const {
            return _Keep;
        }
    private:
        friend istreambuf_iterator;
        _Istreambuf_proxy(streambuf_type* _Strbuf_, _Elem _Keep_) : _Strbuf(_Strbuf_), _Keep(_Keep_) {}
        streambuf_type* _Strbuf;
        _Elem _Keep;
    };
public:
    istreambuf_iterator(const _Istreambuf_proxy& _Px) noexcept
        : _Strbuf(_Px._Strbuf), _Got(_Strbuf == nullptr), _Val() { 
    }
    [[nodiscard]] _Elem operator*() const { 
        if (!_Got) {
            _Peek();
        }
        do { if (_Strbuf != nullptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf", 462, 0, "%s", "istreambuf_iterator is not dereferencable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"istreambuf_iterator is not dereferencable\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf", 462, 0); } while (false); } ; } while (false);
#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
        return _Val;
    }
    istreambuf_iterator& operator++() { 
        do { if (_Strbuf != nullptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf", 470, 0, "%s", "istreambuf_iterator is not incrementable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"istreambuf_iterator is not incrementable\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf", 470, 0); } while (false); } ; } while (false);
#line 472 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
        _Inc();
        return *this;
    }
    _Istreambuf_proxy operator++(int) { 
        if (!_Got) {
            _Peek();
        }
        _Istreambuf_proxy _Tmp{_Strbuf, _Val};
        ++*this;
        return _Tmp;
    }
    [[nodiscard]] bool equal(const istreambuf_iterator& _Right) const { 
        if (!_Got) {
            _Peek();
        }
        if (!_Right._Got) {
            _Right._Peek();
        }
        return (_Strbuf == nullptr && _Right._Strbuf == nullptr) || (_Strbuf != nullptr && _Right._Strbuf != nullptr);
    }
private:
    void _Inc() { 
        if (_Strbuf == nullptr || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {
            _Strbuf = nullptr;
            _Got    = true;
        } else {
            _Got = false;
        }
    }
    _Elem _Peek() const { 
        int_type _Meta;
        if (_Strbuf == nullptr || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {
            _Strbuf = nullptr;
        } else {
            _Val = traits_type::to_char_type(_Meta);
        }
        _Got = true;
        return _Val;
    }
    mutable streambuf_type* _Strbuf; 
    mutable bool _Got; 
    mutable _Elem _Val; 
};
template <class _Elem, class _Traits>
[[nodiscard]] inline bool operator==(const istreambuf_iterator<_Elem, _Traits>& _Left,
    const istreambuf_iterator<_Elem, _Traits>& _Right) { 
    return _Left.equal(_Right);
}
template <class _Elem, class _Traits>
[[nodiscard]] inline bool operator!=(const istreambuf_iterator<_Elem, _Traits>& _Left,
    const istreambuf_iterator<_Elem, _Traits>& _Right) { 
    return !(_Left == _Right);
}
template <class _Elem,
    class _Traits>
class ostreambuf_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using char_type      = _Elem;
    using traits_type    = _Traits;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using ostream_type   = basic_ostream<_Elem, _Traits>;
    ostreambuf_iterator(streambuf_type* _Sb) noexcept
        : _Failed(false), _Strbuf(_Sb) { 
    }
    ostreambuf_iterator(ostream_type& _Ostr) noexcept
        : _Failed(false), _Strbuf(_Ostr.rdbuf()) { 
    }
    ostreambuf_iterator& operator=(_Elem _Right) { 
        if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
            _Failed = true;
        }
        return *this;
    }
    [[nodiscard]] ostreambuf_iterator& operator*() { 
        return *this;
    }
    ostreambuf_iterator& operator++() { 
        return *this;
    }
    ostreambuf_iterator& operator++(int) { 
        return *this;
    }
    [[nodiscard]] bool failed() const noexcept { 
        return _Failed;
    }
private:
    bool _Failed; 
    streambuf_type* _Strbuf; 
};
}
#pragma warning(pop)
#pragma pack(pop)
#line 597 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
#line 598 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\streambuf"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
extern "C" {
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
extern  float __cdecl _Stofx(
    const char*,     char**, long, int*);
extern  double __cdecl _Stodx(
    const char*,     char**, long, int*);
extern  long double __cdecl _Stoldx(
    const char*,     char**, long, int*);
extern  long __cdecl _Stolx(
    const char*,     char**, int, int*);
extern  unsigned long __cdecl _Stoulx(
    const char*,     char**, int, int*);
extern  long long __cdecl _Stollx(
    const char*,     char**, int, int*);
extern  unsigned long long __cdecl _Stoullx(
    const char*,     char**, int, int*);
}
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
namespace std {
inline double _Stodx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr) { 
    int& _Errno_ref = (*_errno()); 
    const int _Orig = _Errno_ref;
    _Errno_ref  = 0;
    double _Val = :: strtod(_Str, _Endptr);
    *_Perr      = _Errno_ref;
    _Errno_ref  = _Orig;
    if (_Pten != 0) {
        _Val *= :: pow(10.0, static_cast<double>(_Pten));
    }
    return _Val;
}
inline float _Stofx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr) { 
    int& _Errno_ref = (*_errno()); 
    const int _Orig = _Errno_ref;
    _Errno_ref = 0;
    float _Val = :: strtof(_Str, _Endptr);
    *_Perr     = _Errno_ref;
    _Errno_ref = _Orig;
    if (_Pten != 0) {
        _Val *= :: powf(10.0f, static_cast<float>(_Pten));
    }
    return _Val;
}
template <class _Elem, size_t _Base_size>
inline size_t _Find_elem(const _Elem (&_Base)[_Base_size],
    const _Elem _Ch) { 
    return static_cast<size_t>(_Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);
}
inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { 
    const size_t _Count = :: wcslen(_Ptr) + 1;
    wchar_t* _Ptrdest = (wchar_t*) _calloc_dbg(_Count, sizeof(wchar_t), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum", 91);
    if (!_Ptrdest) {
        _Xbad_alloc();
    }
    :: wmemcpy(_Ptrdest, _Ptr, _Count);
    return _Ptrdest;
}
template <class _Elem>
class numpunct : public locale::facet { 
private:
    friend _Tidy_guard<numpunct>;
public:
    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;
    using char_type   = _Elem;
      static locale::id id; 
    _Elem decimal_point() const { 
        return do_decimal_point();
    }
    _Elem thousands_sep() const { 
        return do_thousands_sep();
    }
    string grouping() const { 
        return do_grouping();
    }
    string_type falsename() const { 
        return do_falsename();
    }
    string_type truename() const { 
        return do_truename();
    }
    explicit numpunct(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        if (_Kseparator == 0) {
            _Kseparator = 
                _Maklocchr(',', static_cast<_Elem*>(nullptr), _Lobj._Getcvt());
        }
        }
    }
    numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
        : locale::facet(_Refs) { 
        _Init(_Lobj, _Isdef);
    }
    static size_t _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);
        }
        return 4;
    }
protected:
    virtual  ~numpunct() noexcept { 
        _Tidy();
    }
    numpunct(const char* _Locname, size_t _Refs = 0, bool _Isdef = false)
        : locale::facet(_Refs) { 
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj, _Isdef);
        }
    }
    template <class _Elem2>
    void _Getvals(_Elem2, const lconv* _Ptr, _Locinfo::_Cvtvec _Cvt) { 
        _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);
        _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);
    }
    void _Getvals(wchar_t, const lconv* _Ptr, _Locinfo::_Cvtvec) { 
        _Dp         = (_Elem) _Ptr->_W_decimal_point[0];
        _Kseparator = (_Elem) _Ptr->_W_thousands_sep[0];
    }
    void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { 
        const lconv* _Ptr      = _Lobj._Getlconv();
        _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt(); 
        _Grouping  = nullptr;
        _Falsename = nullptr;
        _Truename  = nullptr;
        _Tidy_guard<numpunct> _Guard{this};
        _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());
        _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);
        _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);
        _Guard._Target = nullptr;
        if (_Isdef) { 
            _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);
            _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);
        } else {
            _Getvals((_Elem) 0, _Ptr, _Cvt);
        }
    }
    virtual _Elem  do_decimal_point() const { 
        return _Dp;
    }
    virtual _Elem  do_thousands_sep() const { 
        return _Kseparator;
    }
    virtual string  do_grouping() const { 
        return string(_Grouping);
    }
    virtual string_type  do_falsename() const { 
        return string_type(_Falsename);
    }
    virtual string_type  do_truename() const { 
        return string_type(_Truename);
    }
private:
    void _Tidy() noexcept { 
        :: free((void*) _Grouping);
        :: free((void*) _Falsename);
        :: free((void*) _Truename);
    }
    const char* _Grouping; 
    _Elem _Dp; 
    _Elem _Kseparator; 
    const _Elem* _Falsename; 
    const _Elem* _Truename; 
};
template <class _Elem>
class numpunct_byname : public numpunct<_Elem> { 
public:
    explicit numpunct_byname(const char* _Locname, size_t _Refs = 0)
        : numpunct<_Elem>(_Locname, _Refs) { 
    }
    explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
        : numpunct<_Elem>(_Str.c_str(), _Refs) { 
    }
protected:
    virtual  ~numpunct_byname() noexcept { 
    }
};
template <class _Elem>
 locale::id numpunct<_Elem>::id;
#line 267 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_get : public locale::facet { 
public:
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->c_str()));
        }
        return 4;
    }
     static locale::id id; 
protected:
    virtual  ~num_get() noexcept { 
    }
    void _Init(const _Locinfo&) { 
    }
public:
    explicit  num_get(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }
     num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
        : locale::facet(_Refs) { 
        _Init(_Lobj);
    }
    using char_type = _Elem;
    using iter_type = _InIt;
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }
protected:
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { 
        _Adl_verify_range(_First, _Last);
        if (_Iosbase.flags() & ios_base::boolalpha) { 
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});
            _Str += _Punct_fac.falsename();
            _Str.push_back(_Elem{});
            _Str += _Punct_fac.truename(); 
            switch (_Getloctxt(_First, _Last, 2, _Str.c_str())) {
            case 0:
                _Val = false;
                break;
            case 1:
                _Val = true;
                break;
            default:
                _Val   = false;
                _State = ios_base::failbit;
                break;
            }
        } else { 
            char _Ac[32];
            const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
            if (_Ac[0] == '\0') { 
                _Val   = false;
                _State = ios_base::failbit;
            } else {
                char* _Ep;
                int _Errno;
                const long _Ans = :: _Stolx(_Ac, &_Ep, _Base, &_Errno); 
                if (_Ep == _Ac || _Errno != 0) {
                    _Val   = true;
                    _State = ios_base::failbit;
                } else {
                    _Val = _Ans != 0;
                    if (_Ans != 0 && _Ans != 1) {
                        _State = ios_base::failbit;
                    }
                }
            }
        }
        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            const bool _Minus   = _Ac[0] == '-';
            const char* _Digits = _Ac;
            if (_Minus) { 
                ++_Digits;
            }
            char* _Ep;
            int _Errno;
            const unsigned long _Tmp = :: _Stoulx(_Digits, &_Ep, _Base, &_Errno); 
            _Val                     = static_cast<unsigned short>(_Tmp);
            if (_Ep == _Digits || _Errno != 0 || _Tmp > 0xffff) {
                _State = ios_base::failbit;
                _Val   = 0xffff;
            } else if (_Minus) { 
                _Val = static_cast<unsigned short>(0 - _Val);
            }
        }
        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { 
        static_assert(sizeof(unsigned int) == sizeof(unsigned long),
            "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
        unsigned long _Tmp;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); 
        _Val   = _Tmp;
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stolx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }
        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stoulx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }
        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stollx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }
        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = :: _Stoullx(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
            }
        }
        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16)];
        int _Hexexp     = 1000000000;
        const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0.0f;
        } else {
            int _Errno;
            char* _Ep;
            _Val = _Stofx_v2(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = 0.0f;
            } else if (_Hexexp != 1000000000 && _Hexexp != 0) {
                _Val = :: ldexpf(_Val, 4 * _Hexexp);
            }
        }
        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16)];
        int _Hexexp     = 1000000000;
        const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = 0.0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = _Stodx_v2(_Ac, &_Ep, _Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = 0.0;
            } else if (_Hexexp != 1000000000 && _Hexexp != 0) {
                _Val = :: ldexp(_Val, 4 * _Hexexp);
            }
        }
        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { 
        static_assert(sizeof(double) == sizeof(long double), "Bad assumption: sizeof(double) == sizeof(long double).");
        double _Result;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); 
        _Val   = _Result;
        return _First;
    }
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[32];
        const int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc()); 
        if (_Ac[0] == '\0') { 
            _State = ios_base::failbit;
            _Val   = nullptr;
        } else {
            int _Errno;
            char* _Ep;
            _Val = reinterpret_cast<void*>(:: _Stoullx(_Ac, &_Ep, _Base, &_Errno));
#line 647 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
            if (_Ep == _Ac || _Errno != 0) {
                _State = ios_base::failbit;
                _Val   = nullptr;
            }
        }
        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }
        return _First;
    }
private:
    int __cdecl _Getifld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
        const locale& _Loc) const { 
        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Loc);
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Grouping.size() == 0 ? (_Elem) 0 : _Punct_fac.thousands_sep();
        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff    = 24;
        static constexpr char _Src[]  = {"0123456789ABCDEFabcdef-+Xx"};
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Loc);
        _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);
        char* _Ptr = _Ac;
        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }
        _Basefield &= ios_base::basefield;
        int _Base = _Basefield == ios_base::oct
                        ? 8
                        : _Basefield == ios_base::hex ? 16 : _Basefield == ios_base::_Fmtzero ? 0 : 10;
        bool _Seendigit = false; 
        bool _Nonzero   = false; 
        if (_First != _Last && *_First == _Atoms[0]) { 
            _Seendigit = true;
            ++_First;
            if (_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])
                && (_Base == 0 || _Base == 16)) {
                _Base      = 16;
                _Seendigit = false;
                ++_First;
            } else if (_Base == 0) {
                _Base = 8;
            }
        }
        const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);
        string _Groups((size_t) 1, (char) _Seendigit);
        size_t _Group = 0;
        for (char* const _Pe = &_Ac[32 - 1]; _First != _Last; ++_First) { 
            size_t _Idx = _Find_elem(_Atoms, *_First);
            if (_Idx < _Dlen) { 
                *_Ptr = _Src[_Idx];
                if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe) {
                    ++_Ptr;
                    _Nonzero = true;
                }
                _Seendigit = true;
                if (_Groups[_Group] != 127) {
                    ++_Groups[_Group];
                }
            } else if (_Groups[_Group] == '\0' || _Kseparator == (_Elem) 0 || *_First != _Kseparator) {
                break; 
            } else { 
                _Groups.push_back('\0');
                ++_Group;
            }
        }
        if (_Group != 0) {
            if ('\0' < _Groups[_Group]) {
                ++_Group; 
            } else {
                _Seendigit = false; 
            }
        }
        for (const char* _Pg = &_Grouping[0]; _Seendigit && 0 < _Group;) {
            if (*_Pg == 127) {
                break; 
            } else if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                _Seendigit = false; 
            } else if ('\0' < _Pg[1]) {
                ++_Pg; 
            }
        }
        if (_Seendigit && !_Nonzero) {
            *_Ptr++ = '0'; 
        } else if (!_Seendigit) {
            _Ptr = _Ac; 
        }
        *_Ptr = '\0';
        return _Base;
    }
    int __cdecl _Getffld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase,
        int* _Phexexp) const { 
        if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat) {
            return _Getffldx(_Ac, _First, _Last, _Iosbase, _Phexexp); 
        }
        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        char* _Ptr             = _Ac;
        bool _Bad              = false;
        bool _Sticky           = false;
        constexpr int _Numget_signoff = 10;
        constexpr int _Numget_eoff    = 12;
        static constexpr char _Src[]  = {"0123456789-+Ee"};
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);
        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }
        char* _Leading = _Ptr; 
        *_Ptr++        = '0'; 
        bool _Seendigit  = false; 
        int _Significant = 0; 
        int _Pten        = 0; 
        size_t _Idx;
        const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);
        const char* _Pg = &_Grouping[0];
        if (*_Pg == 127 || *_Pg <= '\0') {
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
                if (_Max_sig_dig <= _Significant) { 
                    ++_Pten;
                    if (0 < _Idx) {
                        _Sticky = true;
                    }
                } else if (_Idx != 0 || _Significant != 0) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        } else { 
            const _Elem _Kseparator = _Grouping.size() == 0 ? (_Elem) 0 : _Punct_fac.thousands_sep();
            string _Groups((size_t) 1, '\0');
            size_t _Group = 0;
            for (; _First != _Last; ++_First) {
                if ((_Idx = _Find_elem(_Atoms, *_First)) < 10) { 
                    _Seendigit = true;
                    if (_Max_sig_dig <= _Significant) { 
                        ++_Pten;
                        if (0 < _Idx) {
                            _Sticky = true;
                        }
                    } else if (_Idx != 0 || _Significant != 0) { 
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }
                    if (_Groups[_Group] != 127) {
                        ++_Groups[_Group];
                    }
                } else if (_Groups[_Group] == '\0' || _Kseparator == (_Elem) 0 || *_First != _Kseparator) {
                    break; 
                } else { 
                    _Groups.push_back('\0');
                    ++_Group;
                }
            }
            if (_Group != 0) {
                if ('\0' < _Groups[_Group]) {
                    ++_Group; 
                } else {
                    _Bad = true; 
                }
            }
            while (!_Bad && 0 < _Group) {
                if (*_Pg == 127) {
                    break; 
                }
                if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                    _Bad = true; 
                } else if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }
        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { 
            *_Ptr++ = localeconv()->decimal_point[0];
            ++_First;
        }
        if (*_Phexexp != 1000000000 && _Significant == 0) { 
            for (; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void) ++_First) {
                --_Pten; 
            }
            if (_Pten < 0) { 
                *_Ptr++ = '0';
                ++_Pten;
            }
        }
        for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { 
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            } else if (0 < _Idx) {
                _Sticky = true; 
            }
        }
        if (_Sticky) { 
            char* _Px = _Ptr;
            while (--_Px != _Leading) { 
                if (*_Px != localeconv()->decimal_point[0]) { 
                    if (*_Px != '9') { 
                        ++*_Px;
                        break;
                    }
                    *_Px = '0'; 
                }
            }
            if (_Px == _Leading) { 
                *_Px = '1';
                ++_Pten;
            }
        }
        if (_Seendigit && _First != _Last
            && (*_First == _Atoms[_Numget_eoff + 1]
                   || *_First == _Atoms[_Numget_eoff])) { 
            *_Ptr++ = 'e';
            ++_First;
            _Seendigit   = false;
            _Significant = 0;
            if (_First != _Last) {
                if (*_First == _Atoms[_Numget_signoff + 1]) { 
                    *_Ptr++ = '+';
                    ++_First;
                } else if (*_First == _Atoms[_Numget_signoff]) { 
                    *_Ptr++ = '-';
                    ++_First;
                }
            }
            for (; _First != _Last && *_First == _Atoms[0]; ++_First) { 
                _Seendigit = true;
            }
            if (_Seendigit) {
                *_Ptr++ = '0'; 
            }
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void) ++_First) {
                if (_Significant < 8) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        }
        if (_Bad || !_Seendigit) {
            _Ptr = _Ac; 
        }
        *_Ptr = '\0';
        return _Pten;
    }
    int __cdecl _Getffldx(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase,
        int* _Phexexp) const { 
        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff    = 24;
        constexpr int _Numget_poff    = 26;
        static constexpr char _Src[]  = {"0123456789ABCDEFabcdef-+XxPp"};
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);
        char* _Ptr = _Ac;
        bool _Bad  = false;
        size_t _Idx;
        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }
        *_Ptr++ = '0';
        *_Ptr++ = 'x';
        bool _Seendigit  = false; 
        int _Significant = 0; 
        int _Phex        = 0; 
        if (_First != _Last && *_First == _Atoms[0]) {
            if (++_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])) {
                ++_First; 
            } else {
                _Seendigit = true; 
            }
        }
        const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);
        const char* _Pg = &_Grouping[0];
        if (*_Pg == 127 || *_Pg <= '\0') {
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
                 _Seendigit = true, (void) ++_First) {
                if (_Max_sig_dig <= _Significant) {
                    ++_Phex; 
                } else if (_Idx != 0 || _Significant != 0) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        } else { 
            const _Elem _Kseparator = _Grouping.size() == 0 ? (_Elem) 0 : _Punct_fac.thousands_sep();
            string _Groups((size_t) 1, '\0');
            size_t _Group = 0;
            for (; _First != _Last; ++_First) {
                if ((_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff) { 
                    _Seendigit = true;
                    if (_Max_sig_dig <= _Significant) {
                        ++_Phex; 
                    } else if (_Idx != 0 || _Significant != 0) { 
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }
                    if (_Groups[_Group] != 127) {
                        ++_Groups[_Group];
                    }
                } else if (_Groups[_Group] == '\0' || _Kseparator == (_Elem) 0 || *_First != _Kseparator) {
                    break; 
                } else { 
                    _Groups.push_back('\0');
                    ++_Group;
                }
            }
            if (_Group != 0) {
                if ('\0' < _Groups[_Group]) {
                    ++_Group; 
                } else {
                    _Bad = true; 
                }
            }
            while (!_Bad && 0 < _Group) {
                if (*_Pg == 127) {
                    break; 
                }
                if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                    _Bad = true; 
                } else if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }
        if (_Seendigit && _Significant == 0) {
            *_Ptr++ = '0'; 
        }
        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { 
            *_Ptr++ = localeconv()->decimal_point[0];
            ++_First;
        }
        if (_Significant == 0) { 
            for (; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void) ++_First) {
                --_Phex; 
            }
            if (_Phex < 0) { 
                *_Ptr++ = '0';
                ++_Phex;
            }
        }
        for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
             _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { 
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            }
        }
        if (_Seendigit && _First != _Last
            && (*_First == _Atoms[_Numget_poff + 1]
                   || *_First == _Atoms[_Numget_poff])) { 
            *_Ptr++ = 'p';
            ++_First;
            _Seendigit   = false;
            _Significant = 0;
            if (_First != _Last) {
                if (*_First == _Atoms[_Numget_signoff + 1]) { 
                    *_Ptr++ = '+';
                    ++_First;
                } else if (*_First == _Atoms[_Numget_signoff]) { 
                    *_Ptr++ = '-';
                    ++_First;
                }
            }
            for (; _First != _Last && *_First == _Atoms[0]; ++_First) { 
                _Seendigit = true;
            }
            if (_Seendigit) {
                *_Ptr++ = '0'; 
            }
            for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
                 _Seendigit = true, (void) ++_First) {
                if (_Significant < 8) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        }
        if (_Bad || !_Seendigit) {
            _Ptr = _Ac; 
        }
        *_Ptr     = '\0';
        *_Phexexp = _Phex; 
        return 0; 
    }
};
template <class _Elem, class _InIt>
 locale::id num_get<_Elem, _InIt>::id;
template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_put : public locale::facet { 
public:
    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr,
        const locale* _Ploc = nullptr) { 
        if (_Ppf != nullptr && *_Ppf == nullptr) {
            *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));
        }
        return 4;
    }
     static locale::id id; 
protected:
    virtual  ~num_put() noexcept { 
    }
    void  _Init(const _Locinfo&) { 
    }
public:
    explicit  num_put(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }
     num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
        : locale::facet(_Refs) { 
        _Init(_Lobj);
    }
    using char_type = _Elem;
    using iter_type = _OutIt;
    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }
    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }
    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }
    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }
    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }
    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }
    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }
    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }
protected:
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { 
        if (!(_Iosbase.flags() & ios_base::boolalpha)) {
            return do_put(_Dest, _Iosbase, _Fill, (long) _Val);
        } else { 
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str;
            if (_Val) {
                _Str.assign(_Punct_fac.truename());
            } else {
                _Str.assign(_Punct_fac.falsename());
            }
            size_t _Fillcount = _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Str.size()
                                    ? 0
                                    : (size_t) _Iosbase.width() - _Str.size();
            if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { 
                _Dest      = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
            }
            _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); 
            _Iosbase.width(0);
            return _Rep(_Dest, _Fill, _Fillcount); 
        }
    }
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { 
        char _Buf[2 * 32], _Fmt[6];
        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
    }
    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { 
        char _Buf[2 * 32], _Fmt[6];
        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
    }
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { 
        char _Buf[2 * 32], _Fmt[8];
        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
    }
    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { 
        char _Buf[2 * 32], _Fmt[8];
        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
    }
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { 
        string _Buf;
        char _Fmt[8];
        bool _Isfixed         = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;
        streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); 
        size_t _Bufsize       = (size_t) _Precision;
        if (_Isfixed && 1e10 < :: fabs(_Val)) { 
            int _Ptwo;
            (void) :: frexp(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }
        _Buf.resize(_Bufsize + 50); 
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            (char*) _Buf.c_str(), _Buf.size(), _Ffmt(_Fmt, 0, _Iosbase.flags()), (int) _Precision, _Val));
        return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
    }
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { 
        string _Buf;
        char _Fmt[8];
        bool _Isfixed         = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;
        streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); 
        size_t _Bufsize       = (size_t) _Precision;
        if (_Isfixed && 1e10 < :: fabsl(_Val)) { 
            int _Ptwo;
            (void) :: frexpl(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }
        _Buf.resize(_Bufsize + 50); 
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            (char*) _Buf.c_str(), _Buf.size(), _Ffmt(_Fmt, 'L', _Iosbase.flags()), (int) _Precision, _Val));
        return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
    }
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { 
        char _Buf[2 * 32];
        return _Iput(
            _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
    }
private:
    char* __cdecl _Ffmt(
        char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { 
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';
        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }
        if (_Flags & ios_base::showpoint) {
            *_Ptr++ = '#';
        }
        *_Ptr++ = '.';
        *_Ptr++ = '*'; 
        if (_Spec != '\0') {
            *_Ptr++ = _Spec; 
        }
        ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
        if (_Flags & ios_base::uppercase) {
            *_Ptr++ = _Ffl == ios_base::fixed
                          ? 'f'
                          : _Ffl == ios_base::hexfloat ? 'A' 
                                                       : _Ffl == ios_base::scientific ? 'E' : 'G'; 
        } else {
            *_Ptr++ = _Ffl == ios_base::fixed
                          ? 'f'
                          : _Ffl == ios_base::hexfloat ? 'a' 
                                                       : _Ffl == ios_base::scientific ? 'e' : 'g'; 
        }
        *_Ptr = '\0';
        return _Fmt;
    }
    _OutIt __cdecl _Fput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const char* _Buf,
        size_t _Count) const { 
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        const char* _Exps;
        if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat) {
            _Exps = "eE";
        } else { 
            _Exps = "pP";
            if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
                && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
                _Prefix += 2;
            }
        }
        const size_t _Eoff = :: strcspn(&_Buf[0], _Exps); 
        char _Dp[2]        = {"."};
        _Dp[0]             = :: localeconv()->decimal_point[0];
        const size_t _Poff = :: strcspn(&_Buf[0], &_Dp[0]); 
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); 
        _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);
        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Punct_fac.thousands_sep();
        if (_Poff != _Count) {
            _Groupstring[_Poff] = _Punct_fac.decimal_point();
        }
        size_t _Off     = _Poff == _Count ? _Eoff : _Poff;
        const char* _Pg = &_Grouping[0];
        while (*_Pg != 127 && '\0' < *_Pg && (size_t) *_Pg < _Off - _Prefix) { 
            _Groupstring.insert(_Off -= *_Pg, (size_t) 1, _Kseparator);
            if ('\0' < _Pg[1]) {
                ++_Pg; 
            }
        }
        _Count = _Groupstring.size();
        size_t _Fillcount =
            _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;
        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { 
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { 
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }
        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); 
    }
    char* __cdecl _Ifmt(
        char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const { 
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';
        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }
        if (_Flags & ios_base::showbase) {
            *_Ptr++ = '#';
        }
        if (_Spec[0] != 'L') {
            *_Ptr++ = _Spec[0]; 
        } else { 
            *_Ptr++ = 'I';
            *_Ptr++ = '6';
            *_Ptr++ = '4';
        }
        ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
        *_Ptr++                       = _Basefield == ios_base::oct ? 'o'
                                              : _Basefield != ios_base::hex ? _Spec[1] 
                                                                            : _Flags & ios_base::uppercase ? 'X' : 'x';
        *_Ptr = '\0';
        return _Fmt;
    }
    _OutIt __cdecl _Iput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, char* _Buf,
        size_t _Count) const { 
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
            && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
            _Prefix += 2;
        }
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); 
        _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);
        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        const char* _Pg        = &_Grouping[0];
        if (*_Pg != 127 && '\0' < *_Pg) { 
            const _Elem _Kseparator = _Punct_fac.thousands_sep();
            while (*_Pg != 127 && '\0' < *_Pg && (size_t) *_Pg < _Count - _Prefix) { 
                _Count -= *_Pg;
                _Groupstring.insert(_Count, 1, _Kseparator);
                if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }
        _Count = _Groupstring.size();
        size_t _Fillcount =
            _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;
        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { 
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { 
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }
        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); 
    }
    _OutIt __cdecl _Put(
        _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { 
        for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {
            *_Dest = *_Ptr;
        }
        return _Dest;
    }
    _OutIt __cdecl _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { 
        for (; 0 < _Count; --_Count, (void) ++_Dest) {
            *_Dest = _Ch;
        }
        return _Dest;
    }
};
template <class _Elem, class _OutIt>
 locale::id num_put<_Elem, _OutIt>::id;
#line 1545 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
}
#pragma warning(pop)
#pragma pack(pop)
#line 1555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
#line 1556 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xlocnum"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ios"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Elem,
    class _Traits>
class basic_ios : public ios_base { 
public:
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Mysb       = basic_streambuf<_Elem, _Traits>;
    using _Ctype      = ctype<_Elem>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;
    explicit  basic_ios(_Mysb* _Strbuf) { 
        init(_Strbuf);
    }
    virtual  ~basic_ios() noexcept { 
    }
    void  clear(
        iostate _State = goodbit, bool _Reraise = false) { 
        ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);
    }
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ios"
    void  setstate(
        iostate _State, bool _Reraise = false) { 
        clear(rdstate() | _State, _Reraise);
    }
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ios"
    basic_ios&  copyfmt(const basic_ios& _Right) { 
        _Tiestr = _Right.tie();
        _Fillch = _Right.fill();
        ios_base::copyfmt(_Right);
        return *this;
    }
    _Myos*  tie() const { 
        return _Tiestr;
    }
    _Myos*  tie(_Myos* _Newtie) { 
        _Myos* _Oldtie = _Tiestr;
        _Tiestr        = _Newtie;
        return _Oldtie;
    }
    [[nodiscard]] _Mysb*  rdbuf() const { 
        return _Mystrbuf;
    }
    _Mysb*  rdbuf(_Mysb* _Strbuf) { 
        _Mysb* _Oldstrbuf = _Mystrbuf;
        _Mystrbuf         = _Strbuf;
        clear();
        return _Oldstrbuf;
    }
    locale  imbue(const locale& _Loc) { 
        locale _Oldlocale = ios_base::imbue(_Loc);
        if (rdbuf() != nullptr) {
            rdbuf()->pubimbue(_Loc);
        }
        return _Oldlocale;
    }
    _Elem  fill() const { 
        return _Fillch;
    }
    _Elem  fill(_Elem _Newfill) { 
        _Elem _Oldfill = _Fillch;
        _Fillch        = _Newfill;
        return _Oldfill;
    }
    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return ::std:: use_facet<_Ctype>(getloc()).narrow(_Ch, _Dflt);
    }
    _Elem  widen(char _Byte) const { 
        return ::std:: use_facet<_Ctype>(getloc()).widen(_Byte);
    }
    void  move(basic_ios& _Right) { 
        if (this != ::std:: addressof(_Right)) { 
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }
    void  move(basic_ios&& _Right) { 
        if (this != ::std:: addressof(_Right)) { 
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }
    void  swap(basic_ios& _Right) noexcept { 
        ios_base::swap(_Right);
        ::std:: swap(_Fillch, _Right._Fillch);
        ::std:: swap(_Tiestr, _Right._Tiestr);
    }
    void  set_rdbuf(_Mysb* _Strbuf) { 
        _Mystrbuf = _Strbuf;
    }
protected:
    void  init(_Mysb* _Strbuf = nullptr,
        bool _Isstd                             = false) { 
        _Init(); 
        _Mystrbuf = _Strbuf;
        _Tiestr   = nullptr;
        _Fillch   = widen(' ');
        if (_Mystrbuf == nullptr) {
            setstate(badbit);
        }
        if (_Isstd) {
            _Addstd(this); 
        }
    }
     basic_ios() { 
    }
private:
    _Mysb* _Mystrbuf; 
    _Myos* _Tiestr; 
    _Elem _Fillch; 
public:
     basic_ios(const basic_ios&) = delete;
    basic_ios&  operator=(const basic_ios&) = delete;
};
#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ios"
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::boolalpha);
    return _Iosbase;
}
inline ios_base& __cdecl dec(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::dec, ios_base::basefield);
    return _Iosbase;
}
inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::floatfield);
    return _Iosbase;
}
inline ios_base& __cdecl fixed(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
    return _Iosbase;
}
inline ios_base& __cdecl hex(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::hex, ios_base::basefield);
    return _Iosbase;
}
inline ios_base& __cdecl hexfloat(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
    return _Iosbase;
}
inline ios_base& __cdecl internal(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
    return _Iosbase;
}
inline ios_base& __cdecl left(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::left, ios_base::adjustfield);
    return _Iosbase;
}
inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::boolalpha);
    return _Iosbase;
}
inline ios_base& __cdecl noshowbase(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showbase);
    return _Iosbase;
}
inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showpoint);
    return _Iosbase;
}
inline ios_base& __cdecl noshowpos(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showpos);
    return _Iosbase;
}
inline ios_base& __cdecl noskipws(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::skipws);
    return _Iosbase;
}
inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::unitbuf);
    return _Iosbase;
}
inline ios_base& __cdecl nouppercase(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::uppercase);
    return _Iosbase;
}
inline ios_base& __cdecl oct(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::oct, ios_base::basefield);
    return _Iosbase;
}
inline ios_base& __cdecl right(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::right, ios_base::adjustfield);
    return _Iosbase;
}
inline ios_base& __cdecl scientific(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
    return _Iosbase;
}
inline ios_base& __cdecl showbase(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showbase);
    return _Iosbase;
}
inline ios_base& __cdecl showpoint(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showpoint);
    return _Iosbase;
}
inline ios_base& __cdecl showpos(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showpos);
    return _Iosbase;
}
inline ios_base& __cdecl skipws(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::skipws);
    return _Iosbase;
}
inline ios_base& __cdecl unitbuf(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::unitbuf);
    return _Iosbase;
}
inline ios_base& __cdecl uppercase(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::uppercase);
    return _Iosbase;
}
#line 308 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ios"
}
#pragma warning(pop)
#pragma pack(pop)
#line 316 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ios"
#line 317 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ios"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ostream"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
#pragma vtordisp(push, 2) 
template <class _Elem, class _Traits>
class basic_ostream : virtual public basic_ios<_Elem, _Traits> { 
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = ostreambuf_iterator<_Elem, _Traits>;
    using _Nput  = num_put<_Elem, _Iter>;
    explicit  basic_ostream(basic_streambuf<_Elem, _Traits>* _Strbuf,
        bool _Isstd = false) { 
        _Myios::init(_Strbuf, _Isstd);
    }
     basic_ostream(_Uninitialized, bool _Addit = true) { 
        if (_Addit) {
            this->_Addstd(this); 
        }
    }
protected:
     basic_ostream(basic_ostream&& _Right) { 
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }
    basic_ostream&  operator=(basic_ostream&& _Right) { 
        this->swap(_Right);
        return *this;
    }
    void  swap(basic_ostream& _Right) { 
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }
public:
     basic_ostream(const basic_ostream&) = delete;
    basic_ostream&  operator=(const basic_ostream&) = delete;
    virtual  ~basic_ostream() noexcept { 
    }
    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;
    class _Sentry_base { 
    public:
         _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { 
            if (_Myostr.rdbuf() != nullptr) {
                _Myostr.rdbuf()->_Lock();
            }
        }
         ~_Sentry_base() noexcept { 
            if (_Myostr.rdbuf() != nullptr) {
                _Myostr.rdbuf()->_Unlock();
            }
        }
        basic_ostream& _Myostr; 
        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };
    class sentry : public _Sentry_base { 
    public:
        explicit  sentry(basic_ostream& _Ostr)
            : _Sentry_base(_Ostr) { 
            if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {
                _Ostr.tie()->flush();
            }
            _Ok = _Ostr.good(); 
        }
#pragma warning(push)
#pragma warning(disable : 4996) 
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ostream"
         ~sentry() noexcept { 
            if (!::std:: uncaught_exception()) { 
                this->_Myostr._Osfx();
            }
#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ostream"
        }
#pragma warning(pop)
#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ostream"
        explicit  operator bool() const { 
            return _Ok;
        }
         sentry(const sentry&) = delete;
        sentry&  operator=(const sentry&) = delete;
    private:
        bool _Ok; 
    };
    bool  opfx() { 
        if (this->good() && _Myios::tie() != nullptr && _Myios::tie() != this) {
            _Myios::tie()->flush();
        }
        return this->good();
    }
    void  osfx() { 
        _Osfx();
    }
    void  _Osfx() { 
        try {
        if (this->good() && this->flags() & ios_base::unitbuf) {
            if (_Myios::rdbuf()->pubsync() == -1) { 
                _Myios::setstate(ios_base::badbit);
            }
        }
        } catch (...) {
        }
    }
    basic_ostream&  operator<<(
        basic_ostream&(__cdecl* _Pfn)(basic_ostream&) ) { 
        return (*_Pfn)(*this);
    }
    basic_ostream&  operator<<(_Myios&(__cdecl* _Pfn)(_Myios&) ) { 
        (*_Pfn)(*(_Myios*) this);
        return *this;
    }
    basic_ostream&  operator<<(ios_base&(__cdecl* _Pfn)(ios_base&) ) { 
        (*_Pfn)(*(ios_base*) this);
        return *this;
    }
    basic_ostream&  operator<<(bool _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(short _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;
            long _Tmp = (_Bfl == ios_base::oct || _Bfl == ios_base::hex) ? (long) (unsigned short) _Val : (long) _Val;
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(unsigned short _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long) _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(int _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;
            long _Tmp = (_Bfl == ios_base::oct || _Bfl == ios_base::hex) ? (long) (unsigned int) _Val : (long) _Val;
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(unsigned int _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long) _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(unsigned long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(long long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(unsigned long long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(float _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (double) _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(double _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(long double _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  operator<<(const void* _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    template <class = void> 
    basic_ostream& operator<<(nullptr_t) { 
        return *this << "nullptr";
    }
#line 437 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ostream"
    basic_ostream&  operator<<(_Mysb* _Strbuf) { 
        ios_base::iostate _State = ios_base::goodbit;
        bool _Copied             = false;
        const sentry _Ok(*this);
        if (_Ok && _Strbuf != nullptr) {
            for (int_type _Meta = _Traits::eof();; _Copied = true) { 
                try {
                _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta) ? _Strbuf->sgetc() : _Strbuf->snextc();
                } catch (...) {
                _Myios::setstate(ios_base::failbit);
                throw;
                }
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; 
                }
                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Traits::to_char_type(_Meta)))) {
                    _State |= ios_base::badbit; 
                    break;
                }
                } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            }
        }
        this->width(0);
        _Myios::setstate(_Strbuf == nullptr ? ios_base::badbit : !_Copied ? _State | ios_base::failbit : _State);
        return *this;
    }
    basic_ostream&  put(_Elem _Ch) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (!_Ok) {
            _State |= ios_base::badbit;
        } else { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  write(const _Elem* _Str,
        streamsize _Count) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);
        if (!_Ok) {
            _State |= ios_base::badbit;
        } else if (0 < _Count) { 
            try {
            if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_ostream&  flush() { 
        if (_Myios::rdbuf() != nullptr) { 
            const sentry _Ok(*this);
            if (_Ok && _Myios::rdbuf()->pubsync() == -1) {
                _Myios::setstate(ios_base::badbit); 
            }
        }
        return *this;
    }
    basic_ostream&  seekp(pos_type _Pos) { 
        const sentry _Ok(*this);
        if (!this->fail() && (off_type) _Myios::rdbuf()->pubseekpos(_Pos, ios_base::out) == -1) {
            _Myios::setstate(ios_base::failbit);
        }
        return *this;
    }
    basic_ostream&  seekp(
        off_type _Off, ios_base::seekdir _Way) { 
        const sentry _Ok(*this);
        if (!this->fail() && (off_type) _Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::out) == -1) {
            _Myios::setstate(ios_base::failbit);
        }
        return *this;
    }
    pos_type  tellp() { 
        const sentry _Ok(*this);
        if (!this->fail()) {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        } else {
            return pos_type(-1);
        }
    }
};
#pragma vtordisp(pop) 
#line 610 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ostream"
template <class _Elem, class _Traits>
inline basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const char* _Val) { 
    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = (streamsize) :: strlen(_Val); 
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }
        for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {
                _State |= ios_base::badbit;
            }
        }
        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }
        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }
    _Ostr.setstate(_State);
    return _Ostr;
}
template <class _Elem, class _Traits>
inline basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, char _Ch) { 
    ios_base::iostate _State = ios_base::goodbit;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
    if (_Ok) { 
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        streamsize _Pad                = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }
        if (_State == ios_base::goodbit
            && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch)))) {
            _State |= ios_base::badbit;
        }
        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }
    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}
template <class _Traits>
inline basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr,
    const char* _Val) { 
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;
    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = (streamsize) _Traits::length(_Val); 
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);
    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }
        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }
        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }
        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }
    _Ostr.setstate(_State);
    return _Ostr;
}
template <class _Traits>
inline basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, char _Ch) { 
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;
    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);
    if (_Ok) { 
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }
        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }
        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }
    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}
template <class _Elem, class _Traits>
inline basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* _Val) { 
    using _Myos = basic_ostream<_Elem, _Traits>;
    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = (streamsize) _Traits::length(_Val); 
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);
    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }
        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }
        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }
        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }
    _Ostr.setstate(_State);
    return _Ostr;
}
template <class _Elem, class _Traits>
inline basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch) { 
    using _Myos = basic_ostream<_Elem, _Traits>;
    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);
    if (_Ok) { 
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }
        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }
        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }
    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}
template <class _Traits>
inline basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, const signed char* _Val) { 
    return _Ostr << (const char*) _Val;
}
template <class _Traits>
inline basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, signed char _Ch) { 
    return _Ostr << (char) _Ch;
}
template <class _Traits>
inline basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, const unsigned char* _Val) { 
    return _Ostr << (const char*) _Val;
}
template <class _Traits>
inline basic_ostream<char, _Traits>& operator<<(
    basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch) { 
    return _Ostr << (char) _Ch;
}
template <class _Ostr, class _Ty, class = void>
struct _Can_stream_out : false_type {};
template <class _Ostr, class _Ty>
struct _Can_stream_out<_Ostr, _Ty, void_t<decltype(::std:: declval<_Ostr&>() << ::std:: declval<const _Ty&>())>> : true_type {
};
template <class _Ostr, class _Ty,
    enable_if_t<conjunction_v< 
                    negation<is_lvalue_reference<_Ostr>>, is_base_of<ios_base, _Ostr>, _Can_stream_out<_Ostr, _Ty>>,
        int> = 0>
inline _Ostr&& operator<<(_Ostr&& _Os, const _Ty& _Val) { 
    _Os << _Val;
    return ::std:: move(_Os);
}
template <class _Elem, class _Traits>
inline basic_ostream<_Elem, _Traits>& __cdecl endl(
    basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.put(_Ostr.widen('\n'));
    _Ostr.flush();
    return _Ostr;
}
template <class _Elem, class _Traits>
inline basic_ostream<_Elem, _Traits>& __cdecl ends(
    basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.put(_Elem());
    return _Ostr;
}
template <class _Elem, class _Traits>
inline basic_ostream<_Elem, _Traits>& __cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.flush();
    return _Ostr;
}
template <class _Elem, class _Traits>
inline basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
    const error_code& _Errcode) { 
    return _Ostr << _Errcode.category().name() << ':' << _Errcode.value();
}
}
#pragma warning(pop)
#pragma pack(pop)
#line 933 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ostream"
#line 934 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ostream"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\istream"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
#pragma vtordisp(push, 2) 
template <class _Elem, class _Traits>
class basic_istream : virtual public basic_ios<_Elem, _Traits> { 
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = istreambuf_iterator<_Elem, _Traits>;
    using _Ctype = ctype<_Elem>;
    using _Nget  = num_get<_Elem, _Iter>;
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\istream"
    explicit  basic_istream(_Mysb* _Strbuf,
        bool _Isstd = false)
        : _Chcount(0) { 
        _Myios::init(_Strbuf, _Isstd);
    }
     basic_istream(_Uninitialized) { 
        this->_Addstd(this);
    }
protected:
     basic_istream(basic_istream&& _Right) : _Chcount(_Right._Chcount) { 
        _Myios::init();
        _Myios::move(::std:: move(_Right));
        _Right._Chcount = 0;
    }
    basic_istream&  operator=(basic_istream&& _Right) { 
        this->swap(_Right);
        return *this;
    }
    void  swap(basic_istream& _Right) { 
        _Myios::swap(_Right);
        ::std:: swap(_Chcount, _Right._Chcount);
    }
public:
     basic_istream(const basic_istream&) = delete;
    basic_istream&  operator=(const basic_istream&) = delete;
    virtual  ~basic_istream() noexcept { 
    }
    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;
    class _Sentry_base { 
    public:
         _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) { 
            if (_Myistr.rdbuf() != nullptr) {
                _Myistr.rdbuf()->_Lock();
            }
        }
         ~_Sentry_base() noexcept { 
            if (_Myistr.rdbuf() != nullptr) {
                _Myistr.rdbuf()->_Unlock();
            }
        }
        basic_istream& _Myistr; 
        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };
    class sentry : public _Sentry_base { 
    public:
        explicit  sentry(basic_istream& _Istr, bool _Noskip = false)
            : _Sentry_base(_Istr) { 
            _Ok = this->_Myistr._Ipfx(_Noskip);
        }
        explicit  operator bool() const { 
            return _Ok;
        }
         sentry(const sentry&) = delete;
        sentry&  operator=(const sentry&) = delete;
    private:
        bool _Ok; 
    };
    bool  _Ipfx(bool _Noskip = false) { 
        if (this->good()) { 
            if (_Myios::tie() != nullptr) {
                _Myios::tie()->flush();
            }
            if (!_Noskip && this->flags() & ios_base::skipws) { 
                const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(this->getloc());
                try {
                int_type _Meta = _Myios::rdbuf()->sgetc();
                for (;; _Meta = _Myios::rdbuf()->snextc()) {
                    if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                        _Myios::setstate(ios_base::eofbit);
                        break;
                    } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                        break; 
                    }
                }
                } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            }
            if (this->good()) {
                return true;
            }
        }
        _Myios::setstate(ios_base::failbit);
        return false;
    }
    bool  ipfx(bool _Noskip = false) { 
        return _Ipfx(_Noskip);
    }
    void  isfx() { 
    }
    basic_istream&  operator>>(
        basic_istream&(__cdecl* _Pfn)(basic_istream&) ) { 
        return (*_Pfn)(*this);
    }
    basic_istream&  operator>>(_Myios&(__cdecl* _Pfn)(_Myios&) ) { 
        (*_Pfn)(*(_Myios*) this);
        return *this;
    }
    basic_istream&  operator>>(ios_base&(__cdecl* _Pfn)(ios_base&) ) { 
        (*_Pfn)(*(ios_base*) this);
        return *this;
    }
private:
    template <class _Ty>
    basic_istream& _Common_extract_with_num_get(_Ty& _Val) { 
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            try {
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_Err);
        return *this;
    }
public:
    basic_istream&  operator>>(bool& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(short& _Val) { 
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok) { 
            try {
            long _Lval;
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Lval);
            if (_Lval < (-32768)) {
                _Err |= ios_base::failbit;
                _Val = (-32768);
            } else if (_Lval > 32767) {
                _Err |= ios_base::failbit;
                _Val = 32767;
            } else {
                _Val = static_cast<short>(_Lval);
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_Err);
        return *this;
    }
    basic_istream&  operator>>(unsigned short& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(int& _Val) { 
        static_assert(sizeof(int) == sizeof(long), "Bad overflow assumptions due to sizeof(int) != sizeof(long)");
        long _Result = _Val;
        _Common_extract_with_num_get(_Result);
        _Val = _Result;
        return *this;
    }
    basic_istream&  operator>>(unsigned int& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(unsigned long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(long long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(unsigned long long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(float& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(double& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(long double& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(void*& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }
    basic_istream&  operator>>(_Mysb* _Strbuf) { 
        _Chcount = 0; 
        const sentry _Ok(*this, true);
        ios_base::iostate _State = ios_base::goodbit;
        if (_Ok && _Strbuf != nullptr) { 
            try {
            for (int_type _Meta = _Myios::rdbuf()->sgetc();; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                }
                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta)))) {
                    break;
                }
                } catch (...) {
                break;
                }
                ++_Chcount;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        if (_Chcount == 0) { 
            _State = ios_base::failbit;
        }
        _Myios::setstate(_State);
        return *this;
    }
    int_type  get() { 
        int_type _Meta           = 0;
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        if (!_Ok) {
            _Meta = _Traits::eof(); 
        } else { 
            try {
            _Meta = _Myios::rdbuf()->sgetc();
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                _State |= ios_base::eofbit | ios_base::failbit; 
            } else { 
                _Myios::rdbuf()->sbumpc();
                ++_Chcount;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return _Meta;
    }
    basic_istream&  get(_Elem* _Str, streamsize _Count) { 
        return get(_Str, _Count, _Myios::widen('\n'));
    }
    basic_istream&  get(
        _Elem* _Str, streamsize _Count, _Elem _Delim) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        if (_Ok && 0 < _Count) { 
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();
            for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Traits::to_char_type(_Meta) == _Delim) {
                    break; 
                } else { 
                    *_Str++ = _Traits::to_char_type(_Meta);
                    ++_Chcount;
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        *_Str = _Elem(); 
        return *this;
    }
    basic_istream&  get(_Elem& _Ch) { 
        int_type _Meta = get();
        if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _Ch = _Traits::to_char_type(_Meta);
        }
        return *this;
    }
    basic_istream&  get(_Mysb& _Strbuf) { 
        return get(_Strbuf, _Myios::widen('\n'));
    }
    basic_istream&  get(
        _Mysb& _Strbuf, _Elem _Delim) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        if (_Ok) { 
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();
            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else { 
                    try {
                    _Elem _Ch = _Traits::to_char_type(_Meta);
                    if (_Ch == _Delim || _Traits::eq_int_type(_Traits::eof(), _Strbuf.sputc(_Ch))) {
                        break;
                    }
                    } catch (...) {
                    break;
                    }
                    ++_Chcount;
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        if (_Chcount == 0) {
            _State |= ios_base::failbit;
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_istream&  getline(
        _Elem* _Str, streamsize _Count) { 
        return getline(_Str, _Count, _Myios::widen('\n'));
    }
    basic_istream&  getline(
        _Elem* _Str, streamsize _Count, _Elem _Delim) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        if (_Ok && 0 < _Count) { 
            int_type _Metadelim = _Traits::to_int_type(_Delim);
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();
            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Meta == _Metadelim) { 
                    ++_Chcount;
                    _Myios::rdbuf()->sbumpc();
                    break;
                } else if (--_Count <= 0) { 
                    _State |= ios_base::failbit;
                    break;
                } else { 
                    *_Str++ = _Traits::to_char_type(_Meta);
                    ++_Chcount;
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        *_Str = _Elem(); 
        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        return *this;
    }
    basic_istream&  ignore(streamsize _Count = 1,
        int_type _Metadelim = _Traits::eof()) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        if (_Ok && 0 < _Count) { 
            try {
            for (;;) { 
                int_type _Meta;
                if (_Count != (numeric_limits<streamsize>::max)() && --_Count < 0) {
                    break; 
                } else if (_Traits::eq_int_type(_Traits::eof(),
                               _Meta = _Myios::rdbuf()->sbumpc())) { 
                    _State |= ios_base::eofbit;
                    break;
                } else { 
                    ++_Chcount;
                    if (_Meta == _Metadelim) {
                        break; 
                    }
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_istream&  read(_Elem* _Str, streamsize _Count) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        if (_Ok && 0 < _Count) { 
            try {
            const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
            _Chcount += _Num;
            if (_Num != _Count) {
                _State |= ios_base::eofbit | ios_base::failbit; 
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    streamsize  readsome(_Elem* _Str,
        streamsize _Count) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        streamsize _Num;
        if (!_Ok) {
            _State |= ios_base::failbit; 
        } else if ((_Num = _Myios::rdbuf()->in_avail()) < 0) {
            _State |= ios_base::eofbit; 
        } else if (0 < _Count && 0 < _Num) { 
            read(_Str, _Num < _Count ? _Num : _Count);
        }
        _Myios::setstate(_State);
        return gcount();
    }
    int_type  peek() { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        int_type _Meta           = 0;
        const sentry _Ok(*this, true);
        if (!_Ok) {
            _Meta = _Traits::eof(); 
        } else { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Myios::rdbuf()->sgetc())) {
                _State |= ios_base::eofbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return _Meta;
    }
    basic_istream&  putback(_Elem _Ch) { 
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);
        if (_Ok) { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputbackc(_Ch))) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    basic_istream&  unget() { 
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);
        if (_Ok) { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sungetc())) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }
        _Myios::setstate(_State);
        return *this;
    }
    [[nodiscard]] streamsize  gcount() const { 
        return _Chcount;
    }
    int  sync() { 
        const sentry _Ok(*this, true);
        if (_Myios::rdbuf() == nullptr) {
            return -1;
        } else if (_Myios::rdbuf()->pubsync() == -1) { 
            _Myios::setstate(ios_base::badbit);
            return -1;
        } else {
            return 0;
        }
    }
    basic_istream&  seekg(pos_type _Pos) { 
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);
        if (!this->fail() && (off_type) _Myios::rdbuf()->pubseekpos(_Pos, ios_base::in) == -1) {
            _Myios::setstate(_State | ios_base::failbit);
        }
        return *this;
    }
    basic_istream&  seekg(
        off_type _Off, ios_base::seekdir _Way) { 
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);
        if (!this->fail() && (off_type) _Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in) == -1) {
            _Myios::setstate(_State | ios_base::failbit);
        }
        return *this;
    }
    pos_type  tellg() { 
        const sentry _Ok(*this, true);
        if (!this->fail()) {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
        } else {
            return pos_type(-1);
        }
    }
private:
    streamsize _Chcount; 
};
#pragma vtordisp(pop) 
#line 683 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\istream"
template <class _Elem, class _Traits>
class basic_iostream : public basic_istream<_Elem, _Traits>,
                       public basic_ostream<_Elem, _Traits> { 
public:
    using _Myis       = basic_istream<_Elem, _Traits>;
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Myios      = basic_ios<_Elem, _Traits>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;
    explicit  basic_iostream(basic_streambuf<_Elem, _Traits>* _Strbuf)
        : _Myis(_Strbuf, false), _Myos(_Noinit, false) { 
    }
protected:
     basic_iostream(basic_iostream&& _Right)
        : _Myis(_Right.rdbuf(), false), _Myos(_Noinit, false) { 
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }
    basic_iostream&  operator=(basic_iostream&& _Right) { 
        this->swap(_Right);
        return *this;
    }
    void  swap(basic_iostream& _Right) { 
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }
public:
     basic_iostream(const basic_iostream&) = delete;
    basic_iostream&  operator=(const basic_iostream&) = delete;
    virtual  ~basic_iostream() noexcept { 
    }
};
#line 739 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\istream"
template <class _Elem, class _Traits>
inline basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem* _Str) { 
    using _Myis  = basic_istream<_Elem, _Traits>;
    using _Ctype = ctype<_Elem>;
    ios_base::iostate _State = ios_base::goodbit;
    _Elem* _Str0             = _Str;
    const typename _Myis::sentry _Ok(_Istr);
    if (_Ok) { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());
        try {
        streamsize _Count              = 0 < _Istr.width() ? _Istr.width() : (numeric_limits<streamsize>::max)();
        typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
        _Elem _Ch;
        for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= ios_base::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Ch = _Traits::to_char_type(_Meta)) || _Ch == _Elem()) {
                break; 
            } else {
                *_Str++ = _Traits::to_char_type(_Meta); 
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }
    *_Str = _Elem(); 
    _Istr.width(0);
    _Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
    return _Istr;
}
template <class _Elem, class _Traits>
inline basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch) { 
    using _Myis = basic_istream<_Elem, _Traits>;
    typename _Myis::int_type _Meta;
    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myis::sentry _Ok(_Istr);
    if (_Ok) { 
        try {
        _Meta = _Istr.rdbuf()->sbumpc();
        if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _State |= ios_base::eofbit | ios_base::failbit; 
        } else {
            _Ch = _Traits::to_char_type(_Meta); 
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }
    _Istr.setstate(_State);
    return _Istr;
}
template <class _Traits>
inline basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, signed char* _Str) { 
    return _Istr >> (char*) _Str;
}
template <class _Traits>
inline basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, signed char& _Ch) { 
    return _Istr >> (char&) _Ch;
}
template <class _Traits>
inline basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, unsigned char* _Str) { 
    return _Istr >> (char*) _Str;
}
template <class _Traits>
inline basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, unsigned char& _Ch) { 
    return _Istr >> (char&) _Ch;
}
template <class _Istr, class _Ty, class = void>
struct _Can_stream_in : false_type {};
template <class _Istr, class _Ty>
struct _Can_stream_in<_Istr, _Ty, void_t<decltype(::std:: declval<_Istr&>() >> ::std:: declval<_Ty>())>> : true_type {};
template <class _Istr, class _Ty,
    enable_if_t<conjunction_v< 
                    negation<is_lvalue_reference<_Istr>>, is_base_of<ios_base, _Istr>, _Can_stream_in<_Istr, _Ty>>,
        int> = 0>
inline _Istr&& operator>>(_Istr&& _Is, _Ty&& _Val) { 
    _Is >> ::std:: forward<_Ty>(_Val);
    return ::std:: move(_Is);
}
template <class _Elem, class _Traits>
inline basic_istream<_Elem, _Traits>& __cdecl ws(
    basic_istream<_Elem, _Traits>& _Istr) { 
    const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);
    if (_Ok) { 
        ios_base::iostate _State = ios_base::goodbit;
        const auto& _Ctype_fac   = ::std:: use_facet<ctype<_Elem>>(_Istr.getloc());
        try {
        for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();; _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= ios_base::eofbit;
                break;
            } else if (!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta))) {
                break; 
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
        _Istr.setstate(_State);
    }
    return _Istr;
}
}
#pragma warning(pop)
#pragma pack(pop)
#line 872 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\istream"
#line 873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\istream"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Container>
class front_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using container_type = _Container;
    explicit front_insert_iterator(_Container& _Cont) : container(::std:: addressof(_Cont)) { 
    }
    front_insert_iterator& operator=(const typename _Container::value_type& _Val) { 
        container->push_front(_Val);
        return *this;
    }
    front_insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        container->push_front(::std:: move(_Val));
        return *this;
    }
    [[nodiscard]] front_insert_iterator& operator*() { 
        return *this;
    }
    front_insert_iterator& operator++() { 
        return *this;
    }
    front_insert_iterator operator++(int) { 
        return *this;
    }
protected:
    _Container* container; 
};
template <class _Container>
[[nodiscard]] inline front_insert_iterator<_Container> front_inserter(_Container& _Cont) { 
    return front_insert_iterator<_Container>(_Cont);
}
template <class _Container>
class insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using container_type = _Container;
    insert_iterator(_Container& _Cont, typename _Container::iterator _Where)
        : container(::std:: addressof(_Cont)), iter(_Where) { 
    }
    insert_iterator& operator=(
        const typename _Container::value_type& _Val) { 
        iter = container->insert(iter, _Val);
        ++iter;
        return *this;
    }
    insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        iter = container->insert(iter, ::std:: move(_Val));
        ++iter;
        return *this;
    }
    [[nodiscard]] insert_iterator& operator*() { 
        return *this;
    }
    insert_iterator& operator++() { 
        return *this;
    }
    insert_iterator& operator++(int) { 
        return *this;
    }
protected:
    _Container* container; 
    typename _Container::iterator iter; 
};
template <class _Container>
[[nodiscard]] inline insert_iterator<_Container> inserter(_Container& _Cont,
    typename _Container::iterator _Where) { 
    return insert_iterator<_Container>(_Cont, _Where);
}
template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>,
    class _Diff = ptrdiff_t>
class istream_iterator { 
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = const _Ty*;
    using reference         = const _Ty&;
    using char_type    = _Elem;
    using traits_type  = _Traits;
    using istream_type = basic_istream<_Elem, _Traits>;
    constexpr istream_iterator() : _Myistr(nullptr), _Myval() { 
    }
    istream_iterator(istream_type& _Istr) : _Myistr(::std:: addressof(_Istr)) { 
        _Getval();
    }
    [[nodiscard]] const _Ty& operator*() const { 
        return _Myval;
    }
    [[nodiscard]] const _Ty* operator->() const { 
        return ::std:: addressof(_Myval);
    }
    istream_iterator& operator++() { 
        _Getval();
        return *this;
    }
    istream_iterator operator++(int) { 
        istream_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    bool _Equal(const istream_iterator& _Right) const { 
        return _Myistr == _Right._Myistr;
    }
protected:
    void _Getval() { 
        if (_Myistr != nullptr && !(*_Myistr >> _Myval)) {
            _Myistr = nullptr;
        }
    }
    istream_type* _Myistr; 
    _Ty _Myval; 
};
template <class _Ty, class _Elem, class _Traits, class _Diff>
[[nodiscard]] inline bool operator==(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) { 
    return _Left._Equal(_Right);
}
template <class _Ty, class _Elem, class _Traits, class _Diff>
[[nodiscard]] inline bool operator!=(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) { 
    return !(_Left == _Right);
}
template <class _Ty, class _Elem = char,
    class _Traits = char_traits<_Elem>>
class ostream_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = void;
    using pointer           = void;
    using reference         = void;
    using char_type    = _Elem;
    using traits_type  = _Traits;
    using ostream_type = basic_ostream<_Elem, _Traits>;
    ostream_iterator(ostream_type& _Ostr, const _Elem* const _Delim = nullptr)
        : _Mydelim(_Delim), _Myostr(::std:: addressof(_Ostr)) { 
    }
    ostream_iterator& operator=(const _Ty& _Val) { 
        *_Myostr << _Val;
        if (_Mydelim != nullptr) {
            *_Myostr << _Mydelim;
        }
        return *this;
    }
    [[nodiscard]] ostream_iterator& operator*() { 
        return *this;
    }
    ostream_iterator& operator++() { 
        return *this;
    }
    ostream_iterator& operator++(int) { 
        return *this;
    }
protected:
    const _Elem* _Mydelim; 
    ostream_type* _Myostr; 
};
}
namespace stdext {
using ::std:: iterator_traits;
using ::std:: size_t;
template <class _Ptr>
class checked_array_iterator { 
    static_assert(::std:: is_pointer_v<_Ptr>, "checked_array_iterator requires pointers");
public:
    using iterator_category = typename iterator_traits<_Ptr>::iterator_category;
    using value_type        = typename iterator_traits<_Ptr>::value_type;
    using difference_type   = typename iterator_traits<_Ptr>::difference_type;
    using pointer           = typename iterator_traits<_Ptr>::pointer;
    using reference         = typename iterator_traits<_Ptr>::reference;
    constexpr checked_array_iterator() noexcept : _Myarray(nullptr), _Mysize(0), _Myindex(0) { 
    }
    constexpr checked_array_iterator(const _Ptr _Array, const size_t _Size, const size_t _Index = 0) noexcept
        : _Myarray(_Array), _Mysize(_Size), _Myindex(_Index) { 
        do { if (_Index <= _Size) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 256, 0, "%s", "checked_array_iterator construction index out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"checked_array_iterator construction index out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 256, 0); } while (false); } ; } while (false);
    }
    [[nodiscard]] constexpr _Ptr base() const noexcept { 
        return _Myarray + _Myindex;
    }
    [[nodiscard]] constexpr reference operator*() const noexcept { 
        return *operator->();
    }
    [[nodiscard]] constexpr pointer operator->() const noexcept { 
        do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 268, 0, "%s", "cannot dereference value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized or null checked_array_iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 268, 0); } while (false); } ; } while (false);
        do { if (_Myindex < _Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 269, 0, "%s", "cannot dereference end checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference end checked_array_iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 269, 0); } while (false); } ; } while (false);
        return _Myarray + _Myindex;
    }
    constexpr checked_array_iterator& operator++() noexcept { 
        do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 274, 0, "%s", "cannot increment value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized or null checked_array_iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 274, 0); } while (false); } ; } while (false);
        do { if (_Myindex < _Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 275, 0, "%s", "cannot increment checked_array_iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment checked_array_iterator past end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 275, 0); } while (false); } ; } while (false);
        ++_Myindex;
        return *this;
    }
    constexpr checked_array_iterator operator++(int) noexcept { 
        checked_array_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    constexpr checked_array_iterator& operator--() noexcept { 
        do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 287, 0, "%s", "cannot decrement value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized or null checked_array_iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 287, 0); } while (false); } ; } while (false);
        do { if (_Myindex != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 288, 0, "%s", "cannot decrement checked_array_iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement checked_array_iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 288, 0); } while (false); } ; } while (false);
        --_Myindex;
        return *this;
    }
    constexpr checked_array_iterator operator--(int) noexcept { 
        checked_array_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    constexpr checked_array_iterator& operator+=(const difference_type _Off) noexcept { 
        if (_Off != 0) {
            do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 301, 0, "%s", "cannot seek value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized or null checked_array_iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 301, 0); } while (false); } ; } while (false);
        }
        if (_Off < 0) {
#pragma warning(suppress : 4146) 
            do { if (_Myindex >= -static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 306, 0, "%s", "cannot seek checked_array_iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 306, 0); } while (false); } ; } while (false);
        }
        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 311, 0, "%s", "cannot seek checked_array_iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 311, 0); } while (false); } ; } while (false);
#line 312 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
        }
        _Myindex += _Off;
        return *this;
    }
    [[nodiscard]] constexpr checked_array_iterator operator+(const difference_type _Off) const
        noexcept { 
        checked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }
    friend constexpr checked_array_iterator operator+(const difference_type _Off,
        const checked_array_iterator<_Ptr>& _Next) noexcept { 
        return _Next + _Off;
    }
    constexpr checked_array_iterator& operator-=(const difference_type _Off) noexcept { 
        if (_Off != 0) {
            do { if (_Myarray) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 333, 0, "%s", "cannot seek value-initialized or null checked_array_iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized or null checked_array_iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 333, 0); } while (false); } ; } while (false);
        }
        if (_Off > 0) {
            do { if (_Myindex >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 337, 0, "%s", "cannot seek checked_array_iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 337, 0); } while (false); } ; } while (false);
        }
        if (_Off < 0) {
#pragma warning(suppress : 4146) 
            do { if (_Mysize - _Myindex >= -static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 343, 0, "%s", "cannot seek checked_array_iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 343, 0); } while (false); } ; } while (false);
#line 344 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
        }
        _Myindex -= _Off;
        return *this;
    }
    [[nodiscard]] constexpr checked_array_iterator operator-(const difference_type _Off) const
        noexcept { 
        checked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }
    [[nodiscard]] constexpr difference_type operator-(const checked_array_iterator& _Right) const
        noexcept { 
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 360, 0, "%s", "cannot subtract incompatible checked_array_iterators")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot subtract incompatible checked_array_iterators\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 360, 0); } while (false); } ; } while (false);
#line 361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
        return static_cast<difference_type>(_Myindex - _Right._Myindex);
    }
    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept { 
        return *(*this + _Off);
    }
    [[nodiscard]] constexpr bool operator==(const checked_array_iterator& _Right) const
        noexcept { 
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 371, 0, "%s", "cannot compare incompatible checked_array_iterators for equality")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot compare incompatible checked_array_iterators for equality\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 371, 0); } while (false); } ; } while (false);
#line 372 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
        return _Myindex == _Right._Myindex;
    }
    [[nodiscard]] constexpr bool operator!=(const checked_array_iterator& _Right) const
        noexcept { 
        return !(*this == _Right);
    }
    [[nodiscard]] constexpr bool operator<(const checked_array_iterator& _Right) const noexcept { 
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 382, 0, "%s", "cannot compare incompatible checked_array_iterators")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot compare incompatible checked_array_iterators\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 382, 0); } while (false); } ; } while (false);
#line 383 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
        return _Myindex < _Right._Myindex;
    }
    [[nodiscard]] constexpr bool operator>(const checked_array_iterator& _Right) const noexcept { 
        return _Right < *this;
    }
    [[nodiscard]] constexpr bool operator<=(const checked_array_iterator& _Right) const
        noexcept { 
        return !(_Right < *this);
    }
    [[nodiscard]] constexpr bool operator>=(const checked_array_iterator& _Right) const
        noexcept { 
        return !(*this < _Right);
    }
    friend constexpr void _Verify_range(
        const checked_array_iterator& _First, const checked_array_iterator& _Last) noexcept {
        do { if (_First._Myarray == _Last._Myarray && _First._Mysize == _Last._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 403, 0, "%s", "mismatching checked_array_iterators")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"mismatching checked_array_iterators\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 403, 0); } while (false); } ; } while (false);
#line 404 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
        do { if (_First._Myindex <= _Last._Myindex) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 404, 0, "%s", "transposed checked_array_iterator range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"transposed checked_array_iterator range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 404, 0); } while (false); } ; } while (false);
    }
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        if (_Off < 0) {
#pragma warning(suppress : 4146) 
            do { if (_Myindex >= -static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 411, 0, "%s", "cannot seek checked_array_iterator iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 411, 0); } while (false); } ; } while (false);
#line 412 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
        }
        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 416, 0, "%s", "cannot seek checked_array_iterator iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek checked_array_iterator iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator", 416, 0); } while (false); } ; } while (false);
#line 417 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
        }
    }
    using _Prevent_inheriting_unwrap = checked_array_iterator;
    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myarray + _Myindex;
    }
    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myindex = static_cast<size_t>(_It - _Myarray);
    }
private:
    _Ptr _Myarray; 
    size_t _Mysize; 
    size_t _Myindex; 
};
template <class _Ptr>
[[nodiscard]] constexpr checked_array_iterator<_Ptr> make_checked_array_iterator(
    const _Ptr _Array, const size_t _Size, const size_t _Index = 0) { 
    return checked_array_iterator<_Ptr>(_Array, _Size, _Index);
}
template <class _Ptr>
class unchecked_array_iterator { 
    static_assert(::std:: is_pointer_v<_Ptr>, "unchecked_array_iterator requires pointers");
public:
    using iterator_category = typename iterator_traits<_Ptr>::iterator_category;
    using value_type        = typename iterator_traits<_Ptr>::value_type;
    using difference_type   = typename iterator_traits<_Ptr>::difference_type;
    using pointer           = typename iterator_traits<_Ptr>::pointer;
    using reference         = typename iterator_traits<_Ptr>::reference;
    constexpr unchecked_array_iterator() noexcept : _Myptr(nullptr) { 
    }
    constexpr explicit unchecked_array_iterator(const _Ptr _Src) noexcept : _Myptr(_Src) { 
    }
    [[nodiscard]] constexpr _Ptr base() const noexcept { 
        return _Myptr;
    }
    [[nodiscard]] constexpr reference operator*() const noexcept { 
        return *_Myptr;
    }
    [[nodiscard]] constexpr pointer operator->() const noexcept { 
        return _Myptr;
    }
    constexpr unchecked_array_iterator& operator++() noexcept { 
        ++_Myptr;
        return *this;
    }
    constexpr unchecked_array_iterator operator++(int) noexcept { 
        unchecked_array_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    constexpr unchecked_array_iterator& operator--() noexcept { 
        --_Myptr;
        return *this;
    }
    constexpr unchecked_array_iterator operator--(int) noexcept { 
        unchecked_array_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    constexpr unchecked_array_iterator& operator+=(const difference_type _Off) noexcept { 
        _Myptr += _Off;
        return *this;
    }
    [[nodiscard]] constexpr unchecked_array_iterator operator+(const difference_type _Off) const
        noexcept { 
        unchecked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }
    friend constexpr unchecked_array_iterator operator+(const difference_type _Off,
        const unchecked_array_iterator& _Next) noexcept { 
        return _Next + _Off;
    }
    constexpr unchecked_array_iterator& operator-=(const difference_type _Off) noexcept { 
        return *this += -_Off;
    }
    [[nodiscard]] constexpr unchecked_array_iterator operator-(const difference_type _Off) const
        noexcept { 
        unchecked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }
    [[nodiscard]] constexpr difference_type operator-(const unchecked_array_iterator& _Right) const
        noexcept { 
        return _Myptr - _Right._Myptr;
    }
    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept { 
        return *(*this + _Off);
    }
    [[nodiscard]] constexpr bool operator==(const unchecked_array_iterator& _Right) const
        noexcept { 
        return _Myptr == _Right._Myptr;
    }
    [[nodiscard]] constexpr bool operator!=(const unchecked_array_iterator& _Right) const
        noexcept { 
        return !(*this == _Right);
    }
    [[nodiscard]] constexpr bool operator<(const unchecked_array_iterator& _Right) const
        noexcept { 
        return _Myptr < _Right._Myptr;
    }
    [[nodiscard]] constexpr bool operator>(const unchecked_array_iterator& _Right) const
        noexcept { 
        return _Right < *this;
    }
    [[nodiscard]] constexpr bool operator<=(const unchecked_array_iterator& _Right) const
        noexcept { 
        return !(_Right < *this);
    }
    [[nodiscard]] constexpr bool operator>=(const unchecked_array_iterator& _Right) const
        noexcept { 
        return !(*this < _Right);
    }
    friend constexpr void _Verify_range(
        const unchecked_array_iterator _First, const unchecked_array_iterator _Last) noexcept {
        ::std:: _Verify_range(_First._Myptr, _Last._Myptr);
    }
#line 568 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
    using _Prevent_inheriting_unwrap = unchecked_array_iterator;
    static constexpr bool _Unwrap_when_unverified = true;
    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myptr;
    }
    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myptr = _It;
    }
private:
    _Ptr _Myptr; 
};
template <class _Ptr>
[[nodiscard]] inline unchecked_array_iterator<_Ptr> make_unchecked_array_iterator(
    const _Ptr _It) noexcept { 
    return unchecked_array_iterator<_Ptr>(_It);
}
}
#pragma warning(pop)
#pragma pack(pop)
#line 597 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
#line 598 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\iterator"
#line 6 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\string"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cctype"
#pragma once
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
using :: isalnum;
using :: isalpha;
using :: iscntrl;
using :: isdigit;
using :: isgraph;
using :: islower;
using :: isprint;
using :: ispunct;
using :: isspace;
using :: isupper;
using :: isxdigit;
using :: tolower;
using :: toupper;
using :: isblank;
}
#pragma warning(pop)
#pragma pack(pop)
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cctype"
#line 59 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cctype"
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\string"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Elem, class _Traits, class _Alloc>
inline basic_istream<_Elem, _Traits>& getline(basic_istream<_Elem, _Traits>&& _Istr,
    basic_string<_Elem, _Traits, _Alloc>& _Str,
    const _Elem _Delim) { 
    using _Myis = basic_istream<_Elem, _Traits>;
    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed                  = false;
    const typename _Myis::sentry _Ok(_Istr, true);
    if (_Ok) { 
        try {
        _Str.erase();
        const typename _Traits::int_type _Metadelim = _Traits::to_int_type(_Delim);
        typename _Traits::int_type _Meta            = _Istr.rdbuf()->sgetc();
        for (;; _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= _Myis::eofbit;
                break;
            } else if (_Traits::eq_int_type(_Meta, _Metadelim)) { 
                _Changed = true;
                _Istr.rdbuf()->sbumpc();
                break;
            } else if (_Str.max_size() <= _Str.size()) { 
                _State |= _Myis::failbit;
                break;
            } else { 
                _Str += _Traits::to_char_type(_Meta);
                _Changed = true;
            }
        }
        } catch (...) { (_Istr) .setstate(_Myis::badbit, true); }
    }
    if (!_Changed) {
        _State |= _Myis::failbit;
    }
    _Istr.setstate(_State);
    return _Istr;
}
template <class _Elem, class _Traits, class _Alloc>
inline basic_istream<_Elem, _Traits>& getline(basic_istream<_Elem, _Traits>&& _Istr,
    basic_string<_Elem, _Traits, _Alloc>& _Str) { 
    return getline(_Istr, _Str, _Istr.widen('\n'));
}
template <class _Elem, class _Traits, class _Alloc>
inline basic_istream<_Elem, _Traits>& getline(basic_istream<_Elem, _Traits>& _Istr,
    basic_string<_Elem, _Traits, _Alloc>& _Str,
    const _Elem _Delim) { 
    return getline(::std:: move(_Istr), _Str, _Delim);
}
template <class _Elem, class _Traits, class _Alloc>
inline basic_istream<_Elem, _Traits>& getline(basic_istream<_Elem, _Traits>& _Istr,
    basic_string<_Elem, _Traits, _Alloc>& _Str) { 
    return getline(::std:: move(_Istr), _Str, _Istr.widen('\n'));
}
inline int stoi(const string& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref      = 0;
    const long _Ans = :: strtol(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoi argument");
    }
    if (_Errno_ref == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans) {
        _Xout_of_range("stoi argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return static_cast<int>(_Ans);
}
inline long stol(const string& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref      = 0;
    const long _Ans = :: strtol(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stol argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stol argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline unsigned long stoul(const string& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref               = 0;
    const unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoul argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoul argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline long long stoll(const string& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref           = 0;
    const long long _Ans = :: strtoll(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoll argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoll argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline unsigned long long stoull(const string& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref                    = 0;
    const unsigned long long _Ans = :: strtoull(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoull argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoull argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline float stof(const string& _Str, size_t* _Idx = nullptr) { 
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref       = 0;
    const float _Ans = :: strtof(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stof argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stof argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline double stod(const string& _Str, size_t* _Idx = nullptr) { 
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref        = 0;
    const double _Ans = :: strtod(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stod argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stod argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline long double stold(const string& _Str, size_t* _Idx = nullptr) { 
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref             = 0;
    const long double _Ans = :: strtold(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stold argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stold argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline int stoi(const wstring& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref      = 0;
    const long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoi argument");
    }
    if (_Errno_ref == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans) {
        _Xout_of_range("stoi argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return static_cast<int>(_Ans);
}
inline long stol(const wstring& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref      = 0;
    const long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stol argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stol argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline unsigned long stoul(const wstring& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref               = 0;
    const unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoul argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoul argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline long long stoll(const wstring& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref           = 0;
    const long long _Ans = :: wcstoll(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoll argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoll argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline unsigned long long stoull(const wstring& _Str, size_t* _Idx = nullptr,
    int _Base = 10) { 
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref                    = 0;
    const unsigned long long _Ans = :: wcstoull(_Ptr, &_Eptr, _Base);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoull argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stoull argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline float stof(const wstring& _Str, size_t* _Idx = nullptr) { 
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref       = 0;
    const float _Ans = :: wcstof(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stof argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stof argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline double stod(const wstring& _Str, size_t* _Idx = nullptr) { 
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref        = 0;
    const double _Ans = :: wcstod(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stod argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stod argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
inline long double stold(const wstring& _Str, size_t* _Idx = nullptr) { 
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref             = 0;
    const long double _Ans = :: wcstold(_Ptr, &_Eptr);
    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stold argument");
    }
    if (_Errno_ref == 34) {
        _Xout_of_range("stold argument out of range");
    }
    if (_Idx != nullptr) {
        *_Idx = (size_t)(_Eptr - _Ptr);
    }
    return _Ans;
}
template <class _Elem, class _UTy>
inline _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { 
    static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
    auto _UVal_trunc = _UVal;
#line 473 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\string"
    do {
        *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);
        _UVal_trunc /= 10;
    } while (_UVal_trunc != 0);
    return _RNext;
}
template <class _Elem,
    class _Ty>
inline basic_string<_Elem> _Integral_to_string(const _Ty _Val) { 
    static_assert(is_integral_v<_Ty>, "_Ty must be integral");
    using _UTy = make_unsigned_t<_Ty>;
    _Elem _Buff[21]; 
    _Elem* const _Buff_end = ::std:: end(_Buff);
    _Elem* _RNext          = _Buff_end;
    const auto _UVal       = static_cast<_UTy>(_Val);
    if (_Val < 0) {
        _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);
        *--_RNext = '-';
    } else {
        _RNext = _UIntegral_to_buff(_RNext, _UVal);
    }
    return basic_string<_Elem>(_RNext, _Buff_end);
}
template <class _Ty>
inline string _Floating_to_string(const char* _Fmt, _Ty _Val) { 
    static_assert(is_floating_point_v<_Ty>, "_Ty must be floating point");
    const auto _Len = static_cast<size_t>(:: _scprintf(_Fmt, _Val));
    string _Str(_Len, '\0');
    :: sprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
    return _Str;
}
template <class _Ty>
inline wstring _Floating_to_wstring(const wchar_t* _Fmt, _Ty _Val) { 
    static_assert(is_floating_point_v<_Ty>, "_Ty must be floating point");
    const auto _Len = static_cast<size_t>(:: _scwprintf(_Fmt, _Val));
    wstring _Str(_Len, L'\0');
    :: swprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
    return _Str;
}
[[nodiscard]] inline string to_string(int _Val) { 
    return _Integral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(unsigned int _Val) { 
    return _Integral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(long _Val) { 
    return _Integral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(unsigned long _Val) { 
    return _Integral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(long long _Val) { 
    return _Integral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(unsigned long long _Val) { 
    return _Integral_to_string<char>(_Val);
}
[[nodiscard]] inline string to_string(float _Val) { 
    return _Floating_to_string("%f", _Val);
}
[[nodiscard]] inline string to_string(double _Val) { 
    return _Floating_to_string("%f", _Val);
}
[[nodiscard]] inline string to_string(long double _Val) { 
    return _Floating_to_string("%Lf", _Val);
}
[[nodiscard]] inline wstring to_wstring(int _Val) { 
    return _Integral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(unsigned int _Val) { 
    return _Integral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(long _Val) { 
    return _Integral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(unsigned long _Val) { 
    return _Integral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(long long _Val) { 
    return _Integral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(unsigned long long _Val) { 
    return _Integral_to_string<wchar_t>(_Val);
}
[[nodiscard]] inline wstring to_wstring(float _Val) { 
    return _Floating_to_wstring(L"%f", _Val);
}
[[nodiscard]] inline wstring to_wstring(double _Val) { 
    return _Floating_to_wstring(L"%f", _Val);
}
[[nodiscard]] inline wstring to_wstring(long double _Val) { 
    return _Floating_to_wstring(L"%Lf", _Val);
}
}
#pragma warning(pop)
#pragma pack(pop)
#line 602 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\string"
#line 603 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\string"
#line 7 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#pragma once
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Myvec>
class _Vector_const_iterator : public _Iterator_base { 
public:
    using iterator_category = random_access_iterator_tag;
    using value_type      = typename _Myvec::value_type;
    using difference_type = typename _Myvec::difference_type;
    using pointer         = typename _Myvec::const_pointer;
    using reference       = const value_type&;
    using _Tptr           = typename _Myvec::pointer;
    _Vector_const_iterator() : _Ptr() { 
    }
    _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) : _Ptr(_Parg) { 
        this->_Adopt(_Pvector);
    }
    [[nodiscard]] reference operator*() const { 
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 42, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 42, 0); } while (false); } ; } while (false);
        do { if (_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 44, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference out of range vector iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 44, 0); } while (false); } ; } while (false);
#line 45 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        return *_Ptr;
    }
    [[nodiscard]] pointer operator->() const { 
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 53, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 53, 0); } while (false); } ; } while (false);
        do { if (_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 55, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference out of range vector iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 55, 0); } while (false); } ; } while (false);
#line 56 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        return _Ptr;
    }
    _Vector_const_iterator& operator++() { 
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 64, 0, "%s", "can't increment value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't increment value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 64, 0); } while (false); } ; } while (false);
        do { if (_Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 65, 0, "%s", "can't increment vector iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't increment vector iterator past end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 65, 0); } while (false); } ; } while (false);
#line 67 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        ++_Ptr;
        return *this;
    }
    _Vector_const_iterator operator++(int) { 
        _Vector_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _Vector_const_iterator& operator--() { 
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 81, 0, "%s", "can't decrement value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't decrement value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 81, 0); } while (false); } ; } while (false);
        do { if (_Mycont->_Myfirst < _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 82, 0, "%s", "can't decrement vector iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't decrement vector iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 82, 0); } while (false); } ; } while (false);
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        --_Ptr;
        return *this;
    }
    _Vector_const_iterator operator--(int) { 
        _Vector_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    void _Verify_offset(const difference_type _Off) const {
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        do { if (_Off == 0 || _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 100, 0, "%s", "cannot seek value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 100, 0); } while (false); } ; } while (false);
        if (_Off < 0) {
            do { if (_Off >= _Mycont->_Myfirst - _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 102, 0, "%s", "cannot seek vector iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek vector iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 102, 0); } while (false); } ; } while (false);
        }
        if (_Off > 0) {
            do { if (_Off <= _Mycont->_Mylast - _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 106, 0, "%s", "cannot seek vector iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek vector iterator after end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 106, 0); } while (false); } ; } while (false);
        }
#line 109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
    _Vector_const_iterator& operator+=(const difference_type _Off) { 
        _Verify_offset(_Off);
        _Ptr += _Off;
        return *this;
    }
    [[nodiscard]] _Vector_const_iterator operator+(const difference_type _Off) const { 
        _Vector_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _Vector_const_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _Vector_const_iterator operator-(const difference_type _Off) const { 
        _Vector_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(const _Vector_const_iterator& _Right) const { 
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }
    [[nodiscard]] reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    [[nodiscard]] bool operator==(const _Vector_const_iterator& _Right) const { 
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }
    [[nodiscard]] bool operator!=(const _Vector_const_iterator& _Right) const { 
        return !(*this == _Right);
    }
    [[nodiscard]] bool operator<(const _Vector_const_iterator& _Right) const { 
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }
    [[nodiscard]] bool operator>(const _Vector_const_iterator& _Right) const { 
        return _Right < *this;
    }
    [[nodiscard]] bool operator<=(const _Vector_const_iterator& _Right) const { 
        return !(_Right < *this);
    }
    [[nodiscard]] bool operator>=(const _Vector_const_iterator& _Right) const { 
        return !(*this < _Right);
    }
    void _Compat(const _Vector_const_iterator& _Right) const { 
#line 170 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 170, 0, "%s", "vector iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 170, 0); } while (false); } ; } while (false);
#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
    friend void _Verify_range(const _Vector_const_iterator& _First, const _Vector_const_iterator& _Last) {
        do { if (_First._Getcont() == _Last._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 176, 0, "%s", "vector iterators in range are from different containers")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector iterators in range are from different containers\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 176, 0); } while (false); } ; } while (false);
        do { if (_First._Ptr <= _Last._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 177, 0, "%s", "vector iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector iterator range transposed\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 177, 0); } while (false); } ; } while (false);
    }
#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    using _Prevent_inheriting_unwrap = _Vector_const_iterator;
    [[nodiscard]] pointer _Unwrapped() const {
        return _Ptr;
    }
    void _Seek_to(pointer _It) {
        _Ptr = _Const_cast(_It);
    }
    _Tptr _Ptr; 
};
template <class _Myvec>
[[nodiscard]] inline _Vector_const_iterator<_Myvec> operator+(
    typename _Vector_const_iterator<_Myvec>::difference_type _Off,
    _Vector_const_iterator<_Myvec> _Next) { 
    return _Next += _Off;
}
template <class _Myvec>
class _Vector_iterator : public _Vector_const_iterator<_Myvec> { 
public:
    using _Mybase           = _Vector_const_iterator<_Myvec>;
    using iterator_category = random_access_iterator_tag;
    using value_type      = typename _Myvec::value_type;
    using difference_type = typename _Myvec::difference_type;
    using pointer         = typename _Myvec::pointer;
    using reference       = value_type&;
    _Vector_iterator() { 
    }
    _Vector_iterator(pointer _Parg, const _Container_base* _Pvector)
        : _Mybase(_Parg, _Pvector) { 
    }
    [[nodiscard]] reference operator*() const { 
        return const_cast<reference>(_Mybase::operator*());
    }
    [[nodiscard]] pointer operator->() const { 
        return _Const_cast(_Mybase::operator->());
    }
    _Vector_iterator& operator++() { 
        ++*(_Mybase*) this;
        return *this;
    }
    _Vector_iterator operator++(int) { 
        _Vector_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _Vector_iterator& operator--() { 
        --*(_Mybase*) this;
        return *this;
    }
    _Vector_iterator operator--(int) { 
        _Vector_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    _Vector_iterator& operator+=(const difference_type _Off) { 
        *(_Mybase*) this += _Off;
        return *this;
    }
    [[nodiscard]] _Vector_iterator operator+(const difference_type _Off) const { 
        _Vector_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _Vector_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _Vector_iterator operator-(const difference_type _Off) const { 
        _Vector_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(const _Mybase& _Right) const { 
        return *(_Mybase*) this - _Right;
    }
    [[nodiscard]] reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    using _Prevent_inheriting_unwrap = _Vector_iterator;
    [[nodiscard]] pointer _Unwrapped() const {
        return this->_Ptr;
    }
};
template <class _Myvec>
[[nodiscard]] inline _Vector_iterator<_Myvec> operator+(typename _Vector_iterator<_Myvec>::difference_type _Off,
    _Vector_iterator<_Myvec> _Next) { 
    return _Next += _Off;
}
template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference,
    class _Const_reference>
struct _Vec_iter_types { 
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};
struct _Value_init_tag { 
};
template <class _Val_types>
class _Vector_val : public _Container_base { 
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;
    _Vector_val() : _Myfirst(), _Mylast(), _Myend() { 
    }
    pointer _Myfirst; 
    pointer _Mylast; 
    pointer _Myend; 
};
template <class _Ptrty>
inline auto _Unfancy_maybe_null(_Ptrty _Ptr) { 
    return _Ptr ? ::std:: addressof(*_Ptr) : nullptr;
}
template <class _Ty>
inline _Ty* _Unfancy_maybe_null(_Ty* _Ptr) { 
    return _Ptr;
}
template <class _Ty, class _Alloc = allocator<_Ty>>
class vector { 
private:
    template <class>
    friend class _Vb_val;
    friend _Tidy_guard<vector>;
    template <class>
    friend class _Hash;
    using _Alty        = _Rebind_alloc_t<_Alloc, _Ty>;
    using _Alty_traits = allocator_traits<_Alty>;
    using _Scary_val = _Vector_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Ty>,
        _Vec_iter_types<_Ty, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Ty&, const _Ty&>>>;
public:
    static_assert(!1 || is_same_v<_Ty, typename _Alloc::value_type>,
        "vector<T, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");
    using value_type             = _Ty;
    using allocator_type         = _Alloc;
    using pointer                = typename _Alty_traits::pointer;
    using const_pointer          = typename _Alty_traits::const_pointer;
    using reference              = _Ty&;
    using const_reference        = const _Ty&;
    using size_type              = typename _Alty_traits::size_type;
    using difference_type        = typename _Alty_traits::difference_type;
    using iterator               = _Vector_iterator<_Scary_val>;
    using const_iterator         = _Vector_const_iterator<_Scary_val>;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
    vector() noexcept(is_nothrow_default_constructible_v<_Alty>)
        : _Mypair(_Zero_then_variadic_args_t()) { 
        _Get_data()._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
    }
    explicit vector(const _Alloc& _Al) noexcept
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Get_data()._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
    }
private:
    template <class _Ty2>
    void _Construct_n_copies_of_ty( const size_type _Count, const _Ty2& _Val) {
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard<vector> _Guard{this};
            _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);
            _Guard._Target = nullptr;
        }
        _Proxy._Release();
    }
public:
    explicit vector( const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Construct_n_copies_of_ty(_Count, _Value_init_tag{});
    }
    vector( const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Construct_n_copies_of_ty(_Count, _Val);
    }
private:
    template <class _Any_alloc>
    vector(_Move_allocator_tag,  const size_type _Count, const _Ty& _Val, _Any_alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), ::std:: move(_Al)) { 
        _Construct_n_copies_of_ty(_Count, _Val);
    }
    template <class _Iter>
    void _Range_construct_or_tidy(_Iter _First, _Iter _Last,
        input_iterator_tag) { 
        _Tidy_guard<vector> _Guard{this};
        for (; _First != _Last; ++_First) {
            emplace_back(*_First); 
        }
        _Guard._Target = nullptr;
    }
    template <class _Iter>
    void _Range_construct_or_tidy(_Iter _First, _Iter _Last,
        forward_iterator_tag) { 
        const auto _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard<vector> _Guard{this};
            _Mylast()      = _Ucopy(_First, _Last, _Myfirst());
            _Guard._Target = nullptr;
        }
    }
public:
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Adl_verify_range(_First, _Last);
        _Range_construct_or_tidy(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        _Proxy._Release();
    }
    vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        _Proxy._Release();
    }
    vector(const vector& _Right)
        : _Mypair(_One_then_variadic_args_t(),
              _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        if (!_Right.empty()) {
            _Buy_raw(_Right.size());
            _Tidy_guard<vector> _Guard{this};
            _Mylast()      = _Ucopy(_Right._Myfirst(), _Right._Mylast(), _Myfirst());
            _Guard._Target = nullptr;
        }
        _Proxy._Release();
    }
    vector(const vector& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        if (!_Right.empty()) {
            _Buy_raw(_Right.size());
            _Tidy_guard<vector> _Guard{this};
            _Mylast()      = _Ucopy(_Right._Myfirst(), _Right._Mylast(), _Myfirst());
            _Guard._Target = nullptr;
        }
        _Proxy._Release();
    }
private:
    void _Take_contents(vector& _Right) noexcept {
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        _My_data._Swap_proxy_and_iterators(_Right_data);
        _My_data._Myfirst = _Right_data._Myfirst;
        _My_data._Mylast  = _Right_data._Mylast;
        _My_data._Myend   = _Right_data._Myend;
        _Right_data._Myfirst = pointer();
        _Right_data._Mylast  = pointer();
        _Right_data._Myend   = pointer();
    }
    void _Move_construct(vector& _Right, true_type) noexcept { 
        _Take_contents(_Right);
    }
    void _Move_construct(vector& _Right, false_type) { 
        if
            constexpr(!_Alty_traits::is_always_equal::value) {
                if (_Getal() != _Right._Getal()) {
                    if (!_Right.empty()) {
                        _Buy_raw(_Right.size());
                        _Tidy_guard<vector> _Guard{this};
                        _Mylast()      = _Umove(_Right._Myfirst(), _Right._Mylast(), _Myfirst());
                        _Guard._Target = nullptr;
                    }
                    return;
                }
            }
        _Move_construct(_Right, true_type{});
    }
public:
    vector(vector&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std:: move(_Right._Getal())) { 
        _Get_data()._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Move_construct(_Right, true_type{});
    }
    vector(vector&& _Right, const _Alloc& _Al) noexcept(_Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Move_construct(_Right, typename _Alty_traits::is_always_equal::type{});
        _Proxy._Release();
    }
private:
    void _Move_assign(vector& _Right, _Equal_allocators) noexcept {
        _Tidy();
        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right);
    }
    void _Move_assign(vector& _Right, _Propagate_allocators) noexcept {
        _Tidy();
        if (_Getal() != _Right._Getal()) {
            _Get_data()._Reload_proxy(
                static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right._Getal()));
        }
#line 553 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right);
    }
    void _Move_assign(vector& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            const pointer _First     = _Right._Myfirst();
            const pointer _Last      = _Right._Mylast();
            const size_type _Newsize = _Right.size();
            _Orphan_all();
            if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Ty*, _Ty*>::_Trivially_copyable>,
                              _Uses_default_construct<_Alty, _Ty*, _Ty>, _Uses_default_destroy<_Alty, _Ty*>>) {
                if (_Newsize > capacity()) {
                    _Clear_and_reserve_geometric(_Newsize);
                }
                _Mylast() = _Refancy<pointer>(_Copy_memmove(_Unfancy(_First), _Unfancy(_Last), _Unfancy(_Myfirst())));
            } else
#line 578 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
            {
                size_type _Oldsize = size();
                if (_Newsize > _Oldsize) {
                    if (_Newsize > capacity()) { 
                        _Clear_and_reserve_geometric(_Newsize);
                        _Oldsize = 0;
                    }
                    const pointer _Mid = _First + _Oldsize;
                    _Move_unchecked(_First, _Mid, _Myfirst());
                    _Mylast() = _Umove(_Mid, _Last, _Mylast());
                } else {
                    const pointer _Newlast = _Myfirst() + _Newsize;
                    _Move_unchecked(_First, _Last, _Myfirst());
                    _Destroy(_Newlast, _Mylast());
                    _Mylast() = _Newlast;
                }
            }
        }
    }
public:
    vector& operator=(vector&& _Right) noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
        if (this != ::std:: addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma<_Alty>{});
        }
        return *this;
    }
    ~vector() noexcept { 
        _Tidy();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Delete_plain(_Alproxy, ::std:: exchange(_Myproxy(), nullptr));
#line 615 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
private:
    template <class... _Valty>
    decltype(auto) _Emplace_back_with_unused_capacity(
        _Valty&&... _Val) { 
        _Alty_traits::construct(_Getal(), _Unfancy(_Mylast()), ::std:: forward<_Valty>(_Val)...);
        _Orphan_range(_Mylast(), _Mylast());
        _Ty& _Result = *_Mylast();
        ++_Mylast();
        return _Result;
#line 631 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
public:
    template <class... _Valty>
    decltype(auto) emplace_back(
        _Valty&&... _Val) { 
        if (_Has_unused_capacity()) {
            return _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
        }
        _Ty& _Result = *_Emplace_reallocate(_Mylast(), ::std:: forward<_Valty>(_Val)...);
        return _Result;
#line 647 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
    void push_back(const _Ty& _Val) { 
        emplace_back(_Val);
    }
    void push_back(_Ty&& _Val) { 
        emplace_back(::std:: move(_Val));
    }
    template <class... _Valty>
    pointer _Emplace_reallocate(
        const pointer _Whereptr, _Valty&&... _Val) { 
        const size_type _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst());
        _Alty& _Al                = _Getal();
        const size_type _Oldsize  = size();
        if (_Oldsize == max_size()) {
            _Xlength();
        }
        const size_type _Newsize     = _Oldsize + 1;
        const size_type _Newcapacity = _Calculate_growth(_Newsize);
        const pointer _Newvec           = _Al.allocate(_Newcapacity);
        const pointer _Constructed_last = _Newvec + _Whereoff + 1;
        pointer _Constructed_first      = _Constructed_last;
        try {
        _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), ::std:: forward<_Valty>(_Val)...);
        _Constructed_first = _Newvec + _Whereoff;
        if (_Whereptr == _Mylast()) { 
            _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
        } else { 
            _Umove(_Myfirst(), _Whereptr, _Newvec);
            _Constructed_first = _Newvec;
            _Umove(_Whereptr, _Mylast(), _Newvec + _Whereoff + 1);
        }
        } catch (...) {
        _Destroy(_Constructed_first, _Constructed_last);
        _Al.deallocate(_Newvec, _Newcapacity);
        throw;
        }
        _Change_array(_Newvec, _Newsize, _Newcapacity);
        return this->_Myfirst() + _Whereoff;
    }
    template <class... _Valty>
    iterator emplace(const_iterator _Where, _Valty&&... _Val) { 
        const pointer _Whereptr = _Where._Ptr;
        const pointer _Oldlast  = _Mylast();
        do { if (_Where._Getcont() == ::std:: addressof(_Get_data()) && _Whereptr >= _Myfirst() && _Oldlast >= _Whereptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 704, 0, "%s", "vector emplace iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector emplace iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 704, 0); } while (false); } ; } while (false);
#line 705 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 706 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        if (_Has_unused_capacity()) {
            if (_Whereptr == _Oldlast) { 
                _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
            } else {
                _Ty _Obj(::std:: forward<_Valty>(_Val)...); 
                _Orphan_range(_Whereptr, _Oldlast);
                _Alty_traits::construct(_Getal(), _Unfancy(_Oldlast), ::std:: move(_Oldlast[-1]));
                ++_Mylast();
                _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                *_Whereptr = ::std:: move(_Obj);
            }
            return _Make_iterator(_Whereptr);
        }
        return _Make_iterator(_Emplace_reallocate(_Whereptr, ::std:: forward<_Valty>(_Val)...));
    }
    iterator insert(const_iterator _Where, const _Ty& _Val) { 
        return emplace(_Where, _Val);
    }
    iterator insert(const_iterator _Where, _Ty&& _Val) { 
        return emplace(_Where, ::std:: move(_Val));
    }
    iterator insert(const_iterator _Where,  const size_type _Count,
        const _Ty& _Val) { 
        do { if (_Where._Getcont() == ::std:: addressof(_Get_data()) && _Where._Ptr >= _Myfirst() && _Mylast() >= _Where._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 739, 0, "%s", "vector insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 739, 0); } while (false); } ; } while (false);
#line 740 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 741 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst());
        const bool _One_at_back   = _Count == 1 && _Where._Ptr == _Mylast();
        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity()) { 
            const size_type _Oldsize = size();
            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }
            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);
            const pointer _Newvec           = _Getal().allocate(_Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;
            try {
            _Ufill(_Newvec + _Whereoff, _Count, _Val);
            _Constructed_first = _Newvec + _Whereoff;
            if (_One_at_back) { 
                _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
            } else { 
                _Umove(_Myfirst(), _Where._Ptr, _Newvec);
                _Constructed_first = _Newvec;
                _Umove(_Where._Ptr, _Mylast(), _Newvec + _Whereoff + _Count);
            }
            } catch (...) {
            _Destroy(_Constructed_first, _Constructed_last);
            _Getal().deallocate(_Newvec, _Newcapacity);
            throw;
            }
            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else if (_One_at_back) { 
            _Emplace_back_with_unused_capacity(_Val);
        } else { 
            const _Ty _Tmp                     = _Val; 
            const pointer _Oldlast             = _Mylast();
            const size_type _Affected_elements = static_cast<size_type>(_Oldlast - _Where._Ptr);
            _Orphan_range(_Where._Ptr, _Oldlast);
            if (_Count > _Affected_elements) { 
                _Mylast() = _Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
                _Mylast() = _Umove(_Where._Ptr, _Oldlast, _Mylast());
                _Fill_unchecked(_Where._Ptr, _Oldlast, _Tmp);
            } else { 
                _Mylast() = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                _Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
                _Fill_unchecked(_Where._Ptr, _Where._Ptr + _Count, _Tmp);
            }
        }
        return _Make_iterator_offset(_Whereoff);
    }
private:
    template <class _Iter>
    void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last,
        input_iterator_tag) { 
        if (_First == _Last) {
            return; 
        }
        const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst());
        const size_type _Oldsize  = size();
        for (; _First != _Last; ++_First) {
            emplace_back(*_First);
        }
        _Orphan_range(_Myfirst() + _Whereoff, _Myfirst() + _Oldsize);
        ::std:: rotate(_Myfirst() + _Whereoff, _Myfirst() + _Oldsize, _Mylast());
    }
    template <class _Iter>
    void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last,
        forward_iterator_tag) { 
        const size_type _Count    = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst());
        const bool _One_at_back   = _Count == 1 && _Where._Ptr == _Mylast();
        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity()) { 
            const size_type _Oldsize = size();
            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }
            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);
            const pointer _Newvec           = _Getal().allocate(_Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;
            try {
            _Ucopy(_First, _Last, _Newvec + _Whereoff);
            _Constructed_first = _Newvec + _Whereoff;
            if (_One_at_back) { 
                _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
            } else { 
                _Umove(_Myfirst(), _Where._Ptr, _Newvec);
                _Constructed_first = _Newvec;
                _Umove(_Where._Ptr, _Mylast(), _Newvec + _Whereoff + _Count);
            }
            } catch (...) {
            _Destroy(_Constructed_first, _Constructed_last);
            _Getal().deallocate(_Newvec, _Newcapacity);
            throw;
            }
            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { 
            const pointer _Oldlast             = _Mylast();
            const size_type _Affected_elements = static_cast<size_type>(_Oldlast - _Where._Ptr);
            if (_Count < _Affected_elements) { 
                _Mylast() = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                _Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
                _Destroy(_Where._Ptr, _Where._Ptr + _Count);
                try {
                _Ucopy(_First, _Last, _Where._Ptr);
                } catch (...) {
                try {
                _Umove(_Where._Ptr + _Count, _Where._Ptr + 2 * _Count, _Where._Ptr);
                } catch (...) {
                _Orphan_range(_Where._Ptr, _Oldlast);
                _Destroy(_Where._Ptr + _Count, _Mylast());
                _Mylast() = _Where._Ptr;
                throw;
                }
                _Move_unchecked(_Where._Ptr + 2 * _Count, _Mylast(), _Where._Ptr + _Count);
                _Destroy(_Oldlast, _Mylast());
                _Mylast() = _Oldlast;
                throw;
                }
            } else { 
                const pointer _Relocated = _Where._Ptr + _Count;
                _Mylast()                = _Umove(_Where._Ptr, _Oldlast, _Relocated);
                _Destroy(_Where._Ptr, _Oldlast);
                try {
                _Ucopy(_First, _Last, _Where._Ptr);
                } catch (...) {
                try {
                _Umove(_Relocated, _Mylast(), _Where._Ptr);
                } catch (...) {
                _Orphan_range(_Where._Ptr, _Oldlast);
                _Destroy(_Relocated, _Mylast());
                _Mylast() = _Where._Ptr;
                throw;
                }
                _Destroy(_Relocated, _Mylast());
                _Mylast() = _Oldlast;
                throw;
                }
            }
            _Orphan_range(_Where._Ptr, _Oldlast);
        }
    }
public:
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) { 
        do { if (_Where._Getcont() == ::std:: addressof(_Get_data()) && _Where._Ptr >= _Myfirst() && _Mylast() >= _Where._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 932, 0, "%s", "vector insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 932, 0); } while (false); } ; } while (false);
#line 933 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 934 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        _Adl_verify_range(_First, _Last);
        const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst());
        _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        return _Make_iterator_offset(_Whereoff);
    }
    iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) { 
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }
    void assign( const size_type _Newsize, const _Ty& _Val) { 
        _Orphan_all();
        size_type _Oldsize = size();
        if (_Newsize > _Oldsize) {
            if (_Newsize > capacity()) { 
                _Clear_and_reserve_geometric(_Newsize);
                _Oldsize = 0;
            } else {
                _Fill_unchecked(_Myfirst(), _Mylast(), _Val);
            }
            _Mylast() = _Ufill(_Mylast(), _Newsize - _Oldsize, _Val);
        } else {
            const pointer _Newlast = _Myfirst() + _Newsize;
            _Fill_unchecked(_Myfirst(), _Newlast, _Val);
            _Destroy(_Newlast, _Mylast());
            _Mylast() = _Newlast;
        }
    }
private:
    template <class _Iter>
    void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag) { 
        _Orphan_all();
        pointer _Next = _Myfirst();
        for (; _First != _Last && _Next != _Mylast(); ++_First, (void) ++_Next) {
            *_Next = *_First;
        }
        _Destroy(_Next, _Mylast());
        _Mylast() = _Next;
        for (; _First != _Last; ++_First) {
            emplace_back(*_First); 
        }
    }
    template <class _Iter>
    void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) { 
        const size_type _Newsize = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        _Orphan_all();
        if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
                          _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
                          _Uses_default_destroy<_Alty, _Ty*>>) {
            if (_Newsize > capacity()) {
                _Clear_and_reserve_geometric(_Newsize);
            }
            _Mylast() = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst())));
        } else
#line 1010 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        {
            size_type _Oldsize = size();
            if (_Newsize > _Oldsize) {
                if (_Newsize > capacity()) { 
                    _Clear_and_reserve_geometric(_Newsize);
                    _Oldsize = 0;
                }
                const _Iter _Mid = ::std:: next(_First, static_cast<difference_type>(_Oldsize));
                _Copy_unchecked(_First, _Mid, _Myfirst());
                _Mylast() = _Ucopy(_Mid, _Last, _Mylast());
            } else {
                const pointer _Newlast = _Myfirst() + _Newsize;
                _Copy_unchecked(_First, _Last, _Myfirst());
                _Destroy(_Newlast, _Mylast());
                _Mylast() = _Newlast;
            }
        }
    }
public:
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    void assign(_Iter _First, _Iter _Last) { 
        _Adl_verify_range(_First, _Last);
        _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
    }
    void assign(initializer_list<_Ty> _Ilist) { 
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
    }
private:
    void _Copy_assign(const vector& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        assign(_Right._Myfirst(), _Right._Mylast());
    }
    void _Copy_assign(const vector& _Right, true_type) {
        if (_Getal() != _Right._Getal()) {
            _Tidy();
            _Get_data()._Reload_proxy(
                static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right._Getal()));
        }
        _Copy_assign(_Right, false_type{});
    }
public:
    vector& operator=(const vector& _Right) { 
        if (this != ::std:: addressof(_Right)) { 
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }
        return *this;
    }
    vector& operator=(initializer_list<_Ty> _Ilist) { 
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        return *this;
    }
private:
    template <class _Ty2>
    void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {
        if (_Newsize > max_size()) {
            _Xlength();
        }
        const size_type _Oldsize     = size();
        const size_type _Newcapacity = _Calculate_growth(_Newsize);
        const pointer _Newvec         = _Getal().allocate(_Newcapacity);
        const pointer _Appended_first = _Newvec + _Oldsize;
        pointer _Appended_last        = _Appended_first;
        try {
        _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);
        _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
        } catch (...) {
        _Destroy(_Appended_first, _Appended_last);
        _Getal().deallocate(_Newvec, _Newcapacity);
        throw;
        }
        _Change_array(_Newvec, _Newsize, _Newcapacity);
    }
    template <class _Ty2>
    void _Resize(const size_type _Newsize, const _Ty2& _Val) { 
        const size_type _Oldsize = size();
        if (_Newsize < _Oldsize) { 
            const pointer _Newlast = _Myfirst() + _Newsize;
            _Orphan_range(_Newlast, _Mylast());
            _Destroy(_Newlast, _Mylast());
            _Mylast() = _Newlast;
            return;
        }
        if (_Newsize > _Oldsize) { 
            if (_Newsize > capacity()) { 
                _Resize_reallocate(_Newsize, _Val);
                return;
            }
            const pointer _Oldlast = _Mylast();
            _Mylast()              = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);
            _Orphan_range(_Oldlast, _Oldlast);
        }
    }
public:
    void resize( const size_type
            _Newsize) { 
        _Resize(_Newsize, _Value_init_tag{});
    }
    void resize( const size_type _Newsize,
        const _Ty& _Val) { 
        _Resize(_Newsize, _Val);
    }
private:
    void _Reallocate_exactly(const size_type
            _Newcapacity) { 
        const size_type _Size = size();
        const pointer _Newvec = _Getal().allocate(_Newcapacity);
        try {
        _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
        } catch (...) {
        _Getal().deallocate(_Newvec, _Newcapacity);
        throw;
        }
        _Change_array(_Newvec, _Size, _Newcapacity);
    }
    void _Clear_and_reserve_geometric(const size_type _Newsize) { 
        if (_Newsize > max_size()) {
            _Xlength();
        }
        const size_type _Newcapacity = _Calculate_growth(_Newsize);
        auto& _My_data               = _Get_data();
        if (_My_data._Myfirst != pointer()) { 
            _Destroy(_My_data._Myfirst, _My_data._Mylast);
            _Getal().deallocate(_My_data._Myfirst, static_cast<size_type>(_My_data._Myend - _My_data._Myfirst));
            _My_data._Myfirst = pointer();
            _My_data._Mylast  = pointer();
            _My_data._Myend   = pointer();
        }
        _Buy_raw(_Newcapacity);
    }
public:
    void reserve( const size_type
            _Newcapacity) { 
        if (_Newcapacity > capacity()) { 
            if (_Newcapacity > max_size()) {
                _Xlength();
            }
            _Reallocate_exactly(_Newcapacity);
        }
    }
    void shrink_to_fit() { 
        if (_Has_unused_capacity()) { 
            if (empty()) {
                _Tidy();
            } else {
                _Reallocate_exactly(size());
            }
        }
    }
    void pop_back() { 
        do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1196, 0, "%s", "vector empty before pop")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector empty before pop\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1196, 0); } while (false); } ; } while (false);
        _Orphan_range(_Mylast() - 1, _Mylast());
#line 1199 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast() - 1));
        --_Mylast();
    }
    iterator erase(const_iterator _Where) { 
        do { if (_Where._Getcont() == ::std:: addressof(_Get_data()) && _Where._Ptr >= _Myfirst() && _Mylast() > _Where._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1208, 0, "%s", "vector erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1208, 0); } while (false); } ; } while (false);
#line 1209 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        _Orphan_range(_Where._Ptr, _Mylast());
#line 1211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        _Move_unchecked(_Where._Ptr + 1, _Mylast(), _Where._Ptr);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast() - 1));
        --_Mylast();
        return iterator(_Where._Ptr, ::std:: addressof(_Get_data()));
    }
    iterator erase(const_iterator _First, const_iterator _Last) { 
        do { if (_First._Getcont() == ::std:: addressof(_Get_data()) && _Last._Getcont() == ::std:: addressof(_Get_data()) && _First._Ptr >= _Myfirst() && _Last._Ptr >= _First._Ptr && _Mylast() >= _Last._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1222, 0, "%s", "vector erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1222, 0); } while (false); } ; } while (false);
#line 1223 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 1224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        if (_First._Ptr != _Last._Ptr) { 
            _Orphan_range(_First._Ptr, _Mylast());
        }
        const pointer _Newlast = _Move_unchecked(_Last._Ptr, _Mylast(), _First._Ptr);
        _Destroy(_Newlast, _Mylast());
        _Mylast() = _Newlast;
        return iterator(_First._Ptr, ::std:: addressof(_Get_data()));
    }
    void clear() noexcept { 
        _Orphan_all();
        _Destroy(_Myfirst(), _Mylast());
        _Mylast() = _Myfirst();
    }
private:
    void _Swap_val(vector& _Right) noexcept {
        _Swap_proxy_and_iterators(_Right);
        _Swap_adl(_Myfirst(), _Right._Myfirst());
        _Swap_adl(_Mylast(), _Right._Mylast());
        _Swap_adl(_Myend(), _Right._Myend());
    }
public:
    void swap(vector& _Right) noexcept { 
        if (this != ::std:: addressof(_Right)) { 
            _Pocs(_Getal(), _Right._Getal());
            _Swap_val(_Right);
        }
    }
    [[nodiscard]] _Ty* data() noexcept { 
        return _Unfancy_maybe_null(_Myfirst());
    }
    [[nodiscard]] const _Ty* data() const noexcept { 
        return _Unfancy_maybe_null(_Myfirst());
    }
    [[nodiscard]] iterator begin() noexcept { 
        return iterator(_Myfirst(), ::std:: addressof(_Get_data()));
    }
    [[nodiscard]] const_iterator begin() const noexcept { 
        return const_iterator(_Myfirst(), ::std:: addressof(_Get_data()));
    }
    [[nodiscard]] iterator end() noexcept { 
        return iterator(_Mylast(), ::std:: addressof(_Get_data()));
    }
    [[nodiscard]] const_iterator end() const noexcept { 
        return const_iterator(_Mylast(), ::std:: addressof(_Get_data()));
    }
    [[nodiscard]] reverse_iterator rbegin() noexcept { 
        return reverse_iterator(end());
    }
    [[nodiscard]] const_reverse_iterator rbegin() const
        noexcept { 
        return const_reverse_iterator(end());
    }
    [[nodiscard]] reverse_iterator rend() noexcept { 
        return reverse_iterator(begin());
    }
    [[nodiscard]] const_reverse_iterator rend() const noexcept { 
        return const_reverse_iterator(begin());
    }
    [[nodiscard]] const_iterator cbegin() const noexcept { 
        return begin();
    }
    [[nodiscard]] const_iterator cend() const noexcept { 
        return end();
    }
    [[nodiscard]] const_reverse_iterator crbegin() const
        noexcept { 
        return rbegin();
    }
    [[nodiscard]] const_reverse_iterator crend() const
        noexcept { 
        return rend();
    }
    pointer _Unchecked_begin() noexcept { 
        return _Myfirst();
    }
    const_pointer _Unchecked_begin() const noexcept { 
        return _Myfirst();
    }
    pointer _Unchecked_end() noexcept { 
        return _Mylast();
    }
    const_pointer _Unchecked_end() const noexcept { 
        return _Mylast();
    }
    [[nodiscard]] bool empty() const noexcept { 
        return _Myfirst() == _Mylast();
    }
    [[nodiscard]] size_type size() const noexcept { 
        return static_cast<size_type>(_Mylast() - _Myfirst());
    }
    [[nodiscard]] size_type max_size() const noexcept { 
        return _Min_value(
            static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
    }
    [[nodiscard]] size_type capacity() const noexcept { 
        return static_cast<size_type>(_Myend() - _Myfirst());
    }
private:
    size_type _Unused_capacity() const noexcept { 
        return static_cast<size_type>(_Myend() - _Mylast());
    }
    bool _Has_unused_capacity() const noexcept { 
        return _Myend() != _Mylast();
    }
public:
    [[nodiscard]] _Ty& operator[](const size_type _Pos) { 
        do { if (_Pos < size()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1363, 0, "%s", "vector subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector subscript out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1363, 0); } while (false); } ; } while (false);
#line 1365 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        return _Myfirst()[_Pos];
    }
    [[nodiscard]] const _Ty& operator[](const size_type _Pos) const { 
        do { if (_Pos < size()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1371, 0, "%s", "vector subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector subscript out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1371, 0); } while (false); } ; } while (false);
#line 1373 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        return _Myfirst()[_Pos];
    }
    [[nodiscard]] _Ty& at(const size_type _Pos) { 
        if (size() <= _Pos) {
            _Xrange();
        }
        return _Myfirst()[_Pos];
    }
    [[nodiscard]] const _Ty& at(const size_type _Pos) const { 
        if (size() <= _Pos) {
            _Xrange();
        }
        return _Myfirst()[_Pos];
    }
    [[nodiscard]] _Ty& front() { 
        do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1395, 0, "%s", "front() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty vector\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1395, 0); } while (false); } ; } while (false);
#line 1397 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        return *_Myfirst();
    }
    [[nodiscard]] const _Ty& front() const { 
        do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1403, 0, "%s", "front() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty vector\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1403, 0); } while (false); } ; } while (false);
#line 1405 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        return *_Myfirst();
    }
    [[nodiscard]] _Ty& back() { 
        do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1411, 0, "%s", "back() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty vector\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1411, 0); } while (false); } ; } while (false);
#line 1413 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        return _Mylast()[-1];
    }
    [[nodiscard]] const _Ty& back() const { 
        do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1419, 0, "%s", "back() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty vector\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1419, 0); } while (false); } ; } while (false);
#line 1421 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        return _Mylast()[-1];
    }
    [[nodiscard]] allocator_type get_allocator() const noexcept { 
        return static_cast<allocator_type>(_Getal());
    }
private:
    pointer _Ufill(pointer _Dest, const size_type _Count,
        const _Ty& _Val) { 
        return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());
    }
    pointer _Ufill(pointer _Dest, const size_type _Count,
        _Value_init_tag) { 
        return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());
    }
    template <class _Iter>
    pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { 
        return _Uninitialized_copy(_First, _Last, _Dest, _Getal());
    }
    pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { 
        return _Uninitialized_move(_First, _Last, _Dest, _Getal());
    }
    void _Umove_if_noexcept1(
        pointer _First, pointer _Last, pointer _Dest, true_type) { 
        _Uninitialized_move(_First, _Last, _Dest, _Getal());
    }
    void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest,
        false_type) { 
        _Uninitialized_copy(_First, _Last, _Dest, _Getal());
    }
    void _Umove_if_noexcept(pointer _First, pointer _Last,
        pointer _Dest) { 
        _Umove_if_noexcept1(_First, _Last, _Dest,
            bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
    }
    void _Destroy(pointer _First, pointer _Last) { 
        _Destroy_range(_First, _Last, _Getal());
    }
    size_type _Calculate_growth(
        const size_type _Newsize) const { 
        const size_type _Oldcapacity = capacity();
        if (_Oldcapacity > max_size() - _Oldcapacity / 2) {
            return _Newsize; 
        }
        const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;
        if (_Geometric < _Newsize) {
            return _Newsize; 
        }
        return _Geometric; 
    }
    void _Buy_raw(const size_type _Newcapacity) { 
        auto& _My_data    = _Get_data();
        _My_data._Myfirst = _Getal().allocate(_Newcapacity);
        _My_data._Mylast  = _My_data._Myfirst;
        _My_data._Myend   = _My_data._Myfirst + _Newcapacity;
    }
    void _Buy_nonzero(const size_type _Newcapacity) { 
        if (_Newcapacity > max_size()) {
            _Xlength();
        }
        _Buy_raw(_Newcapacity);
    }
    void _Change_array(const pointer _Newvec, const size_type _Newsize,
        const size_type _Newcapacity) { 
        _Orphan_all();
        if (_Myfirst() != pointer()) { 
            _Destroy(_Myfirst(), _Mylast());
            _Getal().deallocate(_Myfirst(), capacity());
        }
        _Myfirst() = _Newvec;
        _Mylast()  = _Newvec + _Newsize;
        _Myend()   = _Newvec + _Newcapacity;
    }
    void _Tidy() noexcept { 
        _Orphan_all();
        auto& _My_data    = _Get_data();
        const auto _First = _My_data._Myfirst;
        if (_First != pointer()) { 
            _Destroy(_First, _My_data._Mylast);
            _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));
            _My_data._Myfirst = pointer();
            _My_data._Mylast  = pointer();
            _My_data._Myend   = pointer();
        }
    }
    [[noreturn]] static void _Xlength() { 
        _Xlength_error("vector<T> too long");
    }
    [[noreturn]] static void _Xrange() { 
        _Xout_of_range("invalid vector<T> subscript");
    }
    void _Orphan_range(pointer _First, pointer _Last) const { 
        _Lockit _Lock(3);
        const_iterator** _Pnext = reinterpret_cast<const_iterator**>(_Getpfirst());
        if (_Pnext) {
            while (*_Pnext) {
                if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr) { 
                    _Pnext = reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
                } else { 
                    (*_Pnext)->_Clrcont();
                    *_Pnext = *reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
                }
            }
        }
#line 1564 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
    _Iterator_base12** _Getpfirst() const { 
        return _Get_data()._Getpfirst();
    }
    _Container_proxy*& _Myproxy() noexcept { 
        return _Get_data()._Myproxy;
    }
    _Container_proxy* const& _Myproxy() const noexcept { 
        return _Get_data()._Myproxy;
    }
#line 1579 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    void _Orphan_all() noexcept { 
        _Get_data()._Orphan_all();
    }
    void _Swap_proxy_and_iterators(vector& _Right) { 
        _Get_data()._Swap_proxy_and_iterators(_Right._Get_data());
    }
    _Alty& _Getal() noexcept { 
        return _Mypair._Get_first();
    }
    const _Alty& _Getal() const noexcept { 
        return _Mypair._Get_first();
    }
    _Scary_val& _Get_data() noexcept { 
        return _Mypair._Get_second();
    }
    const _Scary_val& _Get_data() const noexcept { 
        return _Mypair._Get_second();
    }
    iterator _Make_iterator(const pointer _Ptr) noexcept { 
        return iterator(_Ptr, ::std:: addressof(_Mypair._Get_second()));
    }
    iterator _Make_iterator_offset(
        const size_type _Offset) noexcept { 
        auto& _My_data = _Mypair._Get_second();
        return iterator(_My_data._Myfirst + _Offset, ::std:: addressof(_My_data));
    }
    pointer& _Myfirst() noexcept { 
        return _Get_data()._Myfirst;
    }
    const pointer& _Myfirst() const noexcept { 
        return _Get_data()._Myfirst;
    }
    pointer& _Mylast() noexcept { 
        return _Get_data()._Mylast;
    }
    const pointer& _Mylast() const noexcept { 
        return _Get_data()._Mylast;
    }
    pointer& _Myend() noexcept { 
        return _Get_data()._Myend;
    }
    const pointer& _Myend() const noexcept { 
        return _Get_data()._Myend;
    }
    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};
template <class _Iter, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
vector(_Iter, _Iter, _Alloc = _Alloc())->vector<_Iter_value_t<_Iter>, _Alloc>;
#line 1646 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
template <class _Ty, class _Alloc>
inline void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right) noexcept { 
    _Left.swap(_Right);
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator==(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { 
    return _Left.size() == _Right.size() && ::std:: equal(_Left.begin(), _Left.end(), _Right.begin());
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator!=(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { 
    return !(_Left == _Right);
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { 
    return ::std:: lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end());
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { 
    return _Right < _Left;
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<=(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { 
    return !(_Right < _Left);
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>=(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { 
    return !(_Left < _Right);
}
using _Vbase         = unsigned int; 
constexpr int _VBITS = 8 * sizeof(_Vbase); 
template <class _Alloc0>
struct _Wrap_alloc { 
    using _Alloc = _Alloc0;
};
template <class _Alvbase_wrapped>
class _Vb_iter_base : public _Iterator_base { 
public:
    using _Alvbase = typename _Alvbase_wrapped::_Alloc;
    using _Sizet   = typename allocator_traits<_Alvbase>::size_type;
    using _Difft   = typename allocator_traits<_Alvbase>::difference_type;
    using _Mycont  = vector<bool, _Rebind_alloc_t<_Alvbase, bool>>;
    _Vb_iter_base() : _Myptr(nullptr), _Myoff(0) { 
    }
    _Vb_iter_base(const _Vbase* _Ptr, _Sizet _Off, const _Container_base* _Mypvbool)
        : _Myptr(_Ptr), _Myoff(_Off) { 
        this->_Adopt(_Mypvbool);
    }
    void _Advance(_Sizet _Off) { 
        _Myoff += _Off;
        _Myptr += _Myoff / _VBITS;
        _Myoff %= _VBITS;
    }
    int _Valid(_Sizet _Inc) const { 
        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        _Sizet _Mysize   = _Cont->_Mysize;
        _Inc += _Myoff;
        _Inc += static_cast<_Sizet>(_VBITS * (_Myptr - _Cont->_Myvec.data()));
        return _Inc < _Mysize ? -1 : _Inc == _Mysize ? 0 : +1;
#line 1734 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
    const _Vbase* _Myptr;
    _Sizet _Myoff;
};
template <class _Alvbase_wrapped>
class _Vb_reference : public _Vb_iter_base<_Alvbase_wrapped> { 
    using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;
    _Vb_reference() noexcept { 
    }
public:
    _Vb_reference(const _Mybase& _Right)
        : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) { 
    }
    _Vb_reference& operator=(const _Vb_reference& _Right) noexcept { 
        return *this = bool(_Right);
    }
    _Vb_reference& operator=(bool _Val) noexcept { 
        if (_Val) {
            *const_cast<_Vbase*>(_Getptr()) |= _Mask();
        } else {
            *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();
        }
        return *this;
    }
    void flip() noexcept { 
        *const_cast<_Vbase*>(_Getptr()) ^= _Mask();
    }
    operator bool() const noexcept { 
        return (*_Getptr() & _Mask()) != 0;
    }
    const _Vbase* _Getptr() const { 
        do { if (this->_Getcont() && this->_Myptr && this->_Valid(0) < 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1779, 0, "%s", "vector<bool> iterator not dereferencable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterator not dereferencable\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1779, 0); } while (false); } ; } while (false);
#line 1780 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 1781 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        return this->_Myptr;
    }
protected:
    _Vbase _Mask() const { 
        return static_cast<_Vbase>(1) << this->_Myoff;
    }
};
template <class _Alvbase_wrapped>
inline void swap(_Vb_reference<_Alvbase_wrapped> _Left,
    _Vb_reference<_Alvbase_wrapped> _Right) noexcept { 
    bool _Val = _Left; 
    _Left     = _Right;
    _Right    = _Val;
}
template <class _Alvbase_wrapped>
class _Vb_const_iterator : public _Vb_iter_base<_Alvbase_wrapped> { 
private:
    using _Mybase    = _Vb_iter_base<_Alvbase_wrapped>;
    using _Size_type = typename _Mybase::_Sizet;
public:
    using _Reft           = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;
    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::_Difft;
    using pointer           = const_reference*;
    using reference         = const_reference;
    _Vb_const_iterator() { 
    }
    _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool)
        : _Mybase(_Ptr, 0, _Mypvbool) { 
    }
    [[nodiscard]] const_reference operator*() const { 
        return _Reft(*this);
    }
    _Vb_const_iterator& operator++() { 
        _Inc();
        return *this;
    }
    _Vb_const_iterator operator++(int) { 
        _Vb_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _Vb_const_iterator& operator--() { 
        _Dec();
        return *this;
    }
    _Vb_const_iterator operator--(int) { 
        _Vb_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    _Vb_const_iterator& operator+=(const difference_type _Off) { 
        if (_Off < 0 && this->_Myoff < 0 - static_cast<_Size_type>(_Off)) { 
            this->_Myoff += _Off;
            this->_Myptr -= 1 + (static_cast<_Size_type>(-1) - this->_Myoff) / _VBITS;
            this->_Myoff %= _VBITS;
        } else { 
            this->_Myoff += _Off;
            this->_Myptr += this->_Myoff / _VBITS;
            this->_Myoff %= _VBITS;
        }
        return *this;
    }
    [[nodiscard]] _Vb_const_iterator operator+(const difference_type _Off) const { 
        _Vb_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _Vb_const_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _Vb_const_iterator operator-(const difference_type _Off) const { 
        _Vb_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(const _Vb_const_iterator& _Right) const { 
        _Compat(_Right);
        return static_cast<difference_type>(_VBITS * (this->_Myptr - _Right._Myptr))
               + static_cast<difference_type>(this->_Myoff) - static_cast<difference_type>(_Right._Myoff);
    }
    [[nodiscard]] const_reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    [[nodiscard]] bool operator==(const _Vb_const_iterator& _Right) const { 
        _Compat(_Right);
        return this->_Myptr == _Right._Myptr && this->_Myoff == _Right._Myoff;
    }
    [[nodiscard]] bool operator!=(const _Vb_const_iterator& _Right) const { 
        return !(*this == _Right);
    }
    [[nodiscard]] bool operator<(const _Vb_const_iterator& _Right) const { 
        _Compat(_Right);
        return this->_Myptr < _Right._Myptr || (this->_Myptr == _Right._Myptr && this->_Myoff < _Right._Myoff);
    }
    [[nodiscard]] bool operator>(const _Vb_const_iterator& _Right) const { 
        return _Right < *this;
    }
    [[nodiscard]] bool operator<=(const _Vb_const_iterator& _Right) const { 
        return !(_Right < *this);
    }
    [[nodiscard]] bool operator>=(const _Vb_const_iterator& _Right) const { 
        return !(*this < _Right);
    }
    void _Compat(const _Vb_const_iterator& _Right) const { 
#line 1916 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1916, 0, "%s", "vector<bool> iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1916, 0); } while (false); } ; } while (false);
#line 1918 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
    using _Prevent_inheriting_unwrap = _Vb_const_iterator;
    friend void _Verify_range(const _Vb_const_iterator& _First, const _Vb_const_iterator& _Last) {
        do { if (_First <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1925, 0, "%s", "vector<bool> iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterator range transposed\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1925, 0); } while (false); } ; } while (false);
    }
#line 1928 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    void _Dec() { 
        if (this->_Myoff != 0) {
            --this->_Myoff;
        } else { 
            do { if (this->_Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1934, 0, "%s", "cannot decrement value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized vector<bool> iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1934, 0); } while (false); } ; } while (false);
            do { if (this->_Valid(static_cast<_Size_type>(-1)) <= 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1936, 0, "%s", "cannot decrement invalid vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement invalid vector<bool> iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1936, 0); } while (false); } ; } while (false);
#line 1937 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 1938 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
            this->_Myoff = _VBITS - 1;
            --this->_Myptr;
        }
    }
    void _Inc() { 
        if (this->_Myoff < _VBITS - 1) {
            ++this->_Myoff;
        } else { 
            do { if (this->_Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1949, 0, "%s", "cannot increment value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized vector<bool> iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1949, 0); } while (false); } ; } while (false);
            do { if (this->_Valid(1) <= 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1950, 0, "%s", "cannot increment invalid vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment invalid vector<bool> iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 1950, 0); } while (false); } ; } while (false);
#line 1952 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
            this->_Myoff = 0;
            ++this->_Myptr;
        }
    }
};
template <class _Alvbase_wrapped>
[[nodiscard]] _Vb_const_iterator<_Alvbase_wrapped> operator+(
    typename _Vb_const_iterator<_Alvbase_wrapped>::difference_type _Off,
    _Vb_const_iterator<_Alvbase_wrapped> _Right) { 
    return _Right += _Off;
}
template <class _Alvbase_wrapped>
class _Vb_iterator : public _Vb_const_iterator<_Alvbase_wrapped> { 
public:
    using _Mybase = _Vb_const_iterator<_Alvbase_wrapped>;
    using _Reft           = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;
    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::difference_type;
    using pointer           = _Reft*;
    using reference         = _Reft;
    _Vb_iterator() { 
    }
    _Vb_iterator(_Vbase* _Ptr, _Container_base* _Mypvbool)
        : _Mybase(_Ptr, _Mypvbool) { 
    }
    [[nodiscard]] reference operator*() const { 
        return _Reft(*this);
    }
    _Vb_iterator& operator++() { 
        ++*(_Mybase*) this;
        return *this;
    }
    _Vb_iterator operator++(int) { 
        _Vb_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _Vb_iterator& operator--() { 
        --*(_Mybase*) this;
        return *this;
    }
    _Vb_iterator operator--(int) { 
        _Vb_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    _Vb_iterator& operator+=(const difference_type _Off) { 
        *(_Mybase*) this += _Off;
        return *this;
    }
    [[nodiscard]] _Vb_iterator operator+(const difference_type _Off) const { 
        _Vb_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _Vb_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _Vb_iterator operator-(const difference_type _Off) const { 
        _Vb_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(const _Mybase& _Right) const { 
        return *(_Mybase*) this - _Right;
    }
    [[nodiscard]] reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    using _Prevent_inheriting_unwrap = _Vb_iterator;
};
template <class _Alvbase_wrapped>
[[nodiscard]] inline _Vb_iterator<_Alvbase_wrapped> operator+(
    typename _Vb_iterator<_Alvbase_wrapped>::difference_type _Off,
    _Vb_iterator<_Alvbase_wrapped> _Right) { 
    return _Right += _Off;
}
template <class _Alloc>
class _Vb_val : public _Container_base { 
public:
    using _Alvbase         = _Rebind_alloc_t<_Alloc, _Vbase>;
    using _Alvbase_traits  = allocator_traits<_Alvbase>;
    using _Vectype         = vector<_Vbase, _Alvbase>;
    using _Alvbase_wrapped = _Wrap_alloc<_Alvbase>;
    using size_type        = typename _Alvbase_traits::size_type;
    _Vb_val() noexcept(is_nothrow_default_constructible_v<_Vectype>)
        : _Myvec(), _Mysize(0) { 
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }
    _Vb_val(const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Vectype, _Alvbase>)
        : _Myvec(static_cast<_Alvbase>(_Al)), _Mysize(0) { 
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }
    _Vb_val(size_type _Count, const bool& _Val)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0)), _Mysize(0) { 
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }
    _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al)),
          _Mysize(0) { 
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }
    _Vb_val(const _Vb_val& _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) { 
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }
    _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
        : _Myvec(_Right._Myvec, static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) { 
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }
    _Vb_val(_Vb_val&& _Right) noexcept(is_nothrow_move_constructible_v<_Vectype>)
        : _Myvec(::std:: move(_Right._Myvec)), _Mysize(::std:: exchange(_Right._Mysize, size_type{0})) { 
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }
    _Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
        noexcept(is_nothrow_constructible_v<_Vectype, _Vectype, _Alvbase>)
        : _Myvec(::std:: move(_Right._Myvec), static_cast<_Alvbase>(_Al)),
          _Mysize(::std:: exchange(_Right._Mysize, size_type{0})) { 
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }
    ~_Vb_val() noexcept { 
        this->_Orphan_all();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(this->_Getal());
        _Delete_plain(_Alproxy, ::std:: exchange(this->_Myproxy, nullptr));
#line 2109 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
    _Alvbase& _Getal() noexcept {
        return _Myvec._Getal();
    }
    const _Alvbase& _Getal() const noexcept {
        return _Myvec._Getal();
    }
    static size_type _Nw(size_type _Count) { 
        return (_Count + _VBITS - 1) / _VBITS;
    }
    _Vectype _Myvec; 
    size_type _Mysize; 
};
template <class _Alloc>
class vector<bool, _Alloc> : public _Vb_val<_Alloc> { 
public:
    static_assert(!1 || is_same_v<bool, typename _Alloc::value_type>,
        "vector<bool, Allocator>" " requires that Allocator's value_type match " "bool" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");
    using _Mybase          = _Vb_val<_Alloc>;
    using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
    using _Alvbase         = typename _Mybase::_Alvbase;
    using _Alvbase_traits  = typename _Mybase::_Alvbase_traits;
    using size_type       = typename _Alvbase_traits::size_type;
    using difference_type = typename _Alvbase_traits::difference_type;
    using allocator_type  = _Alloc;
    using reference       = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;
    using value_type      = bool;
    using _Reft          = reference;
    using iterator       = _Vb_iterator<_Alvbase_wrapped>;
    using const_iterator = _Vb_const_iterator<_Alvbase_wrapped>;
    using pointer                = iterator;
    using const_pointer          = const_iterator;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
    static const int _VBITS = ::std:: _VBITS;
    enum { _EEN_VBITS = _VBITS }; 
    vector() noexcept(is_nothrow_default_constructible_v<_Mybase>) 
        : _Mybase() { 
    }
    explicit vector(const _Alloc& _Al)
        noexcept(is_nothrow_constructible_v<_Mybase, const _Alloc&>) 
        : _Mybase(_Al) { 
    }
    explicit vector( size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, false, _Al) { 
        _Trim(_Count);
    }
    vector( size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, _Val, _Al) { 
        _Trim(_Count);
    }
    vector(const vector& _Right) : _Mybase(_Right) { 
    }
    vector(const vector& _Right, const _Alloc& _Al) : _Mybase(_Right, _Al) { 
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mybase(_Al) { 
        _BConstruct(_First, _Last);
    }
    template <class _Iter>
    void _BConstruct(_Iter _First, _Iter _Last) { 
        insert(begin(), _First, _Last);
    }
    vector(vector&& _Right) noexcept(is_nothrow_move_constructible_v<_Mybase>) 
        : _Mybase(::std:: move(_Right)) { 
        this->_Swap_proxy_and_iterators(_Right);
    }
    vector(vector&& _Right, const _Alloc& _Al)
        noexcept(is_nothrow_constructible_v<_Mybase, _Mybase, const _Alloc&>)
        : _Mybase(::std:: move(_Right), _Al) { 
        if
            constexpr(!_Alvbase_traits::is_always_equal::value) {
                if (this->_Getal() != _Right._Getal()) {
                    return;
                }
            }
        this->_Swap_proxy_and_iterators(_Right);
    }
private:
    void _Move_assign(vector& _Right, _Equal_allocators) noexcept {
        this->_Myvec  = ::std:: move(_Right._Myvec);
        this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});
        this->_Swap_proxy_and_iterators(_Right);
    }
    void _Move_assign(vector& _Right, _Propagate_allocators) noexcept {
        using _Alproxy_type = _Rebind_alloc_t<_Alvbase, _Container_proxy>;
        if (this->_Getal() != _Right._Getal()) { 
            _Alproxy_type _Oldal(this->_Getal());
            _Alproxy_type _Right_proxy_al(_Right._Getal());
            _Container_proxy_ptr<_Alvbase> _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
            this->_Myvec  = ::std:: move(_Right._Myvec);
            this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});
            _Proxy._Bind(_Oldal, this);
            this->_Swap_proxy_and_iterators(_Right);
            return;
        }
        this->_Myvec  = ::std:: move(_Right._Myvec);
        this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});
        this->_Swap_proxy_and_iterators(_Right);
    }
    void _Move_assign(vector& _Right, _No_propagate_allocators) {
        this->_Myvec  = ::std:: move(_Right._Myvec);
        this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});
        if (this->_Getal() == _Right._Getal()) {
            this->_Swap_proxy_and_iterators(_Right);
        }
    }
#line 2248 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
public:
    vector& operator=(vector&& _Right) noexcept(is_nothrow_move_assignable_v<_Mybase>) {
        if (this != ::std:: addressof(_Right)) { 
#line 2256 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
            this->_Orphan_all();
            _Move_assign(_Right, _Choose_pocma<_Alvbase>{});
#line 2259 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        }
        return *this;
    }
    template <class... _Valty>
    decltype(auto) emplace_back(_Valty&&... _Val) { 
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        push_back(_Tmp);
        return back();
#line 2271 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    }
    template <class... _Valty>
    iterator emplace(const_iterator _Where, _Valty&&... _Val) { 
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        return insert(_Where, _Tmp);
    }
    vector(initializer_list<bool> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mybase(0, false, _Al) { 
        insert(begin(), _Ilist.begin(), _Ilist.end());
    }
    vector& operator=(initializer_list<bool> _Ilist) { 
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }
    void assign(initializer_list<bool> _Ilist) { 
        assign(_Ilist.begin(), _Ilist.end());
    }
    iterator insert(const_iterator _Where,
        initializer_list<bool> _Ilist) { 
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }
    ~vector() noexcept { 
    }
private:
    void _Copy_assign(const vector& _Right, false_type) {
        this->_Myvec  = _Right._Myvec;
        this->_Mysize = _Right._Mysize;
    }
    void _Copy_assign(const vector& _Right, true_type) {
        if (this->_Getal() == _Right._Getal()) {
            _Copy_assign(_Right, false_type{});
        } else {
            using _Alproxy_type = _Rebind_alloc_t<_Alvbase, _Container_proxy>;
            _Alproxy_type _Oldal(this->_Getal());
            _Alproxy_type _Right_proxy_al(_Right._Getal());
            _Container_proxy_ptr<_Alvbase> _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
            this->_Myvec  = _Right._Myvec;
            this->_Mysize = _Right._Mysize;
            _Proxy._Bind(_Oldal, this);
        }
    }
#line 2323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
public:
    vector& operator=(const vector& _Right) { 
        if (this != ::std:: addressof(_Right)) { 
#line 2331 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
            this->_Orphan_all();
            _Copy_assign(_Right, _Choose_pocca<_Alvbase>{});
#line 2334 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        }
        return *this;
    }
    void reserve( size_type _Count) { 
        this->_Myvec.reserve(this->_Nw(_Count));
    }
    [[nodiscard]] size_type capacity() const noexcept { 
        return this->_Myvec.capacity() * _VBITS;
    }
    [[nodiscard]] iterator begin() noexcept { 
        return iterator(this->_Myvec.data(), this);
    }
    [[nodiscard]] const_iterator begin() const noexcept { 
        return const_iterator(this->_Myvec.data(), this);
    }
    [[nodiscard]] iterator end() noexcept { 
        return begin() + static_cast<difference_type>(this->_Mysize);
    }
    [[nodiscard]] const_iterator end() const noexcept { 
        return begin() + static_cast<difference_type>(this->_Mysize);
    }
    [[nodiscard]] const_iterator cbegin() const noexcept { 
        return begin();
    }
    [[nodiscard]] const_iterator cend() const noexcept { 
        return end();
    }
    [[nodiscard]] const_reverse_iterator crbegin() const
        noexcept { 
        return rbegin();
    }
    [[nodiscard]] const_reverse_iterator crend() const
        noexcept { 
        return rend();
    }
    void shrink_to_fit() { 
        if (this->_Myvec.capacity() != this->_Myvec.size()) { 
            this->_Orphan_all();
            this->_Myvec.shrink_to_fit();
        }
    }
    iterator _Make_iter(const_iterator _Where) { 
        iterator _Tmp = begin();
        if (0 < this->_Mysize) {
            _Tmp += _Where - begin();
        }
        return _Tmp;
    }
    [[nodiscard]] reverse_iterator rbegin() noexcept { 
        return reverse_iterator(end());
    }
    [[nodiscard]] const_reverse_iterator rbegin() const
        noexcept { 
        return const_reverse_iterator(end());
    }
    [[nodiscard]] reverse_iterator rend() noexcept { 
        return reverse_iterator(begin());
    }
    [[nodiscard]] const_reverse_iterator rend() const noexcept { 
        return const_reverse_iterator(begin());
    }
    void resize( size_type _Newsize,
        bool _Val = false) { 
        if (size() < _Newsize) {
            _Insert_n(end(), _Newsize - size(), _Val);
        } else if (_Newsize < size()) {
            erase(begin() + static_cast<difference_type>(_Newsize), end());
        }
    }
    [[nodiscard]] size_type size() const noexcept { 
        return this->_Mysize;
    }
    [[nodiscard]] size_type max_size() const noexcept { 
        constexpr size_type _Diff_max = static_cast<size_type>((numeric_limits<difference_type>::max)());
        const size_type _Ints_max     = this->_Myvec.max_size();
        if (_Ints_max > _Diff_max / _VBITS) { 
            return _Diff_max;
        }
        return _Ints_max * _VBITS;
    }
    [[nodiscard]] bool empty() const noexcept { 
        return size() == 0;
    }
    [[nodiscard]] allocator_type get_allocator() const noexcept { 
        return static_cast<allocator_type>(this->_Myvec.get_allocator());
    }
    [[nodiscard]] const_reference at(size_type _Off) const { 
        if (size() <= _Off) {
            _Xran();
        }
        return (*this)[_Off];
    }
    [[nodiscard]] reference at(size_type _Off) { 
        if (size() <= _Off) {
            _Xran();
        }
        return (*this)[_Off];
    }
    [[nodiscard]] const_reference operator[](size_type _Off) const { 
        const_iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }
    [[nodiscard]] reference operator[](size_type _Off) { 
        iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }
    [[nodiscard]] reference front() { 
        return *begin();
    }
    [[nodiscard]] const_reference front() const { 
        return *begin();
    }
    [[nodiscard]] reference back() { 
        return *(end() - 1);
    }
    [[nodiscard]] const_reference back() const { 
        return *(end() - 1);
    }
    void push_back(const bool& _Val) { 
        insert(end(), _Val);
    }
    void pop_back() { 
        erase(end() - 1);
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    void assign(_Iter _First, _Iter _Last) { 
        clear();
        insert(begin(), _First, _Last);
    }
    void assign( size_type _Count, const bool& _Val) { 
        clear();
        _Insert_n(begin(), _Count, _Val);
    }
    iterator insert(const_iterator _Where, const bool& _Val) { 
        return _Insert_n(_Where, static_cast<size_type>(1), _Val);
    }
    iterator insert(const_iterator _Where,  size_type _Count,
        const bool& _Val) { 
        return _Insert_n(_Where, _Count, _Val);
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) { 
        difference_type _Off = _Where - begin();
        _Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
        return begin() + _Off;
    }
    template <class _Iter>
    void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
        input_iterator_tag) { 
        difference_type _Off = _Where - begin();
        for (; _First != _Last; ++_First, (void) ++_Off) {
            insert(begin() + _Off, *_First);
        }
    }
    template <class _Iter>
    void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
        forward_iterator_tag) { 
        _Adl_verify_range(_First, _Last);
        size_type _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
        size_type _Off   = _Insert_x(_Where, _Count);
        _Copy_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), begin() + static_cast<difference_type>(_Off));
    }
    iterator erase(const_iterator _Where_arg) { 
        iterator _Where      = _Make_iter(_Where_arg);
        difference_type _Off = _Where - begin();
        do { if (end() > _Where) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 2549, 0, "%s", "vector<bool> erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 2549, 0); } while (false); } ; } while (false);
        ::std:: copy(_Where + 1, end(), _Where);
        _Orphan_range(static_cast<size_type>(_Off), this->_Mysize);
#line 2556 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        _Trim(this->_Mysize - 1);
        return begin() + _Off;
    }
    iterator erase(const_iterator _First_arg,
        const_iterator _Last_arg) { 
        iterator _First      = _Make_iter(_First_arg);
        iterator _Last       = _Make_iter(_Last_arg);
        difference_type _Off = _First - begin();
        if (_First != _Last) { 
            do { if (_Last >= _First && end() >= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 2569, 0, "%s", "vector<bool> erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 2569, 0); } while (false); } ; } while (false);
            iterator _Next      = ::std:: copy(_Last, end(), _First);
            const auto _Newsize = static_cast<size_type>(_Next - begin());
            _Orphan_range(_Newsize, this->_Mysize);
            _Trim(_Newsize);
#line 2579 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        }
        return begin() + _Off;
    }
    void clear() noexcept { 
        this->_Orphan_all();
        this->_Myvec.clear();
        this->_Mysize = 0;
    }
    void flip() noexcept { 
        for (auto& _Elem : this->_Myvec) {
            _Elem = ~_Elem;
        }
        _Trim(this->_Mysize);
    }
    void swap(vector& _Right) noexcept { 
        if (this != ::std:: addressof(_Right)) { 
            this->_Swap_proxy_and_iterators(_Right);
            this->_Myvec.swap(_Right._Myvec);
            ::std:: swap(this->_Mysize, _Right._Mysize);
        }
    }
    static void swap(reference _Left, reference _Right) noexcept { 
        bool _Val = _Left; 
        _Left     = _Right;
        _Right    = _Val;
    }
    friend hash<vector<bool, _Alloc>>;
    iterator _Insert_n(const_iterator _Where, size_type _Count, const bool& _Val) { 
        size_type _Off     = _Insert_x(_Where, _Count);
        const auto _Result = begin() + static_cast<difference_type>(_Off);
        ::std:: fill(_Result, _Result + static_cast<difference_type>(_Count), _Val);
        return _Result;
    }
    size_type _Insert_x(const_iterator _Where, size_type _Count) { 
        difference_type _Off = _Where - begin();
        do { if (end() >= _Where) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 2625, 0, "%s", "vector<bool> insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector", 2625, 0); } while (false); } ; } while (false);
        bool _Realloc = capacity() - size() < _Count;
#line 2628 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        if (_Count != 0) {
            if (max_size() - size() < _Count) {
                _Xlen(); 
            }
            this->_Myvec.resize(this->_Nw(size() + _Count), 0);
            if (empty()) {
                this->_Mysize += _Count;
            } else { 
                iterator _Oldend = end();
                this->_Mysize += _Count;
                ::std:: copy_backward(begin() + _Off, _Oldend, end());
            }
            _Orphan_range(static_cast<size_type>(_Realloc ? 0 : _Off), this->_Mysize);
#line 2647 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
        }
        return static_cast<size_type>(_Off);
    }
    void _Orphan_range(
        size_type _Offlo, size_type _Offhi) const { 
        _Lockit _Lock(3);
        auto _Base = const_cast<_Vbase*>(this->_Myvec.data());
        const_iterator** _Pnext = (const_iterator**) this->_Getpfirst();
        if (_Pnext != nullptr) {
            while (*_Pnext != nullptr) { 
                size_type _Off = static_cast<size_type>(_VBITS * ((*_Pnext)->_Myptr - _Base)) + (*_Pnext)->_Myoff;
                if (_Off < _Offlo || _Offhi < _Off) {
                    _Pnext = (const_iterator**) (*_Pnext)->_Getpnext();
                } else { 
                    (*_Pnext)->_Clrcont();
                    *_Pnext = *(const_iterator**) (*_Pnext)->_Getpnext();
                }
            }
        }
    }
#line 2676 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
    void _Trim(size_type _Size) { 
        if (max_size() < _Size) {
            _Xlen(); 
        }
        const size_type _Words = this->_Nw(_Size);
        if (_Words < this->_Myvec.size()) {
            this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words), this->_Myvec.end());
        }
        this->_Mysize = _Size;
        _Size %= _VBITS;
        if (0 < _Size) {
            this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;
        }
    }
    [[noreturn]] void _Xlen() const { 
        _Xlength_error("vector<bool> too long");
    }
    [[noreturn]] void _Xran() const { 
        _Xout_of_range("invalid vector<bool> subscript");
    }
};
template <class _Alloc>
[[nodiscard]] inline bool operator==(
    const vector<bool, _Alloc>& _Left, const vector<bool, _Alloc>& _Right) { 
    return _Left.size() == _Right.size() && _Left._Myvec == _Right._Myvec;
}
template <class _Alloc>
[[nodiscard]] inline bool operator!=(
    const vector<bool, _Alloc>& _Left, const vector<bool, _Alloc>& _Right) { 
    return !(_Left == _Right);
}
template <class _Alloc>
struct hash<vector<bool, _Alloc>> { 
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef vector<bool, _Alloc> argument_type;
    [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.")]] typedef size_t result_type;
    [[nodiscard]] size_t operator()(const vector<bool, _Alloc>& _Keyval) const
        noexcept { 
        return _Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size());
    }
};
namespace pmr {
    template <class _Ty>
    using vector = ::std:: vector<_Ty, polymorphic_allocator<_Ty>>;
} 
#line 2733 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
}
#pragma warning(pop)
#pragma pack(pop)
#line 2740 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 2741 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\vector"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/_fixes.hpp"
#line 80 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 17 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
__pragma(pack(push, 8)) extern "C" {
     void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
} __pragma(pack(pop))
#line 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 19 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 30 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 32 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#pragma once
#line 26 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 28 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 30 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 32 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 44 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 72 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 144 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 159 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 197 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 200 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 202 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 204 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 206 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 232 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 274 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 276 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 278 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 280 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 282 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 284 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 286 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 288 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 290 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 292 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 294 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 296 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 327 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 330 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 332 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 334 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 346 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 349 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 356 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 360 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 362 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 367 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 369 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 371 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 373 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
#pragma once
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#pragma once
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\mmintrin.h"
#pragma once
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\mmintrin.h"
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\mmintrin.h"
extern "C" { 
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\mmintrin.h"
typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;
#line 184 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\mmintrin.h"
}; 
#line 188 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\mmintrin.h"
#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\mmintrin.h"
#line 191 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\mmintrin.h"
#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\mmintrin.h"
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;
#line 81 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#line 82 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
extern "C" { 
#line 191 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);
extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);
extern int _mm_cvt_ss2si(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern float _mm_cvtss_f32(__m128 _A);
#line 282 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
extern __int64 _mm_cvtss_si64(__m128 _A);
extern __int64 _mm_cvttss_si64(__m128 _A);
extern __m128  _mm_cvtsi64_ss(__m128 _A, __int64 _B);
#line 291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);
#line 326 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);
extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);
#line 381 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#line 506 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
}; 
#line 511 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#line 513 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#line 514 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#line 515 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\xmmintrin.h"
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;
typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;
extern "C" { 
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);
extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);
extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);
#line 166 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);
extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);
extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);
extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);
#line 221 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);
#line 239 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);
#line 247 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);
extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);
extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);
#line 345 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
extern __m128i _mm_set_epi64x(__int64 _I1,__int64 _I0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
extern __m128i _mm_set1_epi64x(__int64 i);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);
#line 364 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);
extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);
extern __m128i _mm_move_epi64(__m128i _Q);
#line 391 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);
extern double _mm_cvtsd_f64(__m128d _A);
extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);
extern __int64 _mm_cvtsd_si64(__m128d);
extern __int64 _mm_cvttsd_si64(__m128d);
extern __m128d _mm_cvtsi64_sd(__m128d, __int64);
extern __m128i _mm_cvtsi64_si128(__int64);
extern __int64 _mm_cvtsi128_si64(__m128i);
#line 436 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
}; 
#line 440 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
#line 442 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
#line 443 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
#line 444 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\emmintrin.h"
#line 374 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 375 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
	typedef __m128		glm_vec4;
	typedef __m128i		glm_ivec4;
	typedef __m128i		glm_uvec4;
#line 381 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 385 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 390 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/platform.h"
#line 37 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 45 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 63 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 74 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 78 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 87 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 118 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 155 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 165 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 167 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 169 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 184 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 194 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 198 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 200 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 202 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 211 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 253 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 254 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 280 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 292 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 298 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 303 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 308 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 310 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 315 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 320 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 326 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 332 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 335 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 340 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 345 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 347 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 352 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 357 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 364 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 369 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 371 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 373 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 379 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 384 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 386 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 391 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 396 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 398 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 404 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 409 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 411 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 417 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 422 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 424 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 430 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 435 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 437 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 443 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 448 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 453 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 457 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 465 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 469 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 473 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 477 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 510 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 522 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 530 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 533 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 537 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 539 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 555 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 558 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 573 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 575 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 584 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 595 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 602 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 612 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 624 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 633 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 646 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 655 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 671 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 704 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 710 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 716 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 718 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 722 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 728 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 732 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 734 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 740 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
namespace glm
{
	using std::size_t;
#line 758 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
		typedef int length_t;
#line 760 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
}
#line 770 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
	namespace glm
	{
		template<typename T, std::size_t N>
		constexpr std::size_t countof(T const (&)[N])
		{
			return N;
		}
	}
#line 789 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 82 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
__pragma(pack(push, 8)) extern "C" {
     void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
} __pragma(pack(pop))
#line 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 90 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_int.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 7 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_int.hpp"
#line 10 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_int.hpp"
#line 14 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_int.hpp"
namespace glm{
namespace detail
{
		typedef std::int8_t					int8;
		typedef std::int16_t				int16;
		typedef std::int32_t				int32;
		typedef std::int64_t				int64;
		typedef std::uint8_t				uint8;
		typedef std::uint16_t				uint16;
		typedef std::uint32_t				uint32;
		typedef std::uint64_t				uint64;
#line 62 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_int.hpp"
	typedef signed int						lowp_int_t;
	typedef signed int						mediump_int_t;
	typedef signed int						highp_int_t;
	typedef unsigned int					lowp_uint_t;
	typedef unsigned int					mediump_uint_t;
	typedef unsigned int					highp_uint_t;
		using std::make_signed;
		using std::make_unsigned;
#line 204 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_int.hpp"
}
	typedef detail::int8					int8;
	typedef detail::int16					int16;
	typedef detail::int32					int32;
	typedef detail::int64					int64;
	typedef detail::uint8					uint8;
	typedef detail::uint16					uint16;
	typedef detail::uint32					uint32;
	typedef detail::uint64					uint64;
	typedef detail::lowp_int_t				lowp_int;
	typedef detail::mediump_int_t			mediump_int;
	typedef detail::highp_int_t				highp_int;
	typedef detail::lowp_uint_t				lowp_uint;
	typedef detail::mediump_uint_t			mediump_uint;
	typedef detail::highp_uint_t			highp_uint;
	typedef mediump_int					int_t;
#line 272 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_int.hpp"
	typedef mediump_uint				uint_t;
#line 284 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_int.hpp"
	typedef unsigned int				uint;
	static_assert(sizeof(glm::int8) == 1, "int8 size isn't 1 byte on this platform");
	static_assert(sizeof(glm::int16) == 2, "int16 size isn't 2 bytes on this platform");
	static_assert(sizeof(glm::int32) == 4, "int32 size isn't 4 bytes on this platform");
	static_assert(sizeof(glm::int64) == 8, "int64 size isn't 8 bytes on this platform");
	static_assert(sizeof(glm::uint8) == 1, "uint8 size isn't 1 byte on this platform");
	static_assert(sizeof(glm::uint16) == 2, "uint16 size isn't 2 bytes on this platform");
	static_assert(sizeof(glm::uint32) == 4, "uint32 size isn't 4 bytes on this platform");
	static_assert(sizeof(glm::uint64) == 8, "uint64 size isn't 8 bytes on this platform");
#line 305 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_int.hpp"
}
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_float.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 7 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_float.hpp"
namespace glm{
namespace detail
{
	typedef float				float32;
		typedef double			float64;
#line 16 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_float.hpp"
}
	typedef float				lowp_float_t;
	typedef float				mediump_float_t;
	typedef double				highp_float_t;
	typedef lowp_float_t		lowp_float;
	typedef mediump_float_t		mediump_float;
	typedef highp_float_t		highp_float;
	typedef mediump_float		float_t;
#line 57 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_float.hpp"
	typedef float				float32;
		typedef double				float64;
#line 63 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_float.hpp"
	static_assert(sizeof(glm::float32) == 4, "float32 size isn't 4 bytes on this platform");
		static_assert(sizeof(glm::float64) == 8, "float64 size isn't 8 bytes on this platform");
#line 71 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_float.hpp"
#line 72 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_float.hpp"
}
#line 10 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\qualifier.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 7 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\qualifier.hpp"
namespace glm
{
	enum qualifier
	{
		packed_highp, 
		packed_mediump, 
		packed_lowp, 
			aligned_highp, 
			aligned_mediump, 
			aligned_lowp, 
			aligned = aligned_highp, 
#line 23 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\qualifier.hpp"
		highp = packed_highp, 
		mediump = packed_mediump, 
		lowp = packed_lowp, 
		packed = packed_highp, 
#line 32 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\qualifier.hpp"
			defaultp = highp
#line 34 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\qualifier.hpp"
	};
	template<length_t L, typename T, qualifier Q = defaultp> struct vec;
	template<length_t C, length_t R, typename T, qualifier Q = defaultp> struct mat;
namespace detail
{
	template<glm::qualifier P>
	struct is_aligned
	{
		static const bool value = false;
	};
		template<>
		struct is_aligned<glm::aligned_lowp>
		{
			static const bool value = true;
		};
		template<>
		struct is_aligned<glm::aligned_mediump>
		{
			static const bool value = true;
		};
		template<>
		struct is_aligned<glm::aligned_highp>
		{
			static const bool value = true;
		};
#line 66 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\qualifier.hpp"
}
}
#line 7 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\compute_vector_relational.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 4 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\compute_vector_relational.hpp"
namespace glm{
namespace detail
{
	template <typename T, bool isFloat = std::numeric_limits<T>::is_iec559>
	struct compute_equal
	{
		 inline static bool call(T a, T b)
		{
			return a == b;
		}
	};
	template <typename T>
	struct compute_equal<T, true>
	{
		 inline static bool call(T a, T b)
		{
			return std::memcmp(&a, &b, sizeof(T)) == 0;
		}
	};
}
}
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
namespace glm{
namespace detail
{
	template<typename T, std::size_t size, bool aligned>
	struct storage
	{
		typedef struct type {
			uint8 data[size];
		} type;
	};
	template<typename T> struct storage<T, 1, true> { struct __declspec(align(1)) type { uint8 data[1]; }; };
	template<typename T> struct storage<T, 2, true> { struct __declspec(align(2)) type { uint8 data[2]; }; };
	template<typename T> struct storage<T, 4, true> { struct __declspec(align(4)) type { uint8 data[4]; }; };
	template<typename T> struct storage<T, 8, true> { struct __declspec(align(8)) type { uint8 data[8]; }; };
	template<typename T> struct storage<T, 16, true> { struct __declspec(align(16)) type { uint8 data[16]; }; };
	template<typename T> struct storage<T, 32, true> { struct __declspec(align(32)) type { uint8 data[32]; }; };
	template<typename T> struct storage<T, 64, true> { struct __declspec(align(64)) type { uint8 data[64]; }; };
		template<>
		struct storage<float, 16, true>
		{
			typedef glm_vec4 type;
		};
		template<>
		struct storage<int, 16, true>
		{
			typedef glm_ivec4 type;
		};
		template<>
		struct storage<unsigned int, 16, true>
		{
			typedef glm_uvec4 type;
		};
#line 81 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 89 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 103 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
}
	template <typename T, qualifier Q = defaultp> using tvec2 = vec<2, T, Q>;
	template <typename T, qualifier Q = defaultp> using tvec3 = vec<3, T, Q>;
	template <typename T, qualifier Q = defaultp> using tvec4 = vec<4, T, Q>;
#line 110 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
	typedef vec<2, float, highp>		highp_vec2;
	typedef vec<2, float, mediump>	mediump_vec2;
	typedef vec<2, float, lowp>		lowp_vec2;
	typedef vec<2, double, highp>	highp_dvec2;
	typedef vec<2, double, mediump>	mediump_dvec2;
	typedef vec<2, double, lowp>		lowp_dvec2;
	typedef vec<2, int, highp>		highp_ivec2;
	typedef vec<2, int, mediump>		mediump_ivec2;
	typedef vec<2, int, lowp>		lowp_ivec2;
	typedef vec<2, uint, highp>		highp_uvec2;
	typedef vec<2, uint, mediump>	mediump_uvec2;
	typedef vec<2, uint, lowp>		lowp_uvec2;
	typedef vec<2, bool, highp>		highp_bvec2;
	typedef vec<2, bool, mediump>	mediump_bvec2;
	typedef vec<2, bool, lowp>		lowp_bvec2;
	typedef vec<3, float, highp>		highp_vec3;
	typedef vec<3, float, mediump>	mediump_vec3;
	typedef vec<3, float, lowp>		lowp_vec3;
	typedef vec<3, double, highp>	highp_dvec3;
	typedef vec<3, double, mediump>	mediump_dvec3;
	typedef vec<3, double, lowp>		lowp_dvec3;
	typedef vec<3, int, highp>		highp_ivec3;
	typedef vec<3, int, mediump>		mediump_ivec3;
	typedef vec<3, int, lowp>		lowp_ivec3;
	typedef vec<3, uint, highp>		highp_uvec3;
	typedef vec<3, uint, mediump>	mediump_uvec3;
	typedef vec<3, uint, lowp>		lowp_uvec3;
	typedef vec<3, bool, highp>		highp_bvec3;
	typedef vec<3, bool, mediump>	mediump_bvec3;
	typedef vec<3, bool, lowp>		lowp_bvec3;
	typedef vec<4, float, highp>		highp_vec4;
	typedef vec<4, float, mediump>	mediump_vec4;
	typedef vec<4, float, lowp>		lowp_vec4;
	typedef vec<4, double, highp>	highp_dvec4;
	typedef vec<4, double, mediump>	mediump_dvec4;
	typedef vec<4, double, lowp>		lowp_dvec4;
	typedef vec<4, int, highp>		highp_ivec4;
	typedef vec<4, int, mediump>		mediump_ivec4;
	typedef vec<4, int, lowp>		lowp_ivec4;
	typedef vec<4, uint, highp>		highp_uvec4;
	typedef vec<4, uint, mediump>	mediump_uvec4;
	typedef vec<4, uint, lowp>		lowp_uvec4;
	typedef vec<4, bool, highp>		highp_bvec4;
	typedef vec<4, bool, mediump>	mediump_bvec4;
	typedef vec<4, bool, lowp>		lowp_bvec4;
#line 433 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 437 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
	typedef highp_vec2			vec2;
	typedef highp_vec3			vec3;
	typedef highp_vec4			vec4;
#line 452 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 460 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 464 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
	typedef highp_dvec2			dvec2;
	typedef highp_dvec3			dvec3;
	typedef highp_dvec4			dvec4;
#line 479 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 487 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 491 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
	typedef highp_ivec2			ivec2;
	typedef highp_ivec3			ivec3;
	typedef highp_ivec4			ivec4;
#line 506 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 514 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 518 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
	typedef highp_uvec2			uvec2;
	typedef highp_uvec3			uvec3;
	typedef highp_uvec4			uvec4;
#line 533 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 541 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
#line 545 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
	typedef highp_bvec2			bvec2;
	typedef highp_bvec3			bvec3;
	typedef highp_bvec4			bvec4;
#line 560 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec.hpp"
}
#line 11 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat.hpp"
#pragma once
namespace glm{
namespace detail
{
	template<length_t C, length_t R, typename T, qualifier Q>
	struct outerProduct_trait{};
}
	template <typename T, qualifier Q = defaultp> using tmat2x2 = mat<2, 2, T, Q>;
	template <typename T, qualifier Q = defaultp> using tmat2x3 = mat<2, 3, T, Q>;
	template <typename T, qualifier Q = defaultp> using tmat2x4 = mat<2, 4, T, Q>;
	template <typename T, qualifier Q = defaultp> using tmat3x2 = mat<3, 2, T, Q>;
	template <typename T, qualifier Q = defaultp> using tmat3x3 = mat<3, 3, T, Q>;
	template <typename T, qualifier Q = defaultp> using tmat3x4 = mat<3, 4, T, Q>;
	template <typename T, qualifier Q = defaultp> using tmat4x2 = mat<4, 2, T, Q>;
	template <typename T, qualifier Q = defaultp> using tmat4x3 = mat<4, 3, T, Q>;
	template <typename T, qualifier Q = defaultp> using tmat4x4 = mat<4, 4, T, Q>;
#line 26 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat.hpp"
	template<length_t C, length_t R, typename T, qualifier Q>
	 mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);
	typedef mat<2, 2, float, lowp>		lowp_mat2;
	typedef mat<2, 2, float, mediump>	mediump_mat2;
	typedef mat<2, 2, float, highp>		highp_mat2;
	typedef mat<2, 2, float, lowp>		lowp_mat2x2;
	typedef mat<2, 2, float, mediump>	mediump_mat2x2;
	typedef mat<2, 2, float, highp>		highp_mat2x2;
	typedef mat<2, 3, float, lowp>		lowp_mat2x3;
	typedef mat<2, 3, float, mediump>	mediump_mat2x3;
	typedef mat<2, 3, float, highp>		highp_mat2x3;
	typedef mat<2, 4, float, lowp>		lowp_mat2x4;
	typedef mat<2, 4, float, mediump>	mediump_mat2x4;
	typedef mat<2, 4, float, highp>		highp_mat2x4;
	typedef mat<3, 2, float, lowp>		lowp_mat3x2;
	typedef mat<3, 2, float, mediump>	mediump_mat3x2;
	typedef mat<3, 2, float, highp>		highp_mat3x2;
	typedef mat<3, 3, float, lowp>		lowp_mat3;
	typedef mat<3, 3, float, mediump>	mediump_mat3;
	typedef mat<3, 3, float, highp>		highp_mat3;
	typedef mat<3, 3, float, lowp>		lowp_mat3x3;
	typedef mat<3, 3, float, mediump>	mediump_mat3x3;
	typedef mat<3, 3, float, highp>		highp_mat3x3;
	typedef mat<3, 4, float, lowp>		lowp_mat3x4;
	typedef mat<3, 4, float, mediump>	mediump_mat3x4;
	typedef mat<3, 4, float, highp>		highp_mat3x4;
	typedef mat<4, 2, float, lowp>		lowp_mat4x2;
	typedef mat<4, 2, float, mediump>	mediump_mat4x2;
	typedef mat<4, 2, float, highp>		highp_mat4x2;
	typedef mat<4, 3, float, lowp>		lowp_mat4x3;
	typedef mat<4, 3, float, mediump>	mediump_mat4x3;
	typedef mat<4, 3, float, highp>		highp_mat4x3;
	typedef mat<4, 4, float, lowp>		lowp_mat4;
	typedef mat<4, 4, float, mediump>	mediump_mat4;
	typedef mat<4, 4, float, highp>		highp_mat4;
	typedef mat<4, 4, float, lowp>		lowp_mat4x4;
	typedef mat<4, 4, float, mediump>	mediump_mat4x4;
	typedef mat<4, 4, float, highp>		highp_mat4x4;
#line 345 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat.hpp"
#line 355 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat.hpp"
	typedef highp_mat2x2			mat2x2;
	typedef highp_mat2x3			mat2x3;
	typedef highp_mat2x4			mat2x4;
	typedef highp_mat3x2			mat3x2;
	typedef highp_mat3x3			mat3x3;
	typedef highp_mat3x4			mat3x4;
	typedef highp_mat4x2			mat4x2;
	typedef highp_mat4x3			mat4x3;
	typedef highp_mat4x4			mat4x4;
#line 401 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat.hpp"
	typedef mat2x2					mat2;
	typedef mat3x3					mat3;
	typedef mat4x4					mat4;
	typedef mat<2, 2, double, lowp>		lowp_dmat2;
	typedef mat<2, 2, double, mediump>	mediump_dmat2;
	typedef mat<2, 2, double, highp>		highp_dmat2;
	typedef mat<2, 2, double, lowp>		lowp_dmat2x2;
	typedef mat<2, 2, double, mediump>	mediump_dmat2x2;
	typedef mat<2, 2, double, highp>		highp_dmat2x2;
	typedef mat<2, 3, double, lowp>		lowp_dmat2x3;
	typedef mat<2, 3, double, mediump>	mediump_dmat2x3;
	typedef mat<2, 3, double, highp>		highp_dmat2x3;
	typedef mat<2, 4, double, lowp>		lowp_dmat2x4;
	typedef mat<2, 4, double, mediump>	mediump_dmat2x4;
	typedef mat<2, 4, double, highp>		highp_dmat2x4;
	typedef mat<3, 2, double, lowp>		lowp_dmat3x2;
	typedef mat<3, 2, double, mediump>	mediump_dmat3x2;
	typedef mat<3, 2, double, highp>		highp_dmat3x2;
	typedef mat<3, 3, float, lowp>		lowp_dmat3;
	typedef mat<3, 3, double, mediump>	mediump_dmat3;
	typedef mat<3, 3, double, highp>		highp_dmat3;
	typedef mat<3, 3, double, lowp>		lowp_dmat3x3;
	typedef mat<3, 3, double, mediump>	mediump_dmat3x3;
	typedef mat<3, 3, double, highp>		highp_dmat3x3;
	typedef mat<3, 4, double, lowp>		lowp_dmat3x4;
	typedef mat<3, 4, double, mediump>	mediump_dmat3x4;
	typedef mat<3, 4, double, highp>		highp_dmat3x4;
	typedef mat<4, 2, double, lowp>		lowp_dmat4x2;
	typedef mat<4, 2, double, mediump>	mediump_dmat4x2;
	typedef mat<4, 2, double, highp>		highp_dmat4x2;
	typedef mat<4, 3, double, lowp>		lowp_dmat4x3;
	typedef mat<4, 3, double, mediump>	mediump_dmat4x3;
	typedef mat<4, 3, double, highp>		highp_dmat4x3;
	typedef mat<4, 4, double, lowp>		lowp_dmat4;
	typedef mat<4, 4, double, mediump>	mediump_dmat4;
	typedef mat<4, 4, double, highp>		highp_dmat4;
	typedef mat<4, 4, double, lowp>		lowp_dmat4x4;
	typedef mat<4, 4, double, mediump>	mediump_dmat4x4;
	typedef mat<4, 4, double, highp>		highp_dmat4x4;
#line 692 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat.hpp"
#line 702 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat.hpp"
	typedef highp_dmat2x2		dmat2;
	typedef highp_dmat3x3		dmat3;
	typedef highp_dmat4x4		dmat4;
	typedef highp_dmat2x2		dmat2x2;
	typedef highp_dmat2x3		dmat2x3;
	typedef highp_dmat2x4		dmat2x4;
	typedef highp_dmat3x2		dmat3x2;
	typedef highp_dmat3x3		dmat3x3;
	typedef highp_dmat3x4		dmat3x4;
	typedef highp_dmat4x2		dmat4x2;
	typedef highp_dmat4x3		dmat4x3;
	typedef highp_dmat4x4		dmat4x4;
#line 764 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat.hpp"
}
#line 12 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
namespace glm
{
	template<typename T, qualifier Q> struct tquat;
	typedef tquat<float, lowp>		lowp_quat;
	typedef tquat<float, mediump>	mediump_quat;
	typedef tquat<float, highp>		highp_quat;
#line 37 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 39 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 41 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_quat			quat;
#line 44 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef lowp_quat			lowp_fquat;
	typedef mediump_quat		mediump_fquat;
	typedef highp_quat			highp_fquat;
	typedef quat				fquat;
	typedef tquat<double, lowp>		lowp_dquat;
	typedef tquat<double, mediump>	mediump_dquat;
	typedef tquat<double, highp>	highp_dquat;
#line 84 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 86 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 88 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_dquat			dquat;
#line 93 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
}
namespace glm
{
	typedef detail::int8 lowp_int8;
	typedef detail::int16 lowp_int16;
	typedef detail::int32 lowp_int32;
	typedef detail::int64 lowp_int64;
	typedef detail::int8 lowp_int8_t;
	typedef detail::int16 lowp_int16_t;
	typedef detail::int32 lowp_int32_t;
	typedef detail::int64 lowp_int64_t;
	typedef detail::int8 lowp_i8;
	typedef detail::int16 lowp_i16;
	typedef detail::int32 lowp_i32;
	typedef detail::int64 lowp_i64;
	typedef detail::int8 mediump_int8;
	typedef detail::int16 mediump_int16;
	typedef detail::int32 mediump_int32;
	typedef detail::int64 mediump_int64;
	typedef detail::int8 mediump_int8_t;
	typedef detail::int16 mediump_int16_t;
	typedef detail::int32 mediump_int32_t;
	typedef detail::int64 mediump_int64_t;
	typedef detail::int8 mediump_i8;
	typedef detail::int16 mediump_i16;
	typedef detail::int32 mediump_i32;
	typedef detail::int64 mediump_i64;
	typedef detail::int8 highp_int8;
	typedef detail::int16 highp_int16;
	typedef detail::int32 highp_int32;
	typedef detail::int64 highp_int64;
	typedef detail::int8 highp_int8_t;
	typedef detail::int16 highp_int16_t;
	typedef detail::int32 highp_int32_t;
	typedef detail::int64 highp_int64_t;
	typedef detail::int8 highp_i8;
	typedef detail::int16 highp_i16;
	typedef detail::int32 highp_i32;
	typedef detail::int64 highp_i64;
	typedef detail::int8 int8;
	typedef detail::int16 int16;
	typedef detail::int32 int32;
	typedef detail::int64 int64;
	using std::int8_t;
	using std::int16_t;
	using std::int32_t;
	using std::int64_t;
#line 284 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef detail::int8 i8;
	typedef detail::int16 i16;
	typedef detail::int32 i32;
	typedef detail::int64 i64;
	typedef vec<1, i8, lowp> lowp_i8vec1;
	typedef vec<2, i8, lowp> lowp_i8vec2;
	typedef vec<3, i8, lowp> lowp_i8vec3;
	typedef vec<4, i8, lowp> lowp_i8vec4;
	typedef vec<1, i8, mediump> mediump_i8vec1;
	typedef vec<2, i8, mediump> mediump_i8vec2;
	typedef vec<3, i8, mediump> mediump_i8vec3;
	typedef vec<4, i8, mediump> mediump_i8vec4;
	typedef vec<1, i8, highp> highp_i8vec1;
	typedef vec<2, i8, highp> highp_i8vec2;
	typedef vec<3, i8, highp> highp_i8vec3;
	typedef vec<4, i8, highp> highp_i8vec4;
#line 359 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 364 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_i8vec1			i8vec1;
	typedef highp_i8vec2			i8vec2;
	typedef highp_i8vec3			i8vec3;
	typedef highp_i8vec4			i8vec4;
#line 380 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef vec<1, i16, lowp>		lowp_i16vec1;
	typedef vec<2, i16, lowp>		lowp_i16vec2;
	typedef vec<3, i16, lowp>		lowp_i16vec3;
	typedef vec<4, i16, lowp>		lowp_i16vec4;
	typedef vec<1, i16, mediump>		mediump_i16vec1;
	typedef vec<2, i16, mediump>		mediump_i16vec2;
	typedef vec<3, i16, mediump>		mediump_i16vec3;
	typedef vec<4, i16, mediump>		mediump_i16vec4;
	typedef vec<1, i16, highp>		highp_i16vec1;
	typedef vec<2, i16, highp>		highp_i16vec2;
	typedef vec<3, i16, highp>		highp_i16vec3;
	typedef vec<4, i16, highp>		highp_i16vec4;
#line 439 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 444 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_i16vec1			i16vec1;
	typedef highp_i16vec2			i16vec2;
	typedef highp_i16vec3			i16vec3;
	typedef highp_i16vec4			i16vec4;
#line 460 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef vec<1, i32, lowp>		lowp_i32vec1;
	typedef vec<2, i32, lowp>		lowp_i32vec2;
	typedef vec<3, i32, lowp>		lowp_i32vec3;
	typedef vec<4, i32, lowp>		lowp_i32vec4;
	typedef vec<1, i32, mediump>		mediump_i32vec1;
	typedef vec<2, i32, mediump>		mediump_i32vec2;
	typedef vec<3, i32, mediump>		mediump_i32vec3;
	typedef vec<4, i32, mediump>		mediump_i32vec4;
	typedef vec<1, i32, highp>		highp_i32vec1;
	typedef vec<2, i32, highp>		highp_i32vec2;
	typedef vec<3, i32, highp>		highp_i32vec3;
	typedef vec<4, i32, highp>		highp_i32vec4;
#line 518 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 523 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_i32vec1			i32vec1;
	typedef highp_i32vec2			i32vec2;
	typedef highp_i32vec3			i32vec3;
	typedef highp_i32vec4			i32vec4;
#line 539 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef vec<1, i32, lowp>		lowp_i32vec1;
	typedef vec<2, i32, lowp>		lowp_i32vec2;
	typedef vec<3, i32, lowp>		lowp_i32vec3;
	typedef vec<4, i32, lowp>		lowp_i32vec4;
	typedef vec<1, i32, mediump>		mediump_i32vec1;
	typedef vec<2, i32, mediump>		mediump_i32vec2;
	typedef vec<3, i32, mediump>		mediump_i32vec3;
	typedef vec<4, i32, mediump>		mediump_i32vec4;
	typedef vec<1, i32, highp>		highp_i32vec1;
	typedef vec<2, i32, highp>		highp_i32vec2;
	typedef vec<3, i32, highp>		highp_i32vec3;
	typedef vec<4, i32, highp>		highp_i32vec4;
#line 597 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 602 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_i32vec1			i32vec1;
	typedef highp_i32vec2			i32vec2;
	typedef highp_i32vec3			i32vec3;
	typedef highp_i32vec4			i32vec4;
#line 618 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef vec<1, i64, lowp>		lowp_i64vec1;
	typedef vec<2, i64, lowp>		lowp_i64vec2;
	typedef vec<3, i64, lowp>		lowp_i64vec3;
	typedef vec<4, i64, lowp>		lowp_i64vec4;
	typedef vec<1, i64, mediump>		mediump_i64vec1;
	typedef vec<2, i64, mediump>		mediump_i64vec2;
	typedef vec<3, i64, mediump>		mediump_i64vec3;
	typedef vec<4, i64, mediump>		mediump_i64vec4;
	typedef vec<1, i64, highp>		highp_i64vec1;
	typedef vec<2, i64, highp>		highp_i64vec2;
	typedef vec<3, i64, highp>		highp_i64vec3;
	typedef vec<4, i64, highp>		highp_i64vec4;
#line 677 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 682 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_i64vec1			i64vec1;
	typedef highp_i64vec2			i64vec2;
	typedef highp_i64vec3			i64vec3;
	typedef highp_i64vec4			i64vec4;
#line 698 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef detail::uint8 lowp_uint8;
	typedef detail::uint16 lowp_uint16;
	typedef detail::uint32 lowp_uint32;
	typedef detail::uint64 lowp_uint64;
	typedef detail::uint8 lowp_uint8_t;
	typedef detail::uint16 lowp_uint16_t;
	typedef detail::uint32 lowp_uint32_t;
	typedef detail::uint64 lowp_uint64_t;
	typedef detail::uint8 lowp_u8;
	typedef detail::uint16 lowp_u16;
	typedef detail::uint32 lowp_u32;
	typedef detail::uint64 lowp_u64;
	typedef detail::uint8 mediump_uint8;
	typedef detail::uint16 mediump_uint16;
	typedef detail::uint32 mediump_uint32;
	typedef detail::uint64 mediump_uint64;
	typedef detail::uint8 mediump_uint8_t;
	typedef detail::uint16 mediump_uint16_t;
	typedef detail::uint32 mediump_uint32_t;
	typedef detail::uint64 mediump_uint64_t;
	typedef detail::uint8 mediump_u8;
	typedef detail::uint16 mediump_u16;
	typedef detail::uint32 mediump_u32;
	typedef detail::uint64 mediump_u64;
	typedef detail::uint8 highp_uint8;
	typedef detail::uint16 highp_uint16;
	typedef detail::uint32 highp_uint32;
	typedef detail::uint64 highp_uint64;
	typedef detail::uint8 highp_uint8_t;
	typedef detail::uint16 highp_uint16_t;
	typedef detail::uint32 highp_uint32_t;
	typedef detail::uint64 highp_uint64_t;
	typedef detail::uint8 highp_u8;
	typedef detail::uint16 highp_u16;
	typedef detail::uint32 highp_u32;
	typedef detail::uint64 highp_u64;
	typedef detail::uint8 uint8;
	typedef detail::uint16 uint16;
	typedef detail::uint32 uint32;
	typedef detail::uint64 uint64;
	using std::uint8_t;
	using std::uint16_t;
	using std::uint32_t;
	using std::uint64_t;
#line 893 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef detail::uint8 u8;
	typedef detail::uint16 u16;
	typedef detail::uint32 u32;
	typedef detail::uint64 u64;
	typedef vec<1, u8, lowp> lowp_u8vec1;
	typedef vec<2, u8, lowp> lowp_u8vec2;
	typedef vec<3, u8, lowp> lowp_u8vec3;
	typedef vec<4, u8, lowp> lowp_u8vec4;
	typedef vec<1, u8, mediump> mediump_u8vec1;
	typedef vec<2, u8, mediump> mediump_u8vec2;
	typedef vec<3, u8, mediump> mediump_u8vec3;
	typedef vec<4, u8, mediump> mediump_u8vec4;
	typedef vec<1, u8, highp> highp_u8vec1;
	typedef vec<2, u8, highp> highp_u8vec2;
	typedef vec<3, u8, highp> highp_u8vec3;
	typedef vec<4, u8, highp> highp_u8vec4;
#line 968 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 973 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_u8vec1			u8vec1;
	typedef highp_u8vec2			u8vec2;
	typedef highp_u8vec3			u8vec3;
	typedef highp_u8vec4			u8vec4;
#line 989 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef vec<1, u16, lowp>		lowp_u16vec1;
	typedef vec<2, u16, lowp>		lowp_u16vec2;
	typedef vec<3, u16, lowp>		lowp_u16vec3;
	typedef vec<4, u16, lowp>		lowp_u16vec4;
	typedef vec<1, u16, mediump>		mediump_u16vec1;
	typedef vec<2, u16, mediump>		mediump_u16vec2;
	typedef vec<3, u16, mediump>		mediump_u16vec3;
	typedef vec<4, u16, mediump>		mediump_u16vec4;
	typedef vec<1, u16, highp>		highp_u16vec1;
	typedef vec<2, u16, highp>		highp_u16vec2;
	typedef vec<3, u16, highp>		highp_u16vec3;
	typedef vec<4, u16, highp>		highp_u16vec4;
#line 1048 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 1053 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_u16vec1			u16vec1;
	typedef highp_u16vec2			u16vec2;
	typedef highp_u16vec3			u16vec3;
	typedef highp_u16vec4			u16vec4;
#line 1069 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef vec<1, u32, lowp>		lowp_u32vec1;
	typedef vec<2, u32, lowp>		lowp_u32vec2;
	typedef vec<3, u32, lowp>		lowp_u32vec3;
	typedef vec<4, u32, lowp>		lowp_u32vec4;
	typedef vec<1, u32, mediump>		mediump_u32vec1;
	typedef vec<2, u32, mediump>		mediump_u32vec2;
	typedef vec<3, u32, mediump>		mediump_u32vec3;
	typedef vec<4, u32, mediump>		mediump_u32vec4;
	typedef vec<1, u32, highp>		highp_u32vec1;
	typedef vec<2, u32, highp>		highp_u32vec2;
	typedef vec<3, u32, highp>		highp_u32vec3;
	typedef vec<4, u32, highp>		highp_u32vec4;
#line 1127 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 1132 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_u32vec1			u32vec1;
	typedef highp_u32vec2			u32vec2;
	typedef highp_u32vec3			u32vec3;
	typedef highp_u32vec4			u32vec4;
#line 1148 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef vec<1, u32, lowp>		lowp_u32vec1;
	typedef vec<2, u32, lowp>		lowp_u32vec2;
	typedef vec<3, u32, lowp>		lowp_u32vec3;
	typedef vec<4, u32, lowp>		lowp_u32vec4;
	typedef vec<1, u32, mediump>		mediump_u32vec1;
	typedef vec<2, u32, mediump>		mediump_u32vec2;
	typedef vec<3, u32, mediump>		mediump_u32vec3;
	typedef vec<4, u32, mediump>		mediump_u32vec4;
	typedef vec<1, u32, highp>		highp_u32vec1;
	typedef vec<2, u32, highp>		highp_u32vec2;
	typedef vec<3, u32, highp>		highp_u32vec3;
	typedef vec<4, u32, highp>		highp_u32vec4;
#line 1206 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 1211 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_u32vec1			u32vec1;
	typedef highp_u32vec2			u32vec2;
	typedef highp_u32vec3			u32vec3;
	typedef highp_u32vec4			u32vec4;
#line 1227 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef vec<1, u64, lowp>		lowp_u64vec1;
	typedef vec<2, u64, lowp>		lowp_u64vec2;
	typedef vec<3, u64, lowp>		lowp_u64vec3;
	typedef vec<4, u64, lowp>		lowp_u64vec4;
	typedef vec<1, u64, mediump>		mediump_u64vec1;
	typedef vec<2, u64, mediump>		mediump_u64vec2;
	typedef vec<3, u64, mediump>		mediump_u64vec3;
	typedef vec<4, u64, mediump>		mediump_u64vec4;
	typedef vec<1, u64, highp>		highp_u64vec1;
	typedef vec<2, u64, highp>		highp_u64vec2;
	typedef vec<3, u64, highp>		highp_u64vec3;
	typedef vec<4, u64, highp>		highp_u64vec4;
#line 1286 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 1291 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_u64vec1			u64vec1;
	typedef highp_u64vec2			u64vec2;
	typedef highp_u64vec3			u64vec3;
	typedef highp_u64vec4			u64vec4;
#line 1307 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef detail::float32 lowp_float32;
	typedef detail::float64 lowp_float64;
	typedef detail::float32 lowp_float32_t;
	typedef detail::float64 lowp_float64_t;
	typedef float32 lowp_f32;
	typedef float64 lowp_f64;
	typedef detail::float32 lowp_float32;
	typedef detail::float64 lowp_float64;
	typedef detail::float32 lowp_float32_t;
	typedef detail::float64 lowp_float64_t;
	typedef float32 lowp_f32;
	typedef float64 lowp_f64;
	typedef detail::float32 lowp_float32;
	typedef detail::float64 lowp_float64;
	typedef detail::float32 lowp_float32_t;
	typedef detail::float64 lowp_float64_t;
	typedef float32 lowp_f32;
	typedef float64 lowp_f64;
	typedef detail::float32 mediump_float32;
	typedef detail::float64 mediump_float64;
	typedef detail::float32 mediump_float32_t;
	typedef detail::float64 mediump_float64_t;
	typedef float32 mediump_f32;
	typedef float64 mediump_f64;
	typedef detail::float32 highp_float32;
	typedef detail::float64 highp_float64;
	typedef detail::float32 highp_float32_t;
	typedef detail::float64 highp_float64_t;
	typedef float32 highp_f32;
	typedef float64 highp_f64;
#line 1462 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 1488 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_float32 float32;
	typedef highp_float64 float64;
	typedef highp_float32_t float32_t;
	typedef highp_float64_t float64_t;
	typedef highp_float32_t f32;
	typedef highp_float64_t f64;
#line 1513 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef vec<1, float, lowp> lowp_vec1;
	typedef vec<2, float, lowp> lowp_vec2;
	typedef vec<3, float, lowp> lowp_vec3;
	typedef vec<4, float, lowp> lowp_vec4;
	typedef vec<1, float, lowp> lowp_fvec1;
	typedef vec<2, float, lowp> lowp_fvec2;
	typedef vec<3, float, lowp> lowp_fvec3;
	typedef vec<4, float, lowp> lowp_fvec4;
	typedef vec<1, float, mediump> mediump_vec1;
	typedef vec<2, float, mediump> mediump_vec2;
	typedef vec<3, float, mediump> mediump_vec3;
	typedef vec<4, float, mediump> mediump_vec4;
	typedef vec<1, float, mediump> mediump_fvec1;
	typedef vec<2, float, mediump> mediump_fvec2;
	typedef vec<3, float, mediump> mediump_fvec3;
	typedef vec<4, float, mediump> mediump_fvec4;
	typedef vec<1, float, highp> highp_vec1;
	typedef vec<2, float, highp> highp_vec2;
	typedef vec<3, float, highp> highp_vec3;
	typedef vec<4, float, highp> highp_vec4;
	typedef vec<1, float, highp> highp_fvec1;
	typedef vec<2, float, highp> highp_fvec2;
	typedef vec<3, float, highp> highp_fvec3;
	typedef vec<4, float, highp> highp_fvec4;
	typedef vec<1, f32, lowp> lowp_f32vec1;
	typedef vec<2, f32, lowp> lowp_f32vec2;
	typedef vec<3, f32, lowp> lowp_f32vec3;
	typedef vec<4, f32, lowp> lowp_f32vec4;
	typedef vec<1, f32, mediump> mediump_f32vec1;
	typedef vec<2, f32, mediump> mediump_f32vec2;
	typedef vec<3, f32, mediump> mediump_f32vec3;
	typedef vec<4, f32, mediump> mediump_f32vec4;
	typedef vec<1, f32, highp> highp_f32vec1;
	typedef vec<2, f32, highp> highp_f32vec2;
	typedef vec<3, f32, highp> highp_f32vec3;
	typedef vec<4, f32, highp> highp_f32vec4;
	typedef vec<1, f64, lowp> lowp_f64vec1;
	typedef vec<2, f64, lowp> lowp_f64vec2;
	typedef vec<3, f64, lowp> lowp_f64vec3;
	typedef vec<4, f64, lowp> lowp_f64vec4;
	typedef vec<1, f64, mediump> mediump_f64vec1;
	typedef vec<2, f64, mediump> mediump_f64vec2;
	typedef vec<3, f64, mediump> mediump_f64vec3;
	typedef vec<4, f64, mediump> mediump_f64vec4;
	typedef vec<1, f64, highp> highp_f64vec1;
	typedef vec<2, f64, highp> highp_f64vec2;
	typedef vec<3, f64, highp> highp_f64vec3;
	typedef vec<4, f64, highp> highp_f64vec4;
	typedef mat<2, 2, f32, lowp> lowp_fmat2x2;
	typedef mat<2, 3, f32, lowp> lowp_fmat2x3;
	typedef mat<2, 4, f32, lowp> lowp_fmat2x4;
	typedef mat<3, 2, f32, lowp> lowp_fmat3x2;
	typedef mat<3, 3, f32, lowp> lowp_fmat3x3;
	typedef mat<3, 4, f32, lowp> lowp_fmat3x4;
	typedef mat<4, 2, f32, lowp> lowp_fmat4x2;
	typedef mat<4, 3, f32, lowp> lowp_fmat4x3;
	typedef mat<4, 4, f32, lowp> lowp_fmat4x4;
	typedef lowp_fmat2x2 lowp_fmat2;
	typedef lowp_fmat3x3 lowp_fmat3;
	typedef lowp_fmat4x4 lowp_fmat4;
	typedef mat<2, 2, f32, mediump> mediump_fmat2x2;
	typedef mat<2, 3, f32, mediump> mediump_fmat2x3;
	typedef mat<2, 4, f32, mediump> mediump_fmat2x4;
	typedef mat<3, 2, f32, mediump> mediump_fmat3x2;
	typedef mat<3, 3, f32, mediump> mediump_fmat3x3;
	typedef mat<3, 4, f32, mediump> mediump_fmat3x4;
	typedef mat<4, 2, f32, mediump> mediump_fmat4x2;
	typedef mat<4, 3, f32, mediump> mediump_fmat4x3;
	typedef mat<4, 4, f32, mediump> mediump_fmat4x4;
	typedef mediump_fmat2x2 mediump_fmat2;
	typedef mediump_fmat3x3 mediump_fmat3;
	typedef mediump_fmat4x4 mediump_fmat4;
	typedef mat<2, 2, f32, highp> highp_fmat2x2;
	typedef mat<2, 3, f32, highp> highp_fmat2x3;
	typedef mat<2, 4, f32, highp> highp_fmat2x4;
	typedef mat<3, 2, f32, highp> highp_fmat3x2;
	typedef mat<3, 3, f32, highp> highp_fmat3x3;
	typedef mat<3, 4, f32, highp> highp_fmat3x4;
	typedef mat<4, 2, f32, highp> highp_fmat4x2;
	typedef mat<4, 3, f32, highp> highp_fmat4x3;
	typedef mat<4, 4, f32, highp> highp_fmat4x4;
	typedef highp_fmat2x2 highp_fmat2;
	typedef highp_fmat3x3 highp_fmat3;
	typedef highp_fmat4x4 highp_fmat4;
	typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;
	typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;
	typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;
	typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;
	typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;
	typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;
	typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;
	typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;
	typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;
	typedef lowp_f32mat2x2 lowp_f32mat2;
	typedef lowp_f32mat3x3 lowp_f32mat3;
	typedef lowp_f32mat4x4 lowp_f32mat4;
	typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;
	typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;
	typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;
	typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;
	typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;
	typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;
	typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;
	typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;
	typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;
	typedef mediump_f32mat2x2 mediump_f32mat2;
	typedef mediump_f32mat3x3 mediump_f32mat3;
	typedef mediump_f32mat4x4 mediump_f32mat4;
	typedef mat<2, 2, f32, highp> highp_f32mat2x2;
	typedef mat<2, 3, f32, highp> highp_f32mat2x3;
	typedef mat<2, 4, f32, highp> highp_f32mat2x4;
	typedef mat<3, 2, f32, highp> highp_f32mat3x2;
	typedef mat<3, 3, f32, highp> highp_f32mat3x3;
	typedef mat<3, 4, f32, highp> highp_f32mat3x4;
	typedef mat<4, 2, f32, highp> highp_f32mat4x2;
	typedef mat<4, 3, f32, highp> highp_f32mat4x3;
	typedef mat<4, 4, f32, highp> highp_f32mat4x4;
	typedef highp_f32mat2x2 highp_f32mat2;
	typedef highp_f32mat3x3 highp_f32mat3;
	typedef highp_f32mat4x4 highp_f32mat4;
	typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;
	typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;
	typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;
	typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;
	typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;
	typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;
	typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;
	typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;
	typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;
	typedef lowp_f64mat2x2 lowp_f64mat2;
	typedef lowp_f64mat3x3 lowp_f64mat3;
	typedef lowp_f64mat4x4 lowp_f64mat4;
	typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;
	typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;
	typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;
	typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;
	typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;
	typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;
	typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;
	typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;
	typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;
	typedef mediump_f64mat2x2 mediump_f64mat2;
	typedef mediump_f64mat3x3 mediump_f64mat3;
	typedef mediump_f64mat4x4 mediump_f64mat4;
	typedef mat<2, 2, f64, highp> highp_f64mat2x2;
	typedef mat<2, 3, f64, highp> highp_f64mat2x3;
	typedef mat<2, 4, f64, highp> highp_f64mat2x4;
	typedef mat<3, 2, f64, highp> highp_f64mat3x2;
	typedef mat<3, 3, f64, highp> highp_f64mat3x3;
	typedef mat<3, 4, f64, highp> highp_f64mat3x4;
	typedef mat<4, 2, f64, highp> highp_f64mat4x2;
	typedef mat<4, 3, f64, highp> highp_f64mat4x3;
	typedef mat<4, 4, f64, highp> highp_f64mat4x4;
	typedef highp_f64mat2x2 highp_f64mat2;
	typedef highp_f64mat3x3 highp_f64mat3;
	typedef highp_f64mat4x4 highp_f64mat4;
	typedef tquat<f32, lowp> lowp_f32quat;
	typedef tquat<f64, lowp> lowp_f64quat;
	typedef tquat<f32, mediump> mediump_f32quat;
	typedef tquat<f64, mediump> mediump_f64quat;
	typedef tquat<f32, highp> highp_f32quat;
	typedef tquat<f64, highp> highp_f64quat;
#line 2291 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 2327 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_f32vec1			fvec1;
	typedef highp_f32vec2			fvec2;
	typedef highp_f32vec3			fvec3;
	typedef highp_f32vec4			fvec4;
	typedef highp_f32mat2x2			fmat2x2;
	typedef highp_f32mat2x3			fmat2x3;
	typedef highp_f32mat2x4			fmat2x4;
	typedef highp_f32mat3x2			fmat3x2;
	typedef highp_f32mat3x3			fmat3x3;
	typedef highp_f32mat3x4			fmat3x4;
	typedef highp_f32mat4x2			fmat4x2;
	typedef highp_f32mat4x3			fmat4x3;
	typedef highp_f32mat4x4			fmat4x4;
	typedef fmat2x2					fmat2;
	typedef fmat3x3					fmat3;
	typedef fmat4x4					fmat4;
	typedef highp_fquat				fquat;
	typedef highp_f32vec1			f32vec1;
	typedef highp_f32vec2			f32vec2;
	typedef highp_f32vec3			f32vec3;
	typedef highp_f32vec4			f32vec4;
	typedef highp_f32mat2x2			f32mat2x2;
	typedef highp_f32mat2x3			f32mat2x3;
	typedef highp_f32mat2x4			f32mat2x4;
	typedef highp_f32mat3x2			f32mat3x2;
	typedef highp_f32mat3x3			f32mat3x3;
	typedef highp_f32mat3x4			f32mat3x4;
	typedef highp_f32mat4x2			f32mat4x2;
	typedef highp_f32mat4x3			f32mat4x3;
	typedef highp_f32mat4x4			f32mat4x4;
	typedef f32mat2x2				f32mat2;
	typedef f32mat3x3				f32mat3;
	typedef f32mat4x4				f32mat4;
	typedef highp_f32quat			f32quat;
#line 2465 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 2485 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
#line 2503 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
	typedef highp_f64vec1			f64vec1;
	typedef highp_f64vec2			f64vec2;
	typedef highp_f64vec3			f64vec3;
	typedef highp_f64vec4			f64vec4;
	typedef highp_f64mat2x2			f64mat2x2;
	typedef highp_f64mat2x3			f64mat2x3;
	typedef highp_f64mat2x4			f64mat2x4;
	typedef highp_f64mat3x2			f64mat3x2;
	typedef highp_f64mat3x3			f64mat3x3;
	typedef highp_f64mat3x4			f64mat3x4;
	typedef highp_f64mat4x2			f64mat4x2;
	typedef highp_f64mat4x3			f64mat4x3;
	typedef highp_f64mat4x4			f64mat4x4;
	typedef f64mat2x2				f64mat2;
	typedef f64mat3x3				f64mat3;
	typedef f64mat4x4				f64mat4;
	typedef highp_f64quat			f64quat;
#line 2571 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\fwd.hpp"
}
#line 91 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 96 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\vec2.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\vec2.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
#pragma once
#line 14 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
namespace glm
{
	template<typename T, qualifier Q>
	struct vec<2, T, Q>
	{
		typedef T value_type;
		typedef vec type;
		typedef vec<2, bool, Q> bool_type;
#line 33 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
#line 37 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
#line 42 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
			union
			{
				struct{ T x, y; };
				struct{ T r, g; };
				struct{ T s, t; };
#line 60 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
			};
#line 66 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
#line 69 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
#line 77 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
		typedef length_t length_type;
		 static constexpr length_type length(){return 2;}
		 T& operator[](length_type i);
		 T const& operator[](length_type i) const;
		 constexpr vec() = default;
		 constexpr vec(vec const& v) = default;
		template<qualifier P>
		 constexpr vec(vec<2, T, P> const& v);
		 constexpr explicit vec(T scalar);
		 constexpr vec(T x, T y);
		template<typename A, typename B>
		 constexpr vec(A x, B y);
		template<typename A, typename B>
		 constexpr vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);
		template<typename U, qualifier P>
		 constexpr  vec(vec<3, U, P> const& v);
		template<typename U, qualifier P>
		 constexpr  vec(vec<4, U, P> const& v);
		template<typename U, qualifier P>
		 constexpr  vec(vec<2, U, P> const& v);
#line 128 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
		 vec& operator=(vec const& v) = default;
		template<typename U>
		 vec& operator=(vec<2, U, Q> const& v);
		template<typename U>
		 vec& operator+=(U scalar);
		template<typename U>
		 vec& operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 vec& operator+=(vec<2, U, Q> const& v);
		template<typename U>
		 vec& operator-=(U scalar);
		template<typename U>
		 vec& operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 vec& operator-=(vec<2, U, Q> const& v);
		template<typename U>
		 vec& operator*=(U scalar);
		template<typename U>
		 vec& operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 vec& operator*=(vec<2, U, Q> const& v);
		template<typename U>
		 vec& operator/=(U scalar);
		template<typename U>
		 vec& operator/=(vec<1, U, Q> const& v);
		template<typename U>
		 vec& operator/=(vec<2, U, Q> const& v);
		 vec & operator++();
		 vec & operator--();
		 vec operator++(int);
		 vec operator--(int);
		template<typename U> 
		 vec & operator%=(U scalar);
		template<typename U> 
		 vec & operator%=(vec<1, U, Q> const& v);
		template<typename U> 
		 vec & operator%=(vec<2, U, Q> const& v);
		template<typename U> 
		 vec & operator&=(U scalar);
		template<typename U> 
		 vec & operator&=(vec<1, U, Q> const& v);
		template<typename U> 
		 vec & operator&=(vec<2, U, Q> const& v);
		template<typename U> 
		 vec & operator|=(U scalar);
		template<typename U> 
		 vec & operator|=(vec<1, U, Q> const& v);
		template<typename U> 
		 vec & operator|=(vec<2, U, Q> const& v);
		template<typename U> 
		 vec & operator^=(U scalar);
		template<typename U> 
		 vec & operator^=(vec<1, U, Q> const& v);
		template<typename U> 
		 vec & operator^=(vec<2, U, Q> const& v);
		template<typename U> 
		 vec & operator<<=(U scalar);
		template<typename U> 
		 vec & operator<<=(vec<1, U, Q> const& v);
		template<typename U> 
		 vec & operator<<=(vec<2, U, Q> const& v);
		template<typename U> 
		 vec & operator>>=(U scalar);
		template<typename U> 
		 vec & operator>>=(vec<1, U, Q> const& v);
		template<typename U> 
		 vec & operator>>=(vec<2, U, Q> const& v);
	};
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator+(vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator-(vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<2, T, Q> operator~(vec<2, T, Q> const& v);
	template<typename T, qualifier Q>
	 bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<typename T, qualifier Q>
	 bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);
	template<qualifier Q>
	 vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
	template<qualifier Q>
	 vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec2.inl"
namespace glm
{
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec2.inl"
#line 20 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec2.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr vec<2, T, Q>::vec(vec<2, T, P> const& v)
		: x(v.x), y(v.y)
	{}
	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q>::vec(T scalar)
		: x(scalar), y(scalar)
	{}
	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q>::vec(T _x, T _y)
		: x(_x), y(_y)
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B>
	 inline constexpr vec<2, T, Q>::vec(A _x, B _y)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B>
	 inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, vec<1, B, Q> const& _y)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<2, T, Q>::vec(vec<2, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<2, T, Q>::vec(vec<3, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<2, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}
	template<typename T, qualifier Q>
	 inline T & vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec2.inl", (unsigned)(83)), 0) );
		return (&x)[i];
	}
	template<typename T, qualifier Q>
	 inline T const& vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec2.inl", (unsigned)(90)), 0) );
		return (&x)[i];
	}
#line 105 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec2.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<2, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<2, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<2, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		this->y /= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<2, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator++()
	{
		++this->x;
		++this->y;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator--()
	{
		--this->x;
		--this->y;
		return *this;
	}
	template<typename T, qualifier Q> 
	 inline vec<2, T, Q> vec<2, T, Q>::operator++(int)
	{
		vec<2, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q> 
	 inline vec<2, T, Q> vec<2, T, Q>::operator--(int)
	{
		vec<2, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		this->y %= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<2, U, Q> const& v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		this->y &= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<2, U, Q> const& v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		this->y |= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<2, U, Q> const& v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		this->y ^= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<2, U, Q> const& v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		this->y <<= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<2, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<2, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v)
	{
		return v;
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			-v.x, 
			-v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x + scalar,
			v.y + scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x + v2.x,
			v1.y + v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar + v.x,
			scalar + v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x + v2.x,
			v1.x + v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x + v2.x,
			v1.y + v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x - scalar,
			v.y - scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x - v2.x,
			v1.y - v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar - v.x,
			scalar - v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x - v2.x,
			v1.x - v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x - v2.x,
			v1.y - v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x * scalar,
			v.y * scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x * v2.x,
			v1.y * v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar * v.x,
			scalar * v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x * v2.x,
			v1.x * v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x * v2.x,
			v1.y * v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x / scalar,
			v.y / scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x / v2.x,
			v1.y / v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar / v.x,
			scalar / v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x / v2.x,
			v1.x / v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x / v2.x,
			v1.y / v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x % scalar,
			v.y % scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x % v2.x,
			v1.y % v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar % v.x,
			scalar % v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x % v2.x,
			v1.x % v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x % v2.x,
			v1.y % v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x & scalar,
			v.y & scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x & v2.x,
			v1.y & v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar & v.x,
			scalar & v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x & v2.x,
			v1.x & v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x & v2.x,
			v1.y & v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x | scalar,
			v.y | scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x | v2.x,
			v1.y | v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar | v.x,
			scalar | v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x | v2.x,
			v1.x | v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x | v2.x,
			v1.y | v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x ^ scalar,
			v.y ^ scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x ^ v2.x,
			v1.y ^ v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar ^ v.x,
			scalar ^ v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x ^ v2.x,
			v1.x ^ v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x ^ v2.x,
			v1.y ^ v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x << scalar,
			v.y << scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x << v2.x,
			v1.y << v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar << v.x,
			scalar << v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x << v2.x,
			v1.x << v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x << v2.x,
			v1.y << v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x >> scalar,
			v.y >> scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x >> v2.x,
			v1.y >> v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar >> v.x,
			scalar >> v.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x >> v2.x,
			v1.x >> v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x >> v2.x,
			v1.y >> v2.y);
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> operator~(vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			~v.x,
			~v.y);
	}
	template<typename T, qualifier Q>
	 inline bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return
			detail::compute_equal<T>::call(v1.x, v2.x) &&
			detail::compute_equal<T>::call(v1.y, v2.y);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return !(v1 == v2);
	}
	template<qualifier Q>
	 inline vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
	{
		return vec<2, bool, Q>(v1.x && v2.x, v1.y && v2.y);
	}
	template<qualifier Q>
	 inline vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
	{
		return vec<2, bool, Q>(v1.x || v2.x, v1.y || v2.y);
	}
}
#line 387 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
#line 388 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec2.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\vec2.hpp"
#line 98 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\vec3.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\vec3.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
#pragma once
#line 14 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
namespace glm
{
	template<typename T, qualifier Q>
	struct vec<3, T, Q>
	{
		typedef T value_type;
		typedef vec type;
		typedef vec<3, bool, Q> bool_type;
#line 33 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
#line 37 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
#line 42 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
			union
			{
				struct{ T x, y, z; };
				struct{ T r, g, b; };
				struct{ T s, t, p; };
#line 60 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
			};
#line 65 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
#line 68 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
#line 77 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
		typedef length_t length_type;
		 static constexpr length_type length(){return 3;}
		 T & operator[](length_type i);
		 T const& operator[](length_type i) const;
		 constexpr vec() = default;
		 constexpr vec(vec const& v) = default;
		template<qualifier P>
		 constexpr vec(vec<3, T, P> const& v);
		 constexpr explicit vec(T scalar);
		 constexpr vec(T a, T b, T c);
		template<typename X, typename Y, typename Z>
		 constexpr vec(X x, Y y, Z z);
		template<typename X, typename Y, typename Z>
		 constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, B _z);
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z);
		template<typename A, typename B, qualifier P>
		 constexpr vec(A _x, vec<2, B, P> const& _yz);
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz);
		template<typename U, qualifier P>
		 constexpr  vec(vec<4, U, P> const& v);
		template<typename U, qualifier P>
		 constexpr  vec(vec<3, U, P> const& v);
#line 149 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
		 vec & operator=(vec const& v) = default;
		template<typename U>
		 vec & operator=(vec<3, U, Q> const& v);
		template<typename U>
		 vec & operator+=(U scalar);
		template<typename U>
		 vec & operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator+=(vec<3, U, Q> const& v);
		template<typename U>
		 vec & operator-=(U scalar);
		template<typename U>
		 vec & operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator-=(vec<3, U, Q> const& v);
		template<typename U>
		 vec & operator*=(U scalar);
		template<typename U>
		 vec & operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator*=(vec<3, U, Q> const& v);
		template<typename U>
		 vec & operator/=(U scalar);
		template<typename U>
		 vec & operator/=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator/=(vec<3, U, Q> const& v);
		 vec & operator++();
		 vec & operator--();
		 vec operator++(int);
		 vec operator--(int);
		template<typename U>
		 vec & operator%=(U scalar);
		template<typename U>
		 vec & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator%=(vec<3, U, Q> const& v);
		template<typename U>
		 vec & operator&=(U scalar);
		template<typename U>
		 vec & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator&=(vec<3, U, Q> const& v);
		template<typename U>
		 vec & operator|=(U scalar);
		template<typename U>
		 vec & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator|=(vec<3, U, Q> const& v);
		template<typename U>
		 vec & operator^=(U scalar);
		template<typename U>
		 vec & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator^=(vec<3, U, Q> const& v);
		template<typename U>
		 vec & operator<<=(U scalar);
		template<typename U>
		 vec & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator<<=(vec<3, U, Q> const& v);
		template<typename U>
		 vec & operator>>=(U scalar);
		template<typename U>
		 vec & operator>>=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator>>=(vec<3, U, Q> const& v);
	};
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator+(vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator-(vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator+(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator-(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator*(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator/(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator%(T const& scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator%(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator&(vec<3, T, Q> const& v1, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator&(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator|(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator^(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator<<(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator>>(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q> 
	 vec<3, T, Q> operator~(vec<3, T, Q> const& v);
	template<typename T, qualifier Q>
	 bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<typename T, qualifier Q>
	 bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);
	template<qualifier Q>
	 vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);
	template<qualifier Q>
	 vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec3.inl"
namespace glm
{
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec3.inl"
#line 20 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec3.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<3, T, P> const& v)
		: x(v.x), y(v.y), z(v.z)
	{}
	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q>::vec(T scalar)
		: x(scalar), y(scalar), z(scalar)
	{}
	template <typename T, qualifier Q>
	 inline constexpr vec<3, T, Q>::vec(T _x, T _y, T _z)
		: x(_x), y(_y), z(_z)
	{}
	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(X _x, Y _y, Z _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
	{}
	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, B _z)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z.x))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(A _x, vec<2, B, P> const& _yz)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<3, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
	{}
	template<typename T, qualifier Q>
	 inline T & vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec3.inl", (unsigned)(112)), 0) );
		return (&x)[i];
	}
	template<typename T, qualifier Q>
	 inline T const& vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec3.inl", (unsigned)(119)), 0) );
		return (&x)[i];
	}
#line 135 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec3.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q>& vec<3, T, Q>::operator=(vec<3, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		this->z += static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		this->z += static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<3, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		this->z += static_cast<T>(v.z);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		this->z -= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		this->z -= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<3, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		this->z -= static_cast<T>(v.z);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		this->z *= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		this->z *= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<3, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		this->z *= static_cast<T>(v.z);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator/=(U v)
	{
		this->x /= static_cast<T>(v);
		this->y /= static_cast<T>(v);
		this->z /= static_cast<T>(v);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		this->z /= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<3, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		this->z /= static_cast<T>(v.z);
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		return *this;
	}
	template<typename T, qualifier Q> 
	 inline vec<3, T, Q> vec<3, T, Q>::operator++(int)
	{
		vec<3, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q> 
	 inline vec<3, T, Q> vec<3, T, Q>::operator--(int)
	{
		vec<3, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator%=(U scalar)
	{
		this->x %= scalar;
		this->y %= scalar;
		this->z %= scalar;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		this->x %= v.x;
		this->y %= v.x;
		this->z %= v.x;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<3, U, Q> const& v)
	{
		this->x %= v.x;
		this->y %= v.y;
		this->z %= v.z;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator&=(U scalar)
	{
		this->x &= scalar;
		this->y &= scalar;
		this->z &= scalar;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		this->x &= v.x;
		this->y &= v.x;
		this->z &= v.x;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<3, U, Q> const& v)
	{
		this->x &= v.x;
		this->y &= v.y;
		this->z &= v.z;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<3, T, Q> & vec<3, T, Q>::operator|=(U scalar)
	{
		this->x |= scalar;
		this->y |= scalar;
		this->z |= scalar;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		this->x |= v.x;
		this->y |= v.x;
		this->z |= v.x;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<3, U, Q> const& v)
	{
		this->x |= v.x;
		this->y |= v.y;
		this->z |= v.z;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator^=(U scalar)
	{
		this->x ^= scalar;
		this->y ^= scalar;
		this->z ^= scalar;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		this->x ^= v.x;
		this->y ^= v.x;
		this->z ^= v.x;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<3, U, Q> const& v)
	{
		this->x ^= v.x;
		this->y ^= v.y;
		this->z ^= v.z;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator<<=(U scalar)
	{
		this->x <<= scalar;
		this->y <<= scalar;
		this->z <<= scalar;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		this->z <<= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<3, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		this->z <<= static_cast<T>(v.z);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		this->z >>= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		this->z >>= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<3, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		this->z >>= static_cast<T>(v.z);
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator+(vec<3, T, Q> const& v)
	{
		return v;
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator-(vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			-v.x, 
			-v.y, 
			-v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x + scalar,
			v.y + scalar,
			v.z + scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x + scalar.x,
			v.y + scalar.x,
			v.z + scalar.x);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar + v.x,
			scalar + v.y,
			scalar + v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator+(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x + v.x,
			scalar.x + v.y,
			scalar.x + v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x + v2.x,
			v1.y + v2.y,
			v1.z + v2.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x - scalar,
			v.y - scalar,
			v.z - scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator-(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x - scalar.x,
			v.y - scalar.x,
			v.z - scalar.x);
	}
	template<typename T, qualifier Q> 
	 inline vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar - v.x,
			scalar - v.y,
			scalar - v.z);
	}
	template<typename T, qualifier Q> 
	 inline vec<3, T, Q> operator-(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x - v.x,
			scalar.x - v.y,
			scalar.x - v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x - v2.x,
			v1.y - v2.y,
			v1.z - v2.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x * scalar,
			v.y * scalar,
			v.z * scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator*(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x * scalar.x,
			v.y * scalar.x,
			v.z * scalar.x);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar * v.x,
			scalar * v.y,
			scalar * v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator*(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x * v.x,
			scalar.x * v.y,
			scalar.x * v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x * v2.x,
			v1.y * v2.y,
			v1.z * v2.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x / scalar,
			v.y / scalar,
			v.z / scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator/(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x / scalar.x,
			v.y / scalar.x,
			v.z / scalar.x);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar / v.x,
			scalar / v.y,
			scalar / v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator/(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x / v.x,
			scalar.x / v.y,
			scalar.x / v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x / v2.x,
			v1.y / v2.y,
			v1.z / v2.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x % scalar,
			v.y % scalar,
			v.z % scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator%(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x % scalar.x,
			v.y % scalar.x,
			v.z % scalar.x);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar % v.x,
			scalar % v.y,
			scalar % v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator%(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x % v.x,
			scalar.x % v.y,
			scalar.x % v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x % v2.x,
			v1.y % v2.y,
			v1.z % v2.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator&(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x & scalar,
			v.y & scalar,
			v.z & scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator&(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x & scalar.x,
			v.y & scalar.x,
			v.z & scalar.x);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar & v.x,
			scalar & v.y,
			scalar & v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator&(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x & v.x,
			scalar.x & v.y,
			scalar.x & v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x & v2.x,
			v1.y & v2.y,
			v1.z & v2.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x | scalar,
			v.y | scalar,
			v.z | scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator|(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x | scalar.x,
			v.y | scalar.x,
			v.z | scalar.x);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar | v.x,
			scalar | v.y,
			scalar | v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator|(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x | v.x,
			scalar.x | v.y,
			scalar.x | v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x | v2.x,
			v1.y | v2.y,
			v1.z | v2.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x ^ scalar,
			v.y ^ scalar,
			v.z ^ scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator^(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x ^ scalar.x,
			v.y ^ scalar.x,
			v.z ^ scalar.x);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar ^ v.x,
			scalar ^ v.y,
			scalar ^ v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator^(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x ^ v.x,
			scalar.x ^ v.y,
			scalar.x ^ v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x ^ v2.x,
			v1.y ^ v2.y,
			v1.z ^ v2.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x << scalar,
			v.y << scalar,
			v.z << scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator<<(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x << scalar.x,
			v.y << scalar.x,
			v.z << scalar.x);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar << v.x,
			scalar << v.y,
			scalar << v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x << v.x,
			scalar.x << v.y,
			scalar.x << v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x << v2.x,
			v1.y << v2.y,
			v1.z << v2.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x >> scalar,
			v.y >> scalar,
			v.z >> scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator>>(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x >> scalar.x,
			v.y >> scalar.x,
			v.z >> scalar.x);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar >> v.x,
			scalar >> v.y,
			scalar >> v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x >> v.x,
			scalar.x >> v.y,
			scalar.x >> v.z);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x >> v2.x,
			v1.y >> v2.y,
			v1.z >> v2.z);
	}
	template<typename T, qualifier Q> 
	 inline vec<3, T, Q> operator~(vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			~v.x,
			~v.y,
			~v.z);
	}
	template<typename T, qualifier Q>
	 inline bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return
			detail::compute_equal<T>::call(v1.x, v2.x) &&
			detail::compute_equal<T>::call(v1.y, v2.y) &&
			detail::compute_equal<T>::call(v1.z, v2.z);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return !(v1 == v2);
	}
	template<qualifier Q>
	 inline vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
	{
		return vec<3, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
	}
	template<qualifier Q>
	 inline vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
	{
		return vec<3, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
	}
}
#line 408 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
#line 409 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec3.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\vec3.hpp"
#line 99 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\vec4.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\vec4.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
#pragma once
#line 14 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
namespace glm
{
	template<typename T, qualifier Q>
	struct vec<4, T, Q>
	{
		typedef T value_type;
		typedef vec<4, T, Q> type;
		typedef vec<4, bool, Q> bool_type;
#line 33 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
#line 37 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
#line 42 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
			union
			{
				struct { T x, y, z, w;};
				struct { T r, g, b, a; };
				struct { T s, t, p, q; };
				typename detail::storage<T, sizeof(T) * 4, detail::is_aligned<Q>::value>::type data;
#line 62 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
			};
#line 67 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
#line 70 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
#line 80 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
		typedef length_t length_type;
		 static constexpr length_type length(){return 4;}
		 T & operator[](length_type i);
		 T const& operator[](length_type i) const;
		  vec() = default;
		  vec(vec<4, T, Q> const& v) = default;
		template<qualifier P>
		  vec(vec<4, T, P> const& v);
		  explicit vec(T scalar);
		  vec(T x, T y, T z, T w);
		template<typename X, typename Y, typename Z, typename W>
		  vec(X _x, Y _y, Z _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _Y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, B _z, C _w);
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(A _x, vec<2, B, P> const& _yz, C _w);
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(A _x, B _y, vec<2, C, P> const& _zw);
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<3, A, P> const& _xyz, B _w);
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);
		template<typename A, typename B, qualifier P>
		 constexpr vec(A _x, vec<3, B, P> const& _yzw);
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);
		template<typename U, qualifier P>
		 constexpr  vec(vec<4, U, P> const& v);
#line 194 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
		 vec<4, T, Q>& operator=(vec<4, T, Q> const& v) = default;
		template<typename U>
		 vec<4, T, Q>& operator=(vec<4, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q>& operator+=(U scalar);
		template<typename U>
		 vec<4, T, Q>& operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q>& operator+=(vec<4, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q>& operator-=(U scalar);
		template<typename U>
		 vec<4, T, Q>& operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q>& operator-=(vec<4, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q>& operator*=(U scalar);
		template<typename U>
		 vec<4, T, Q>& operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q>& operator*=(vec<4, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q>& operator/=(U scalar);
		template<typename U>
		 vec<4, T, Q>& operator/=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q>& operator/=(vec<4, U, Q> const& v);
		 vec<4, T, Q> & operator++();
		 vec<4, T, Q> & operator--();
		 vec<4, T, Q> operator++(int);
		 vec<4, T, Q> operator--(int);
		template<typename U>
		 vec<4, T, Q> & operator%=(U scalar);
		template<typename U>
		 vec<4, T, Q> & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator%=(vec<4, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator&=(U scalar);
		template<typename U>
		 vec<4, T, Q> & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator&=(vec<4, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator|=(U scalar);
		template<typename U>
		 vec<4, T, Q> & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator|=(vec<4, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator^=(U scalar);
		template<typename U>
		 vec<4, T, Q> & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator^=(vec<4, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator<<=(U scalar);
		template<typename U>
		 vec<4, T, Q> & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator<<=(vec<4, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator>>=(U scalar);
		template<typename U>
		 vec<4, T, Q> & operator>>=(vec<1, U, Q> const& v);
		template<typename U>
		 vec<4, T, Q> & operator>>=(vec<4, U, Q> const& v);
	};
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator+(vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator-(vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator%(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator&(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator|(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator|(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator^(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator^(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator<<(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator>>(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<4, T, Q> operator~(vec<4, T, Q> const& v);
	template<typename T, qualifier Q>
	 bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<typename T, qualifier Q>
	 bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);
	template<qualifier Q>
	 vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
	template<qualifier Q>
	 vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4.inl"
namespace glm{
namespace detail
{
	template<typename T>
	struct is_int
	{
		enum test {value = 0};
	};
	template<>
	struct is_int<uint32>
	{
		enum test {value = ~0};
	};
	template<>
	struct is_int<int32>
	{
		enum test {value = ~0};
	};
	template<>
	struct is_int<uint64>
	{
		enum test {value = ~0};
	};
	template<>
	struct is_int<int64>
	{
		enum test {value = ~0};
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_add
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_sub
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_mul
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_div
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_mod
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
		}
	};
	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_and
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
		}
	};
	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_or
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
		}
	};
	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_xor
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
		}
	};
	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_left
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
		}
	};
	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_right
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
		}
	};
	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_equal
	{
		 inline static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
		{
			return
				detail::compute_equal<T>::call(v1.x, v2.x) &&
				detail::compute_equal<T>::call(v1.y, v2.y) &&
				detail::compute_equal<T>::call(v1.z, v2.z) &&
				detail::compute_equal<T>::call(v1.w, v2.w);
		}
	};
	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_nequal
	{
		 inline static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
		{
			return !compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
		}
	};
	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_bitwise_not
	{
		 inline static vec<4, T, Q> call(vec<4, T, Q> const& v)
		{
			return vec<4, T, Q>(~v.x, ~v.y, ~v.z, ~v.w);
		}
	};
}
#line 166 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4.inl"
#line 173 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline  vec<4, T, Q>::vec(vec<4, T, P> const& v)
		: x(v.x), y(v.y), z(v.z), w(v.w)
	{}
	template<typename T, qualifier Q>
	 inline  vec<4, T, Q>::vec(T scalar)
		: x(scalar), y(scalar), z(scalar), w(scalar)
	{}
	template <typename T, qualifier Q>
	 inline  vec<4, T, Q>::vec(T _x, T _y, T _z, T _w)
		: x(_x), y(_y), z(_z), w(_w)
	{}
	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline  vec<4, T, Q>::vec(X _x, Y _y, Z _z, W _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}
	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, C _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, C _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w.x))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(A _x, B _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, B _w)
		: x(static_cast<T>(_xyz.x))
		, y(static_cast<T>(_xyz.y))
		, z(static_cast<T>(_xyz.z))
		, w(static_cast<T>(_w))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w)
		: x(static_cast<T>(_xyz.x))
		, y(static_cast<T>(_xyz.y))
		, z(static_cast<T>(_xyz.z))
		, w(static_cast<T>(_w.x))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(A _x, vec<3, B, P> const& _yzw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yzw.x))
		, z(static_cast<T>(_yzw.y))
		, w(static_cast<T>(_yzw.z))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yzw.x))
		, z(static_cast<T>(_yzw.y))
		, w(static_cast<T>(_yzw.z))
	{}
	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
		, w(static_cast<T>(v.w))
	{}
	template<typename T, qualifier Q>
	 inline T& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4.inl", (unsigned)(327)), 0) );
		return (&x)[i];
	}
	template<typename T, qualifier Q>
	 inline T const& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4.inl", (unsigned)(334)), 0) );
		return (&x)[i];
	}
#line 351 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		this->w = static_cast<T>(v.w);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator+=(U scalar)
	{
		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator-=(U scalar)
	{
		return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator*=(U scalar)
	{
		return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator/=(U scalar)
	{
		return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		++this->w;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		--this->w;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> vec<4, T, Q>::operator++(int)
	{
		vec<4, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> vec<4, T, Q>::operator--(int)
	{
		vec<4, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator%=(U scalar)
	{
		return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator&=(U scalar)
	{
		return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator|=(U scalar)
	{
		return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator^=(U scalar)
	{
		return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator<<=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator>>=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v)
	{
		return v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(0) -= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) += scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) += v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(v) += scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v2) += v1;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) += v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) -= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) -= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) -= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) -= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) -= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) *= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) *= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(v) *= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v2) *= v1;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) *= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) /= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) /= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) /= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) /= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) /= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) %= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) %= v2.x;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) %= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar.x) %= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) %= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) &= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<4, T, Q>(v) &= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) &= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator&(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) &= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) &= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) |= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) |= v2.x;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) |= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator|(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) |= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) |= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) ^= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) ^= v2.x;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) ^= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator^(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) ^= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) ^= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) <<= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) <<= v2.x;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) <<= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator<<(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) <<= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) <<= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) >>= scalar;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) >>= v2.x;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) >>= v;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator>>(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) >>= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) >>= v2;
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> operator~(vec<4, T, Q> const& v)
	{
		return detail::compute_vec4_bitwise_not<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v);
	}
	template<typename T, qualifier Q>
	 inline bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return detail::compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return detail::compute_vec4_nequal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
	}
	template<qualifier Q>
	 inline vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
	{
		return vec<4, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
	}
	template<qualifier Q>
	 inline vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
	{
		return vec<4, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
namespace glm{
namespace detail
{
#line 53 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<qualifier Q>
	struct compute_vec4_add<float, Q, true>
	{
		static vec<4, float, Q> call(vec<4, float, Q> const& a, vec<4, float, Q> const& b)
		{
			vec<4, float, Q> Result;
			Result.data = _mm_add_ps(a.data, b.data);
			return Result;
		}
	};
#line 77 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<qualifier Q>
	struct compute_vec4_sub<float, Q, true>
	{
		static vec<4, float, Q> call(vec<4, float, Q> const& a, vec<4, float, Q> const& b)
		{
			vec<4, float, Q> Result;
			Result.data = _mm_sub_ps(a.data, b.data);
			return Result;
		}
	};
#line 101 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<qualifier Q>
	struct compute_vec4_mul<float, Q, true>
	{
		static vec<4, float, Q> call(vec<4, float, Q> const& a, vec<4, float, Q> const& b)
		{
			vec<4, float, Q> Result;
			Result.data = _mm_mul_ps(a.data, b.data);
			return Result;
		}
	};
#line 125 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<qualifier Q>
	struct compute_vec4_div<float, Q, true>
	{
		static vec<4, float, Q> call(vec<4, float, Q> const& a, vec<4, float, Q> const& b)
		{
			vec<4, float, Q> Result;
			Result.data = _mm_div_ps(a.data, b.data);
			return Result;
		}
	};
#line 149 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<>
	struct compute_vec4_div<float, aligned_lowp, true>
	{
		static vec<4, float, aligned_lowp> call(vec<4, float, aligned_lowp> const& a, vec<4, float, aligned_lowp> const& b)
		{
			vec<4, float, aligned_lowp> Result;
			Result.data = _mm_mul_ps(a.data, _mm_rcp_ps(b.data));
			return Result;
		}
	};
	template<typename T, qualifier Q>
	struct compute_vec4_and<T, Q, true, 32, true>
	{
		static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			vec<4, T, Q> Result;
			Result.data = _mm_and_si128(a.data, b.data);
			return Result;
		}
	};
#line 184 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<typename T, qualifier Q>
	struct compute_vec4_or<T, Q, true, 32, true>
	{
		static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			vec<4, T, Q> Result;
			Result.data = _mm_or_si128(a.data, b.data);
			return Result;
		}
	};
#line 208 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<typename T, qualifier Q>
	struct compute_vec4_xor<T, Q, true, 32, true>
	{
		static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			vec<4, T, Q> Result;
			Result.data = _mm_xor_si128(a.data, b.data);
			return Result;
		}
	};
#line 232 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<typename T, qualifier Q>
	struct compute_vec4_shift_left<T, Q, true, 32, true>
	{
		static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			vec<4, T, Q> Result;
			Result.data = _mm_sll_epi32(a.data, b.data);
			return Result;
		}
	};
#line 256 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<typename T, qualifier Q>
	struct compute_vec4_shift_right<T, Q, true, 32, true>
	{
		static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			vec<4, T, Q> Result;
			Result.data = _mm_srl_epi32(a.data, b.data);
			return Result;
		}
	};
#line 280 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<typename T, qualifier Q>
	struct compute_vec4_bitwise_not<T, Q, true, 32, true>
	{
		static vec<4, T, Q> call(vec<4, T, Q> const& v)
		{
			vec<4, T, Q> Result;
			Result.data = _mm_xor_si128(v.data, _mm_set1_epi32(-1));
			return Result;
		}
	};
#line 304 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<qualifier Q>
	struct compute_vec4_equal<float, Q, false, 32, true>
	{
		static bool call(vec<4, float, Q> const& v1, vec<4, float, Q> const& v2)
		{
			return _mm_movemask_ps(_mm_cmpeq_ps(v1.data, v2.data)) != 0;
		}
	};
	template<qualifier Q>
	struct compute_vec4_equal<int32, Q, true, 32, true>
	{
		static bool call(vec<4, int32, Q> const& v1, vec<4, int32, Q> const& v2)
		{
			return _mm_movemask_epi8(_mm_cmpeq_epi32(v1.data, v2.data)) != 0;
		}
	};
	template<qualifier Q>
	struct compute_vec4_nequal<float, Q, false, 32, true>
	{
		static bool call(vec<4, float, Q> const& v1, vec<4, float, Q> const& v2)
		{
			return _mm_movemask_ps(_mm_cmpneq_ps(v1.data, v2.data)) != 0;
		}
	};
	template<qualifier Q>
	struct compute_vec4_nequal<int32, Q, true, 32, true>
	{
		static bool call(vec<4, int32, Q> const& v1, vec<4, int32, Q> const& v2)
		{
			return _mm_movemask_epi8(_mm_cmpneq_epi32(v1.data, v2.data)) != 0;
		}
	};
}
	template<>
	 inline  vec<4, float, aligned_lowp>::vec(float _s) :
		data(_mm_set_ps1(_s))
	{}
	template<>
	 inline  vec<4, float, aligned_mediump>::vec(float _s) :
		data(_mm_set_ps1(_s))
	{}
	template<>
	 inline  vec<4, float, aligned_highp>::vec(float _s) :
		data(_mm_set_ps1(_s))
	{}
#line 373 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<>
	 inline  vec<4, int32, aligned_lowp>::vec(int32 _s) :
		data(_mm_set1_epi32(_s))
	{}
	template<>
	 inline  vec<4, int32, aligned_mediump>::vec(int32 _s) :
		data(_mm_set1_epi32(_s))
	{}
	template<>
	 inline  vec<4, int32, aligned_highp>::vec(int32 _s) :
		data(_mm_set1_epi32(_s))
	{}
#line 405 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
	template<>
	 inline  vec<4, float, aligned_lowp>::vec(float _x, float _y, float _z, float _w) :
		data(_mm_set_ps(_w, _z, _y, _x))
	{}
	template<>
	 inline  vec<4, float, aligned_mediump>::vec(float _x, float _y, float _z, float _w) :
		data(_mm_set_ps(_w, _z, _y, _x))
	{}
	template<>
	 inline  vec<4, float, aligned_highp>::vec(float _x, float _y, float _z, float _w) :
		data(_mm_set_ps(_w, _z, _y, _x))
	{}
	template<>
	template<>
	 inline  vec<4, int32, aligned_lowp>::vec(int32 _x, int32 _y, int32 _z, int32 _w) :
		data(_mm_set_epi32(_w, _z, _y, _x))
	{}
	template<>
	template<>
	 inline  vec<4, int32, aligned_mediump>::vec(int32 _x, int32 _y, int32 _z, int32 _w) :
		data(_mm_set_epi32(_w, _z, _y, _x))
	{}
	template<>
	template<>
	 inline  vec<4, int32, aligned_highp>::vec(int32 _x, int32 _y, int32 _z, int32 _w) :
		data(_mm_set_epi32(_w, _z, _y, _x))
	{}
	template<>
	template<>
	 inline  vec<4, float, aligned_lowp>::vec(int32 _x, int32 _y, int32 _z, int32 _w) :
		data(_mm_castsi128_ps(_mm_set_epi32(_w, _z, _y, _x)))
	{}
	template<>
	template<>
	 inline  vec<4, float, aligned_mediump>::vec(int32 _x, int32 _y, int32 _z, int32 _w) :
		data(_mm_castsi128_ps(_mm_set_epi32(_w, _z, _y, _x)))
	{}
	template<>
	template<>
	 inline  vec<4, float, aligned_highp>::vec(int32 _x, int32 _y, int32 _z, int32 _w) :
		data(_mm_castsi128_ps(_mm_set_epi32(_w, _z, _y, _x)))
	{}
}
#line 459 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4_simd.inl"
#line 966 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4.inl"
#line 967 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec4.inl"
#line 453 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
#line 454 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec4.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\vec4.hpp"
#line 100 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat2x2.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat2x2.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat2x2.hpp"
#pragma once
namespace glm
{
	template<typename T, qualifier Q>
	struct mat<2, 2, T, Q>
	{
		typedef vec<2, T, Q> col_type;
		typedef vec<2, T, Q> row_type;
		typedef mat<2, 2, T, Q> type;
		typedef mat<2, 2, T, Q> transpose_type;
		typedef T value_type;
	private:
		col_type value[2];
	public:
		typedef length_t length_type;
		 static constexpr length_type length() { return 2; }
		 col_type & operator[](length_type i);
		 col_type const& operator[](length_type i) const;
		 mat() = default;
		 mat(mat<2, 2, T, Q> const& m) = default;
		template<qualifier P>
		 mat(mat<2, 2, T, P> const& m);
		 explicit mat(T scalar);
		 mat(
			T const& x1, T const& y1,
			T const& x2, T const& y2);
		 mat(
			col_type const& v1,
			col_type const& v2);
		template<typename U, typename V, typename M, typename N>
		 mat(
			U const& x1, V const& y1,
			M const& x2, N const& y2);
		template<typename U, typename V>
		 mat(
			vec<2, U, Q> const& v1,
			vec<2, V, Q> const& v2);
		template<typename U, qualifier P>
		  mat(mat<2, 2, U, P> const& m);
		  mat(mat<3, 3, T, Q> const& x);
		  mat(mat<4, 4, T, Q> const& x);
		  mat(mat<2, 3, T, Q> const& x);
		  mat(mat<3, 2, T, Q> const& x);
		  mat(mat<2, 4, T, Q> const& x);
		  mat(mat<4, 2, T, Q> const& x);
		  mat(mat<3, 4, T, Q> const& x);
		  mat(mat<4, 3, T, Q> const& x);
		 mat<2, 2, T, Q> & operator=(mat<2, 2, T, Q> const& v) = default;
		template<typename U>
		 mat<2, 2, T, Q> & operator=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 mat<2, 2, T, Q> & operator+=(U s);
		template<typename U>
		 mat<2, 2, T, Q> & operator+=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 mat<2, 2, T, Q> & operator-=(U s);
		template<typename U>
		 mat<2, 2, T, Q> & operator-=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 mat<2, 2, T, Q> & operator*=(U s);
		template<typename U>
		 mat<2, 2, T, Q> & operator*=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 mat<2, 2, T, Q> & operator/=(U s);
		template<typename U>
		 mat<2, 2, T, Q> & operator/=(mat<2, 2, U, Q> const& m);
		 mat<2, 2, T, Q> & operator++ ();
		 mat<2, 2, T, Q> & operator-- ();
		 mat<2, 2, T, Q> operator++(int);
		 mat<2, 2, T, Q> operator--(int);
	};
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<2, 2, T, Q>::col_type operator*(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<2, 2, T, Q>::row_type operator*(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
} 
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x2.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 22 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat2x3.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat2x3.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat2x3.hpp"
#pragma once
namespace glm
{
	template<typename T, qualifier Q>
	struct mat<2, 3, T, Q>
	{
		typedef vec<3, T, Q> col_type;
		typedef vec<2, T, Q> row_type;
		typedef mat<2, 3, T, Q> type;
		typedef mat<3, 2, T, Q> transpose_type;
		typedef T value_type;
	private:
		col_type value[2];
	public:
		typedef length_t length_type;
		 static constexpr length_type length() { return 2; }
		 col_type & operator[](length_type i);
		 col_type const& operator[](length_type i) const;
		 mat() = default;
		 mat(mat<2, 3, T, Q> const& m) = default;
		template<qualifier P>
		 mat(mat<2, 3, T, P> const& m);
		 explicit mat(T scalar);
		 mat(
			T x0, T y0, T z0,
			T x1, T y1, T z1);
		 mat(
			col_type const& v0,
			col_type const& v1);
		template<typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
		 mat(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2);
		template<typename U, typename V>
		 mat(
			vec<3, U, Q> const& v1,
			vec<3, V, Q> const& v2);
		template<typename U, qualifier P>
		  mat(mat<2, 3, U, P> const& m);
		  mat(mat<2, 2, T, Q> const& x);
		  mat(mat<3, 3, T, Q> const& x);
		  mat(mat<4, 4, T, Q> const& x);
		  mat(mat<2, 4, T, Q> const& x);
		  mat(mat<3, 2, T, Q> const& x);
		  mat(mat<3, 4, T, Q> const& x);
		  mat(mat<4, 2, T, Q> const& x);
		  mat(mat<4, 3, T, Q> const& x);
		 mat<2, 3, T, Q> & operator=(mat<2, 3, T, Q> const& m) = default;
		template<typename U>
		 mat<2, 3, T, Q> & operator=(mat<2, 3, U, Q> const& m);
		template<typename U>
		 mat<2, 3, T, Q> & operator+=(U s);
		template<typename U>
		 mat<2, 3, T, Q> & operator+=(mat<2, 3, U, Q> const& m);
		template<typename U>
		 mat<2, 3, T, Q> & operator-=(U s);
		template<typename U>
		 mat<2, 3, T, Q> & operator-=(mat<2, 3, U, Q> const& m);
		template<typename U>
		 mat<2, 3, T, Q> & operator*=(U s);
		template<typename U>
		 mat<2, 3, T, Q> & operator/=(U s);
		 mat<2, 3, T, Q> & operator++ ();
		 mat<2, 3, T, Q> & operator-- ();
		 mat<2, 3, T, Q> operator++(int);
		 mat<2, 3, T, Q> operator--(int);
	};
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<2, 3, T, Q>::col_type operator*(mat<2, 3, T, Q> const& m, typename mat<2, 3, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<2, 3, T, Q>::row_type operator*(typename mat<2, 3, T, Q>::col_type const& v, mat<2, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x3.inl"
namespace glm
{
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x3.inl"
#line 22 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x3.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline mat<2, 3, T, Q>::mat(mat<2, 3, T, P> const& m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat(T scalar)
	{
		this->value[0] = col_type(scalar, 0, 0);
		this->value[1] = col_type(0, scalar, 0);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat 
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat(col_type const& v0, col_type const& v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}
	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2>
	 inline mat<2, 3, T, Q>::mat 
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
	}
	template<typename T, qualifier Q>
	template<typename V1, typename V2>
	 inline mat<2, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline mat<2, 3, T, Q>::mat(mat<2, 3, U, P> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}
	template<typename T, qualifier Q> 
	 inline  mat<2, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 3, T, Q>::col_type & mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x3.inl", (unsigned)(151)), 0) );
		return this->value[i];
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 3, T, Q>::col_type const& mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x3.inl", (unsigned)(158)), 0) );
		return this->value[i];
	}
#line 173 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x3.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator=(mat<2, 3, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator+=(mat<2, 3, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(mat<2, 3, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> mat<2, 3, T, Q>::operator++(int)
	{
		mat<2, 3, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> mat<2, 3, T, Q>::operator--(int)
	{
		mat<2, 3, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m)
	{
		return m;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m)
	{
		return mat<2, 3, T, Q>(
			-m[0],
			-m[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] - scalar,
			m[1] - scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m)
	{
		return mat<2, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 3, T, Q>::col_type operator*
	(
		mat<2, 3, T, Q> const& m,
		typename mat<2, 3, T, Q>::row_type const& v)
	{
		return typename mat<2, 3, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y);
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 3, T, Q>::row_type operator*
	(
		typename mat<2, 3, T, Q>::col_type const& v,
		mat<2, 3, T, Q> const& m)
	{
		return typename mat<2, 3, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];
		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];
		mat<3, 3, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] / scalar,
			m[1] / scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m)
	{
		return mat<2, 3, T, Q>(
			scalar / m[0],
			scalar / m[1]);
	}
	template<typename T, qualifier Q>
	 inline bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 164 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat2x3.hpp"
#line 165 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat2x3.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat2x3.hpp"
namespace glm
{
	typedef mat<2, 3, float, lowp>		lowp_mat2x3;
	typedef mat<2, 3, float, mediump>		mediump_mat2x3;
	typedef mat<2, 3, float, highp>		highp_mat2x3;
}
#line 28 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat2x4.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat2x4.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat2x4.hpp"
#pragma once
namespace glm
{
	template<typename T, qualifier Q>
	struct mat<2, 4, T, Q>
	{
		typedef vec<4, T, Q> col_type;
		typedef vec<2, T, Q> row_type;
		typedef mat<2, 4, T, Q> type;
		typedef mat<4, 2, T, Q> transpose_type;
		typedef T value_type;
	private:
		col_type value[2];
	public:
		typedef length_t length_type;
		 static constexpr length_type length() { return 2; }
		 col_type & operator[](length_type i);
		 col_type const& operator[](length_type i) const;
		 mat() = default;
		 mat(mat<2, 4, T, Q> const& m) = default;
		template<qualifier P>
		 mat(mat<2, 4, T, P> const& m);
		 explicit mat(T scalar);
		 mat(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1);
		 mat(
			col_type const& v0,
			col_type const& v1);
		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2>
		 mat(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2);
		template<typename U, typename V>
		 mat(
			vec<4, U, Q> const& v1,
			vec<4, V, Q> const& v2);
		template<typename U, qualifier P>
		  mat(mat<2, 4, U, P> const& m);
		  mat(mat<2, 2, T, Q> const& x);
		  mat(mat<3, 3, T, Q> const& x);
		  mat(mat<4, 4, T, Q> const& x);
		  mat(mat<2, 3, T, Q> const& x);
		  mat(mat<3, 2, T, Q> const& x);
		  mat(mat<3, 4, T, Q> const& x);
		  mat(mat<4, 2, T, Q> const& x);
		  mat(mat<4, 3, T, Q> const& x);
		 mat<2, 4, T, Q> & operator=(mat<2, 4, T, Q> const& m) = default;
		template<typename U>
		 mat<2, 4, T, Q> & operator=(mat<2, 4, U, Q> const& m);
		template<typename U>
		 mat<2, 4, T, Q> & operator+=(U s);
		template<typename U>
		 mat<2, 4, T, Q> & operator+=(mat<2, 4, U, Q> const& m);
		template<typename U>
		 mat<2, 4, T, Q> & operator-=(U s);
		template<typename U>
		 mat<2, 4, T, Q> & operator-=(mat<2, 4, U, Q> const& m);
		template<typename U>
		 mat<2, 4, T, Q> & operator*=(U s);
		template<typename U>
		 mat<2, 4, T, Q> & operator/=(U s);
		 mat<2, 4, T, Q> & operator++ ();
		 mat<2, 4, T, Q> & operator-- ();
		 mat<2, 4, T, Q> operator++(int);
		 mat<2, 4, T, Q> operator--(int);
	};
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x4.inl"
namespace glm
{
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x4.inl"
#line 22 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x4.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline mat<2, 4, T, Q>::mat(mat<2, 4, T, P> const& m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(T scalar)
	{
		value_type const Zero(0);
		this->value[0] = col_type(scalar, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, scalar, Zero, Zero);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(col_type const& v0, col_type const& v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}
	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	 inline mat<2, 4, T, Q>::mat
	(
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
	}
	template<typename T, qualifier Q>
	template<typename V1, typename V2>
	 inline mat<2, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline mat<2, 4, T, Q>::mat(mat<2, 4, U, P> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 4, T, Q>::col_type & mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x4.inl", (unsigned)(152)), 0) );
		return this->value[i];
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 4, T, Q>::col_type const& mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x4.inl", (unsigned)(159)), 0) );
		return this->value[i];
	}
#line 174 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x4.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator=(mat<2, 4, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(mat<2, 4, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(mat<2, 4, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 4, T, Q> & mat<2, 4, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> mat<2, 4, T, Q>::operator++(int)
	{
		mat<2, 4, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> mat<2, 4, T, Q>::operator--(int)
	{
		mat<2, 4, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m)
	{
		return m;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m)
	{
		return mat<2, 4, T, Q>(
			-m[0], 
			-m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] - scalar,
			m[1] - scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m)
	{
		return mat<2, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v)
	{
		return typename mat<2, 4, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y,
			m[0][3] * v.x + m[1][3] * v.y);
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m)
	{
		return typename mat<2, 4, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA03 = m1[0][3];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];
		T SrcA13 = m1[1][3];
		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];
		T SrcB30 = m2[3][0];
		T SrcB31 = m2[3][1];
		mat<4, 4, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] / scalar,
			m[1] / scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m)
	{
		return mat<2, 4, T, Q>(
			scalar / m[0],
			scalar / m[1]);
	}
	template<typename T, qualifier Q>
	 inline bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 166 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat2x4.hpp"
#line 167 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat2x4.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat2x4.hpp"
namespace glm
{
	typedef mat<2, 4, float, lowp>		lowp_mat2x4;
	typedef mat<2, 4, float, mediump>		mediump_mat2x4;
	typedef mat<2, 4, float, highp>		highp_mat2x4;
}
#line 29 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat3x2.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat3x2.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat3x2.hpp"
#pragma once
namespace glm
{
	template<typename T, qualifier Q>
	struct mat<3, 2, T, Q>
	{
		typedef vec<2, T, Q> col_type;
		typedef vec<3, T, Q> row_type;
		typedef mat<3, 2, T, Q> type;
		typedef mat<2, 3, T, Q> transpose_type;
		typedef T value_type;
	private:
		col_type value[3];
	public:
		typedef length_t length_type;
		 static constexpr length_type length() { return 3; }
		 col_type & operator[](length_type i);
		 col_type const& operator[](length_type i) const;
		 mat() = default;
		 mat(mat<3, 2, T, Q> const& m) = default;
		template<qualifier P>
		 mat(mat<3, 2, T, P> const& m);
		 explicit mat(T scalar);
		 mat(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2);
		 mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);
		template<
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
		 mat(
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3);
		template<typename V1, typename V2, typename V3>
		 mat(
			vec<2, V1, Q> const& v1,
			vec<2, V2, Q> const& v2,
			vec<2, V3, Q> const& v3);
		template<typename U, qualifier P>
		  mat(mat<3, 2, U, P> const& m);
		  mat(mat<2, 2, T, Q> const& x);
		  mat(mat<3, 3, T, Q> const& x);
		  mat(mat<4, 4, T, Q> const& x);
		  mat(mat<2, 3, T, Q> const& x);
		  mat(mat<2, 4, T, Q> const& x);
		  mat(mat<3, 4, T, Q> const& x);
		  mat(mat<4, 2, T, Q> const& x);
		  mat(mat<4, 3, T, Q> const& x);
		 mat<3, 2, T, Q> & operator=(mat<3, 2, T, Q> const& m) = default;
		template<typename U>
		 mat<3, 2, T, Q> & operator=(mat<3, 2, U, Q> const& m);
		template<typename U>
		 mat<3, 2, T, Q> & operator+=(U s);
		template<typename U>
		 mat<3, 2, T, Q> & operator+=(mat<3, 2, U, Q> const& m);
		template<typename U>
		 mat<3, 2, T, Q> & operator-=(U s);
		template<typename U>
		 mat<3, 2, T, Q> & operator-=(mat<3, 2, U, Q> const& m);
		template<typename U>
		 mat<3, 2, T, Q> & operator*=(U s);
		template<typename U>
		 mat<3, 2, T, Q> & operator/=(U s);
		 mat<3, 2, T, Q> & operator++ ();
		 mat<3, 2, T, Q> & operator-- ();
		 mat<3, 2, T, Q> operator++(int);
		 mat<3, 2, T, Q> operator--(int);
	};
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x2.inl"
namespace glm
{
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x2.inl"
#line 23 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x2.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline mat<3, 2, T, Q>::mat(mat<3, 2, T, P> const& m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat(T scalar)
	{
		this->value[0] = col_type(scalar, 0);
		this->value[1] = col_type(0, scalar);
		this->value[2] = col_type(0, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat
	(
		col_type const& v0,
		col_type const& v1,
		col_type const& v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}
	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3>
	 inline mat<3, 2, T, Q>::mat
	(
		X1 x1, Y1 y1,
		X2 x2, Y2 y2,
		X3 x3, Y3 y3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
	}
	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3>
	 inline mat<3, 2, T, Q>::mat
	(
		vec<2, V1, Q> const& v1,
		vec<2, V2, Q> const& v2,
		vec<2, V3, Q> const& v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline mat<3, 2, T, Q>::mat(mat<3, 2, U, P> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 2, T, Q>::col_type & mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x2.inl", (unsigned)(180)), 0) );
		return this->value[i];
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 2, T, Q>::col_type const& mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x2.inl", (unsigned)(187)), 0) );
		return this->value[i];
	}
#line 203 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x2.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator=(mat<3, 2, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(mat<3, 2, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(mat<3, 2, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 2, T, Q> & mat<3, 2, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> mat<3, 2, T, Q>::operator++(int)
	{
		mat<3, 2, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> mat<3, 2, T, Q>::operator--(int)
	{
		mat<3, 2, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m)
	{
		return m;
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m)
	{
		return mat<3, 2, T, Q>(
			-m[0],
			-m[1],
			-m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m)
	{
		return mat<3, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v)
	{
		return typename mat<3, 2, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m)
	{
		return typename mat<3, 2, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];
		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];
		mat<2, 2, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m)
	{
		return mat<3, 2, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}
	template<typename T, qualifier Q>
	 inline bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}
	template<typename T, qualifier Q> 
	 inline bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 172 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat3x2.hpp"
#line 173 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat3x2.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat3x2.hpp"
namespace glm
{
	typedef mat<3, 2, float, lowp>		lowp_mat3x2;
	typedef mat<3, 2, float, mediump>		mediump_mat3x2;
	typedef mat<3, 2, float, highp>		highp_mat3x2;
}
#line 30 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat3x3.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat3x3.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat3x3.hpp"
#pragma once
namespace glm
{
	template<typename T, qualifier Q>
	struct mat<3, 3, T, Q>
	{
		typedef vec<3, T, Q> col_type;
		typedef vec<3, T, Q> row_type;
		typedef mat<3, 3, T, Q> type;
		typedef mat<3, 3, T, Q> transpose_type;
		typedef T value_type;
	private:
		col_type value[3];
	public:
		typedef length_t length_type;
		 static constexpr length_type length() { return 3; }
		 col_type & operator[](length_type i);
		 col_type const& operator[](length_type i) const;
		 mat() = default;
		 mat(mat<3, 3, T, Q> const& m) = default;
		template<qualifier P>
		 mat(mat<3, 3, T, P> const& m);
		 explicit mat(T scalar);
		 mat(
			T x0, T y0, T z0,
			T x1, T y1, T z1,
			T x2, T y2, T z2);
		 mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);
		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3>
		 mat(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2,
			X3 x3, Y3 y3, Z3 z3);
		template<typename V1, typename V2, typename V3>
		 mat(
			vec<3, V1, Q> const& v1,
			vec<3, V2, Q> const& v2,
			vec<3, V3, Q> const& v3);
		template<typename U, qualifier P>
		  mat(mat<3, 3, U, P> const& m);
		  mat(mat<2, 2, T, Q> const& x);
		  mat(mat<4, 4, T, Q> const& x);
		  mat(mat<2, 3, T, Q> const& x);
		  mat(mat<3, 2, T, Q> const& x);
		  mat(mat<2, 4, T, Q> const& x);
		  mat(mat<4, 2, T, Q> const& x);
		  mat(mat<3, 4, T, Q> const& x);
		  mat(mat<4, 3, T, Q> const& x);
		 mat<3, 3, T, Q> & operator=(mat<3, 3, T, Q> const& m) = default;
		template<typename U>
		 mat<3, 3, T, Q> & operator=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 mat<3, 3, T, Q> & operator+=(U s);
		template<typename U>
		 mat<3, 3, T, Q> & operator+=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 mat<3, 3, T, Q> & operator-=(U s);
		template<typename U>
		 mat<3, 3, T, Q> & operator-=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 mat<3, 3, T, Q> & operator*=(U s);
		template<typename U>
		 mat<3, 3, T, Q> & operator*=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 mat<3, 3, T, Q> & operator/=(U s);
		template<typename U>
		 mat<3, 3, T, Q> & operator/=(mat<3, 3, U, Q> const& m);
		 mat<3, 3, T, Q> & operator++();
		 mat<3, 3, T, Q> & operator--();
		 mat<3, 3, T, Q> operator++(int);
		 mat<3, 3, T, Q> operator--(int);
	};
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x3.inl"
namespace glm
{
#line 15 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x3.inl"
#line 25 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x3.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline mat<3, 3, T, Q>::mat(mat<3, 3, T, P> const& m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat(T scalar)
	{
		this->value[0] = col_type(scalar, 0, 0);
		this->value[1] = col_type(0, scalar, 0);
		this->value[2] = col_type(0, 0, scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1,
		T x2, T y2, T z2
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat
	(
		col_type const& v0,
		col_type const& v1,
		col_type const& v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}
	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	 inline mat<3, 3, T, Q>::mat
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2,
		X3 x3, Y3 y3, Z3 z3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
	}
	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3>
	 inline mat<3, 3, T, Q>::mat
	(
		vec<3, V1, Q> const& v1,
		vec<3, V2, Q> const& v2,
		vec<3, V3, Q> const& v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline mat<3, 3, T, Q>::mat(mat<3, 3, U, P> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 3, T, Q>::col_type & mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x3.inl", (unsigned)(182)), 0) );
		return this->value[i];
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 3, T, Q>::col_type const& mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x3.inl", (unsigned)(189)), 0) );
		return this->value[i];
	}
#line 205 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x3.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator=(mat<3, 3, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(mat<3, 3, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(mat<3, 3, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(mat<3, 3, U, Q> const& m)
	{
		return (*this = *this * m);
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(mat<3, 3, U, Q> const& m)
	{
		return *this *= inverse(m);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> mat<3, 3, T, Q>::operator++(int)
	{
		mat<3, 3, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> mat<3, 3, T, Q>::operator--(int)
	{
		mat<3, 3, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m)
	{
		return m;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			-m[0], 
			-m[1],
			-m[2]);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 3, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			scalar - m[0],
			scalar - m[1],
			scalar - m[2]);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 3, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}
	template<typename T, qualifier Q> 
	 inline typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
	{
		return typename mat<3, 3, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
	}
	template<typename T, qualifier Q> 
	 inline typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
	{
		return typename mat<3, 3, T, Q>::row_type(
			m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
	}
	template<typename T, qualifier Q> 
	 inline mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];
		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];
		mat<3, 3, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m,	T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
	{
		return  inverse(m) * v;
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
	{
		return v * inverse(m);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		mat<3, 3, T, Q> m1_copy(m1);
		return m1_copy /= m2;
	}
	template<typename T, qualifier Q>
	 inline bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 189 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat3x3.hpp"
#line 190 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat3x3.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat3x3.hpp"
namespace glm
{
	typedef mat<3, 3, float, lowp>		lowp_mat3;
	typedef mat<3, 3, float, mediump>		mediump_mat3;
	typedef mat<3, 3, float, highp>		highp_mat3;
	typedef mat<3, 3, float, lowp>		lowp_mat3x3;
	typedef mat<3, 3, float, mediump>		mediump_mat3x3;
	typedef mat<3, 3, float, highp>		highp_mat3x3;
}
#line 31 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat3x4.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat3x4.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat3x4.hpp"
#pragma once
namespace glm
{
	template<typename T, qualifier Q>
	struct mat<3, 4, T, Q>
	{
		typedef vec<4, T, Q> col_type;
		typedef vec<3, T, Q> row_type;
		typedef mat<3, 4, T, Q> type;
		typedef mat<4, 3, T, Q> transpose_type;
		typedef T value_type;
	private:
		col_type value[3];
	public:
		typedef length_t length_type;
		 static constexpr length_type length() { return 3; }
		 col_type & operator[](length_type i);
		 col_type const& operator[](length_type i) const;
		 mat() = default;
		 mat(mat<3, 4, T, Q> const& m) = default;
		template<qualifier P>
		 mat(mat<3, 4, T, P> const& m);
		 explicit mat(T scalar);
		 mat(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1,
			T x2, T y2, T z2, T w2);
		 mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);
		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3>
		 mat(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2,
			X3 x3, Y3 y3, Z3 z3, W3 w3);
		template<typename V1, typename V2, typename V3>
		 mat(
			vec<4, V1, Q> const& v1,
			vec<4, V2, Q> const& v2,
			vec<4, V3, Q> const& v3);
		template<typename U, qualifier P>
		  mat(mat<3, 4, U, P> const& m);
		  mat(mat<2, 2, T, Q> const& x);
		  mat(mat<3, 3, T, Q> const& x);
		  mat(mat<4, 4, T, Q> const& x);
		  mat(mat<2, 3, T, Q> const& x);
		  mat(mat<3, 2, T, Q> const& x);
		  mat(mat<2, 4, T, Q> const& x);
		  mat(mat<4, 2, T, Q> const& x);
		  mat(mat<4, 3, T, Q> const& x);
		 mat<3, 4, T, Q> & operator=(mat<3, 4, T, Q> const& m) = default;
		template<typename U>
		 mat<3, 4, T, Q> & operator=(mat<3, 4, U, Q> const& m);
		template<typename U>
		 mat<3, 4, T, Q> & operator+=(U s);
		template<typename U>
		 mat<3, 4, T, Q> & operator+=(mat<3, 4, U, Q> const& m);
		template<typename U>
		 mat<3, 4, T, Q> & operator-=(U s);
		template<typename U>
		 mat<3, 4, T, Q> & operator-=(mat<3, 4, U, Q> const& m);
		template<typename U>
		 mat<3, 4, T, Q> & operator*=(U s);
		template<typename U>
		 mat<3, 4, T, Q> & operator/=(U s);
		 mat<3, 4, T, Q> & operator++();
		 mat<3, 4, T, Q> & operator--();
		 mat<3, 4, T, Q> operator++(int);
		 mat<3, 4, T, Q> operator--(int);
	};
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<3, 4, T, Q>::col_type operator*(mat<3, 4, T, Q> const& m, typename mat<3, 4, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<3, 4, T, Q>::row_type operator*(typename mat<3, 4, T, Q>::col_type const& v, mat<3, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1,	mat<4, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1,	mat<3, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x4.inl"
namespace glm
{
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x4.inl"
#line 23 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x4.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline mat<3, 4, T, Q>::mat(mat<3, 4, T, P> const& m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat(T scalar)
	{
		this->value[0] = col_type(scalar, 0, 0, 0);
		this->value[1] = col_type(0, scalar, 0, 0);
		this->value[2] = col_type(0, 0, scalar, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat 
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1,
		T x2, T y2, T z2, T w2
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat 
	(
		col_type const& v0,
		col_type const& v1,
		col_type const& v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}
	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3>
	 inline mat<3, 4, T, Q>::mat 
	(
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2,
		X3 x3, Y3 y3, Z3 z3, W3 w3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
	}
	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3>
	 inline mat<3, 4, T, Q>::mat 
	(
		vec<4, V1, Q> const& v1,
		vec<4, V2, Q> const& v2,
		vec<4, V3, Q> const& v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline mat<3, 4, T, Q>::mat(mat<3, 4, U, P> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 4, T, Q>::col_type & mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x4.inl", (unsigned)(180)), 0) );
		return this->value[i];
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 4, T, Q>::col_type const& mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x4.inl", (unsigned)(187)), 0) );
		return this->value[i];
	}
#line 203 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat3x4.inl"
	template<typename T, qualifier Q> 
	template<typename U> 
	 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator=(mat<3, 4, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}
	template<typename T, qualifier Q> 
	template<typename U> 
	 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}
	template<typename T, qualifier Q> 
	template<typename U> 
	 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(mat<3, 4, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(mat<3, 4, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<3, 4, T, Q> & mat<3, 4, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> mat<3, 4, T, Q>::operator++(int)
	{
		mat<3, 4, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> mat<3, 4, T, Q>::operator--(int)
	{
		mat<3, 4, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m)
	{
		return m;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m)
	{
		return mat<3, 4, T, Q>(
			-m[0],
			-m[1],
			-m[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m,	T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m)
	{
		return mat<3, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 4, T, Q>::col_type operator*
	(
		mat<3, 4, T, Q> const& m,
		typename mat<3, 4, T, Q>::row_type const& v
	)
	{
		return typename mat<3, 4, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
			m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
	}
	template<typename T, qualifier Q>
	 inline typename mat<3, 4, T, Q>::row_type operator*
	(
		typename mat<3, 4, T, Q>::col_type const& v,
		mat<3, 4, T, Q> const& m
	)
	{
		return typename mat<3, 4, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA02 = m1[0][2];
		const T SrcA03 = m1[0][3];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA12 = m1[1][2];
		const T SrcA13 = m1[1][3];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];
		const T SrcA22 = m1[2][2];
		const T SrcA23 = m1[2][3];
		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];
		const T SrcB20 = m2[2][0];
		const T SrcB21 = m2[2][1];
		const T SrcB22 = m2[2][2];
		const T SrcB30 = m2[3][0];
		const T SrcB31 = m2[3][1];
		const T SrcB32 = m2[3][2];
		mat<4, 4, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m,	T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m)
	{
		return mat<3, 4, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}
	template<typename T, qualifier Q>
	 inline bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 171 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat3x4.hpp"
#line 172 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat3x4.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat3x4.hpp"
namespace glm
{
	typedef mat<3, 4, float, lowp>		lowp_mat3x4;
	typedef mat<3, 4, float, mediump>		mediump_mat3x4;
	typedef mat<3, 4, float, highp>		highp_mat3x4;
}
#line 32 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat4x2.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat4x2.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat4x2.hpp"
#pragma once
namespace glm
{
	template<typename T, qualifier Q>
	struct mat<4, 2, T, Q>
	{
		typedef vec<2, T, Q> col_type;
		typedef vec<4, T, Q> row_type;
		typedef mat<4, 2, T, Q> type;
		typedef mat<2, 4, T, Q> transpose_type;
		typedef T value_type;
	private:
		col_type value[4];
	public:
		typedef length_t length_type;
		 static constexpr length_type length() { return 4; }
		 col_type & operator[](length_type i);
		 col_type const& operator[](length_type i) const;
		 mat() = default;
		 mat(mat<4, 2, T, Q> const& m) = default;
		template<qualifier P>
		 mat(mat<4, 2, T, P> const& m);
		 explicit mat(T scalar);
		 mat(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2,
			T x3, T y3);
		 mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);
		template<
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3,
			typename X4, typename Y4>
		 mat(
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3,
			X4 x4, Y4 y4);
		template<typename V1, typename V2, typename V3, typename V4>
		 mat(
			vec<2, V1, Q> const& v1,
			vec<2, V2, Q> const& v2,
			vec<2, V3, Q> const& v3,
			vec<2, V4, Q> const& v4);
		template<typename U, qualifier P>
		  mat(mat<4, 2, U, P> const& m);
		  mat(mat<2, 2, T, Q> const& x);
		  mat(mat<3, 3, T, Q> const& x);
		  mat(mat<4, 4, T, Q> const& x);
		  mat(mat<2, 3, T, Q> const& x);
		  mat(mat<3, 2, T, Q> const& x);
		  mat(mat<2, 4, T, Q> const& x);
		  mat(mat<4, 3, T, Q> const& x);
		  mat(mat<3, 4, T, Q> const& x);
		 mat<4, 2, T, Q> & operator=(mat<4, 2, T, Q> const& m) = default;
		template<typename U>
		 mat<4, 2, T, Q> & operator=(mat<4, 2, U, Q> const& m);
		template<typename U>
		 mat<4, 2, T, Q> & operator+=(U s);
		template<typename U>
		 mat<4, 2, T, Q> & operator+=(mat<4, 2, U, Q> const& m);
		template<typename U>
		 mat<4, 2, T, Q> & operator-=(U s);
		template<typename U>
		 mat<4, 2, T, Q> & operator-=(mat<4, 2, U, Q> const& m);
		template<typename U>
		 mat<4, 2, T, Q> & operator*=(U s);
		template<typename U>
		 mat<4, 2, T, Q> & operator/=(U s);
		 mat<4, 2, T, Q> & operator++ ();
		 mat<4, 2, T, Q> & operator-- ();
		 mat<4, 2, T, Q> operator++(int);
		 mat<4, 2, T, Q> operator--(int);
	};
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1,	mat<4, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar);
	template<typename T, qualifier Q>
	 mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m);
	template<typename T, qualifier Q>
	 bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x2.inl"
namespace glm
{
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x2.inl"
#line 24 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x2.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline mat<4, 2, T, Q>::mat(mat<4, 2, T, P> const& m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat(T scalar)
	{
		this->value[0] = col_type(scalar, 0);
		this->value[1] = col_type(0, scalar);
		this->value[2] = col_type(0, 0);
		this->value[3] = col_type(0, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2,
		T x3, T y3
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
		this->value[3] = col_type(x3, y3);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat
	(
		col_type const& v0,
		col_type const& v1,
		col_type const& v2,
		col_type const& v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}
	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3,
		typename X4, typename Y4>
	 inline mat<4, 2, T, Q>::mat
	(
		X1 x1, Y1 y1,
		X2 x2, Y2 y2,
		X3 x3, Y3 y3,
		X4 x4, Y4 y4
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4));
	}
	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3, typename V4>
	 inline mat<4, 2, T, Q>::mat
	(
		vec<2, V1, Q> const& v1,
		vec<2, V2, Q> const& v2,
		vec<2, V3, Q> const& v3,
		vec<2, V4, Q> const& v4
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline mat<4, 2, T, Q>::mat(mat<4, 2, U, P> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 2, T, Q>::col_type & mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x2.inl", (unsigned)(201)), 0) );
		return this->value[i];
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 2, T, Q>::col_type const& mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x2.inl", (unsigned)(208)), 0) );
		return this->value[i];
	}
#line 225 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x2.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 2, T, Q>& mat<4, 2, T, Q>::operator=(mat<4, 2, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(mat<4, 2, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(mat<4, 2, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> mat<4, 2, T, Q>::operator++(int)
	{
		mat<4, 2, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> mat<4, 2, T, Q>::operator--(int)
	{
		mat<4, 2, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m)
	{
		return m;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m)
	{
		return mat<4, 2, T, Q>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m)
	{
		return mat<4, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v)
	{
		return typename mat<4, 2, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m)
	{
		return typename mat<4, 2, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1],
			v.x * m[3][0] + v.y * m[3][1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];
		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];
		mat<2, 2, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m)
	{
		return mat<4, 2, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}
	template<typename T, qualifier Q>
	 inline bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 176 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat4x2.hpp"
#line 177 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat4x2.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat4x2.hpp"
namespace glm
{
	typedef mat<4, 2, float, lowp>		lowp_mat4x2;
	typedef mat<4, 2, float, mediump>		mediump_mat4x2;
	typedef mat<4, 2, float, highp>		highp_mat4x2;
}
#line 33 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat4x3.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat4x3.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat4x3.hpp"
#pragma once
namespace glm
{
	template<typename T, qualifier Q>
	struct mat<4, 3, T, Q>
	{
		typedef vec<3, T, Q> col_type;
		typedef vec<4, T, Q> row_type;
		typedef mat<4, 3, T, Q> type;
		typedef mat<3, 4, T, Q> transpose_type;
		typedef T value_type;
	private:
		col_type value[4];
	public:
		typedef length_t length_type;
		 static constexpr length_type length() { return 4; }
		 col_type & operator[](length_type i);
		 col_type const& operator[](length_type i) const;
		 mat() = default;
		 mat(mat<4, 3, T, Q> const& m) = default;
		template<qualifier P>
		 mat(mat<4, 3, T, P> const& m);
		 explicit mat(T const& x);
		 mat(
			T const& x0, T const& y0, T const& z0,
			T const& x1, T const& y1, T const& z1,
			T const& x2, T const& y2, T const& z2,
			T const& x3, T const& y3, T const& z3);
		 mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);
		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3,
			typename X4, typename Y4, typename Z4>
		 mat(
			X1 const& x1, Y1 const& y1, Z1 const& z1,
			X2 const& x2, Y2 const& y2, Z2 const& z2,
			X3 const& x3, Y3 const& y3, Z3 const& z3,
			X4 const& x4, Y4 const& y4, Z4 const& z4);
		template<typename V1, typename V2, typename V3, typename V4>
		 mat(
			vec<3, V1, Q> const& v1,
			vec<3, V2, Q> const& v2,
			vec<3, V3, Q> const& v3,
			vec<3, V4, Q> const& v4);
		template<typename U, qualifier P>
		  mat(mat<4, 3, U, P> const& m);
		  mat(mat<2, 2, T, Q> const& x);
		  mat(mat<3, 3, T, Q> const& x);
		  mat(mat<4, 4, T, Q> const& x);
		  mat(mat<2, 3, T, Q> const& x);
		  mat(mat<3, 2, T, Q> const& x);
		  mat(mat<2, 4, T, Q> const& x);
		  mat(mat<4, 2, T, Q> const& x);
		  mat(mat<3, 4, T, Q> const& x);
		 mat<4, 3, T, Q> & operator=(mat<4, 3, T, Q> const& m) = default;
		template<typename U>
		 mat<4, 3, T, Q> & operator=(mat<4, 3, U, Q> const& m);
		template<typename U>
		 mat<4, 3, T, Q> & operator+=(U s);
		template<typename U>
		 mat<4, 3, T, Q> & operator+=(mat<4, 3, U, Q> const& m);
		template<typename U>
		 mat<4, 3, T, Q> & operator-=(U s);
		template<typename U>
		 mat<4, 3, T, Q> & operator-=(mat<4, 3, U, Q> const& m);
		template<typename U>
		 mat<4, 3, T, Q> & operator*=(U s);
		template<typename U>
		 mat<4, 3, T, Q> & operator/=(U s);
		 mat<4, 3, T, Q>& operator++();
		 mat<4, 3, T, Q>& operator--();
		 mat<4, 3, T, Q> operator++(int);
		 mat<4, 3, T, Q> operator--(int);
	};
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T const& s);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T const& s);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T const& s);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator*(T const& s, mat<4, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<4, 3, T, Q>::col_type operator*(mat<4, 3, T, Q> const& m, typename mat<4, 3, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<4, 3, T, Q>::row_type operator*(typename mat<4, 3, T, Q>::col_type const& v, mat<4, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1,	mat<3, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T const& s);
	template<typename T, qualifier Q>
	 mat<4, 3, T, Q> operator/(T const& s, mat<4, 3, T, Q> const& m);
	template<typename T, qualifier Q>
	 bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x3.inl"
namespace glm
{
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x3.inl"
#line 24 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x3.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline mat<4, 3, T, Q>::mat(mat<4, 3, T, P> const& m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat(T const& s)
	{
		this->value[0] = col_type(s, 0, 0);
		this->value[1] = col_type(0, s, 0);
		this->value[2] = col_type(0, 0, s);
		this->value[3] = col_type(0, 0, 0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat
	(
		T const& x0, T const& y0, T const& z0,
		T const& x1, T const& y1, T const& z1,
		T const& x2, T const& y2, T const& z2,
		T const& x3, T const& y3, T const& z3
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
		this->value[3] = col_type(x3, y3, z3);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat
	(
		col_type const& v0,
		col_type const& v1,
		col_type const& v2,
		col_type const& v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}
	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3,
		typename X4, typename Y4, typename Z4>
	 inline mat<4, 3, T, Q>::mat
	(
		X1 const& x1, Y1 const& y1, Z1 const& z1,
		X2 const& x2, Y2 const& y2, Z2 const& z2,
		X3 const& x3, Y3 const& y3, Z3 const& z3,
		X4 const& x4, Y4 const& y4, Z4 const& z4
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4));
	}
	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3, typename V4>
	 inline mat<4, 3, T, Q>::mat
	(
		vec<3, V1, Q> const& v1,
		vec<3, V2, Q> const& v2,
		vec<3, V3, Q> const& v3,
		vec<3, V4, Q> const& v4
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline mat<4, 3, T, Q>::mat(mat<4, 3, U, P> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
		this->value[3] = col_type(m[3], 0);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 3, T, Q>::col_type & mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x3.inl", (unsigned)(201)), 0) );
		return this->value[i];
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 3, T, Q>::col_type const& mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x3.inl", (unsigned)(208)), 0) );
		return this->value[i];
	}
#line 225 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x3.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 3, T, Q>& mat<4, 3, T, Q>::operator=(mat<4, 3, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(mat<4, 3, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(mat<4, 3, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> mat<4, 3, T, Q>::operator++(int)
	{
		mat<4, 3, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> mat<4, 3, T, Q>::operator--(int)
	{
		mat<4, 3, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m)
	{
		return m;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m)
	{
		return mat<4, 3, T, Q>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T const& s)
	{
		return mat<4, 3, T, Q>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T const& s)
	{
		return mat<4, 3, T, Q>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T const& s)
	{
		return mat<4, 3, T, Q>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator*(T const& s, mat<4, 3, T, Q> const& m)
	{
		return mat<4, 3, T, Q>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 3, T, Q>::col_type operator*
	(
		mat<4, 3, T, Q> const& m,
		typename mat<4, 3, T, Q>::row_type const& v)
	{
		return typename mat<4, 3, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 3, T, Q>::row_type operator*
	(
		typename mat<4, 3, T, Q>::col_type const& v,
		mat<4, 3, T, Q> const& m)
	{
		return typename mat<4, 3, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
			v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];
		T const SrcA32 = m1[3][2];
		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];
		T const SrcB23 = m2[2][3];
		mat<3, 3, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T const& s)
	{
		return mat<4, 3, T, Q>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 3, T, Q> operator/(T const& s, mat<4, 3, T, Q> const& m)
	{
		return mat<4, 3, T, Q>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}
	template<typename T, qualifier Q>
	 inline bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 176 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat4x3.hpp"
#line 177 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat4x3.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat4x3.hpp"
namespace glm
{
	typedef mat<4, 3, float, lowp>		lowp_mat4x3;
	typedef mat<4, 3, float, mediump>		mediump_mat4x3;
	typedef mat<4, 3, float, highp>		highp_mat4x3;
}
#line 34 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat4x4.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat4x4.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat4x4.hpp"
#pragma once
namespace glm
{
	template<typename T, qualifier Q>
	struct mat<4, 4, T, Q>
	{
		typedef vec<4, T, Q> col_type;
		typedef vec<4, T, Q> row_type;
		typedef mat<4, 4, T, Q> type;
		typedef mat<4, 4, T, Q> transpose_type;
		typedef T value_type;
	private:
		col_type value[4];
	public:
		typedef length_t length_type;
		 static constexpr length_type length(){return 4;}
		 col_type & operator[](length_type i);
		 col_type const& operator[](length_type i) const;
		 mat() = default;
		 mat(mat<4, 4, T, Q> const& m) = default;
		template<qualifier P>
		 mat(mat<4, 4, T, P> const& m);
		 explicit mat(T const& x);
		 mat(
			T const& x0, T const& y0, T const& z0, T const& w0,
			T const& x1, T const& y1, T const& z1, T const& w1,
			T const& x2, T const& y2, T const& z2, T const& w2,
			T const& x3, T const& y3, T const& z3, T const& w3);
		 mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);
		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3,
			typename X4, typename Y4, typename Z4, typename W4>
		 mat(
			X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
			X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
			X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
			X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4);
		template<typename V1, typename V2, typename V3, typename V4>
		 mat(
			vec<4, V1, Q> const& v1,
			vec<4, V2, Q> const& v2,
			vec<4, V3, Q> const& v3,
			vec<4, V4, Q> const& v4);
		template<typename U, qualifier P>
		  mat(mat<4, 4, U, P> const& m);
		  mat(mat<2, 2, T, Q> const& x);
		  mat(mat<3, 3, T, Q> const& x);
		  mat(mat<2, 3, T, Q> const& x);
		  mat(mat<3, 2, T, Q> const& x);
		  mat(mat<2, 4, T, Q> const& x);
		  mat(mat<4, 2, T, Q> const& x);
		  mat(mat<3, 4, T, Q> const& x);
		  mat(mat<4, 3, T, Q> const& x);
		 mat<4, 4, T, Q> & operator=(mat<4, 4, T, Q> const& m) = default;
		template<typename U>
		 mat<4, 4, T, Q> & operator=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 mat<4, 4, T, Q> & operator+=(U s);
		template<typename U>
		 mat<4, 4, T, Q> & operator+=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 mat<4, 4, T, Q> & operator-=(U s);
		template<typename U>
		 mat<4, 4, T, Q> & operator-=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 mat<4, 4, T, Q> & operator*=(U s);
		template<typename U>
		 mat<4, 4, T, Q> & operator*=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 mat<4, 4, T, Q> & operator/=(U s);
		template<typename U>
		 mat<4, 4, T, Q> & operator/=(mat<4, 4, U, Q> const& m);
		 mat<4, 4, T, Q> & operator++();
		 mat<4, 4, T, Q> & operator--();
		 mat<4, 4, T, Q> operator++(int);
		 mat<4, 4, T, Q> operator--(int);
	};
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T const& s);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator+(T const& s, mat<4, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T const& s);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator-(T const& s, mat<4, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1,	mat<4, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T const& s);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator*(T const& s, mat<4, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<4, 4, T, Q>::col_type operator*(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<4, 4, T, Q>::row_type operator*(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T const& s);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator/(T const& s, mat<4, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);
	template<typename T, qualifier Q>
	 typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);
	template<typename T, qualifier Q>
	 mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1,	mat<4, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
	template<typename T, qualifier Q>
	 bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x4.inl"
namespace glm
{
#line 15 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x4.inl"
#line 26 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x4.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline mat<4, 4, T, Q>::mat(mat<4, 4, T, P> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat(T const& s)
	{
		this->value[0] = col_type(s, 0, 0, 0);
		this->value[1] = col_type(0, s, 0, 0);
		this->value[2] = col_type(0, 0, s, 0);
		this->value[3] = col_type(0, 0, 0, s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat
	(
		T const& x0, T const& y0, T const& z0, T const& w0,
		T const& x1, T const& y1, T const& z1, T const& w1,
		T const& x2, T const& y2, T const& z2, T const& w2,
		T const& x3, T const& y3, T const& z3, T const& w3
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
		this->value[3] = col_type(x3, y3, z3, w3);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat
	(
		col_type const& v0,
		col_type const& v1,
		col_type const& v2,
		col_type const& v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline mat<4, 4, T, Q>::mat(mat<4, 4, U, P> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}
	template<typename T, qualifier Q> 
	template<
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3,
		typename X4, typename Y4, typename Z4, typename W4>
	 inline mat<4, 4, T, Q>::mat
	(
		X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
		X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
		X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
		X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
	)
	{
		static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");
		static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
		static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
		static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
		static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");
		static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
		static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
		static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
		static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");
		static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
		static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
		static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
		static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));
	}
	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3, typename V4>
	 inline mat<4, 4, T, Q>::mat
	(
		vec<4, V1, Q> const& v1,
		vec<4, V2, Q> const& v2,
		vec<4, V3, Q> const& v3,
		vec<4, V4, Q> const& v4
	)		
	{
		static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = col_type(0, 0, 0, 1);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
		this->value[3] = col_type(m[3], 1);
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 4, T, Q>::col_type & mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x4.inl", (unsigned)(228)), 0) );
		return this->value[i];
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 4, T, Q>::col_type const& mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x4.inl", (unsigned)(235)), 0) );
		return this->value[i];
	}
#line 254 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x4.inl"
	template<typename T, qualifier Q> 
	template<typename U> 
	 inline mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator=(mat<4, 4, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(mat<4, 4, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(mat<4, 4, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(mat<4, 4, U, Q> const& m)
	{
		return (*this = *this * m);
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(mat<4, 4, U, Q> const& m)
	{
		return *this *= inverse(m);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> mat<4, 4, T, Q>::operator++(int)
	{
		mat<4, 4, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> mat<4, 4, T, Q>::operator--(int)
	{
		mat<4, 4, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m)
	{
		return m;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T const& s)
	{
		return mat<4, 4, T, Q>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator+(T const& s, mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 4, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T const& s)
	{
		return mat<4, 4, T, Q>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator-(T const& s, mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			s - m[0],
			s - m[1],
			s - m[2],
			s - m[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 4, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T const  & s)
	{
		return mat<4, 4, T, Q>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator*(T const& s, mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 4, T, Q>::col_type operator*
	(
		mat<4, 4, T, Q> const& m,
		typename mat<4, 4, T, Q>::row_type const& v
	)
	{
		typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);
		typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);
		typename mat<4, 4, T, Q>::col_type const Mul0 = m[0] * Mov0;
		typename mat<4, 4, T, Q>::col_type const Mul1 = m[1] * Mov1;
		typename mat<4, 4, T, Q>::col_type const Add0 = Mul0 + Mul1;
		typename mat<4, 4, T, Q>::col_type const Mov2(v[2]);
		typename mat<4, 4, T, Q>::col_type const Mov3(v[3]);
		typename mat<4, 4, T, Q>::col_type const Mul2 = m[2] * Mov2;
		typename mat<4, 4, T, Q>::col_type const Mul3 = m[3] * Mov3;
		typename mat<4, 4, T, Q>::col_type const Add1 = Mul2 + Mul3;
		typename mat<4, 4, T, Q>::col_type const Add2 = Add0 + Add1;
		return Add2;
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 4, T, Q>::row_type operator*
	(
		typename mat<4, 4, T, Q>::col_type const& v,
		mat<4, 4, T, Q> const& m
	)
	{
		return typename mat<4, 4, T, Q>::row_type(
			m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
			m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
			m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
			m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		typename mat<4, 4, T, Q>::col_type const SrcA0 = m1[0];
		typename mat<4, 4, T, Q>::col_type const SrcA1 = m1[1];
		typename mat<4, 4, T, Q>::col_type const SrcA2 = m1[2];
		typename mat<4, 4, T, Q>::col_type const SrcA3 = m1[3];
		typename mat<4, 4, T, Q>::col_type const SrcB0 = m2[0];
		typename mat<4, 4, T, Q>::col_type const SrcB1 = m2[1];
		typename mat<4, 4, T, Q>::col_type const SrcB2 = m2[2];
		typename mat<4, 4, T, Q>::col_type const SrcB3 = m2[3];
		mat<4, 4, T, Q> Result;
		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T const& s)
	{
		return mat<4, 4, T, Q>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator/(T const& s,	mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v)
	{
		return inverse(m) * v;
	}
	template<typename T, qualifier Q>
	 inline typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m)
	{
		return v * inverse(m);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		mat<4, 4, T, Q> m1_copy(m1);
		return m1_copy /= m2;
	}
	template<typename T, qualifier Q>
	 inline bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x4_simd.inl"
namespace glm
{
}
#line 657 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x4.inl"
#line 658 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat4x4.inl"
#line 194 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat4x4.hpp"
#line 195 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat4x4.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat4x4.hpp"
namespace glm
{
	typedef mat<4, 4, float, lowp>		lowp_mat4;
	typedef mat<4, 4, float, mediump>		mediump_mat4;
	typedef mat<4, 4, float, highp>		highp_mat4;
	typedef mat<4, 4, float, lowp>		lowp_mat4x4;
	typedef mat<4, 4, float, mediump>		mediump_mat4x4;
	typedef mat<4, 4, float, highp>		highp_mat4x4;
}
#line 35 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
namespace glm {
	namespace detail
	{
		template<typename T, qualifier Q>
		struct outerProduct_trait<2, 2, T, Q>
		{
			typedef mat<2, 2, T, Q> type;
		};
		template<typename T, qualifier Q>
		struct outerProduct_trait<2, 3, T, Q>
		{
			typedef mat<3, 2, T, Q> type;
		};
		template<typename T, qualifier Q>
		struct outerProduct_trait<2, 4, T, Q>
		{
			typedef mat<4, 2, T, Q> type;
		};
		template<typename T, qualifier Q>
		struct outerProduct_trait<3, 2, T, Q>
		{
			typedef mat<2, 3, T, Q> type;
		};
		template<typename T, qualifier Q>
		struct outerProduct_trait<3, 3, T, Q>
		{
			typedef mat<3, 3, T, Q> type;
		};
		template<typename T, qualifier Q>
		struct outerProduct_trait<3, 4, T, Q>
		{
			typedef mat<4, 3, T, Q> type;
		};
		template<typename T, qualifier Q>
		struct outerProduct_trait<4, 2, T, Q>
		{
			typedef mat<2, 4, T, Q> type;
		};
		template<typename T, qualifier Q>
		struct outerProduct_trait<4, 3, T, Q>
		{
			typedef mat<3, 4, T, Q> type;
		};
		template<typename T, qualifier Q>
		struct outerProduct_trait<4, 4, T, Q>
		{
			typedef mat<4, 4, T, Q> type;
		};
	}
	template<length_t C, length_t R, typename T, qualifier Q>
	 mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);
	template<length_t C, length_t R, typename T, qualifier Q>
	 typename detail::outerProduct_trait<C, R, T, Q>::type outerProduct(vec<C, T, Q> const& c, vec<R, T, Q> const& r);
	template<length_t C, length_t R, typename T, qualifier Q>
	 typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& x);
	template<length_t C, length_t R, typename T, qualifier Q>
	 T determinant(mat<C, R, T, Q> const& m);
	template<length_t C, length_t R, typename T, qualifier Q>
	 mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_matrix.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../geometric.hpp"
#pragma once
namespace glm
{
	template<length_t L, typename T, qualifier Q>
	 T length(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1);
	template<length_t L, typename T, qualifier Q>
	 T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<typename T, qualifier Q>
	 vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> normalize(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> faceforward(
		vec<L, T, Q> const& N,
		vec<L, T, Q> const& I,
		vec<L, T, Q> const& Nref);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> reflect(
		vec<L, T, Q> const& I,
		vec<L, T, Q> const& N);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> refract(
		vec<L, T, Q> const& I,
		vec<L, T, Q> const& N,
		T eta);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_geometric.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../exponential.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_vec1.hpp"
#line 16 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../exponential.hpp"
namespace glm
{
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> exp(vec<L, T, Q> const& v);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> log(vec<L, T, Q> const& v);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> exp2(vec<L, T, Q> const& v);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> log2(vec<L, T, Q> const& v);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> sqrt(vec<L, T, Q> const& v);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> inversesqrt(vec<L, T, Q> const& v);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_exponential.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../vector_relational.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 22 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../vector_relational.hpp"
namespace glm
{
	template<length_t L, typename T, qualifier Q>
	 vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<length_t L, qualifier Q>
	 bool any(vec<L, bool, Q> const& v);
	template<length_t L, qualifier Q>
	 bool all(vec<L, bool, Q> const& v);
	template<length_t L, qualifier Q>
	 vec<L, bool, Q> not_(vec<L, bool, Q> const& v);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_vector_relational.inl"
namespace glm
{
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_vector_relational.inl", (unsigned)(11)), 0) );
		vec<L, bool, Q> Result;
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] < y[i];
		return Result;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_vector_relational.inl", (unsigned)(23)), 0) );
		vec<L, bool, Q> Result;
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_vector_relational.inl", (unsigned)(34)), 0) );
		vec<L, bool, Q> Result;
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_vector_relational.inl", (unsigned)(45)), 0) );
		vec<L, bool, Q> Result;
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_vector_relational.inl", (unsigned)(56)), 0) );
		vec<L, bool, Q> Result;
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = detail::compute_equal<T>::call(x[i], y[i]);
		return Result;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_vector_relational.inl", (unsigned)(67)), 0) );
		vec<L, bool, Q> Result;
		for(length_t i = 0; i < x.length(); ++i)
			Result[i] = !detail::compute_equal<T>::call(x[i], y[i]);
		return Result;
	}
	template<length_t L, qualifier Q>
	 inline bool any(vec<L, bool, Q> const& v)
	{
		bool Result = false;
		for(length_t i = 0; i < v.length(); ++i)
			Result = Result || v[i];
		return Result;
	}
	template<length_t L, qualifier Q>
	 inline bool all(vec<L, bool, Q> const& v)
	{
		bool Result = true;
		for(length_t i = 0; i < v.length(); ++i)
			Result = Result && v[i];
		return Result;
	}
	template<length_t L, qualifier Q>
	 inline vec<L, bool, Q> not_(vec<L, bool, Q> const& v)
	{
		vec<L, bool, Q> Result;
		for(length_t i = 0; i < v.length(); ++i)
			Result[i] = !v[i];
		return Result;
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_vector_relational_simd.inl"
namespace glm{
namespace detail
{
}
}
#line 105 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_vector_relational.inl"
#line 106 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_vector_relational.inl"
#line 120 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../vector_relational.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_exponential.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\_vectorize.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_vec1.hpp"
#line 7 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\_vectorize.hpp"
namespace glm{
namespace detail
{
	template<length_t L, typename R, typename T, qualifier Q>
	struct functor1{};
	template<typename R, typename T, qualifier Q>
	struct functor1<1, R, T, Q>
	{
		 inline static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)
		{
			return vec<1, R, Q>(Func(v.x));
		}
	};
	template<typename R, typename T, qualifier Q>
	struct functor1<2, R, T, Q>
	{
		 inline static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)
		{
			return vec<2, R, Q>(Func(v.x), Func(v.y));
		}
	};
	template<typename R, typename T, qualifier Q>
	struct functor1<3, R, T, Q>
	{
		 inline static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)
		{
			return vec<3, R, Q>(Func(v.x), Func(v.y), Func(v.z));
		}
	};
	template<typename R, typename T, qualifier Q>
	struct functor1<4, R, T, Q>
	{
		 inline static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)
		{
			return vec<4, R, Q>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
		}
	};
	template<length_t L, typename T, qualifier Q>
	struct functor2{};
	template<typename T, qualifier Q>
	struct functor2<1, T, Q>
	{
		 inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)
		{
			return vec<1, T, Q>(Func(a.x, b.x));
		}
	};
	template<typename T, qualifier Q>
	struct functor2<2, T, Q>
	{
		 inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)
		{
			return vec<2, T, Q>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};
	template<typename T, qualifier Q>
	struct functor2<3, T, Q>
	{
		 inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)
		{
			return vec<3, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};
	template<typename T, qualifier Q>
	struct functor2<4, T, Q>
	{
		 inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};
	template<length_t L, typename T, qualifier Q>
	struct functor2_vec_sca{};
	template<typename T, qualifier Q>
	struct functor2_vec_sca<1, T, Q>
	{
		 inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)
		{
			return vec<1, T, Q>(Func(a.x, b));
		}
	};
	template<typename T, qualifier Q>
	struct functor2_vec_sca<2, T, Q>
	{
		 inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)
		{
			return vec<2, T, Q>(Func(a.x, b), Func(a.y, b));
		}
	};
	template<typename T, qualifier Q>
	struct functor2_vec_sca<3, T, Q>
	{
		 inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)
		{
			return vec<3, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
		}
	};
	template<typename T, qualifier Q>
	struct functor2_vec_sca<4, T, Q>
	{
		 inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)
		{
			return vec<4, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
		}
	};
}
}
#line 6 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_exponential.inl"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
__pragma(pack(push, 8)) extern "C" {
     void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
} __pragma(pack(pop))
#line 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_exponential.inl"
namespace glm{
namespace detail
{
		using std::log2;
#line 22 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_exponential.inl"
	template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
	struct compute_log2
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'log2' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
			return detail::functor1<L, T, T, Q>::call(log2, v);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_sqrt
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<L, T, T, Q>::call(std::sqrt, x);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_inversesqrt
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return static_cast<T>(1) / sqrt(x);
		}
	};
	template<length_t L, bool Aligned>
	struct compute_inversesqrt<L, float, lowp, Aligned>
	{
		 inline static vec<L, float, lowp> call(vec<L, float, lowp> const& x)
		{
			vec<L, float, lowp> tmp(x);
			vec<L, float, lowp> xhalf(tmp * 0.5f);
			vec<L, uint, lowp>* p = reinterpret_cast<vec<L, uint, lowp>*>(const_cast<vec<L, float, lowp>*>(&x));
			vec<L, uint, lowp> i = vec<L, uint, lowp>(0x5f375a86) - (*p >> vec<L, uint, lowp>(1));
			vec<L, float, lowp>* ptmp = reinterpret_cast<vec<L, float, lowp>*>(&i);
			tmp = *ptmp;
			tmp = tmp * (1.5f - xhalf * tmp * tmp);
			return tmp;
		}
	};
}
	using std::pow;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)
	{
		return detail::functor2<L, T, Q>::call(pow, base, exponent);
	}
	using std::exp;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> exp(vec<L, T, Q> const& x)
	{
		return detail::functor1<L, T, T, Q>::call(exp, x);
	}
	using std::log;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> log(vec<L, T, Q> const& x)
	{
		return detail::functor1<L, T, T, Q>::call(log, x);
	}
	template<typename genType>
	 inline genType exp2(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'exp2' only accept floating-point inputs");
		return std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> exp2(vec<L, T, Q> const& x)
	{
		return detail::functor1<L, T, T, Q>::call(exp2, x);
	}
	template<typename genType>
	 inline genType log2(genType x)
	{
		return log2(vec<1, genType>(x)).x;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> log2(vec<L, T, Q> const& x)
	{
		return detail::compute_log2<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
	}
	using std::sqrt;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> sqrt(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'sqrt' only accept floating-point inputs");
		return detail::compute_sqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
	template<typename genType>
	 inline genType inversesqrt(genType x)
	{
		return static_cast<genType>(1) / sqrt(x);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> inversesqrt(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'inversesqrt' only accept floating-point inputs");
		return detail::compute_inversesqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_exponential_simd.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/exponential.h"
#pragma once
 inline glm_vec4 glm_vec1_sqrt_lowp(glm_vec4 x)
{
	return _mm_mul_ss(_mm_rsqrt_ss(x), x);
}
 inline glm_vec4 glm_vec4_sqrt_lowp(glm_vec4 x)
{
	return _mm_mul_ps(_mm_rsqrt_ps(x), x);
}
#line 21 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/exponential.h"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_exponential_simd.inl"
namespace glm{
namespace detail
{
	template<qualifier Q>
	struct compute_sqrt<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& v)
		{
			vec<4, float, Q> Result;
			Result.data = _mm_sqrt_ps(v.data);
			return Result;
		}
	};
	template<>
	struct compute_sqrt<4, float, aligned_lowp, true>
	{
		 inline static vec<4, float, aligned_lowp> call(vec<4, float, aligned_lowp> const& v)
		{
			vec<4, float, aligned_lowp> Result;
			Result.data = glm_vec4_sqrt_lowp(v.data);
			return Result;
		}
	};
}
}
#line 36 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_exponential_simd.inl"
#line 147 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_exponential.inl"
#line 148 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_exponential.inl"
#line 109 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../exponential.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_geometric.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../common.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 16 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../common.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/_fixes.hpp"
#line 19 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../common.hpp"
namespace glm
{
	template<typename genType>
	 genType abs(genType x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> abs(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> sign(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> floor(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> trunc(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> round(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> roundEven(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> ceil(vec<L, T, Q> const& x);
	template<typename genType>
	 genType fract(genType x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> fract(vec<L, T, Q> const& x);
	template<typename genType>
	 genType mod(genType x, genType y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> mod(vec<L, T, Q> const& x, T y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<typename genType>
	 genType modf(genType x, genType& i);
	template<typename genType>
	 genType min(genType x, genType y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> min(vec<L, T, Q> const& x, T y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<typename genType>
	 genType max(genType x, genType y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> max(vec<L, T, Q> const& x, T y);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
	template<typename genType>
	 genType clamp(genType x, genType minVal, genType maxVal);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);
	template<typename genTypeT, typename genTypeU>
	 genTypeT mix(genTypeT x, genTypeT y, genTypeU a);
	template<length_t L, typename T, typename U, qualifier Q>
	 vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a);
	template<length_t L, typename T, typename U, qualifier Q>
	 vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a);
	template<typename genType>
	 genType step(genType edge, genType x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> step(T edge, vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x);
	template<typename genType>
	 genType smoothstep(genType edge0, genType edge1, genType x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, bool, Q> isnan(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, bool, Q> isinf(vec<L, T, Q> const& x);
	 int floatBitsToInt(float const& v);
	template<length_t L, qualifier Q>
	 vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v);
	 uint floatBitsToUint(float const& v);
	template<length_t L, qualifier Q>
	 vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v);
	 float intBitsToFloat(int const& v);
	template<length_t L, qualifier Q>
	 vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v);
	 float uintBitsToFloat(uint const& v);
	template<length_t L, qualifier Q>
	 vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v);
	template<typename genType>
	 genType fma(genType const& a, genType const& b, genType const& c);
	template<typename genType, typename genIType>
	 genType frexp(genType const& x, genIType& exp);
	template<typename genType, typename genIType>
	 genType ldexp(genType const& x, genIType const& exp);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
namespace glm
{
	template<typename genType>
	 inline genType min(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer || 0, "'min' only accept floating-point or integer inputs");
		return (y < x) ? y : x;
	}
	template<typename genType>
	 inline genType max(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer || 0, "'max' only accept floating-point or integer inputs");
		return (x < y) ? y : x;
	}
	template<>
	 inline int32 abs(int32 x)
	{
		int32 const y = x >> 31;
		return (x ^ y) - y;
	}
		using ::std::round;
#line 50 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
		using ::std::trunc;
#line 63 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
}
namespace glm{
namespace detail
{
	template<typename genFIType, bool >
	struct compute_abs
	{};
	template<typename genFIType>
	struct compute_abs<genFIType, true>
	{
		 inline static genFIType call(genFIType x)
		{
			static_assert(std::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed || 0, "'abs' only accept floating-point and integer scalar or vector inputs");
#line 81 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
			return x >= genFIType(0) ? x : -x;
		}
	};
#line 97 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
	template<typename genFIType>
	struct compute_abs<genFIType, false>
	{
		 inline static genFIType call(genFIType x)
		{
			static_assert((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer) || 0, "'abs' only accept floating-point and integer scalar or vector inputs");
#line 106 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
			return x;
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_abs_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<L, T, T, Q>::call(abs, x);
		}
	};
	template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
	struct compute_mix_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");
			return vec<L, T, Q>(vec<L, U, Q>(x) + a * vec<L, U, Q>(y - x));
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_mix_vector<L, T, bool, Q, Aligned>
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, bool, Q> const& a)
		{
			vec<L, T, Q> Result;
			for(length_t i = 0; i < x.length(); ++i)
				Result[i] = a[i] ? y[i] : x[i];
			return Result;
		}
	};
	template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
	struct compute_mix_scalar
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");
			return vec<L, T, Q>(vec<L, U, Q>(x) + a * vec<L, U, Q>(y - x));
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_mix_scalar<L, T, bool, Q, Aligned>
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, bool const& a)
		{
			return a ? y : x;
		}
	};
	template<typename T, typename U>
	struct compute_mix
	{
		 inline static T call(T const& x, T const& y, U const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");
			return static_cast<T>(static_cast<U>(x) + a * static_cast<U>(y - x));
		}
	};
	template<typename T>
	struct compute_mix<T, bool>
	{
		 inline static T call(T const& x, T const& y, bool const& a)
		{
			return a ? y : x;
		}
	};
	template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
	struct compute_sign
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return vec<L, T, Q>(glm::lessThan(vec<L, T, Q>(0), x)) - vec<L, T, Q>(glm::lessThan(x, vec<L, T, Q>(0)));
		}
	};
#line 204 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_floor
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<L, T, T, Q>::call(std::floor, x);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_ceil
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<L, T, T, Q>::call(std::ceil, x);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_fract
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return x - floor(x);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_trunc
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<L, T, T, Q>::call(trunc, x);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_round
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<L, T, T, Q>::call(round, x);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_mod
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
			return a - b * floor(a / b);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_min_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
		{
			return detail::functor2<L, T, Q>::call(min, x, y);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_max_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
		{
			return detail::functor2<L, T, Q>::call(max, x, y);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_clamp_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
		{
			return min(max(x, minVal), maxVal);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_step_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
		{
			return mix(vec<L, T, Q>(1), vec<L, T, Q>(0), glm::lessThan(x, edge));
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_smoothstep_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'step' only accept floating-point inputs");
			vec<L, T, Q> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
			return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
		}
	};
}
	template<typename genFIType>
	 inline genFIType abs(genFIType x)
	{
		return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> abs(vec<L, T, Q> const& x)
	{
		return detail::compute_abs_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
	template<typename genFIType> 
	 inline genFIType sign(genFIType x)
	{
		static_assert(std::numeric_limits<genFIType>::is_iec559 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs");
#line 328 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
		return detail::compute_sign<1, genFIType, defaultp, std::numeric_limits<genFIType>::is_iec559, highp>::call(vec<1, genFIType>(x)).x;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> sign(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs");
#line 338 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
		return detail::compute_sign<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
	}
	using ::std::floor;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> floor(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'floor' only accept floating-point inputs.");
		return detail::compute_floor<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> trunc(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'trunc' only accept floating-point inputs");
		return detail::compute_trunc<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> round(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'round' only accept floating-point inputs");
		return detail::compute_round<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
	template<typename genType>
	 inline genType roundEven(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'roundEven' only accept floating-point inputs");
		int Integer = static_cast<int>(x);
		genType IntegerPart = static_cast<genType>(Integer);
		genType FractionalPart = fract(x);
		if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
		{
			return round(x);
		}
		else if((Integer % 2) == 0)
		{
			return IntegerPart;
		}
		else if(x <= static_cast<genType>(0)) 
		{
			return IntegerPart - static_cast<genType>(1);
		}
		else
		{
			return IntegerPart + static_cast<genType>(1);
		}
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> roundEven(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'roundEven' only accept floating-point inputs");
		return detail::functor1<L, T, T, Q>::call(roundEven, x);
	}
	using ::std::ceil;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> ceil(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'ceil' only accept floating-point inputs");
		return detail::compute_ceil<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
	template<typename genType>
	 inline genType fract(genType x)
	{
		return fract(vec<1, genType>(x)).x;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> fract(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'fract' only accept floating-point inputs");
		return detail::compute_fract<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
	template<typename genType>
	 inline genType mod(genType x, genType y)
	{
#line 447 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
			return mod(vec<1, genType, defaultp>(x), y).x;
#line 449 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, T y)
	{
		return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(y));
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, y);
	}
	template<typename genType>
	 inline genType modf(genType x, genType & i)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'modf' only accept floating-point inputs");
		return std::modf(x, &i);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> modf(vec<1, T, Q> const& x, vec<1, T, Q> & i)
	{
		return vec<1, T, Q>(
			modf(x.x, i.x));
	}
	template<typename T, qualifier Q>
	 inline vec<2, T, Q> modf(vec<2, T, Q> const& x, vec<2, T, Q> & i)
	{
		return vec<2, T, Q>(
			modf(x.x, i.x),
			modf(x.y, i.y));
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> modf(vec<3, T, Q> const& x, vec<3, T, Q> & i)
	{
		return vec<3, T, Q>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z));
	}
	template<typename T, qualifier Q>
	 inline vec<4, T, Q> modf(vec<4, T, Q> const& x, vec<4, T, Q> & i)
	{
		return vec<4, T, Q>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z),
			modf(x.w, i.w));
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> min(vec<L, T, Q> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer || 0, "'min' only accept floating-point or integer inputs");
		return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
	{
		return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> max(vec<L, T, Q> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer || 0, "'max' only accept floating-point or integer inputs");
		return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> max(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
	{
		return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
	}
	template<typename genType>
	 inline genType clamp(genType x, genType minVal, genType maxVal)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer || 0, "'clamp' only accept floating-point or integer inputs");
		return min(max(x, minVal), maxVal);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer || 0, "'clamp' only accept floating-point or integer inputs");
		return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(minVal), vec<L, T, Q>(maxVal));
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer || 0, "'clamp' only accept floating-point or integer inputs");
		return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, minVal, maxVal);
	}
	template<typename genTypeT, typename genTypeU>
	 inline genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
	{
		return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
	}
	template<length_t L, typename T, typename U, qualifier Q>
	 inline vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a)
	{
		return detail::compute_mix_scalar<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
	}
	template<length_t L, typename T, typename U, qualifier Q>
	 inline vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
	{
		return detail::compute_mix_vector<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
	}
	template<typename genType>
	 inline genType step(genType edge, genType x)
	{
		return mix(static_cast<genType>(1), static_cast<genType>(0), x < edge);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> step(T edge, vec<L, T, Q> const& x)
	{
		return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge), x);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
	{
		return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge, x);
	}
	template<typename genType>
	 inline genType smoothstep(genType edge0, genType edge1, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'smoothstep' only accept floating-point inputs");
		genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
		return tmp * tmp * (genType(3) - genType(2) * tmp);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x)
	{
		return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge0), vec<L, T, Q>(edge1), x);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
	{
		return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge0, edge1, x);
	}
		using std::isnan;
#line 649 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> isnan(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");
		vec<L, bool, Q> Result;
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = glm::isnan(v[l]);
		return Result;
	}
		using std::isinf;
#line 691 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> isinf(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isinf' only accept floating-point inputs");
		vec<L, bool, Q> Result;
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = glm::isinf(v[l]);
		return Result;
	}
	 inline int floatBitsToInt(float const& v)
	{
		union
		{
			float in;
			int out;
		} u;
		u.in = v;
		return u.out;
	}
	template<length_t L, qualifier Q>
	 inline vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v)
	{
		return reinterpret_cast<vec<L, int, Q>&>(const_cast<vec<L, float, Q>&>(v));
	}
	 inline uint floatBitsToUint(float const& v)
	{
		union
		{
			float in;
			uint out;
		} u;
		u.in = v;
		return u.out;
	}
	template<length_t L, qualifier Q>
	 inline vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v)
	{
		return reinterpret_cast<vec<L, uint, Q>&>(const_cast<vec<L, float, Q>&>(v));
	}
	 inline float intBitsToFloat(int const& v)
	{
		union
		{
			int in;
			float out;
		} u;
		u.in = v;
		return u.out;
	}
	template<length_t L, qualifier Q>
	 inline vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v)
	{
		return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, int, Q>&>(v));
	}
	 inline float uintBitsToFloat(uint const& v)
	{
		union
		{
			uint in;
			float out;
		} u;
		u.in = v;
		return u.out;
	}
	template<length_t L, qualifier Q>
	 inline vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v)
	{
		return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, uint, Q>&>(v));
	}
	template<typename genType>
	 inline genType fma(genType const& a, genType const& b, genType const& c)
	{
		return a * b + c;
	}
	template<typename genType>
	 inline genType frexp(genType x, int& exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'frexp' only accept floating-point inputs");
		return std::frexp(x, &exp);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs");
		vec<L, T, Q> Result;
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = std::frexp(v[l], &exp[l]);
		return Result;
	}
	template<typename genType>
	 inline genType ldexp(genType const& x, int const& exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");
		return std::ldexp(x, exp);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");
		vec<L, T, Q> Result;
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = std::ldexp(v[l], exp[l]);
		return Result;
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_common_simd.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
#pragma once
 inline glm_vec4 glm_vec4_add(glm_vec4 a, glm_vec4 b)
{
	return _mm_add_ps(a, b);
}
 inline glm_vec4 glm_vec1_add(glm_vec4 a, glm_vec4 b)
{
	return _mm_add_ss(a, b);
}
 inline glm_vec4 glm_vec4_sub(glm_vec4 a, glm_vec4 b)
{
	return _mm_sub_ps(a, b);
}
 inline glm_vec4 glm_vec1_sub(glm_vec4 a, glm_vec4 b)
{
	return _mm_sub_ss(a, b);
}
 inline glm_vec4 glm_vec4_mul(glm_vec4 a, glm_vec4 b)
{
	return _mm_mul_ps(a, b);
}
 inline glm_vec4 glm_vec1_mul(glm_vec4 a, glm_vec4 b)
{
	return _mm_mul_ss(a, b);
}
 inline glm_vec4 glm_vec4_div(glm_vec4 a, glm_vec4 b)
{
	return _mm_div_ps(a, b);
}
 inline glm_vec4 glm_vec1_div(glm_vec4 a, glm_vec4 b)
{
	return _mm_div_ss(a, b);
}
 inline glm_vec4 glm_vec4_div_lowp(glm_vec4 a, glm_vec4 b)
{
	return glm_vec4_mul(a, _mm_rcp_ps(b));
}
 inline glm_vec4 glm_vec4_swizzle_xyzw(glm_vec4 a)
{
#line 60 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
		return _mm_shuffle_ps(a, a, (((3) << 6) | ((2) << 4) | ((1) << 2) | ((0))));
#line 62 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
}
 inline glm_vec4 glm_vec1_fma(glm_vec4 a, glm_vec4 b, glm_vec4 c)
{
#line 69 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
		return _mm_add_ss(_mm_mul_ss(a, b), c);
#line 71 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
}
 inline glm_vec4 glm_vec4_fma(glm_vec4 a, glm_vec4 b, glm_vec4 c)
{
#line 78 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
		return glm_vec4_add(glm_vec4_mul(a, b), c);
#line 80 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
}
 inline glm_vec4 glm_vec4_abs(glm_vec4 x)
{
	return _mm_and_ps(x, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));
}
 inline glm_ivec4 glm_ivec4_abs(glm_ivec4 x)
{
#line 92 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
		glm_ivec4 const sgn0 = _mm_srai_epi32(x, 31);
		glm_ivec4 const inv0 = _mm_xor_si128(x, sgn0);
		glm_ivec4 const sub0 = _mm_sub_epi32(inv0, sgn0);
		return sub0;
#line 97 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
}
 inline glm_vec4 glm_vec4_sign(glm_vec4 x)
{
	glm_vec4 const zro0 = _mm_setzero_ps();
	glm_vec4 const cmp0 = _mm_cmplt_ps(x, zro0);
	glm_vec4 const cmp1 = _mm_cmpgt_ps(x, zro0);
	glm_vec4 const and0 = _mm_and_ps(cmp0, _mm_set_ps1(-1.0f));
	glm_vec4 const and1 = _mm_and_ps(cmp1, _mm_set_ps1(1.0f));
	glm_vec4 const or0 = _mm_or_ps(and0, and1);;
	return or0;
}
 inline glm_vec4 glm_vec4_round(glm_vec4 x)
{
#line 115 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
		glm_vec4 const sgn0 = _mm_castsi128_ps(_mm_set1_epi32(int(0x80000000)));
		glm_vec4 const and0 = _mm_and_ps(sgn0, x);
		glm_vec4 const or0 = _mm_or_ps(and0, _mm_set_ps1(8388608.0f));
		glm_vec4 const add0 = glm_vec4_add(x, or0);
		glm_vec4 const sub0 = glm_vec4_sub(add0, or0);
		return sub0;
#line 122 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
}
 inline glm_vec4 glm_vec4_floor(glm_vec4 x)
{
#line 129 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
		glm_vec4 const rnd0 = glm_vec4_round(x);
		glm_vec4 const cmp0 = _mm_cmplt_ps(x, rnd0);
		glm_vec4 const and0 = _mm_and_ps(cmp0, _mm_set_ps1(1.0f));
		glm_vec4 const sub0 = glm_vec4_sub(rnd0, and0);
		return sub0;
#line 135 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
}
 inline glm_vec4 glm_vec4_roundEven(glm_vec4 x)
{
	glm_vec4 const sgn0 = _mm_castsi128_ps(_mm_set1_epi32(int(0x80000000)));
	glm_vec4 const and0 = _mm_and_ps(sgn0, x);
	glm_vec4 const or0 = _mm_or_ps(and0, _mm_set_ps1(8388608.0f));
	glm_vec4 const add0 = glm_vec4_add(x, or0);
	glm_vec4 const sub0 = glm_vec4_sub(add0, or0);
	return sub0;
}
 inline glm_vec4 glm_vec4_ceil(glm_vec4 x)
{
#line 160 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
		glm_vec4 const rnd0 = glm_vec4_round(x);
		glm_vec4 const cmp0 = _mm_cmpgt_ps(x, rnd0);
		glm_vec4 const and0 = _mm_and_ps(cmp0, _mm_set_ps1(1.0f));
		glm_vec4 const add0 = glm_vec4_add(rnd0, and0);
		return add0;
#line 166 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
}
 inline glm_vec4 glm_vec4_fract(glm_vec4 x)
{
	glm_vec4 const flr0 = glm_vec4_floor(x);
	glm_vec4 const sub0 = glm_vec4_sub(x, flr0);
	return sub0;
}
 inline glm_vec4 glm_vec4_mod(glm_vec4 x, glm_vec4 y)
{
	glm_vec4 const div0 = glm_vec4_div(x, y);
	glm_vec4 const flr0 = glm_vec4_floor(div0);
	glm_vec4 const mul0 = glm_vec4_mul(y, flr0);
	glm_vec4 const sub0 = glm_vec4_sub(x, mul0);
	return sub0;
}
 inline glm_vec4 glm_vec4_clamp(glm_vec4 v, glm_vec4 minVal, glm_vec4 maxVal)
{
	glm_vec4 const min0 = _mm_min_ps(v, maxVal);
	glm_vec4 const max0 = _mm_max_ps(min0, minVal);
	return max0;
}
 inline glm_vec4 glm_vec4_mix(glm_vec4 v1, glm_vec4 v2, glm_vec4 a)
{
	glm_vec4 const sub0 = glm_vec4_sub(_mm_set_ps1(1.0f), a);
	glm_vec4 const mul0 = glm_vec4_mul(v1, sub0);
	glm_vec4 const mad0 = glm_vec4_fma(v2, a, mul0);
	return mad0;
}
 inline glm_vec4 glm_vec4_step(glm_vec4 edge, glm_vec4 x)
{
	glm_vec4 const cmp = _mm_cmple_ps(x, edge);
	return _mm_movemask_ps(cmp) == 0 ? _mm_set_ps1(1.0f) : _mm_setzero_ps();
}
 inline glm_vec4 glm_vec4_smoothstep(glm_vec4 edge0, glm_vec4 edge1, glm_vec4 x)
{
	glm_vec4 const sub0 = glm_vec4_sub(x, edge0);
	glm_vec4 const sub1 = glm_vec4_sub(edge1, edge0);
	glm_vec4 const div0 = glm_vec4_sub(sub0, sub1);
	glm_vec4 const clp0 = glm_vec4_clamp(div0, _mm_setzero_ps(), _mm_set_ps1(1.0f));
	glm_vec4 const mul0 = glm_vec4_mul(_mm_set_ps1(2.0f), clp0);
	glm_vec4 const sub2 = glm_vec4_sub(_mm_set_ps1(3.0f), mul0);
	glm_vec4 const mul1 = glm_vec4_mul(clp0, clp0);
	glm_vec4 const mul2 = glm_vec4_mul(mul1, sub2);
	return mul2;
}
 inline glm_vec4 glm_vec4_nan(glm_vec4 x)
{
	glm_ivec4 const t1 = _mm_castps_si128(x);						
	glm_ivec4 const t2 = _mm_sll_epi32(t1, _mm_cvtsi32_si128(1));	
	glm_ivec4 const t3 = _mm_set1_epi32(int(0xFF000000));				
	glm_ivec4 const t4 = _mm_and_si128(t2, t3);						
	glm_ivec4 const t5 = _mm_andnot_si128(t3, t2);					
	glm_ivec4 const Equal = _mm_cmpeq_epi32(t3, t4);
	glm_ivec4 const Nequal = _mm_cmpeq_epi32(t5, _mm_setzero_si128());
	glm_ivec4 const And = _mm_and_si128(Equal, Nequal);
	return _mm_castsi128_ps(And);									
}
 inline glm_vec4 glm_vec4_inf(glm_vec4 x)
{
	glm_ivec4 const t1 = _mm_castps_si128(x);										
	glm_ivec4 const t2 = _mm_sll_epi32(t1, _mm_cvtsi32_si128(1));					
	return _mm_castsi128_ps(_mm_cmpeq_epi32(t2, _mm_set1_epi32(int(0xFF000000))));		
}
#line 241 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/common.h"
#line 7 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_common_simd.inl"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
#pragma once
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\wmmintrin.h"
#pragma once
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\wmmintrin.h"
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\wmmintrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
#pragma once
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
#pragma once
#line 23 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
#pragma once
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\pmmintrin.h"
#pragma once
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\pmmintrin.h"
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\pmmintrin.h"
extern "C" { 
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\pmmintrin.h"
extern __m128 _mm_addsub_ps(__m128 , __m128 );
extern __m128 _mm_hadd_ps(__m128 , __m128 );
extern __m128 _mm_hsub_ps(__m128 , __m128 );
extern __m128 _mm_movehdup_ps(__m128 );
extern __m128 _mm_moveldup_ps(__m128 );
extern __m128d _mm_addsub_pd(__m128d , __m128d );
extern __m128d _mm_hadd_pd(__m128d , __m128d );
extern __m128d _mm_hsub_pd(__m128d , __m128d );
extern __m128d _mm_loaddup_pd(double const * );
extern __m128d _mm_movedup_pd(__m128d );
extern __m128i _mm_lddqu_si128(__m128i const * );
extern void _mm_monitor(void const * , unsigned , unsigned );
extern void _mm_mwait(unsigned , unsigned );
}; 
#line 103 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\pmmintrin.h"
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\pmmintrin.h"
#line 106 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\pmmintrin.h"
#line 107 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\pmmintrin.h"
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
extern "C" {
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
    extern __m128i _mm_hadd_epi16 (__m128i, __m128i);
    extern __m128i _mm_hadd_epi32 (__m128i, __m128i);
    extern __m128i _mm_hadds_epi16 (__m128i, __m128i);
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
    extern __m128i _mm_hsub_epi16 (__m128i, __m128i);
    extern __m128i _mm_hsub_epi32 (__m128i, __m128i);
    extern __m128i _mm_hsubs_epi16 (__m128i, __m128i);
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
    extern __m128i _mm_maddubs_epi16 (__m128i, __m128i);
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
    extern __m128i _mm_mulhrs_epi16 (__m128i, __m128i);
#line 96 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
    extern __m128i _mm_shuffle_epi8 (__m128i, __m128i);
#line 105 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
    extern __m128i _mm_sign_epi8 (__m128i, __m128i);
    extern __m128i _mm_sign_epi16 (__m128i, __m128i);
    extern __m128i _mm_sign_epi32 (__m128i, __m128i);
#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
    extern __m128i _mm_alignr_epi8 (__m128i, __m128i, int);
#line 127 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
    extern __m128i _mm_abs_epi8 (__m128i);
    extern __m128i _mm_abs_epi16 (__m128i);
    extern __m128i _mm_abs_epi32 (__m128i);
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
};
#line 144 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
#line 146 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
#line 148 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\tmmintrin.h"
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
extern "C" {
#line 85 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
        extern __m128i _mm_blend_epi16 (__m128i, __m128i, const int );
        extern __m128i _mm_blendv_epi8 (__m128i, __m128i, __m128i mask);
        extern __m128  _mm_blend_ps (__m128, __m128, const int );
        extern __m128  _mm_blendv_ps(__m128, __m128, __m128 );
        extern __m128d _mm_blend_pd (__m128d, __m128d, const int );
        extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d );
        extern __m128  _mm_dp_ps(__m128, __m128, const int );
        extern __m128d _mm_dp_pd(__m128d, __m128d, const int );
        extern __m128i _mm_cmpeq_epi64(__m128i, __m128i);
        extern __m128i _mm_min_epi8 (__m128i, __m128i);
        extern __m128i _mm_max_epi8 (__m128i, __m128i);
        extern __m128i _mm_min_epu16(__m128i, __m128i);
        extern __m128i _mm_max_epu16(__m128i, __m128i);
        extern __m128i _mm_min_epi32(__m128i, __m128i);
        extern __m128i _mm_max_epi32(__m128i, __m128i);
        extern __m128i _mm_min_epu32(__m128i, __m128i);
        extern __m128i _mm_max_epu32(__m128i, __m128i);
        extern __m128i _mm_mullo_epi32(__m128i, __m128i);
        extern __m128i _mm_mul_epi32(__m128i, __m128i);
        extern int _mm_testz_si128(__m128i , __m128i );
        extern int _mm_testc_si128(__m128i , __m128i );
        extern int _mm_testnzc_si128(__m128i , __m128i );
        extern __m128 _mm_insert_ps(__m128 , __m128 , const int );
        extern int _mm_extract_ps(__m128 , const int );
        extern __m128i _mm_insert_epi8 (__m128i , int , const int );
        extern __m128i _mm_insert_epi32(__m128i , int , const int );
        extern __m128i _mm_insert_epi64(__m128i , __int64 , const int );
#line 194 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
        extern int   _mm_extract_epi8 (__m128i , const int );
        extern int   _mm_extract_epi32(__m128i , const int );
        extern __int64 _mm_extract_epi64(__m128i , const int );
#line 203 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
        extern __m128i _mm_minpos_epu16(__m128i);
        extern __m128d _mm_round_pd(__m128d , int );
        extern __m128d _mm_round_sd(__m128d , __m128d , int );
        extern __m128  _mm_round_ps(__m128  , int );
        extern __m128  _mm_round_ss(__m128 , __m128  , int );
        extern __m128i _mm_cvtepi8_epi32 (__m128i);
        extern __m128i _mm_cvtepi16_epi32(__m128i);
        extern __m128i _mm_cvtepi8_epi64 (__m128i);
        extern __m128i _mm_cvtepi32_epi64(__m128i);
        extern __m128i _mm_cvtepi16_epi64(__m128i);
        extern __m128i _mm_cvtepi8_epi16 (__m128i);
        extern __m128i _mm_cvtepu8_epi32 (__m128i);
        extern __m128i _mm_cvtepu16_epi32(__m128i);
        extern __m128i _mm_cvtepu8_epi64 (__m128i);
        extern __m128i _mm_cvtepu32_epi64(__m128i);
        extern __m128i _mm_cvtepu16_epi64(__m128i);
        extern __m128i _mm_cvtepu8_epi16 (__m128i);
        extern __m128i _mm_packus_epi32(__m128i, __m128i);
        extern __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int );
#line 256 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
        extern __m128i _mm_stream_load_si128(const __m128i*);
#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
}; 
#line 262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
#line 264 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
#line 265 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\smmintrin.h"
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
extern "C" {
#line 38 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
    extern __m128i _mm_cmpistrm (__m128i , __m128i , const int );
    extern int     _mm_cmpistri (__m128i , __m128i , const int );
    extern __m128i _mm_cmpestrm (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestri (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpistrz (__m128i , __m128i , const int );
    extern int     _mm_cmpistrc (__m128i , __m128i , const int );
    extern int     _mm_cmpistrs (__m128i , __m128i , const int );
    extern int     _mm_cmpistro (__m128i , __m128i , const int );
    extern int     _mm_cmpistra (__m128i , __m128i , const int );
    extern int     _mm_cmpestrz (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrc (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrs (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestro (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestra (__m128i , int , __m128i , int , const int );
    extern __m128i _mm_cmpgt_epi64(__m128i , __m128i );
    extern int _mm_popcnt_u32(unsigned int );
    extern __int64 _mm_popcnt_u64(unsigned __int64 );
#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
    extern unsigned int _mm_crc32_u8 (unsigned int , unsigned char );
    extern unsigned int _mm_crc32_u16(unsigned int , unsigned short );
    extern unsigned int _mm_crc32_u32(unsigned int , unsigned int );
    extern unsigned __int64 _mm_crc32_u64(unsigned __int64 , unsigned __int64 );
#line 133 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
}; 
#line 137 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
#line 141 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\nmmintrin.h"
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\wmmintrin.h"
extern "C" {
#line 37 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\wmmintrin.h"
extern __m128i _mm_aesdec_si128(__m128i , __m128i );
extern __m128i _mm_aesdeclast_si128(__m128i , __m128i );
extern __m128i _mm_aesenc_si128(__m128i , __m128i );
extern __m128i _mm_aesenclast_si128(__m128i , __m128i );
extern __m128i _mm_aesimc_si128(__m128i );
extern __m128i _mm_aeskeygenassist_si128(__m128i , const int );
extern __m128i _mm_clmulepi64_si128(__m128i , __m128i ,
                                            const int );
}; 
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\wmmintrin.h"
#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\wmmintrin.h"
#line 91 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\wmmintrin.h"
#line 92 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\wmmintrin.h"
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern "C" {
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;
typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;
typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;
extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_add_ps(__m256, __m256);
extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);
extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_and_ps(__m256, __m256);
extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);
extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);
extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);
extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);
extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_div_ps(__m256, __m256);
extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);
extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);
extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);
extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_max_ps(__m256, __m256);
extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_min_ps(__m256, __m256);
extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);
extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_or_ps(__m256, __m256);
extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);
extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);
extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);
extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);
extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);
extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);
extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);
extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);
extern int __cdecl _mm_comi_sd(__m128d, __m128d, const int);
extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);
extern int __cdecl _mm_comi_ss(__m128, __m128, const int);
extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);
extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);
extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);
extern __m256i __cdecl _mm256_cvtps_epi32(__m256);
extern __m256d __cdecl _mm256_cvtps_pd(__m128);
extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);
extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);
extern __m256i __cdecl _mm256_cvttps_epi32(__m256);
#line 614 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);
extern void __cdecl _mm256_zeroall(void);
extern void __cdecl _mm256_zeroupper(void);
extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);
extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);
extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);
extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);
extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);
extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);
extern __m256d __cdecl _mm256_broadcast_sd(double const *);
extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);
extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);
extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);
extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);
extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);
extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);
extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);
extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);
extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);
extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);
extern __m256  __cdecl _mm256_movehdup_ps(__m256);
extern __m256  __cdecl _mm256_moveldup_ps(__m256);
extern __m256d __cdecl _mm256_movedup_pd(__m256d);
extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);
extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);
extern void    __cdecl _mm256_stream_pd(double *, __m256d);
extern void    __cdecl _mm256_stream_ps(float *, __m256);
extern __m256  __cdecl _mm256_rcp_ps(__m256);
extern __m256  __cdecl _mm256_rsqrt_ps(__m256);
extern __m256d __cdecl _mm256_sqrt_pd(__m256d);
extern __m256  __cdecl _mm256_sqrt_ps(__m256);
extern __m256d __cdecl _mm256_round_pd(__m256d, int);
extern __m256  __cdecl _mm256_round_ps(__m256, int);
extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);
extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);
extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);
extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);
extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);
extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);
extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);
extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);
extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);
extern int     __cdecl _mm256_movemask_pd(__m256d);
extern int     __cdecl _mm256_movemask_ps(__m256);
extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);
extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);
extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);
extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);
extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);
extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 , const int );
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);
extern unsigned __int64 __cdecl _xgetbv(unsigned int);
extern void __cdecl _xsetbv(unsigned int, unsigned __int64);
extern void __cdecl _xsave(void *, unsigned __int64);
extern void __cdecl _xsave64(void *, unsigned __int64);
#line 1262 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern void __cdecl _xsaveopt(void *, unsigned __int64);
extern void __cdecl _xsaveopt64(void *, unsigned __int64);
#line 1272 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern void __cdecl _xsavec(void *, unsigned __int64);
extern void __cdecl _xsavec64(void *, unsigned __int64);
#line 1281 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern void __cdecl _xrstor(void const *, unsigned __int64);
extern void __cdecl _xrstor64(void const *, unsigned __int64);
#line 1291 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern void __cdecl _xsaves(void *, unsigned __int64);
extern void __cdecl _xsaves64(void *, unsigned __int64);
#line 1301 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern void __cdecl _xrstors(void const *, unsigned __int64);
extern void __cdecl _xrstors64(void const *, unsigned __int64);
#line 1311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern void __cdecl _fxsave(void *);
extern void __cdecl _fxsave64(void *);
#line 1320 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern void __cdecl _fxrstor(void const *);
extern void __cdecl _fxrstor64(void const *);
#line 1329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);
extern int __cdecl _rdrand64_step(unsigned __int64 *);
#line 1341 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern unsigned int     __cdecl _readfsbase_u32();
extern unsigned int     __cdecl _readgsbase_u32();
extern unsigned __int64 __cdecl _readfsbase_u64();
extern unsigned __int64 __cdecl _readgsbase_u64();
extern void __cdecl _writefsbase_u32(unsigned int);
extern void __cdecl _writegsbase_u32(unsigned int);
extern void __cdecl _writefsbase_u64(unsigned __int64);
extern void __cdecl _writegsbase_u64(unsigned __int64);
#line 1359 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);
extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);
extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);
extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);
extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);
extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);
extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);
extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);
extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);
extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);
extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);
extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);
extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);
extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);
extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);
extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);
extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);
extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);
extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);
extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);
extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);
extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);
extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);
extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);
extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);
extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);
extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);
extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);
extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);
extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);
extern int __cdecl _mm256_movemask_epi8(__m256i);
extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i     );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i         );
extern void __cdecl _mm_maskstore_epi32(int *   ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i   ,
                                        __m128i   );
extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i     );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i         );
extern void __cdecl _mm256_maskstore_epi32(int *   ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i   ,
                                           __m256i   );
extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);
extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);
extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);
extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);
extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d        ,
                                                double const * ,
                                                __m128i        ,
                                                __m256d        ,
                                                const int      );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m256         ,
                                                const int      );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d        ,
                                                double const * ,
                                                __m256i        ,
                                                __m256d        ,
                                                const int      );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m128         ,
                                                const int      );
extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i     ,
                                                   int const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m128i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i     ,
                                                   int     const * ,
                                                   __m256i     ,
                                                   __m128i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i         ,
                                                int const *     ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i         ,
                                                int     const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i        ,
                                           const int      );
extern __m256  __cdecl _mm256_i32gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i        ,
                                           const int      );
extern __m128  __cdecl _mm256_i64gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i32gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i64gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m256i __cdecl _mm256_i32gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i         ,
                                              const int       );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i         ,
                                              const int       );
extern __m128i __cdecl _mm_i32gather_epi32(int const *     ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi32(int     const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern unsigned int     _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int     _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int              _sarx_i32(int ,
                                  unsigned int );
extern unsigned int     _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _shrx_u32(unsigned int ,
                                          unsigned int );
extern unsigned __int64 _bextr_u64(unsigned __int64 ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned __int64 _blsi_u64(unsigned __int64);
extern unsigned __int64 _blsmsk_u64(unsigned __int64);
extern unsigned __int64 _blsr_u64(unsigned __int64);
extern unsigned __int64 _bzhi_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _mulx_u64(unsigned __int64 ,
                                  unsigned __int64 ,
                                  unsigned __int64 * );
extern unsigned __int64 _pdep_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _pext_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _rorx_u64(unsigned __int64 ,
                                  const unsigned int );
extern __int64          _sarx_i64(__int64 ,
                                  unsigned int );
extern unsigned __int64 _shlx_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _shrx_u64(unsigned __int64 ,
                                          unsigned int );
#line 1892 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern unsigned int     _lzcnt_u32(unsigned int);
extern unsigned __int64 _lzcnt_u64(unsigned __int64);
#line 1904 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern unsigned int     _tzcnt_u32(unsigned int);
extern unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 1916 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern void __cdecl _invpcid(unsigned int , void * );
extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);
extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);
extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);
extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);
extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);
extern unsigned char _interlockedbittestandset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandset_HLERelease(long *,long);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandreset_HLERelease(long *,long);
extern void _Store64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedExchangeAdd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchangeAdd64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedAnd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedAnd64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLERelease(__int64 volatile *,__int64);
extern unsigned char _interlockedbittestandset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandset64_HLERelease(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLERelease(__int64 *,__int64);
#line 1975 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern unsigned int     __cdecl _xbegin(void);
extern void             __cdecl _xend(void);
extern void             __cdecl _xabort(const unsigned int);
extern unsigned char    __cdecl _xtest(void);
extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);
extern int __cdecl _rdseed64_step(unsigned __int64 *);
#line 2003 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );
extern unsigned char __cdecl _addcarryx_u64(unsigned char ,
                                                   unsigned __int64 ,
                                                   unsigned __int64 ,
                                                   unsigned __int64 * );
#line 2025 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern unsigned short   __cdecl _load_be_u16(void const*);
extern unsigned int     __cdecl _load_be_u32(void const*);
extern unsigned __int64 __cdecl _load_be_u64(void const*);
extern void __cdecl _store_be_u16(void *, unsigned short);
extern void __cdecl _store_be_u32(void *, unsigned int);
extern void __cdecl _store_be_u64(void *, unsigned __int64);
extern __m128i __cdecl _mm_sha1msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1nexte_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1rnds4_epu32(__m128i, __m128i, const int);
extern __m128i __cdecl _mm_sha256msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i);
extern void * __cdecl _bnd_set_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_narrow_ptr_bounds(const void *, const void *, size_t);
extern void * __cdecl _bnd_copy_ptr_bounds(const void *, const void *);
extern void * __cdecl _bnd_init_ptr_bounds(const void *);
extern void __cdecl _bnd_store_ptr_bounds(const void **, const void *);
extern void __cdecl _bnd_chk_ptr_lbounds(const void *);
extern void __cdecl _bnd_chk_ptr_ubounds(const void *);
extern void __cdecl _bnd_chk_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_load_ptr_bounds(const void **, const void *);
extern const void * __cdecl _bnd_get_ptr_lbound(const void *);
extern const void * __cdecl _bnd_get_ptr_ubound(const void *);
extern __m256i __cdecl _mm256_insert_epi8 (__m256i , int , const int );
extern __m256i __cdecl _mm256_insert_epi16(__m256i , int , const int );
extern __m256i __cdecl _mm256_insert_epi32(__m256i , int , const int );
extern __m256i __cdecl _mm256_insert_epi64(__m256i , __int64 , const int );
#line 2081 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern int __cdecl _mm256_extract_epi8 (__m256i , const int );
extern int __cdecl _mm256_extract_epi16(__m256i , const int );
extern int __cdecl _mm256_extract_epi32(__m256i , const int );
extern __int64 __cdecl _mm256_extract_epi64(__m256i , const int );
#line 2089 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern __m256d __cdecl _mm256_zextpd128_pd256(__m128d);
extern __m256  __cdecl _mm256_zextps128_ps256(__m128);
extern __m256i __cdecl _mm256_zextsi128_si256(__m128i);
extern unsigned int __cdecl _rdpid_u32(void);
extern void         __cdecl _ptwrite32(unsigned int);
extern void         __cdecl _ptwrite64(unsigned __int64);
#line 2102 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern unsigned int __cdecl _pconfig_u32(const int, size_t __data[]);
extern void __cdecl _wbnoinvd(void);
extern unsigned int __cdecl _encls_u32(const int, size_t __data[]);
extern unsigned int __cdecl _enclu_u32(const int, size_t __data[]);
extern unsigned int __cdecl _enclv_u32(const int, size_t __data[]);
extern unsigned __int64 __cdecl _udiv128(unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64*);
extern __int64          __cdecl _div128(__int64, __int64, __int64, __int64*);
extern unsigned         __cdecl _udiv64(unsigned __int64, unsigned, unsigned*);
extern int              __cdecl _div64(__int64, int, int*);
extern void             __cdecl _incsspd (unsigned int);
extern unsigned int     __cdecl _rdsspd (void);
extern void             __cdecl _saveprevssp (void);
extern void             __cdecl _rstorssp (void *);
extern void             __cdecl _wrssd (unsigned int, void *);
extern void             __cdecl _wrussd (unsigned int, void *);
extern void             __cdecl _setssbsy (void);
extern void             __cdecl _clrssbsy (void *);
extern void *           __cdecl _switchssp(void *);
extern void             __cdecl _incsspq (unsigned __int64);
extern unsigned __int64 __cdecl _rdsspq (void);
extern void             __cdecl _wrssq (unsigned __int64, void *);
extern void             __cdecl _wrussq(unsigned __int64, void *);
#line 2136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
extern __m128i _mm_div_epi8(__m128i, __m128i);
extern __m128i _mm_div_epi16(__m128i, __m128i);
extern __m128i _mm_div_epi32(__m128i, __m128i);
extern __m128i _mm_div_epi64(__m128i, __m128i);
extern __m128i _mm_div_epu8(__m128i, __m128i);
extern __m128i _mm_div_epu16(__m128i, __m128i);
extern __m128i _mm_div_epu32(__m128i, __m128i);
extern __m128i _mm_div_epu64(__m128i, __m128i);
extern __m128i _mm_rem_epi8(__m128i, __m128i);
extern __m128i _mm_rem_epi16(__m128i, __m128i);
extern __m128i _mm_rem_epi32(__m128i, __m128i);
extern __m128i _mm_rem_epi64(__m128i, __m128i);
extern __m128i _mm_rem_epu8(__m128i, __m128i);
extern __m128i _mm_rem_epu16(__m128i, __m128i);
extern __m128i _mm_rem_epu32(__m128i, __m128i);
extern __m128i _mm_rem_epu64(__m128i, __m128i);
extern __m256i _mm256_div_epi8(__m256i, __m256i);
extern __m256i _mm256_div_epi16(__m256i, __m256i);
extern __m256i _mm256_div_epi32(__m256i, __m256i);
extern __m256i _mm256_div_epi64(__m256i, __m256i);
extern __m256i _mm256_div_epu8(__m256i, __m256i);
extern __m256i _mm256_div_epu16(__m256i, __m256i);
extern __m256i _mm256_div_epu32(__m256i, __m256i);
extern __m256i _mm256_div_epu64(__m256i, __m256i);
extern __m256i _mm256_rem_epi8(__m256i, __m256i);
extern __m256i _mm256_rem_epi16(__m256i, __m256i);
extern __m256i _mm256_rem_epi32(__m256i, __m256i);
extern __m256i _mm256_rem_epi64(__m256i, __m256i);
extern __m256i _mm256_rem_epu8(__m256i, __m256i);
extern __m256i _mm256_rem_epu16(__m256i, __m256i);
extern __m256i _mm256_rem_epu32(__m256i, __m256i);
extern __m256i _mm256_rem_epu64(__m256i, __m256i);
extern __m128i _mm_divrem_epi32(__m128i * , __m128i, __m128i);
extern __m128i _mm_divrem_epu32(__m128i * , __m128i, __m128i);
extern __m256i _mm256_divrem_epi32(__m256i * , __m256i, __m256i);
extern __m256i _mm256_divrem_epu32(__m256i * , __m256i, __m256i);
extern __m128  _mm_sin_ps(__m128);
extern __m128d _mm_sin_pd(__m128d);
extern __m256  _mm256_sin_ps(__m256);
extern __m256d _mm256_sin_pd(__m256d);
extern __m128  _mm_cos_ps(__m128);
extern __m128d _mm_cos_pd(__m128d);
extern __m256  _mm256_cos_ps(__m256);
extern __m256d _mm256_cos_pd(__m256d);
extern __m128  _mm_sincos_ps(__m128  * , __m128);
extern __m128d _mm_sincos_pd(__m128d * , __m128d);
extern __m256  _mm256_sincos_ps(__m256  * , __m256);
extern __m256d _mm256_sincos_pd(__m256d * , __m256d);
extern __m128  _mm_tan_ps(__m128);
extern __m128d _mm_tan_pd(__m128d);
extern __m256  _mm256_tan_ps(__m256);
extern __m256d _mm256_tan_pd(__m256d);
extern __m128  _mm_asin_ps(__m128);
extern __m128d _mm_asin_pd(__m128d);
extern __m256  _mm256_asin_ps(__m256);
extern __m256d _mm256_asin_pd(__m256d);
extern __m128  _mm_acos_ps(__m128);
extern __m128d _mm_acos_pd(__m128d);
extern __m256  _mm256_acos_ps(__m256);
extern __m256d _mm256_acos_pd(__m256d);
extern __m128  _mm_atan_ps(__m128);
extern __m128d _mm_atan_pd(__m128d);
extern __m256  _mm256_atan_ps(__m256);
extern __m256d _mm256_atan_pd(__m256d);
extern __m128  _mm_atan2_ps(__m128, __m128);
extern __m128d _mm_atan2_pd(__m128d, __m128d);
extern __m256  _mm256_atan2_ps(__m256, __m256);
extern __m256d _mm256_atan2_pd(__m256d, __m256d);
extern __m128  _mm_sind_ps(__m128);
extern __m128d _mm_sind_pd(__m128d);
extern __m256  _mm256_sind_ps(__m256);
extern __m256d _mm256_sind_pd(__m256d);
extern __m128  _mm_cosd_ps(__m128);
extern __m128d _mm_cosd_pd(__m128d);
extern __m256  _mm256_cosd_ps(__m256);
extern __m256d _mm256_cosd_pd(__m256d);
extern __m128  _mm_tand_ps(__m128);
extern __m128d _mm_tand_pd(__m128d);
extern __m256  _mm256_tand_ps(__m256);
extern __m256d _mm256_tand_pd(__m256d);
extern __m128  _mm_sinh_ps(__m128);
extern __m128d _mm_sinh_pd(__m128d);
extern __m256  _mm256_sinh_ps(__m256);
extern __m256d _mm256_sinh_pd(__m256d);
extern __m128  _mm_cosh_ps(__m128);
extern __m128d _mm_cosh_pd(__m128d);
extern __m256  _mm256_cosh_ps(__m256);
extern __m256d _mm256_cosh_pd(__m256d);
extern __m128  _mm_tanh_ps(__m128);
extern __m128d _mm_tanh_pd(__m128d);
extern __m256  _mm256_tanh_ps(__m256);
extern __m256d _mm256_tanh_pd(__m256d);
extern __m128  _mm_asinh_ps(__m128);
extern __m128d _mm_asinh_pd(__m128d);
extern __m256  _mm256_asinh_ps(__m256);
extern __m256d _mm256_asinh_pd(__m256d);
extern __m128  _mm_acosh_ps(__m128);
extern __m128d _mm_acosh_pd(__m128d);
extern __m256  _mm256_acosh_ps(__m256);
extern __m256d _mm256_acosh_pd(__m256d);
extern __m128  _mm_atanh_ps(__m128);
extern __m128d _mm_atanh_pd(__m128d);
extern __m256  _mm256_atanh_ps(__m256);
extern __m256d _mm256_atanh_pd(__m256d);
extern __m128  _mm_log_ps(__m128);
extern __m128d _mm_log_pd(__m128d);
extern __m256  _mm256_log_ps(__m256);
extern __m256d _mm256_log_pd(__m256d);
extern __m128  _mm_log1p_ps(__m128);
extern __m128d _mm_log1p_pd(__m128d);
extern __m256  _mm256_log1p_ps(__m256);
extern __m256d _mm256_log1p_pd(__m256d);
extern __m128  _mm_log10_ps(__m128);
extern __m128d _mm_log10_pd(__m128d);
extern __m256  _mm256_log10_ps(__m256);
extern __m256d _mm256_log10_pd(__m256d);
extern __m128  _mm_log2_ps(__m128);
extern __m128d _mm_log2_pd(__m128d);
extern __m256  _mm256_log2_ps(__m256);
extern __m256d _mm256_log2_pd(__m256d);
extern __m128  _mm_logb_ps(__m128);
extern __m128d _mm_logb_pd(__m128d);
extern __m256  _mm256_logb_ps(__m256);
extern __m256d _mm256_logb_pd(__m256d);
extern __m128  _mm_exp_ps(__m128);
extern __m128d _mm_exp_pd(__m128d);
extern __m256  _mm256_exp_ps(__m256);
extern __m256d _mm256_exp_pd(__m256d);
extern __m128  _mm_exp10_ps(__m128);
extern __m128d _mm_exp10_pd(__m128d);
extern __m256  _mm256_exp10_ps(__m256);
extern __m256d _mm256_exp10_pd(__m256d);
extern __m128  _mm_exp2_ps(__m128);
extern __m128d _mm_exp2_pd(__m128d);
extern __m256  _mm256_exp2_ps(__m256);
extern __m256d _mm256_exp2_pd(__m256d);
extern __m128  _mm_expm1_ps(__m128);
extern __m128d _mm_expm1_pd(__m128d);
extern __m256  _mm256_expm1_ps(__m256);
extern __m256d _mm256_expm1_pd(__m256d);
extern __m128  _mm_pow_ps(__m128, __m128);
extern __m128d _mm_pow_pd(__m128d, __m128d);
extern __m256  _mm256_pow_ps(__m256, __m256);
extern __m256d _mm256_pow_pd(__m256d, __m256d);
extern __m128  _mm_trunc_ps(__m128);
extern __m128d _mm_trunc_pd(__m128d);
extern __m256  _mm256_trunc_ps(__m256);
extern __m256d _mm256_trunc_pd(__m256d);
extern __m128  _mm_svml_floor_ps(__m128);
extern __m128d _mm_svml_floor_pd(__m128d);
extern __m256  _mm256_svml_floor_ps(__m256);
extern __m256d _mm256_svml_floor_pd(__m256d);
extern __m128  _mm_svml_ceil_ps(__m128);
extern __m128d _mm_svml_ceil_pd(__m128d);
extern __m256  _mm256_svml_ceil_ps(__m256);
extern __m256d _mm256_svml_ceil_pd(__m256d);
extern __m128  _mm_svml_round_ps(__m128);
extern __m128d _mm_svml_round_pd(__m128d);
extern __m256  _mm256_svml_round_ps(__m256);
extern __m256d _mm256_svml_round_pd(__m256d);
extern __m128  _mm_fmod_ps(__m128, __m128);
extern __m128d _mm_fmod_pd(__m128d, __m128d);
extern __m256  _mm256_fmod_ps(__m256, __m256);
extern __m256d _mm256_fmod_pd(__m256d, __m256d);
extern __m128  _mm_svml_sqrt_ps(__m128);
extern __m128d _mm_svml_sqrt_pd(__m128d);
extern __m256  _mm256_svml_sqrt_ps(__m256);
extern __m256d _mm256_svml_sqrt_pd(__m256d);
extern __m128  _mm_invsqrt_ps(__m128);
extern __m128d _mm_invsqrt_pd(__m128d);
extern __m256  _mm256_invsqrt_ps(__m256);
extern __m256d _mm256_invsqrt_pd(__m256d);
extern __m128  _mm_cbrt_ps(__m128);
extern __m128d _mm_cbrt_pd(__m128d);
extern __m256  _mm256_cbrt_ps(__m256);
extern __m256d _mm256_cbrt_pd(__m256d);
extern __m128  _mm_invcbrt_ps(__m128);
extern __m128d _mm_invcbrt_pd(__m128d);
extern __m256  _mm256_invcbrt_ps(__m256);
extern __m256d _mm256_invcbrt_pd(__m256d);
extern __m128  _mm_hypot_ps(__m128, __m128);
extern __m128d _mm_hypot_pd(__m128d, __m128d);
extern __m256  _mm256_hypot_ps(__m256, __m256);
extern __m256d _mm256_hypot_pd(__m256d, __m256d);
extern __m128  _mm_cdfnorm_ps(__m128);
extern __m128d _mm_cdfnorm_pd(__m128d);
extern __m256  _mm256_cdfnorm_ps(__m256);
extern __m256d _mm256_cdfnorm_pd(__m256d);
extern __m128  _mm_cdfnorminv_ps(__m128);
extern __m128d _mm_cdfnorminv_pd(__m128d);
extern __m256  _mm256_cdfnorminv_ps(__m256);
extern __m256d _mm256_cdfnorminv_pd(__m256d);
extern __m128  _mm_cexp_ps(__m128);
extern __m256  _mm256_cexp_ps(__m256);
extern __m128  _mm_clog_ps(__m128);
extern __m256  _mm256_clog_ps(__m256);
extern __m128  _mm_csqrt_ps(__m128);
extern __m256  _mm256_csqrt_ps(__m256);
extern __m128  _mm_erf_ps(__m128);
extern __m128d _mm_erf_pd(__m128d);
extern __m256  _mm256_erf_ps(__m256);
extern __m256d _mm256_erf_pd(__m256d);
extern __m128  _mm_erfc_ps(__m128);
extern __m128d _mm_erfc_pd(__m128d);
extern __m256  _mm256_erfc_ps(__m256);
extern __m256d _mm256_erfc_pd(__m256d);
extern __m128  _mm_erfcinv_ps(__m128);
extern __m128d _mm_erfcinv_pd(__m128d);
extern __m256  _mm256_erfcinv_ps(__m256);
extern __m256d _mm256_erfcinv_pd(__m256d);
extern __m128  _mm_erfinv_ps(__m128);
extern __m128d _mm_erfinv_pd(__m128d);
extern __m256  _mm256_erfinv_ps(__m256);
extern __m256d _mm256_erfinv_pd(__m256d);
}; 
#line 2377 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\zmmintrin.h"
typedef unsigned char       __mmask8;
typedef unsigned short      __mmask16;
typedef unsigned int        __mmask32;
typedef unsigned __int64    __mmask64;
typedef union __declspec(intrin_type) __declspec(align(64)) __m512 {
    float m512_f32[16];
} __m512;
typedef struct __declspec(intrin_type) __declspec(align(64)) __m512d {
    double m512d_f64[8];
} __m512d;
typedef union  __declspec(intrin_type) __declspec(align(64)) __m512i {
    __int8              m512i_i8[64];
    __int16             m512i_i16[32];
    __int32             m512i_i32[16];
    __int64             m512i_i64[8];
    unsigned __int8     m512i_u8[64];
    unsigned __int16    m512i_u16[32];
    unsigned __int32    m512i_u32[16];
    unsigned __int64    m512i_u64[8];
} __m512i;
extern "C" {
#line 72 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\zmmintrin.h"
extern __m256  __cdecl _mm512_castps512_ps256(__m512);
extern __m512  __cdecl _mm512_castpd_ps(__m512d);
extern __m512  __cdecl _mm512_castps256_ps512(__m256);
extern __m512  __cdecl _mm512_castsi512_ps(__m512i);
extern __m512  __cdecl _mm512_castps128_ps512(__m128);
extern __m256d __cdecl _mm512_castpd512_pd256(__m512d);
extern __m512d __cdecl _mm512_castpd256_pd512(__m256d);
extern __m512d __cdecl _mm512_castps_pd(__m512);
extern __m512d __cdecl _mm512_castsi512_pd(__m512i);
extern __m512d __cdecl _mm512_castpd128_pd512(__m128d);
extern __m256i __cdecl _mm512_castsi512_si256(__m512i);
extern __m512i __cdecl _mm512_castpd_si512(__m512d);
extern __m512i __cdecl _mm512_castps_si512(__m512);
extern __m512i __cdecl _mm512_castsi256_si512(__m256i);
typedef enum {
    _MM_BROADCAST32_NONE,   
    _MM_BROADCAST_1X16,     
    _MM_BROADCAST_4X16      
} _MM_BROADCAST32_ENUM;
typedef enum {
    _MM_BROADCAST64_NONE,   
    _MM_BROADCAST_1X8,      
    _MM_BROADCAST_4X8       
} _MM_BROADCAST64_ENUM;
typedef enum {
    _MM_ROUND_MODE_NEAREST,             
    _MM_ROUND_MODE_DOWN,                
    _MM_ROUND_MODE_UP,                  
    _MM_ROUND_MODE_TOWARD_ZERO,         
    _MM_ROUND_MODE_DEFAULT,             
    _MM_ROUND_MODE_NO_EXC = 8,          
} _MM_ROUND_MODE_ENUM;
typedef enum {
    _MM_EXPADJ_NONE,               
    _MM_EXPADJ_4,                  
    _MM_EXPADJ_5,                  
    _MM_EXPADJ_8,                  
    _MM_EXPADJ_16,                 
    _MM_EXPADJ_24,                 
    _MM_EXPADJ_31,                 
    _MM_EXPADJ_32                  
} _MM_EXP_ADJ_ENUM;
typedef enum {
    _MM_SCALE_1 = 1,
    _MM_SCALE_2 = 2,
    _MM_SCALE_4 = 4,
    _MM_SCALE_8 = 8
} _MM_INDEX_SCALE_ENUM;
typedef enum {
    _MM_PERM_AAAA = 0x00, _MM_PERM_AAAB = 0x01, _MM_PERM_AAAC = 0x02,
    _MM_PERM_AAAD = 0x03, _MM_PERM_AABA = 0x04, _MM_PERM_AABB = 0x05,
    _MM_PERM_AABC = 0x06, _MM_PERM_AABD = 0x07, _MM_PERM_AACA = 0x08,
    _MM_PERM_AACB = 0x09, _MM_PERM_AACC = 0x0A, _MM_PERM_AACD = 0x0B,
    _MM_PERM_AADA = 0x0C, _MM_PERM_AADB = 0x0D, _MM_PERM_AADC = 0x0E,
    _MM_PERM_AADD = 0x0F, _MM_PERM_ABAA = 0x10, _MM_PERM_ABAB = 0x11,
    _MM_PERM_ABAC = 0x12, _MM_PERM_ABAD = 0x13, _MM_PERM_ABBA = 0x14,
    _MM_PERM_ABBB = 0x15, _MM_PERM_ABBC = 0x16, _MM_PERM_ABBD = 0x17,
    _MM_PERM_ABCA = 0x18, _MM_PERM_ABCB = 0x19, _MM_PERM_ABCC = 0x1A,
    _MM_PERM_ABCD = 0x1B, _MM_PERM_ABDA = 0x1C, _MM_PERM_ABDB = 0x1D,
    _MM_PERM_ABDC = 0x1E, _MM_PERM_ABDD = 0x1F, _MM_PERM_ACAA = 0x20,
    _MM_PERM_ACAB = 0x21, _MM_PERM_ACAC = 0x22, _MM_PERM_ACAD = 0x23,
    _MM_PERM_ACBA = 0x24, _MM_PERM_ACBB = 0x25, _MM_PERM_ACBC = 0x26,
    _MM_PERM_ACBD = 0x27, _MM_PERM_ACCA = 0x28, _MM_PERM_ACCB = 0x29,
    _MM_PERM_ACCC = 0x2A, _MM_PERM_ACCD = 0x2B, _MM_PERM_ACDA = 0x2C,
    _MM_PERM_ACDB = 0x2D, _MM_PERM_ACDC = 0x2E, _MM_PERM_ACDD = 0x2F,
    _MM_PERM_ADAA = 0x30, _MM_PERM_ADAB = 0x31, _MM_PERM_ADAC = 0x32,
    _MM_PERM_ADAD = 0x33, _MM_PERM_ADBA = 0x34, _MM_PERM_ADBB = 0x35,
    _MM_PERM_ADBC = 0x36, _MM_PERM_ADBD = 0x37, _MM_PERM_ADCA = 0x38,
    _MM_PERM_ADCB = 0x39, _MM_PERM_ADCC = 0x3A, _MM_PERM_ADCD = 0x3B,
    _MM_PERM_ADDA = 0x3C, _MM_PERM_ADDB = 0x3D, _MM_PERM_ADDC = 0x3E,
    _MM_PERM_ADDD = 0x3F, _MM_PERM_BAAA = 0x40, _MM_PERM_BAAB = 0x41,
    _MM_PERM_BAAC = 0x42, _MM_PERM_BAAD = 0x43, _MM_PERM_BABA = 0x44,
    _MM_PERM_BABB = 0x45, _MM_PERM_BABC = 0x46, _MM_PERM_BABD = 0x47,
    _MM_PERM_BACA = 0x48, _MM_PERM_BACB = 0x49, _MM_PERM_BACC = 0x4A,
    _MM_PERM_BACD = 0x4B, _MM_PERM_BADA = 0x4C, _MM_PERM_BADB = 0x4D,
    _MM_PERM_BADC = 0x4E, _MM_PERM_BADD = 0x4F, _MM_PERM_BBAA = 0x50,
    _MM_PERM_BBAB = 0x51, _MM_PERM_BBAC = 0x52, _MM_PERM_BBAD = 0x53,
    _MM_PERM_BBBA = 0x54, _MM_PERM_BBBB = 0x55, _MM_PERM_BBBC = 0x56,
    _MM_PERM_BBBD = 0x57, _MM_PERM_BBCA = 0x58, _MM_PERM_BBCB = 0x59,
    _MM_PERM_BBCC = 0x5A, _MM_PERM_BBCD = 0x5B, _MM_PERM_BBDA = 0x5C,
    _MM_PERM_BBDB = 0x5D, _MM_PERM_BBDC = 0x5E, _MM_PERM_BBDD = 0x5F,
    _MM_PERM_BCAA = 0x60, _MM_PERM_BCAB = 0x61, _MM_PERM_BCAC = 0x62,
    _MM_PERM_BCAD = 0x63, _MM_PERM_BCBA = 0x64, _MM_PERM_BCBB = 0x65,
    _MM_PERM_BCBC = 0x66, _MM_PERM_BCBD = 0x67, _MM_PERM_BCCA = 0x68,
    _MM_PERM_BCCB = 0x69, _MM_PERM_BCCC = 0x6A, _MM_PERM_BCCD = 0x6B,
    _MM_PERM_BCDA = 0x6C, _MM_PERM_BCDB = 0x6D, _MM_PERM_BCDC = 0x6E,
    _MM_PERM_BCDD = 0x6F, _MM_PERM_BDAA = 0x70, _MM_PERM_BDAB = 0x71,
    _MM_PERM_BDAC = 0x72, _MM_PERM_BDAD = 0x73, _MM_PERM_BDBA = 0x74,
    _MM_PERM_BDBB = 0x75, _MM_PERM_BDBC = 0x76, _MM_PERM_BDBD = 0x77,
    _MM_PERM_BDCA = 0x78, _MM_PERM_BDCB = 0x79, _MM_PERM_BDCC = 0x7A,
    _MM_PERM_BDCD = 0x7B, _MM_PERM_BDDA = 0x7C, _MM_PERM_BDDB = 0x7D,
    _MM_PERM_BDDC = 0x7E, _MM_PERM_BDDD = 0x7F, _MM_PERM_CAAA = 0x80,
    _MM_PERM_CAAB = 0x81, _MM_PERM_CAAC = 0x82, _MM_PERM_CAAD = 0x83,
    _MM_PERM_CABA = 0x84, _MM_PERM_CABB = 0x85, _MM_PERM_CABC = 0x86,
    _MM_PERM_CABD = 0x87, _MM_PERM_CACA = 0x88, _MM_PERM_CACB = 0x89,
    _MM_PERM_CACC = 0x8A, _MM_PERM_CACD = 0x8B, _MM_PERM_CADA = 0x8C,
    _MM_PERM_CADB = 0x8D, _MM_PERM_CADC = 0x8E, _MM_PERM_CADD = 0x8F,
    _MM_PERM_CBAA = 0x90, _MM_PERM_CBAB = 0x91, _MM_PERM_CBAC = 0x92,
    _MM_PERM_CBAD = 0x93, _MM_PERM_CBBA = 0x94, _MM_PERM_CBBB = 0x95,
    _MM_PERM_CBBC = 0x96, _MM_PERM_CBBD = 0x97, _MM_PERM_CBCA = 0x98,
    _MM_PERM_CBCB = 0x99, _MM_PERM_CBCC = 0x9A, _MM_PERM_CBCD = 0x9B,
    _MM_PERM_CBDA = 0x9C, _MM_PERM_CBDB = 0x9D, _MM_PERM_CBDC = 0x9E,
    _MM_PERM_CBDD = 0x9F, _MM_PERM_CCAA = 0xA0, _MM_PERM_CCAB = 0xA1,
    _MM_PERM_CCAC = 0xA2, _MM_PERM_CCAD = 0xA3, _MM_PERM_CCBA = 0xA4,
    _MM_PERM_CCBB = 0xA5, _MM_PERM_CCBC = 0xA6, _MM_PERM_CCBD = 0xA7,
    _MM_PERM_CCCA = 0xA8, _MM_PERM_CCCB = 0xA9, _MM_PERM_CCCC = 0xAA,
    _MM_PERM_CCCD = 0xAB, _MM_PERM_CCDA = 0xAC, _MM_PERM_CCDB = 0xAD,
    _MM_PERM_CCDC = 0xAE, _MM_PERM_CCDD = 0xAF, _MM_PERM_CDAA = 0xB0,
    _MM_PERM_CDAB = 0xB1, _MM_PERM_CDAC = 0xB2, _MM_PERM_CDAD = 0xB3,
    _MM_PERM_CDBA = 0xB4, _MM_PERM_CDBB = 0xB5, _MM_PERM_CDBC = 0xB6,
    _MM_PERM_CDBD = 0xB7, _MM_PERM_CDCA = 0xB8, _MM_PERM_CDCB = 0xB9,
    _MM_PERM_CDCC = 0xBA, _MM_PERM_CDCD = 0xBB, _MM_PERM_CDDA = 0xBC,
    _MM_PERM_CDDB = 0xBD, _MM_PERM_CDDC = 0xBE, _MM_PERM_CDDD = 0xBF,
    _MM_PERM_DAAA = 0xC0, _MM_PERM_DAAB = 0xC1, _MM_PERM_DAAC = 0xC2,
    _MM_PERM_DAAD = 0xC3, _MM_PERM_DABA = 0xC4, _MM_PERM_DABB = 0xC5,
    _MM_PERM_DABC = 0xC6, _MM_PERM_DABD = 0xC7, _MM_PERM_DACA = 0xC8,
    _MM_PERM_DACB = 0xC9, _MM_PERM_DACC = 0xCA, _MM_PERM_DACD = 0xCB,
    _MM_PERM_DADA = 0xCC, _MM_PERM_DADB = 0xCD, _MM_PERM_DADC = 0xCE,
    _MM_PERM_DADD = 0xCF, _MM_PERM_DBAA = 0xD0, _MM_PERM_DBAB = 0xD1,
    _MM_PERM_DBAC = 0xD2, _MM_PERM_DBAD = 0xD3, _MM_PERM_DBBA = 0xD4,
    _MM_PERM_DBBB = 0xD5, _MM_PERM_DBBC = 0xD6, _MM_PERM_DBBD = 0xD7,
    _MM_PERM_DBCA = 0xD8, _MM_PERM_DBCB = 0xD9, _MM_PERM_DBCC = 0xDA,
    _MM_PERM_DBCD = 0xDB, _MM_PERM_DBDA = 0xDC, _MM_PERM_DBDB = 0xDD,
    _MM_PERM_DBDC = 0xDE, _MM_PERM_DBDD = 0xDF, _MM_PERM_DCAA = 0xE0,
    _MM_PERM_DCAB = 0xE1, _MM_PERM_DCAC = 0xE2, _MM_PERM_DCAD = 0xE3,
    _MM_PERM_DCBA = 0xE4, _MM_PERM_DCBB = 0xE5, _MM_PERM_DCBC = 0xE6,
    _MM_PERM_DCBD = 0xE7, _MM_PERM_DCCA = 0xE8, _MM_PERM_DCCB = 0xE9,
    _MM_PERM_DCCC = 0xEA, _MM_PERM_DCCD = 0xEB, _MM_PERM_DCDA = 0xEC,
    _MM_PERM_DCDB = 0xED, _MM_PERM_DCDC = 0xEE, _MM_PERM_DCDD = 0xEF,
    _MM_PERM_DDAA = 0xF0, _MM_PERM_DDAB = 0xF1, _MM_PERM_DDAC = 0xF2,
    _MM_PERM_DDAD = 0xF3, _MM_PERM_DDBA = 0xF4, _MM_PERM_DDBB = 0xF5,
    _MM_PERM_DDBC = 0xF6, _MM_PERM_DDBD = 0xF7, _MM_PERM_DDCA = 0xF8,
    _MM_PERM_DDCB = 0xF9, _MM_PERM_DDCC = 0xFA, _MM_PERM_DDCD = 0xFB,
    _MM_PERM_DDDA = 0xFC, _MM_PERM_DDDB = 0xFD, _MM_PERM_DDDC = 0xFE,
    _MM_PERM_DDDD = 0xFF
} _MM_PERM_ENUM;
typedef enum {
    _MM_FIXUP_NO_CHANGE,
    _MM_FIXUP_NEG_INF,
    _MM_FIXUP_NEG_ZERO,
    _MM_FIXUP_POS_ZERO,
    _MM_FIXUP_POS_INF,
    _MM_FIXUP_NAN,
    _MM_FIXUP_MAX_FLOAT,
    _MM_FIXUP_MIN_FLOAT
} _MM_FIXUPRESULT_ENUM;
typedef enum {
    _MM_MANT_NORM_1_2,      
    _MM_MANT_NORM_p5_2,     
    _MM_MANT_NORM_p5_1,     
    _MM_MANT_NORM_p75_1p5   
} _MM_MANTISSA_NORM_ENUM;
typedef enum {
    _MM_MANT_SIGN_src,      
    _MM_MANT_SIGN_zero,     
    _MM_MANT_SIGN_nan       
} _MM_MANTISSA_SIGN_ENUM;
typedef enum {
    _MM_CMPINT_EQ,      
    _MM_CMPINT_LT,      
    _MM_CMPINT_LE,      
    _MM_CMPINT_UNUSED,
    _MM_CMPINT_NE,      
    _MM_CMPINT_NLT,     
    _MM_CMPINT_NLE      
} _MM_CMPINT_ENUM;
extern __m512  __cdecl _mm512_setzero_ps(void);
extern __m512d __cdecl _mm512_setzero_pd(void);
extern __m512  __cdecl _mm512_set_ps(float , float, float, float, float, float, float, float, float, float, float, float, float, float, float, float );
extern __m512d __cdecl _mm512_set_pd(double , double, double, double, double, double, double, double );
extern __m512  __cdecl _mm512_set1_ps(float);
extern __m512d __cdecl _mm512_set1_pd(double);
extern __m512  __cdecl _mm512_maskz_load_ps(__mmask16, void const*);
extern __m512d __cdecl _mm512_maskz_load_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_load_ps(__m512, __mmask16, void const*);
extern __m512d __cdecl _mm512_mask_load_pd(__m512d, __mmask8, void const*);
extern __m512  __cdecl _mm512_maskz_loadu_ps(__mmask16, void const*);
extern __m512d __cdecl _mm512_maskz_loadu_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_loadu_ps(__m512, __mmask16, void const*);
extern __m512d __cdecl _mm512_mask_loadu_pd(__m512d, __mmask8, void const*);
extern void    __cdecl _mm512_storeu_ps(void*, __m512);
extern void    __cdecl _mm512_storeu_pd(void*, __m512d);
extern void    __cdecl _mm512_mask_store_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_store_pd(void*, __mmask8, __m512d);
extern void    __cdecl _mm512_mask_storeu_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_storeu_pd(void*, __mmask8, __m512d);
extern __m512  __cdecl _mm512_maskz_add_round_ps(__mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_maskz_add_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_add_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_add_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_sub_round_ps(__mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_maskz_sub_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_sub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_sub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_mul_round_ps(__mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_maskz_mul_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_mul_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_mul_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_maskz_div_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_div_round_ps(__mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_div_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_div_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_fmadd_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmadd_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmadd_round_ps(__mmask16, __m512, __m512, __m512, const int);
extern __m512d __cdecl _mm512_mask_fmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int);
extern __m512  __cdecl _mm512_mask_fmsub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmsub_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmsub_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_fmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_fmaddsub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmaddsub_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmaddsub_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_fmaddsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmaddsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmaddsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_fmsubadd_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmsubadd_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmsubadd_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_fmsubadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmsubadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmsubadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_fnmadd_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fnmadd_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fnmadd_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_fnmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fnmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fnmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_fnmsub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fnmsub_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fnmsub_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_fnmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fnmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fnmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_sqrt_round_ps(__mmask16, __m512, const int );
extern __m512d __cdecl _mm512_maskz_sqrt_round_pd(__mmask8, __m512d, const int );
extern __m512  __cdecl _mm512_mask_sqrt_round_ps(__m512, __mmask16, __m512, const int );
extern __m512d __cdecl _mm512_mask_sqrt_round_pd(__m512d, __mmask8, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_abs_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_mask_abs_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_abs_pd(__mmask8, __m512d);
extern __m512d __cdecl _mm512_mask_abs_pd(__m512d, __mmask8, __m512d);
extern __m512  __cdecl _mm512_maskz_max_round_ps(__mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_maskz_max_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_max_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_max_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_min_round_ps(__mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_maskz_min_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_min_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_min_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_rcp14_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_rcp14_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_rcp14_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_rcp14_pd(__m512d, __mmask8, __m512d);
extern __m512  __cdecl _mm512_maskz_rsqrt14_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_rsqrt14_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_rsqrt14_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_rsqrt14_pd(__m512d, __mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_rcp28_round_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_rcp28_round_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_mask_rcp28_round_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_rcp28_round_pd(__mmask8, __m512d, const int);
extern __m512  __cdecl _mm512_mask_rsqrt28_round_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_rsqrt28_round_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_mask_rsqrt28_round_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_rsqrt28_round_pd(__mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_cvt_roundps_pd(__mmask8, __m256, const int );
extern __m256  __cdecl _mm512_maskz_cvt_roundpd_ps(__mmask8, __m512d, const int );
extern __m512d __cdecl _mm512_mask_cvt_roundps_pd(__m512d, __mmask8, __m256, const int );
extern __m256  __cdecl _mm512_mask_cvt_roundpd_ps(__m256, __mmask8, __m512d, const int );
extern __mmask16 __cdecl _mm512_mask_cmp_round_ps_mask(__mmask16, __m512, __m512, const int, const int );
extern __mmask8  __cdecl _mm512_mask_cmp_round_pd_mask(__mmask8, __m512d, __m512d, const int, const int );
extern __m512  __cdecl _mm512_mask_broadcast_f32x2(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x2(__mmask16, __m128);
extern __m512  __cdecl _mm512_mask_broadcast_f32x4(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x4(__mmask16, __m128);
extern __m512  __cdecl _mm512_mask_broadcast_f32x8(__m512, __mmask16, __m256);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x8(__mmask16, __m256);
extern __m512d __cdecl _mm512_mask_broadcast_f64x2(__m512d, __mmask8, __m128d);
extern __m512d __cdecl _mm512_maskz_broadcast_f64x2(__mmask8, __m128d);
extern __m512d __cdecl _mm512_mask_broadcast_f64x4(__m512d, __mmask8, __m256d);
extern __m512d __cdecl _mm512_maskz_broadcast_f64x4(__mmask8, __m256d);
extern __m512d __cdecl _mm512_mask_broadcastsd_pd(__m512d, __mmask8, __m128d);
extern __m512d __cdecl _mm512_maskz_broadcastsd_pd(__mmask8, __m128d);
extern __m512  __cdecl _mm512_mask_broadcastss_ps(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcastss_ps(__mmask16, __m128);
extern __m128  __cdecl _mm512_mask_extractf32x4_ps(__m128, __mmask8, __m512, const int);
extern __m128  __cdecl _mm512_maskz_extractf32x4_ps(__mmask8, __m512, int);
extern __m256  __cdecl _mm512_mask_extractf32x8_ps(__m256, __mmask8, __m512, const int);
extern __m256  __cdecl _mm512_maskz_extractf32x8_ps(__mmask8, __m512, int);
extern __m128d __cdecl _mm512_mask_extractf64x2_pd(__m128d, __mmask8, __m512d, const int);
extern __m128d __cdecl _mm512_maskz_extractf64x2_pd(__mmask8, __m512d, int);
extern __m256d __cdecl _mm512_mask_extractf64x4_pd(__m256d, __mmask8, __m512d, const int);
extern __m256d __cdecl _mm512_maskz_extractf64x4_pd(__mmask8, __m512d, int);
extern __m512  __cdecl _mm512_mask_insertf32x4(__m512, __mmask16, __m512, __m128, const int);
extern __m512  __cdecl _mm512_maskz_insertf32x4(__mmask16, __m512, __m128, int);
extern __m512  __cdecl _mm512_mask_insertf32x8(__m512, __mmask16, __m512, __m256, const int);
extern __m512  __cdecl _mm512_maskz_insertf32x8(__mmask16, __m512, __m256, int);
extern __m512d __cdecl _mm512_mask_insertf64x2(__m512d, __mmask8, __m512d, __m128d, const int);
extern __m512d __cdecl _mm512_maskz_insertf64x2(__mmask8, __m512d, __m128d, int);
extern __m512d __cdecl _mm512_mask_insertf64x4(__m512d, __mmask8, __m512d, __m256d, const int);
extern __m512d __cdecl _mm512_maskz_insertf64x4(__mmask8, __m512d, __m256d, int);
extern __m512  __cdecl _mm512_mask_shuffle_f32x4(__m512, __mmask16, __m512, __m512, const int);
extern __m512  __cdecl _mm512_maskz_shuffle_f32x4(__mmask16, __m512, __m512, const int);
extern __m512d __cdecl _mm512_mask_shuffle_f64x2(__m512d, __mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_shuffle_f64x2(__mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_mask_shuffle_pd(__m512d, __mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_shuffle_pd(__mmask8, __m512d, __m512d, const int);
extern __m512  __cdecl _mm512_mask_shuffle_ps(__m512, __mmask16, __m512, __m512, const int);
extern __m512  __cdecl _mm512_maskz_shuffle_ps(__mmask16, __m512, __m512, const int);
extern __m512i __cdecl _mm512_setzero_si512(void);
extern __m512i __cdecl _mm512_set_epi8(char , char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char );
extern __m512i __cdecl _mm512_set_epi16(short , short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short );
extern __m512i __cdecl _mm512_set_epi32(int , int, int, int, int, int, int, int, int, int, int, int, int, int, int, int );
extern __m512i __cdecl _mm512_set_epi64(__int64 , __int64, __int64, __int64, __int64, __int64, __int64, __int64 );
extern __m512i __cdecl _mm512_mask_set1_epi8(__m512i, __mmask64, char);
extern __m512i __cdecl _mm512_maskz_set1_epi8(__mmask64, char);
extern __m512i __cdecl _mm512_mask_set1_epi16(__m512i, __mmask32, short);
extern __m512i __cdecl _mm512_maskz_set1_epi16(__mmask32, short);
extern __m512i __cdecl _mm512_mask_set1_epi32(__m512i, __mmask16, int);
extern __m512i __cdecl _mm512_maskz_set1_epi32(__mmask16, int);
extern __m512i __cdecl _mm512_mask_set1_epi64(__m512i, __mmask8, __int64);
extern __m512i __cdecl _mm512_maskz_set1_epi64(__mmask8, __int64);
extern __m512i __cdecl _mm512_mask_add_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_abs_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_abs_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_abs_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_abs_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi64(__mmask8, __m512i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x2(__m512i, __mmask16, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x2(__mmask16, __m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x4(__m512i, __mmask16, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x4(__mmask16, __m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x8(__m512i, __mmask16, __m256i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x8(__mmask16, __m256i);
extern __m512i  __cdecl _mm512_mask_broadcast_i64x2(__m512i, __mmask8, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i64x2(__mmask8, __m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i64x4(__m512i, __mmask8, __m256i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i64x4(__mmask8, __m256i);
extern __m512i __cdecl _mm512_mask_broadcastb_epi8(__m512i, __mmask64, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastb_epi8(__mmask64, __m128i);
extern __m512i __cdecl _mm512_mask_broadcastw_epi16(__m512i, __mmask32, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastw_epi16(__mmask32, __m128i);
extern __m512i __cdecl _mm512_mask_broadcastd_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastd_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_mask_broadcastq_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_broadcastmw_epi32(__mmask16);
extern __m512i __cdecl _mm512_broadcastmb_epi64(__mmask8);
extern __m512i __cdecl _mm512_mask_sub_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mul_epi32(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mul_epi32(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mul_epu32(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mul_epu32(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhi_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhi_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhi_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhi_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullox_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullox_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhrs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhrs_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_load_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_load_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_load_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_load_epi64(__mmask8, void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi8(__m512i, __mmask64, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi8(__mmask64, void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi16(__m512i, __mmask32, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi16(__mmask32, void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi64(__mmask8, void const*);
extern void    __cdecl _mm512_mask_store_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_mask_store_epi64(void*, __mmask8, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi8(void*, __mmask64, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi16(void*, __mmask32, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi64(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_mask_extracti32x4_epi32(__m128i, __mmask8, __m512i, int);
extern __m128i __cdecl _mm512_maskz_extracti32x4_epi32(__mmask8, __m512i, int);
extern __m256i __cdecl _mm512_mask_extracti32x8_epi32(__m256i, __mmask8, __m512i, int);
extern __m256i __cdecl _mm512_maskz_extracti32x8_epi32(__mmask8, __m512i, int);
extern __m128i __cdecl _mm512_mask_extracti64x2_epi64(__m128i, __mmask8, __m512i, int);
extern __m128i __cdecl _mm512_maskz_extracti64x2_epi64(__mmask8, __m512i, int);
extern __m256i __cdecl _mm512_mask_extracti64x4_epi64(__m256i, __mmask8, __m512i, int);
extern __m256i __cdecl _mm512_maskz_extracti64x4_epi64(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_mask_inserti32x4(__m512i, __mmask16, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_maskz_inserti32x4(__mmask16, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_mask_inserti32x8(__m512i, __mmask16, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_maskz_inserti32x8(__mmask16, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_mask_inserti64x2(__m512i, __mmask8, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_maskz_inserti64x2(__mmask8, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_mask_inserti64x4(__m512i, __mmask8, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_maskz_inserti64x4(__mmask8, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_mask_shuffle_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shuffle_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shuffle_epi32(__m512i, __mmask16, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shuffle_epi32(__mmask16, __m512i, int);
extern __m512i __cdecl _mm512_mask_shuffle_i32x4(__m512i, __mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_shuffle_i32x4(__mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_shuffle_i64x2(__m512i, __mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_shuffle_i64x2(__mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_shufflehi_epi16(__m512i, __mmask32, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shufflehi_epi16(__mmask32, __m512i, int);
extern __m512i __cdecl _mm512_mask_shufflelo_epi16(__m512i, __mmask32, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shufflelo_epi16(__mmask32, __m512i, int);
extern __m512  __cdecl _mm512_mask_mov_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_mov_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_mask_mov_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_mov_pd(__mmask8, __m512d);
extern __m512i __cdecl _mm512_mask_mov_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi64(__mmask8, __m512i);
extern __m512d __cdecl _mm512_mask_movedup_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_movedup_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_movehdup_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_movehdup_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_mask_moveldup_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_moveldup_ps(__mmask16, __m512);
extern __m512i __cdecl _mm512_movm_epi8(__mmask64);
extern __m512i __cdecl _mm512_movm_epi16(__mmask32);
extern __m512i __cdecl _mm512_movm_epi32(__mmask16);
extern __m512i __cdecl _mm512_movm_epi64(__mmask8);
extern __mmask64 __cdecl _mm512_movepi8_mask(__m512i);
extern __mmask32 __cdecl _mm512_movepi16_mask(__m512i);
extern __mmask16 __cdecl _mm512_movepi32_mask(__m512i);
extern __mmask8  __cdecl _mm512_movepi64_mask(__m512i);
extern __m512i __cdecl _mm512_mask_alignr_epi8(__m512i, __mmask64, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_alignr_epi8(__mmask64, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi32(__m512i, __mmask16, __m512i, __m512i, const int );
extern __m512i __cdecl _mm512_maskz_alignr_epi32(__mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi64(__m512i, __mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_alignr_epi64(__mmask8, __m512i, __m512i, const int);
extern __m512d __cdecl _mm512_mask_and_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_and_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_and_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_and_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_mask_and_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_and_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_and_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_and_epi64(__mmask8, __m512i, __m512i);
extern __m512d __cdecl _mm512_mask_andnot_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_andnot_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_andnot_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_andnot_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_mask_andnot_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_andnot_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_andnot_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_andnot_epi64(__mmask8, __m512i, __m512i);
extern __m512d __cdecl _mm512_mask_or_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_or_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_or_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_or_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_mask_or_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_or_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_or_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_or_epi64(__mmask8, __m512i, __m512i);
extern __m512d __cdecl _mm512_mask_xor_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_xor_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_xor_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_xor_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_mask_xor_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_xor_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_xor_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_xor_epi64(__mmask8, __m512i, __m512i);
extern __m512  __cdecl _mm512_mask_blend_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_blend_pd(__mmask8, __m512d, __m512d);
extern __m512i __cdecl _mm512_mask_blend_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sll_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sll_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sll_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_slli_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi16(__mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_slli_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_slli_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_sllv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sllv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sllv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srl_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srl_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srl_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srli_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi16(__mmask32, __m512i, int);
extern __m512i __cdecl _mm512_mask_srli_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srli_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srlv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srlv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srlv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sra_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sra_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sra_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srai_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi16(__mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srai_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srai_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srav_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srav_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srav_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_bslli_epi128(__m512i, int);
extern __m512i __cdecl _mm512_bsrli_epi128(__m512i, int);
extern __m512i __cdecl _mm512_mask_rol_epi32(__m512i, __mmask16, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_rol_epi32(__mmask16, __m512i, const int);
extern __m512i __cdecl _mm512_mask_rol_epi64(__m512i, __mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_rol_epi64(__mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_mask_rolv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rolv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rolv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rolv_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_ror_epi32(__m512i, __mmask16, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ror_epi32(__mmask16, __m512i, int);
extern __m512i __cdecl _mm512_mask_ror_epi64(__m512i, __mmask8, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ror_epi64(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_mask_rorv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rorv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rorv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rorv_epi64(__mmask8, __m512i, __m512i);
extern __m512d __cdecl _mm512_mask_unpackhi_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_unpackhi_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_unpackhi_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_unpackhi_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_unpacklo_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_unpacklo_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_unpacklo_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_unpacklo_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_mask_unpackhi_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi64(__mmask8, __m512i, __m512i);
extern __m512  __cdecl _mm512_mask_getexp_round_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_getexp_round_ps(__mmask16, __m512, int);
extern __m512d __cdecl _mm512_mask_getexp_round_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_getexp_round_pd(__mmask8, __m512d, int);
extern __m512  __cdecl _mm512_mask_getmant_round_ps(__m512, __mmask16, __m512, int, int, int);
extern __m512  __cdecl _mm512_maskz_getmant_round_ps(__mmask16, __m512, int, int, int);
extern __m512d __cdecl _mm512_mask_getmant_round_pd(__m512d, __mmask8, __m512d, int, int, int);
extern __m512d __cdecl _mm512_maskz_getmant_round_pd(__mmask8, __m512d, int, int, int);
extern __m512d __cdecl _mm512_mask_permute_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_permute_pd(__mmask8, __m512d, const int);
extern __m512  __cdecl _mm512_mask_permute_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_permute_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_mask_permutevar_pd(__m512d, __mmask8, __m512d, __m512i);
extern __m512d __cdecl _mm512_maskz_permutevar_pd(__mmask8, __m512d, __m512i);
extern __m512  __cdecl _mm512_mask_permutevar_ps(__m512, __mmask16, __m512, __m512i);
extern __m512  __cdecl _mm512_maskz_permutevar_ps(__mmask16, __m512, __m512i);
extern __m512i __cdecl _mm512_permutevar_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutevar_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512d __cdecl _mm512_mask_permutex_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_permutex_pd(__mmask8, __m512d, const int);
extern __m512i __cdecl _mm512_mask_permutex_epi64(__m512i, __mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_permutex_epi64(__mmask8, __m512i, const int);
extern __m512d __cdecl _mm512_mask_permutexvar_pd(__m512d, __mmask8, __m512i, __m512d);
extern __m512d __cdecl _mm512_maskz_permutexvar_pd(__mmask8, __m512i, __m512d);
extern __m512  __cdecl _mm512_mask_permutexvar_ps(__m512, __mmask16, __m512i, __m512);
extern __m512  __cdecl _mm512_maskz_permutexvar_ps(__mmask16, __m512i, __m512);
extern __m512i __cdecl _mm512_mask_permutexvar_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi64(__mmask8, __m512i, __m512i);
extern __m512d __cdecl _mm512_mask_permutex2var_pd(__m512d, __mmask8, __m512i , __m512d);
extern __m512d __cdecl _mm512_mask2_permutex2var_pd(__m512d, __m512i , __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_permutex2var_pd(__mmask8, __m512d, __m512i , __m512d);
extern __m512  __cdecl _mm512_mask_permutex2var_ps(__m512, __mmask16, __m512i , __m512);
extern __m512  __cdecl _mm512_mask2_permutex2var_ps(__m512, __m512i , __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_permutex2var_ps(__mmask16, __m512, __m512i , __m512);
extern __m512i __cdecl _mm512_mask_permutex2var_epi16(__m512i, __mmask32, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi16(__m512i, __m512i , __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi16(__mmask32, __m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi32(__m512i, __mmask16, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi32(__m512i, __m512i , __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi32(__mmask16, __m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi64(__m512i, __mmask8, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi64(__m512i, __m512i , __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi64(__mmask8, __m512i, __m512i , __m512i);
extern __m512d __cdecl _mm512_mask_compress_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_compress_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_compress_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_compress_ps(__mmask16, __m512);
extern __m512i __cdecl _mm512_mask_compress_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi64(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_pd(void*, __mmask8, __m512d);
extern void    __cdecl _mm512_mask_compressstoreu_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_compressstoreu_epi8(void*, __mmask64, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi16(void*, __mmask32, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi64(void*, __mmask8, __m512i);
extern __m512d __cdecl _mm512_mask_expand_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_expand_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_expand_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_expand_ps(__mmask16, __m512);
extern __m512i __cdecl _mm512_mask_expand_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi64(__mmask8, __m512i);
extern __m512d __cdecl _mm512_mask_expandloadu_pd(__m512d, __mmask8, void const*);
extern __m512d __cdecl _mm512_maskz_expandloadu_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_expandloadu_ps(__m512, __mmask16, void const*);
extern __m512  __cdecl _mm512_maskz_expandloadu_ps(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi8(__m512i, __mmask64, const void*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi8(__mmask64, const void*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi16(__m512i, __mmask32, const void*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi16(__mmask32, const void*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi64(__mmask8, void const*);
extern __m512i __cdecl _mm512_mask_ternarylogic_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi32(__mmask16, __m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_ternarylogic_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi64(__mmask8, __m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_conflict_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_conflict_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_conflict_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_conflict_epi64(__mmask8, __m512i);
extern __m512i __cdecl _mm512_mask_lzcnt_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_lzcnt_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_lzcnt_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_lzcnt_epi64(__mmask8, __m512i);
extern __m512i __cdecl _mm512_mask_avg_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_avg_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_avg_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_avg_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_sad_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dbsad_epu8(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_dbsad_epu8(__mmask32, __m512i, __m512i, int);
extern float   __cdecl _mm512_reduce_add_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_add_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_add_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_add_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_add_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_add_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_add_epi64(__mmask8, __m512i);
extern float   __cdecl _mm512_reduce_mul_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_mul_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_mul_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_mul_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_mul_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_mul_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_mul_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_mul_epi64(__mmask8, __m512i);
extern float   __cdecl _mm512_reduce_min_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_min_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_min_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_min_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_min_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_min_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_min_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_min_epi64(__mmask8, __m512i);
extern unsigned int     __cdecl _mm512_reduce_min_epu32(__m512i);
extern unsigned int     __cdecl _mm512_mask_reduce_min_epu32(__mmask16, __m512i);
extern unsigned __int64 __cdecl _mm512_reduce_min_epu64(__m512i);
extern unsigned __int64 __cdecl _mm512_mask_reduce_min_epu64(__mmask8, __m512i);
extern float   __cdecl _mm512_reduce_max_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_max_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_max_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_max_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_max_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_max_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_max_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_max_epi64(__mmask8, __m512i);
extern unsigned int     __cdecl _mm512_reduce_max_epu32(__m512i);
extern unsigned int     __cdecl _mm512_mask_reduce_max_epu32(__mmask16, __m512i);
extern unsigned __int64 __cdecl _mm512_reduce_max_epu64(__m512i);
extern unsigned __int64 __cdecl _mm512_mask_reduce_max_epu64(__mmask8, __m512i);
extern int     __cdecl _mm512_reduce_and_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_and_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_and_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_and_epi64(__mmask8, __m512i);
extern int     __cdecl _mm512_reduce_or_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_or_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_or_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_or_epi64(__mmask8, __m512i);
extern __m512d __cdecl _mm512_mask_reduce_round_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_reduce_round_pd(__mmask8, __m512d, int, int);
extern __m512  __cdecl _mm512_mask_reduce_round_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_reduce_round_ps(__mmask16, __m512, int, int);
extern __m512d __cdecl _mm512_mask_roundscale_round_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_roundscale_round_pd(__mmask8, __m512d, int, int);
extern __m512  __cdecl _mm512_mask_roundscale_round_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_roundscale_round_ps(__mmask16, __m512, int, int);
extern __m512d __cdecl _mm512_mask_scalef_round_pd(__m512d, __mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_maskz_scalef_round_pd(__mmask8, __m512d, __m512d, int);
extern __m512  __cdecl _mm512_mask_scalef_round_ps(__m512, __mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_maskz_scalef_round_ps(__mmask16, __m512, __m512, int);
extern __m512d __cdecl _mm512_mask_fixupimm_round_pd(__m512d, __mmask8, __m512d, __m512i, const int, const int);
extern __m512d __cdecl _mm512_maskz_fixupimm_round_pd(__mmask8, __m512d, __m512d, __m512i, const int, const int);
extern __m512  __cdecl _mm512_mask_fixupimm_round_ps(__m512, __mmask16, __m512, __m512i, const int, const int);
extern __m512  __cdecl _mm512_maskz_fixupimm_round_ps(__mmask16, __m512, __m512, __m512i, const int, const int);
extern void    __cdecl _mm512_stream_pd(void*, __m512d);
extern void    __cdecl _mm512_stream_ps(void*, __m512);
extern void    __cdecl _mm512_stream_si512(void*, __m512i);
extern __m512i __cdecl _mm512_stream_load_si512(void const*);
extern __m128d __cdecl _mm512_castpd512_pd128(__m512d);
extern __m128  __cdecl _mm512_castps512_ps128(__m512);
extern __m128i __cdecl _mm512_castsi512_si128(__m512i);
extern __m512i __cdecl _mm512_castsi128_si512(__m128i);
extern __m512  __cdecl _mm512_mask_exp2a23_round_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_exp2a23_round_ps(__mmask16, __m512, int);
extern __m512d __cdecl _mm512_mask_exp2a23_round_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_exp2a23_round_pd(__mmask8, __m512d, int);
extern __mmask16 __cdecl _mm512_mask_fpclass_ps_mask(__mmask16, __m512, int);
extern __mmask8  __cdecl _mm512_mask_fpclass_pd_mask(__mmask8, __m512d, int);
extern __m512d __cdecl _mm512_mask_range_round_pd(__m512d, __mmask8, __m512d, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_range_round_pd(__mmask8, __m512d, __m512d, int, int);
extern __m512  __cdecl _mm512_mask_range_round_ps(__m512, __mmask16, __m512, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_range_round_ps(__mmask16, __m512, __m512, int, int);
extern __m512i __cdecl _mm512_mask_madd_epi16(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd_epi16(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_maddubs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_maddubs_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packs_epi16(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packs_epi16(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packs_epi32(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packs_epi32(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packus_epi16(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packus_epi16(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packus_epi32(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packus_epi32(__mmask32, __m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_cmp_epi8_mask(__mmask64, __m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_epi16_mask(__mmask32, __m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_epi32_mask(__mmask16, __m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_epi64_mask(__mmask8, __m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_mask_cmp_epu8_mask(__mmask64, __m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_epu16_mask(__mmask32, __m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_epu32_mask(__mmask16, __m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_epu64_mask(__mmask8, __m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_mask_test_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask32 __cdecl _mm512_mask_test_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_testn_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask32 __cdecl _mm512_mask_testn_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask16 __cdecl _mm512_mask_test_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_test_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask16 __cdecl _mm512_mask_testn_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_testn_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask16 __cdecl _mm512_kunpackb(__mmask16, __mmask16);
extern __mmask32 __cdecl _mm512_kunpackw(__mmask32, __mmask32);
extern __mmask64 __cdecl _mm512_kunpackd(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_and_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_and_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_and_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_and_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_andn_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_andn_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_andn_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_andn_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_or_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_or_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_or_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_or_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_nor_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_nor_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_nor_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_nor_mask64(__mmask64, __mmask64);
extern __m512  __cdecl _mm512_i32gather_ps(__m512i, void const*, int);
extern __m512  __cdecl _mm512_mask_i32gather_ps(__m512, __mmask16, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_ps(void*, __m512i, __m512, int);
extern void    __cdecl _mm512_mask_i32scatter_ps(void*, __mmask16, __m512i, __m512, int);
extern __m512d __cdecl _mm512_i64gather_pd(__m512i, void const*, int);
extern __m512d __cdecl _mm512_mask_i64gather_pd(__m512d, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_pd(void*, __m512i, __m512d, int);
extern void    __cdecl _mm512_mask_i64scatter_pd(void*, __mmask8, __m512i, __m512d, int);
extern __m512d __cdecl _mm512_i32gather_pd(__m256i, void const*, int);
extern __m512d __cdecl _mm512_mask_i32gather_pd(__m512d, __mmask8, __m256i, void const*, int);
extern void    __cdecl _mm512_i32scatter_pd(void*, __m256i, __m512d, int);
extern void    __cdecl _mm512_mask_i32scatter_pd(void*, __mmask8, __m256i, __m512d, int);
extern __m512i __cdecl _mm512_i32gather_epi32(__m512i, void const*, int);
extern __m512i __cdecl _mm512_mask_i32gather_epi32(__m512i, __mmask16, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_epi32(void*, __m512i, __m512i, int);
extern void    __cdecl _mm512_mask_i32scatter_epi32(void*, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_i32gather_epi64(__m256i, void const*, int);
extern __m512i __cdecl _mm512_mask_i32gather_epi64(__m512i, __mmask8, __m256i, void const*, int);
extern __m512i __cdecl _mm512_i64gather_epi64(__m512i, void const*, int);
extern __m512i __cdecl _mm512_mask_i64gather_epi64(__m512i, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_epi64(void*, __m256i, __m512i, int);
extern void    __cdecl _mm512_mask_i32scatter_epi64(void*, __mmask8, __m256i, __m512i, int);
extern void    __cdecl _mm512_i64scatter_epi64(void*, __m512i, __m512i, int);
extern void    __cdecl _mm512_mask_i64scatter_epi64(void*, __mmask8, __m512i, __m512i, int);
extern __m256  __cdecl _mm512_i64gather_ps(__m512i, void const*, int);
extern __m256  __cdecl _mm512_mask_i64gather_ps(__m256, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_ps(void*, __m512i, __m256, int);
extern void    __cdecl _mm512_mask_i64scatter_ps(void*, __mmask8, __m512i, __m256, int);
extern __m256i __cdecl _mm512_i64gather_epi32(__m512i, void const*, int);
extern __m256i __cdecl _mm512_mask_i64gather_epi32(__m256i, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_epi32(void*, __m512i, __m256i, int);
extern void    __cdecl _mm512_mask_i64scatter_epi32(void*, __mmask8, __m512i, __m256i, int);
extern void __cdecl _mm512_prefetch_i32gather_pd(__m256i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32gather_ps(__m512i index, void const* mv, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32scatter_pd(void* base_addr, __m256i vindex, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32scatter_ps(void* mv, __m512i index, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64gather_pd(__m512i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64gather_ps(__m512i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64scatter_pd(void* base_addr, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64scatter_ps(void* base_addr, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32gather_pd(__m256i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32gather_ps(__m512i vindex, __mmask16 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32scatter_pd(void* base_addr, __mmask8 mask, __m256i vinde, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32scatter_ps(void* mv, __mmask16 k, __m512i index, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64gather_pd(__m512i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64gather_ps(__m512i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64scatter_pd(void* base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64scatter_ps(void* base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint);
extern __m512d __cdecl _mm512_cvtpslo_pd(__m512);
extern __m512d __cdecl _mm512_mask_cvtpslo_pd(__m512d, __mmask8, __m512);
extern __m512d __cdecl _mm512_cvtepi32lo_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepi32lo_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_cvtepu32lo_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepu32lo_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_mask_cvtepi32_pd(__m512d, __mmask8, __m256i);
extern __m512d __cdecl _mm512_maskz_cvtepi32_pd(__mmask8, __m256i);
extern __m512d __cdecl _mm512_mask_cvtepu32_pd(__m512d, __mmask8, __m256i);
extern __m512d __cdecl _mm512_maskz_cvtepu32_pd(__mmask8, __m256i);
extern __m512  __cdecl _mm512_mask_cvt_roundepi32_ps(__m512, __mmask16, __m512i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundepi32_ps(__mmask16, __m512i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundepu32_ps(__m512, __mmask16, __m512i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundepu32_ps(__mmask16, __m512i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundph_ps(__m512, __mmask16, __m256i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundph_ps(__mmask16, __m256i, int);
extern __m256i __cdecl _mm512_mask_cvt_roundps_ph(__m256i, __mmask16, __m512, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundps_ph(__mmask16, __m512, int);
extern __m256  __cdecl _mm512_mask_cvt_roundepi64_ps(__m256, __mmask8, __m512i, int);
extern __m256  __cdecl _mm512_maskz_cvt_roundepi64_ps(__mmask8, __m512i, int);
extern __m256  __cdecl _mm512_mask_cvt_roundepu64_ps(__m256, __mmask8, __m512i, int);
extern __m256  __cdecl _mm512_maskz_cvt_roundepu64_ps(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_mask_cvtepi16_epi32(__m512i, __mmask16, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi32(__mmask16, __m256i);
extern __m512i __cdecl _mm512_mask_cvtepi16_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m128i __cdecl _mm512_mask_cvtepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_mask_cvtepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_cvtepi32_epi64(__m512i, __mmask8, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi32_epi64(__mmask8, __m256i);
extern __m128i __cdecl _mm512_mask_cvtepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_mask_cvtepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_mask_cvtepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_mask_cvtepu16_epi32(__m512i, __mmask16, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi32(__mmask16, __m256i);
extern __m512i __cdecl _mm512_mask_cvtepu16_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_mask_cvtepu32_epi64(__m512i, __mmask8, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu32_epi64(__mmask8, __m256i);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu32(__mmask16, __m512, int);
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epi32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epi32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epi32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epi32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epu32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epu32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epu32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epu32(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi16(__m512i, __mmask32, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi16(__mmask32, __m256i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi16(__m512i, __mmask32, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi16(__mmask32, __m256i);
extern __m256i __cdecl _mm512_mask_cvtepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtepi16_storeu_epi8(void*, __mmask32, __m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi16_storeu_epi8(void*, __mmask32, __m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi16_storeu_epi8(void*, __mmask32, __m512i);
extern __m512d __cdecl _mm512_mask_cvt_roundepi64_pd(__m512d, __mmask8, __m512i, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundepi64_pd(__mmask8, __m512i, int);
extern __m512d __cdecl _mm512_mask_cvt_roundepu64_pd(__m512d, __mmask8, __m512i, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundepu64_pd(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epi64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epi64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epu64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epu64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epi64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epi64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epu64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epu64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu64(__mmask8, __m256, int);
extern __m128i   __cdecl _mm_mask_abs_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_abs_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_abs_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_abs_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_abs_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_abs_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_abs_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_add_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_add_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_add_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_add_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_add_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_add_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_add_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_add_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_adds_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_alignr_epi32(__m128i, __m128i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi32(__m128i, __mmask8, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi32(__mmask8, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_alignr_epi32(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi32(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi32(__mmask8, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_alignr_epi64(__m128i, __m128i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi64(__m128i, __mmask8, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi64(__mmask8, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_alignr_epi64(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi64(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi64(__mmask8, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi8(__m128i, __mmask16, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi8(__mmask16, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi8(__m256i, __mmask32, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi8(__mmask32, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_mask_and_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_and_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_and_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_and_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_and_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_and_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_and_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_and_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_and_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_and_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_and_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_and_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_and_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_and_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_and_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_and_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_andnot_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_andnot_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_andnot_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_andnot_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_andnot_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_andnot_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_andnot_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_andnot_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_andnot_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_andnot_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_andnot_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_andnot_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_andnot_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_andnot_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_andnot_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_andnot_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_avg_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_avg_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_avg_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_avg_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_avg_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_avg_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_avg_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_avg_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_blend_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_blend_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_blend_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_blend_ps(__mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_broadcast_f32x2(__m128);
extern __m256    __cdecl _mm256_mask_broadcast_f32x2(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcast_f32x2(__mmask8, __m128);
extern __m256    __cdecl _mm256_broadcast_f32x4(__m128);
extern __m256    __cdecl _mm256_mask_broadcast_f32x4(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcast_f32x4(__mmask8, __m128);
extern __m256d   __cdecl _mm256_broadcast_f64x2(__m128d);
extern __m256d   __cdecl _mm256_mask_broadcast_f64x2(__m256d, __mmask8, __m128d);
extern __m256d   __cdecl _mm256_maskz_broadcast_f64x2(__mmask8, __m128d);
extern __m128i   __cdecl _mm_broadcast_i32x2(__m128i);
extern __m128i   __cdecl _mm_mask_broadcast_i32x2(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcast_i32x2(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i32x2(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i32x2(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i32x2(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i32x4(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i32x4(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i32x4(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i64x2(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i64x2(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i64x2(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_broadcastb_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastb_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastb_epi8(__m256i, __mmask32, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastb_epi8(__mmask32, __m128i);
extern __m128i   __cdecl _mm_mask_broadcastd_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastd_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastd_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastd_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_broadcastmb_epi64(__mmask8);
extern __m256i   __cdecl _mm256_broadcastmb_epi64(__mmask8);
extern __m128i   __cdecl _mm_broadcastmw_epi32(__mmask16);
extern __m256i   __cdecl _mm256_broadcastmw_epi32(__mmask16);
extern __m128i   __cdecl _mm_mask_broadcastq_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastq_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_broadcastsd_pd(__m256d, __mmask8, __m128d);
extern __m256d   __cdecl _mm256_maskz_broadcastsd_pd(__mmask8, __m128d);
extern __m128    __cdecl _mm_mask_broadcastss_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_broadcastss_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_broadcastss_ps(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcastss_ps(__mmask8, __m128);
extern __m128i   __cdecl _mm_mask_broadcastw_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastw_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastw_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastw_epi16(__mmask16, __m128i);
extern __mmask8  __cdecl _mm_cmp_epi16_mask(__m128i, __m128i, const int);
extern __mmask8  __cdecl _mm_mask_cmp_epi16_mask(__mmask8, __m128i, __m128i, const int);
extern __mmask16 __cdecl _mm256_cmp_epi16_mask(__m256i, __m256i, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_epi16_mask(__mmask16, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epi32_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epi32_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epi32_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epi32_mask(__mmask8, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_cmp_epi64_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epi64_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epi64_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epi64_mask(__mmask8, __m256i, __m256i, int);
extern __mmask16 __cdecl _mm_cmp_epi8_mask(__m128i, __m128i, const int);
extern __mmask16 __cdecl _mm_mask_cmp_epi8_mask(__mmask16, __m128i, __m128i, const int);
extern __mmask32 __cdecl _mm256_cmp_epi8_mask(__m256i, __m256i, const int);
extern __mmask32 __cdecl _mm256_mask_cmp_epi8_mask(__mmask32, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epu16_mask(__m128i, __m128i, const int);
extern __mmask8  __cdecl _mm_mask_cmp_epu16_mask(__mmask8, __m128i, __m128i, const int);
extern __mmask16 __cdecl _mm256_cmp_epu16_mask(__m256i, __m256i, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_epu16_mask(__mmask16, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epu32_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epu32_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epu32_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epu32_mask(__mmask8, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_cmp_epu64_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epu64_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epu64_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epu64_mask(__mmask8, __m256i, __m256i, int);
extern __mmask16 __cdecl _mm_cmp_epu8_mask(__m128i, __m128i, const int);
extern __mmask16 __cdecl _mm_mask_cmp_epu8_mask(__mmask16, __m128i, __m128i, const int);
extern __mmask32 __cdecl _mm256_cmp_epu8_mask(__m256i, __m256i, const int);
extern __mmask32 __cdecl _mm256_mask_cmp_epu8_mask(__mmask32, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_pd_mask(__m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_mask_cmp_pd_mask(__mmask8, __m128d, __m128d, const int);
extern __mmask8  __cdecl _mm256_cmp_pd_mask(__m256d, __m256d, const int);
extern __mmask8  __cdecl _mm256_mask_cmp_pd_mask(__mmask8, __m256d, __m256d, const int);
extern __mmask8  __cdecl _mm_cmp_ps_mask(__m128, __m128, const int);
extern __mmask8  __cdecl _mm_mask_cmp_ps_mask(__mmask8, __m128, __m128, const int);
extern __mmask8  __cdecl _mm256_cmp_ps_mask(__m256, __m256, const int);
extern __mmask8  __cdecl _mm256_mask_cmp_ps_mask(__mmask8, __m256, __m256, const int);
extern __m128i   __cdecl _mm_mask_compress_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi64(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_compress_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_compress_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_compress_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_compress_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_compress_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_compress_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_compress_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_compress_ps(__mmask8, __m256);
extern void      __cdecl _mm_mask_compressstoreu_epi8(void*, __mmask16, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi8(void*, __mmask32, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi16(void*, __mmask16, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_compressstoreu_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_compressstoreu_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_compressstoreu_ps(void*, __mmask8, __m256);
extern __m128i   __cdecl _mm_conflict_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_conflict_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_conflict_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_conflict_epi32(__m256i);
extern __m256i   __cdecl _mm256_mask_conflict_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_conflict_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_conflict_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_conflict_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_conflict_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_conflict_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_conflict_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_conflict_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvt_roundps_ph(__m128i, __mmask8, __m128, int);
extern __m128i   __cdecl _mm_maskz_cvt_roundps_ph(__mmask8, __m128, int);
extern __m128i   __cdecl _mm256_mask_cvt_roundps_ph(__m128i, __mmask8, __m256, int);
extern __m128i   __cdecl _mm256_maskz_cvt_roundps_ph(__mmask8, __m256, int);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi16_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi16_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi16_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi32_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi32_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi32_epi8(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_cvtepi32_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepi32_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_cvtepi32_pd(__m256d, __mmask8, __m128i);
extern __m256d   __cdecl _mm256_maskz_cvtepi32_pd(__mmask8, __m128i);
extern __m128    __cdecl _mm_mask_cvtepi32_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepi32_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_mask_cvtepi32_ps(__m256, __mmask8, __m256i);
extern __m256    __cdecl _mm256_maskz_cvtepi32_ps(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi8(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_cvtepi64_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepi64_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_cvtepi64_pd(__m256d, __mmask8, __m256i);
extern __m256d   __cdecl _mm256_maskz_cvtepi64_pd(__mmask8, __m256i);
extern __m128    __cdecl _mm_mask_cvtepi64_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepi64_ps(__mmask8, __m128i);
extern __m128    __cdecl _mm256_mask_cvtepi64_ps(__m128, __mmask8, __m256i);
extern __m128    __cdecl _mm256_maskz_cvtepi64_ps(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi16(__mmask16, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu16_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu16_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu16_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu16_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu16_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu16_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu32_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu32_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu32_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu32_epi64(__mmask8, __m128i);
extern __m128d   __cdecl _mm_mask_cvtepu32_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepu32_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_cvtepu32_pd(__m256d, __mmask8, __m128i);
extern __m256d   __cdecl _mm256_maskz_cvtepu32_pd(__mmask8, __m128i);
extern __m128d   __cdecl _mm_mask_cvtepu64_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepu64_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_cvtepu64_pd(__m256d, __mmask8, __m256i);
extern __m256d   __cdecl _mm256_maskz_cvtepu64_pd(__mmask8, __m256i);
extern __m128    __cdecl _mm_mask_cvtepu64_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepu64_ps(__mmask8, __m128i);
extern __m128    __cdecl _mm256_mask_cvtepu64_ps(__m128, __mmask8, __m256i);
extern __m128    __cdecl _mm256_maskz_cvtepu64_ps(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi16(__mmask16, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtpd_epi32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epi32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvtpd_epi32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvtpd_epi32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvtpd_epi64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epi64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_mask_cvtpd_epi64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvtpd_epi64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvtpd_epu32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epu32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvtpd_epu32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvtpd_epu32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvtpd_epu64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epu64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_mask_cvtpd_epu64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvtpd_epu64(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_cvtpd_ps(__m128, __mmask8, __m128d);
extern __m128    __cdecl _mm_maskz_cvtpd_ps(__mmask8, __m128d);
extern __m128    __cdecl _mm256_mask_cvtpd_ps(__m128, __mmask8, __m256d);
extern __m128    __cdecl _mm256_maskz_cvtpd_ps(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_cvtph_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtph_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_mask_cvtph_ps(__m256, __mmask8, __m128i);
extern __m256    __cdecl _mm256_maskz_cvtph_ps(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtps_epi32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epi32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epi32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvtps_epi32(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_cvtps_epi64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epi64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epi64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvtps_epi64(__mmask8, __m128);
extern __m128i   __cdecl _mm_mask_cvtps_epu32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epu32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epu32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvtps_epu32(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_cvtps_epu64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epu64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epu64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvtps_epu64(__mmask8, __m128);
extern __m128i   __cdecl _mm_mask_cvtsepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtsepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtsepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_cvtsepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtsepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtsepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtsepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi32_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvttpd_epi32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epi32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvttpd_epi32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvttpd_epi32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvttpd_epi64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epi64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_mask_cvttpd_epi64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvttpd_epi64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvttpd_epu32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epu32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvttpd_epu32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvttpd_epu32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvttpd_epu64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epu64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_mask_cvttpd_epu64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvttpd_epu64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvttps_epi32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epi32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epi32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvttps_epi32(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_cvttps_epi64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epi64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epi64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvttps_epi64(__mmask8, __m128);
extern __m128i   __cdecl _mm_mask_cvttps_epu32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epu32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epu32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvttps_epu32(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_cvttps_epu64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epu64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epu64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvttps_epu64(__mmask8, __m128);
extern __m128i   __cdecl _mm_mask_cvtusepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtusepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtusepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_cvtusepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtusepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtusepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtusepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi32_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_dbsad_epu8(__m128i, __m128i, int);
extern __m128i   __cdecl _mm_mask_dbsad_epu8(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_dbsad_epu8(__mmask8, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_dbsad_epu8(__m256i, __m256i, int);
extern __m256i   __cdecl _mm256_mask_dbsad_epu8(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_dbsad_epu8(__mmask16, __m256i, __m256i, int);
extern __m128d   __cdecl _mm_mask_div_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_div_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_div_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_div_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_div_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_div_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_div_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_div_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_expand_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi64(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_expand_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_expand_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_expand_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_expand_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_expand_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_expand_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_expand_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_expand_ps(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_expandloadu_epi8(__m128i, __mmask16, const void*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi8(__mmask16, const void*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi8(__m256i, __mmask32, const void*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi8(__mmask32, const void*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi16(__m128i, __mmask8, const void*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi16(__mmask8, const void*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi16(__m256i, __mmask16, const void*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi16(__mmask16, const void*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi64(__mmask8, void const*);
extern __m128d   __cdecl _mm_mask_expandloadu_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_expandloadu_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_expandloadu_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_expandloadu_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_expandloadu_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_expandloadu_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_expandloadu_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_expandloadu_ps(__mmask8, void const*);
extern __m128    __cdecl _mm256_extractf32x4_ps(__m256, int);
extern __m128    __cdecl _mm256_mask_extractf32x4_ps(__m128, __mmask8, __m256, int);
extern __m128    __cdecl _mm256_maskz_extractf32x4_ps(__mmask8, __m256, int);
extern __m128d   __cdecl _mm256_extractf64x2_pd(__m256d, int);
extern __m128d   __cdecl _mm256_mask_extractf64x2_pd(__m128d, __mmask8, __m256d, int);
extern __m128d   __cdecl _mm256_maskz_extractf64x2_pd(__mmask8, __m256d, int);
extern __m128i   __cdecl _mm256_extracti32x4_epi32(__m256i, int);
extern __m128i   __cdecl _mm256_mask_extracti32x4_epi32(__m128i, __mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_maskz_extracti32x4_epi32(__mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_extracti64x2_epi64(__m256i, int);
extern __m128i   __cdecl _mm256_mask_extracti64x2_epi64(__m128i, __mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_maskz_extracti64x2_epi64(__mmask8, __m256i, int);
extern __m128d   __cdecl _mm_fixupimm_pd(__m128d, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_mask_fixupimm_pd(__m128d, __mmask8, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_pd(__mmask8, __m128d, __m128d, __m128i, const int);
extern __m256d   __cdecl _mm256_fixupimm_pd(__m256d, __m256d, __m256i, const int);
extern __m256d   __cdecl _mm256_mask_fixupimm_pd(__m256d, __mmask8, __m256d, __m256i, const int);
extern __m256d   __cdecl _mm256_maskz_fixupimm_pd(__mmask8, __m256d, __m256d, __m256i, const int);
extern __m128    __cdecl _mm_fixupimm_ps(__m128, __m128, __m128i, const int);
extern __m128    __cdecl _mm_mask_fixupimm_ps(__m128, __mmask8, __m128, __m128i, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_ps(__mmask8, __m128, __m128, __m128i, const int);
extern __m256    __cdecl _mm256_fixupimm_ps(__m256, __m256, __m256i, const int);
extern __m256    __cdecl _mm256_mask_fixupimm_ps(__m256, __mmask8, __m256, __m256i, const int);
extern __m256    __cdecl _mm256_maskz_fixupimm_ps(__mmask8, __m256, __m256, __m256i, const int);
extern __m128d   __cdecl _mm_mask_fmadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmaddsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmaddsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmaddsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmaddsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmaddsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmaddsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmaddsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmaddsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmaddsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmaddsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmaddsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmaddsub_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmsub_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmsubadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsubadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsubadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmsubadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmsubadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmsubadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmsubadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsubadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsubadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmsubadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmsubadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmsubadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fnmadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fnmadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fnmadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fnmadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fnmadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fnmadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fnmadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fnmadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fnmsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fnmsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fnmsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fnmsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fnmsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fnmsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fnmsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fnmsub_ps(__mmask8, __m256, __m256, __m256);
extern __mmask8  __cdecl _mm_fpclass_pd_mask(__m128d, int);
extern __mmask8  __cdecl _mm_mask_fpclass_pd_mask(__mmask8, __m128d, int);
extern __mmask8  __cdecl _mm256_fpclass_pd_mask(__m256d, int);
extern __mmask8  __cdecl _mm256_mask_fpclass_pd_mask(__mmask8, __m256d, int);
extern __mmask8  __cdecl _mm_fpclass_ps_mask(__m128, int);
extern __mmask8  __cdecl _mm_mask_fpclass_ps_mask(__mmask8, __m128, int);
extern __mmask8  __cdecl _mm256_fpclass_ps_mask(__m256, int);
extern __mmask8  __cdecl _mm256_mask_fpclass_ps_mask(__mmask8, __m256, int);
extern __m128d   __cdecl _mm_getexp_pd(__m128d);
extern __m128d   __cdecl _mm_mask_getexp_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_getexp_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_getexp_pd(__m256d);
extern __m256d   __cdecl _mm256_mask_getexp_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_getexp_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_getexp_ps(__m128);
extern __m128    __cdecl _mm_mask_getexp_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_getexp_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_getexp_ps(__m256);
extern __m256    __cdecl _mm256_mask_getexp_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_getexp_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_getmant_pd(__m128d, int, int);
extern __m128d   __cdecl _mm_mask_getmant_pd(__m128d, __mmask8, __m128d, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_pd(__mmask8, __m128d, int, int);
extern __m256d   __cdecl _mm256_getmant_pd(__m256d, int, int);
extern __m256d   __cdecl _mm256_mask_getmant_pd(__m256d, __mmask8, __m256d, int, int);
extern __m256d   __cdecl _mm256_maskz_getmant_pd(__mmask8, __m256d, int, int);
extern __m128    __cdecl _mm_getmant_ps(__m128, int, int);
extern __m128    __cdecl _mm_mask_getmant_ps(__m128, __mmask8, __m128, int, int);
extern __m128    __cdecl _mm_maskz_getmant_ps(__mmask8, __m128, int, int);
extern __m256    __cdecl _mm256_getmant_ps(__m256, int, int);
extern __m256    __cdecl _mm256_mask_getmant_ps(__m256, __mmask8, __m256, int, int);
extern __m256    __cdecl _mm256_maskz_getmant_ps(__mmask8, __m256, int, int);
extern __m128i   __cdecl _mm_mmask_i32gather_epi32(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i32gather_epi32(__m256i, __mmask8, __m256i, void const*, const int);
extern __m128i   __cdecl _mm_mmask_i32gather_epi64(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i32gather_epi64(__m256i, __mmask8, __m128i, void const*, const int);
extern __m128d   __cdecl _mm_mmask_i32gather_pd(__m128d, __mmask8, __m128i, void const*, const int);
extern __m256d   __cdecl _mm256_mmask_i32gather_pd(__m256d, __mmask8, __m128i, void const*, const int);
extern __m128    __cdecl _mm_mmask_i32gather_ps(__m128, __mmask8, __m128i, void const*, const int);
extern __m256    __cdecl _mm256_mmask_i32gather_ps(__m256, __mmask8, __m256i, void const*, const int);
extern void      __cdecl _mm_i32scatter_epi32(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i32scatter_epi32(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i32scatter_epi32(void*, __m256i, __m256i, const int);
extern void      __cdecl _mm256_mask_i32scatter_epi32(void*, __mmask8, __m256i, __m256i, const int);
extern void      __cdecl _mm_i32scatter_epi64(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i32scatter_epi64(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i32scatter_epi64(void*, __m128i, __m256i, const int);
extern void      __cdecl _mm256_mask_i32scatter_epi64(void*, __mmask8, __m128i, __m256i, const int);
extern void      __cdecl _mm_i32scatter_pd(void*, __m128i, __m128d, const int);
extern void      __cdecl _mm_mask_i32scatter_pd(void*, __mmask8, __m128i, __m128d, const int);
extern void      __cdecl _mm256_i32scatter_pd(void*, __m128i, __m256d, const int);
extern void      __cdecl _mm256_mask_i32scatter_pd(void*, __mmask8, __m128i, __m256d, const int);
extern void      __cdecl _mm_i32scatter_ps(void*, __m128i, __m128, const int);
extern void      __cdecl _mm_mask_i32scatter_ps(void*, __mmask8, __m128i, __m128, const int);
extern void      __cdecl _mm256_i32scatter_ps(void*, __m256i, __m256, const int);
extern void      __cdecl _mm256_mask_i32scatter_ps(void*, __mmask8, __m256i, __m256, const int);
extern __m128i   __cdecl _mm_mmask_i64gather_epi32(__m128i, __mmask8, __m128i, void const*, const int);
extern __m128i   __cdecl _mm256_mmask_i64gather_epi32(__m128i, __mmask8, __m256i, void const*, const int);
extern __m128i   __cdecl _mm_mmask_i64gather_epi64(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i64gather_epi64(__m256i, __mmask8, __m256i, void const*, const int);
extern __m128d   __cdecl _mm_mmask_i64gather_pd(__m128d, __mmask8, __m128i, void const*, const int);
extern __m256d   __cdecl _mm256_mmask_i64gather_pd(__m256d, __mmask8, __m256i, void const*, const int);
extern __m128    __cdecl _mm_mmask_i64gather_ps(__m128, __mmask8, __m128i, void const*, const int);
extern __m128    __cdecl _mm256_mmask_i64gather_ps(__m128, __mmask8, __m256i, void const*, const int);
extern void      __cdecl _mm_i64scatter_epi32(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i64scatter_epi32(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i64scatter_epi32(void*, __m256i, __m128i, const int);
extern void      __cdecl _mm256_mask_i64scatter_epi32(void*, __mmask8, __m256i, __m128i, const int);
extern void      __cdecl _mm_i64scatter_epi64(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i64scatter_epi64(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i64scatter_epi64(void*, __m256i, __m256i, const int);
extern void      __cdecl _mm256_mask_i64scatter_epi64(void*, __mmask8, __m256i, __m256i, const int);
extern void      __cdecl _mm_i64scatter_pd(void*, __m128i, __m128d, const int);
extern void      __cdecl _mm_mask_i64scatter_pd(void*, __mmask8, __m128i, __m128d, const int);
extern void      __cdecl _mm256_i64scatter_pd(void*, __m256i, __m256d, const int);
extern void      __cdecl _mm256_mask_i64scatter_pd(void*, __mmask8, __m256i, __m256d, const int);
extern void      __cdecl _mm_i64scatter_ps(void*, __m128i, __m128, const int);
extern void      __cdecl _mm_mask_i64scatter_ps(void*, __mmask8, __m128i, __m128, const int);
extern void      __cdecl _mm256_i64scatter_ps(void*, __m256i, __m128, const int);
extern void      __cdecl _mm256_mask_i64scatter_ps(void*, __mmask8, __m256i, __m128, const int);
extern __m256    __cdecl _mm256_insertf32x4(__m256, __m128, int);
extern __m256    __cdecl _mm256_mask_insertf32x4(__m256, __mmask8, __m256, __m128, int);
extern __m256    __cdecl _mm256_maskz_insertf32x4(__mmask8, __m256, __m128, int);
extern __m256d   __cdecl _mm256_insertf64x2(__m256d, __m128d, int);
extern __m256d   __cdecl _mm256_mask_insertf64x2(__m256d, __mmask8, __m256d, __m128d, int);
extern __m256d   __cdecl _mm256_maskz_insertf64x2(__mmask8, __m256d, __m128d, int);
extern __m256i   __cdecl _mm256_inserti32x4(__m256i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_inserti32x4(__m256i, __mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_maskz_inserti32x4(__mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_inserti64x2(__m256i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_inserti64x2(__m256i, __mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_maskz_inserti64x2(__mmask8, __m256i, __m128i, int);
extern __m128i   __cdecl _mm_mask_load_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_load_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_load_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_load_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_load_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_load_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_load_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_load_epi64(__mmask8, void const*);
extern __m128d   __cdecl _mm_mask_load_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_load_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_load_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_load_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_load_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_load_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_load_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_load_ps(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi16(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi16(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi16(__m256i, __mmask16, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi16(__mmask16, void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi64(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi8(__m128i, __mmask16, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi8(__mmask16, void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi8(__m256i, __mmask32, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi8(__mmask32, void const*);
extern __m128d   __cdecl _mm_mask_loadu_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_loadu_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_loadu_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_loadu_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_loadu_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_loadu_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_loadu_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_loadu_ps(__mmask8, void const*);
extern __m128i   __cdecl _mm_lzcnt_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_lzcnt_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_lzcnt_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_lzcnt_epi32(__m256i);
extern __m256i   __cdecl _mm256_mask_lzcnt_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_lzcnt_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_lzcnt_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_lzcnt_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_lzcnt_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_lzcnt_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_lzcnt_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_lzcnt_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_madd_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_madd_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_madd_epi16(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_madd_epi16(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_maddubs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_maddubs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_maddubs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_maddubs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_max_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_max_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_max_epu64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_max_epu64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_max_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_max_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_max_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_max_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_max_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_max_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_max_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_max_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_min_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_min_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_min_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_min_epu64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_min_epu64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_min_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_min_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_min_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_min_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_min_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_min_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_min_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_min_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_mov_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi8(__mmask32, __m256i);
extern __m128d   __cdecl _mm_mask_mov_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_mov_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_mov_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_mov_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_mov_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_mov_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_mov_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_mov_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_mask_movedup_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_movedup_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_movedup_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_movedup_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_movehdup_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_movehdup_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_movehdup_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_movehdup_ps(__mmask8, __m256);
extern __m128    __cdecl _mm_mask_moveldup_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_moveldup_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_moveldup_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_moveldup_ps(__mmask8, __m256);
extern __mmask8  __cdecl _mm_movepi16_mask(__m128i);
extern __mmask16 __cdecl _mm256_movepi16_mask(__m256i);
extern __mmask8  __cdecl _mm_movepi32_mask(__m128i);
extern __mmask8  __cdecl _mm256_movepi32_mask(__m256i);
extern __mmask8  __cdecl _mm_movepi64_mask(__m128i);
extern __mmask8  __cdecl _mm256_movepi64_mask(__m256i);
extern __mmask16 __cdecl _mm_movepi8_mask(__m128i);
extern __mmask32 __cdecl _mm256_movepi8_mask(__m256i);
extern __m128i   __cdecl _mm_movm_epi16(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi16(__mmask16);
extern __m128i   __cdecl _mm_movm_epi32(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi32(__mmask8);
extern __m128i   __cdecl _mm_movm_epi64(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi64(__mmask8);
extern __m128i   __cdecl _mm_movm_epi8(__mmask16);
extern __m256i   __cdecl _mm256_movm_epi8(__mmask32);
extern __m128i   __cdecl _mm_mask_mul_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mul_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mul_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mul_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mul_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mul_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mul_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mul_epu32(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_mul_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_mul_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_mul_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_mul_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_mul_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_mul_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_mul_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_mul_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_mulhi_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhi_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhi_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhi_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mulhi_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhi_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhi_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhi_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mulhrs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhrs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhrs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhrs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mullo_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mullo_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_or_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_or_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_or_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_or_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_or_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_or_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_or_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_or_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_or_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_or_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_or_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_or_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_or_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_or_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_or_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_or_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_packs_epi16(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packs_epi16(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packs_epi16(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packs_epi16(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packs_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packs_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packs_epi32(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packs_epi32(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packus_epi16(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packus_epi16(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packus_epi16(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packus_epi16(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packus_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packus_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packus_epi32(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packus_epi32(__mmask16, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_permute_pd(__m128d, __mmask8, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_permute_pd(__mmask8, __m128d, const int);
extern __m256d   __cdecl _mm256_mask_permute_pd(__m256d, __mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_permute_pd(__mmask8, __m256d, const int);
extern __m128    __cdecl _mm_mask_permute_ps(__m128, __mmask8, __m128, const int);
extern __m128    __cdecl _mm_maskz_permute_ps(__mmask8, __m128, const int);
extern __m256    __cdecl _mm256_mask_permute_ps(__m256, __mmask8, __m256, const int);
extern __m256    __cdecl _mm256_maskz_permute_ps(__mmask8, __m256, const int);
extern __m128d   __cdecl _mm_mask_permutevar_pd(__m128d, __mmask8, __m128d, __m128i);
extern __m128d   __cdecl _mm_maskz_permutevar_pd(__mmask8, __m128d, __m128i);
extern __m256d   __cdecl _mm256_mask_permutevar_pd(__m256d, __mmask8, __m256d, __m256i);
extern __m256d   __cdecl _mm256_maskz_permutevar_pd(__mmask8, __m256d, __m256i);
extern __m128    __cdecl _mm_mask_permutevar_ps(__m128, __mmask8, __m128, __m128i);
extern __m128    __cdecl _mm_maskz_permutevar_ps(__mmask8, __m128, __m128i);
extern __m256    __cdecl _mm256_mask_permutevar_ps(__m256, __mmask8, __m256, __m256i);
extern __m256    __cdecl _mm256_maskz_permutevar_ps(__mmask8, __m256, __m256i);
extern __m256i   __cdecl _mm256_mask_permutex_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_permutex_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_permutex_epi64(__m256i, const int);
extern __m256d   __cdecl _mm256_mask_permutex_pd(__m256d, __mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_permutex_pd(__mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_permutex_pd(__m256d, const int);
extern __m128i   __cdecl _mm_mask_permutex2var_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi16(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi16(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi16(__m256i, __m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi16(__m256i, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_permutex2var_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi32(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi32(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi32(__m256i, __m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi32(__m256i, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_permutex2var_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi64(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi64(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi64(__m256i, __m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi64(__m256i, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_permutex2var_pd(__m128d, __mmask8, __m128i, __m128d);
extern __m128d   __cdecl _mm_mask2_permutex2var_pd(__m128d, __m128i, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_permutex2var_pd(__mmask8, __m128d, __m128i, __m128d);
extern __m128d   __cdecl _mm_permutex2var_pd(__m128d, __m128i, __m128d);
extern __m256d   __cdecl _mm256_mask_permutex2var_pd(__m256d, __mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_mask2_permutex2var_pd(__m256d, __m256i, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_permutex2var_pd(__mmask8, __m256d, __m256i, __m256d);
extern __m256d   __cdecl _mm256_permutex2var_pd(__m256d, __m256i, __m256d);
extern __m128    __cdecl _mm_mask_permutex2var_ps(__m128, __mmask8, __m128i, __m128);
extern __m128    __cdecl _mm_mask2_permutex2var_ps(__m128, __m128i, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_permutex2var_ps(__mmask8, __m128, __m128i, __m128);
extern __m128    __cdecl _mm_permutex2var_ps(__m128, __m128i, __m128);
extern __m256    __cdecl _mm256_mask_permutex2var_ps(__m256, __mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_mask2_permutex2var_ps(__m256, __m256i, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_permutex2var_ps(__mmask8, __m256, __m256i, __m256);
extern __m256    __cdecl _mm256_permutex2var_ps(__m256, __m256i, __m256);
extern __m128i   __cdecl _mm_mask_permutexvar_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_permutexvar_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutexvar_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi16(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi64(__m256i, __m256i);
extern __m256d   __cdecl _mm256_mask_permutexvar_pd(__m256d, __mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_maskz_permutexvar_pd(__mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_permutexvar_pd(__m256i, __m256d);
extern __m256    __cdecl _mm256_mask_permutexvar_ps(__m256, __mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_maskz_permutexvar_ps(__mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_permutexvar_ps(__m256i, __m256);
extern __m128d   __cdecl _mm_mask_range_pd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_range_pd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_range_pd(__m128d, __m128d, int);
extern __m256d   __cdecl _mm256_mask_range_pd(__m256d, __mmask8, __m256d, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_range_pd(__mmask8, __m256d, __m256d, int);
extern __m256d   __cdecl _mm256_range_pd(__m256d, __m256d, int);
extern __m128    __cdecl _mm_mask_range_ps(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_range_ps(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_range_ps(__m128, __m128, int);
extern __m256    __cdecl _mm256_mask_range_ps(__m256, __mmask8, __m256, __m256, int);
extern __m256    __cdecl _mm256_maskz_range_ps(__mmask8, __m256, __m256, int);
extern __m256    __cdecl _mm256_range_ps(__m256, __m256, int);
extern __m128d   __cdecl _mm_mask_rcp14_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp14_pd(__mmask8, __m128d);
extern __m128d   __cdecl _mm_rcp14_pd(__m128d);
extern __m256d   __cdecl _mm256_mask_rcp14_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_rcp14_pd(__mmask8, __m256d);
extern __m256d   __cdecl _mm256_rcp14_pd(__m256d);
extern __m128    __cdecl _mm_mask_rcp14_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_rcp14_ps(__mmask8, __m128);
extern __m128    __cdecl _mm_rcp14_ps(__m128);
extern __m256    __cdecl _mm256_mask_rcp14_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_rcp14_ps(__mmask8, __m256);
extern __m256    __cdecl _mm256_rcp14_ps(__m256);
extern __m128d   __cdecl _mm_mask_reduce_pd(__m128d, __mmask8, __m128d, int);
extern __m128d   __cdecl _mm_maskz_reduce_pd(__mmask8, __m128d, int);
extern __m128d   __cdecl _mm_reduce_pd(__m128d, int);
extern __m256d   __cdecl _mm256_mask_reduce_pd(__m256d, __mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_reduce_pd(__mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_reduce_pd(__m256d, int);
extern __m128    __cdecl _mm_mask_reduce_ps(__m128, __mmask8, __m128, int);
extern __m128    __cdecl _mm_maskz_reduce_ps(__mmask8, __m128, int);
extern __m128    __cdecl _mm_reduce_ps(__m128, int);
extern __m256    __cdecl _mm256_mask_reduce_ps(__m256, __mmask8, __m256, int);
extern __m256    __cdecl _mm256_maskz_reduce_ps(__mmask8, __m256, int);
extern __m256    __cdecl _mm256_reduce_ps(__m256, int);
extern __m128i   __cdecl _mm_mask_rol_epi32(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_rol_epi32(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_rol_epi32(__m128i, int);
extern __m256i   __cdecl _mm256_mask_rol_epi32(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_rol_epi32(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_rol_epi32(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rol_epi64(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_rol_epi64(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_rol_epi64(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_rol_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_rol_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_rol_epi64(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rolv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rolv_epi32(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rolv_epi32(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rolv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rolv_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rolv_epi32(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_rolv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rolv_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rolv_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rolv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rolv_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rolv_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_ror_epi32(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_ror_epi32(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_ror_epi32(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_ror_epi32(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_ror_epi32(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_ror_epi32(__m256i, const int);
extern __m128i   __cdecl _mm_mask_ror_epi64(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_ror_epi64(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_ror_epi64(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_ror_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_ror_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_ror_epi64(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rorv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rorv_epi32(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rorv_epi32(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rorv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rorv_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rorv_epi32(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_rorv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rorv_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rorv_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rorv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rorv_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rorv_epi64(__m256i, __m256i);
extern __m128d   __cdecl _mm_mask_roundscale_pd(__m128d, __mmask8, __m128d, int);
extern __m128d   __cdecl _mm_maskz_roundscale_pd(__mmask8, __m128d, int);
extern __m128d   __cdecl _mm_roundscale_pd(__m128d, int);
extern __m256d   __cdecl _mm256_mask_roundscale_pd(__m256d, __mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_roundscale_pd(__mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_roundscale_pd(__m256d, int);
extern __m128    __cdecl _mm_mask_roundscale_ps(__m128, __mmask8, __m128, int);
extern __m128    __cdecl _mm_maskz_roundscale_ps(__mmask8, __m128, int);
extern __m128    __cdecl _mm_roundscale_ps(__m128, int);
extern __m256    __cdecl _mm256_mask_roundscale_ps(__m256, __mmask8, __m256, int);
extern __m256    __cdecl _mm256_maskz_roundscale_ps(__mmask8, __m256, int);
extern __m256    __cdecl _mm256_roundscale_ps(__m256, int);
extern __m128d   __cdecl _mm_mask_rsqrt14_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt14_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_rsqrt14_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_rsqrt14_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_rsqrt14_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt14_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_rsqrt14_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_rsqrt14_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_mask_scalef_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_scalef_pd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_scalef_pd(__m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_scalef_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_scalef_pd(__mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_scalef_pd(__m256d, __m256d);
extern __m128    __cdecl _mm_mask_scalef_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_scalef_ps(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_scalef_ps(__m128, __m128);
extern __m256    __cdecl _mm256_mask_scalef_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_scalef_ps(__mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_scalef_ps(__m256, __m256);
extern __m128i   __cdecl _mm_mask_set1_epi16(__m128i, __mmask8, short);
extern __m128i   __cdecl _mm_maskz_set1_epi16(__mmask8, short);
extern __m256i   __cdecl _mm256_mask_set1_epi16(__m256i, __mmask16, short);
extern __m256i   __cdecl _mm256_maskz_set1_epi16(__mmask16, short);
extern __m128i   __cdecl _mm_mask_set1_epi32(__m128i, __mmask8, int);
extern __m128i   __cdecl _mm_maskz_set1_epi32(__mmask8, int);
extern __m256i   __cdecl _mm256_mask_set1_epi32(__m256i, __mmask8, int);
extern __m256i   __cdecl _mm256_maskz_set1_epi32(__mmask8, int);
extern __m128i   __cdecl _mm_mask_set1_epi64(__m128i, __mmask8, __int64);
extern __m128i   __cdecl _mm_maskz_set1_epi64(__mmask8, __int64);
extern __m256i   __cdecl _mm256_mask_set1_epi64(__m256i, __mmask8, __int64);
extern __m256i   __cdecl _mm256_maskz_set1_epi64(__mmask8, __int64);
extern __m128i   __cdecl _mm_mask_set1_epi8(__m128i, __mmask16, char);
extern __m128i   __cdecl _mm_maskz_set1_epi8(__mmask16, char);
extern __m256i   __cdecl _mm256_mask_set1_epi8(__m256i, __mmask32, char);
extern __m256i   __cdecl _mm256_maskz_set1_epi8(__mmask32, char);
extern __m128i   __cdecl _mm_mask_shuffle_epi32(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shuffle_epi32(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shuffle_epi32(__m256i, __mmask8, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shuffle_epi32(__mmask8, __m256i, int);
extern __m128i   __cdecl _mm_mask_shuffle_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_shuffle_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_shuffle_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_shuffle_epi8(__mmask32, __m256i, __m256i);
extern __m256    __cdecl _mm256_mask_shuffle_f32x4(__m256, __mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_maskz_shuffle_f32x4(__mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_shuffle_f32x4(__m256, __m256, const int);
extern __m256d   __cdecl _mm256_mask_shuffle_f64x2(__m256d, __mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_shuffle_f64x2(__mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_shuffle_f64x2(__m256d, __m256d, const int);
extern __m256i   __cdecl _mm256_mask_shuffle_i32x4(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_shuffle_i32x4(__mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_shuffle_i32x4(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_shuffle_i64x2(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_shuffle_i64x2(__mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_shuffle_i64x2(__m256i, __m256i, const int);
extern __m128d   __cdecl _mm_mask_shuffle_pd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_shuffle_pd(__mmask8, __m128d, __m128d, const int);
extern __m256d   __cdecl _mm256_mask_shuffle_pd(__m256d, __mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_shuffle_pd(__mmask8, __m256d, __m256d, const int);
extern __m128    __cdecl _mm_mask_shuffle_ps(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_shuffle_ps(__mmask8, __m128, __m128, const int);
extern __m256    __cdecl _mm256_mask_shuffle_ps(__m256, __mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_maskz_shuffle_ps(__mmask8, __m256, __m256, const int);
extern __m128i   __cdecl _mm_mask_shufflehi_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shufflehi_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shufflehi_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shufflehi_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_shufflelo_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shufflelo_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shufflelo_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shufflelo_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_sll_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sll_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sll_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi64(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_slli_epi16(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi16(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi16(__m256i, __mmask16, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi16(__mmask16, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_slli_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_slli_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi64(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi64(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_sllv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_sllv_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_sllv_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sllv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sllv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_sqrt_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_sqrt_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_sqrt_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_sqrt_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_sqrt_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_sqrt_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_sqrt_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_sqrt_ps(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_sra_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sra_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sra_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_sra_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi64(__mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_sra_epi64(__m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srai_epi16(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi16(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi16(__m256i, __mmask16, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi16(__mmask16, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srai_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srai_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi64(__mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_srai_epi64(__m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi64(__mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_srai_epi64(__m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srav_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srav_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srav_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srav_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srav_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srav_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srav_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srl_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srl_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srl_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi64(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srli_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_srli_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_srli_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_srli_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_srli_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srli_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srli_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srli_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srli_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srli_epi64(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srli_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srli_epi64(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srlv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srlv_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srlv_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srlv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srlv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi64(__mmask8, __m256i, __m256i);
extern void      __cdecl _mm_mask_store_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_store_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_store_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_store_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_store_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_store_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_store_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_store_ps(void*, __mmask8, __m256);
extern void      __cdecl _mm_mask_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi16(void*, __mmask16, __m256i);
extern void      __cdecl _mm_mask_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_storeu_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_storeu_epi8(void*, __mmask16, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi8(void*, __mmask32, __m256i);
extern void      __cdecl _mm_mask_storeu_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_storeu_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_storeu_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_storeu_ps(void*, __mmask8, __m256);
extern __m128i   __cdecl _mm_mask_sub_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_sub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sub_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_sub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_sub_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_sub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sub_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_sub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_sub_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_subs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_ternarylogic_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_ternarylogic_epi32(__mmask8, __m128i, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_ternarylogic_epi32(__m128i, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_ternarylogic_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_ternarylogic_epi32(__mmask8, __m256i, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_ternarylogic_epi32(__m256i, __m256i, __m256i, int);
extern __m128i   __cdecl _mm_mask_ternarylogic_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_ternarylogic_epi64(__mmask8, __m128i, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_ternarylogic_epi64(__m128i, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_ternarylogic_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_ternarylogic_epi64(__mmask8, __m256i, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_ternarylogic_epi64(__m256i, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_mask_test_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi16_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm256_mask_test_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16 __cdecl _mm256_test_epi16_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_test_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_test_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_test_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_test_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_test_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_test_epi64_mask(__m256i, __m256i);
extern __mmask16 __cdecl _mm_mask_test_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16 __cdecl _mm_test_epi8_mask(__m128i, __m128i);
extern __mmask32 __cdecl _mm256_mask_test_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32 __cdecl _mm256_test_epi8_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi16_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm256_mask_testn_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16 __cdecl _mm256_testn_epi16_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_testn_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_testn_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_testn_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_testn_epi64_mask(__m256i, __m256i);
extern __mmask16 __cdecl _mm_mask_testn_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16 __cdecl _mm_testn_epi8_mask(__m128i, __m128i);
extern __mmask32 __cdecl _mm256_mask_testn_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32 __cdecl _mm256_testn_epi8_mask(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_unpackhi_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_unpackhi_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_unpackhi_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_unpackhi_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_unpackhi_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_unpackhi_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_unpackhi_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_unpackhi_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_unpacklo_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_unpacklo_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_unpacklo_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_unpacklo_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_unpacklo_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_unpacklo_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_unpacklo_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_unpacklo_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_unpacklo_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_xor_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_xor_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_xor_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_xor_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_xor_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_xor_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_xor_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_xor_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_xor_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_xor_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_xor_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_xor_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_xor_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_xor_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_xor_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_xor_ps(__mmask8, __m256, __m256);
extern __m128d   __cdecl _mm_add_round_sd(__m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_add_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_add_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128    __cdecl _mm_add_round_ss(__m128, __m128, int);
extern __m128    __cdecl _mm_mask_add_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_add_round_ss(__mmask8, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_add_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_add_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_add_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_add_ss(__mmask8, __m128, __m128);
extern __mmask8  __cdecl _mm_cmp_round_sd_mask(__m128d, __m128d, const int, const int);
extern __mmask8  __cdecl _mm_mask_cmp_round_sd_mask(__mmask8, __m128d, __m128d, const int, const int);
extern __mmask8  __cdecl _mm_cmp_round_ss_mask(__m128, __m128, const int, const int);
extern __mmask8  __cdecl _mm_mask_cmp_round_ss_mask(__mmask8, __m128, __m128, const int, const int);
extern __mmask8  __cdecl _mm_cmp_sd_mask(__m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_mask_cmp_sd_mask(__mmask8, __m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_cmp_ss_mask(__m128, __m128, const int);
extern __mmask8  __cdecl _mm_mask_cmp_ss_mask(__mmask8, __m128, __m128, const int);
extern int       __cdecl _mm_comi_round_sd(__m128d, __m128d, const int, const int);
extern int       __cdecl _mm_comi_round_ss(__m128, __m128, const int, const int);
extern __m128    __cdecl _mm_cvt_roundi32_ss(__m128, int, int);
extern int       __cdecl _mm_cvt_roundsd_i32(__m128d, int);
extern int       __cdecl _mm_cvt_roundsd_si32(__m128d, int);
extern __m128    __cdecl _mm_cvt_roundsd_ss(__m128, __m128d, int);
extern __m128    __cdecl _mm_mask_cvt_roundsd_ss(__m128, __mmask8, __m128, __m128d, int);
extern __m128    __cdecl _mm_maskz_cvt_roundsd_ss(__mmask8, __m128, __m128d, int);
extern unsigned int __cdecl _mm_cvt_roundsd_u32(__m128d, int);
extern __m128    __cdecl _mm_cvt_roundsi32_ss(__m128, int, int);
extern int       __cdecl _mm_cvt_roundss_i32(__m128, int);
extern __m128d   __cdecl _mm_cvt_roundss_sd(__m128d, __m128, int);
extern __m128d   __cdecl _mm_mask_cvt_roundss_sd(__m128d, __mmask8, __m128d, __m128, int);
extern __m128d   __cdecl _mm_maskz_cvt_roundss_sd(__mmask8, __m128d, __m128, int);
extern int       __cdecl _mm_cvt_roundss_si32(__m128, int);
extern unsigned int __cdecl _mm_cvt_roundss_u32(__m128, int);
extern __m128    __cdecl _mm_cvt_roundu32_ss(__m128, unsigned int, int);
extern __m128d   __cdecl _mm_cvti32_sd(__m128d, int);
extern __m128    __cdecl _mm_cvti32_ss(__m128, int);
extern int       __cdecl _mm_cvtsd_i32(__m128d);
extern __m128    __cdecl _mm_mask_cvtsd_ss(__m128, __mmask8, __m128, __m128d);
extern __m128    __cdecl _mm_maskz_cvtsd_ss(__mmask8, __m128, __m128d);
extern unsigned int __cdecl _mm_cvtsd_u32(__m128d);
extern int       __cdecl _mm_cvtss_i32(__m128);
extern __m128d   __cdecl _mm_mask_cvtss_sd(__m128d, __mmask8, __m128d, __m128);
extern __m128d   __cdecl _mm_maskz_cvtss_sd(__mmask8, __m128d, __m128);
extern unsigned int __cdecl _mm_cvtss_u32(__m128);
extern int       __cdecl _mm_cvtt_roundsd_i32(__m128d, int);
extern int       __cdecl _mm_cvtt_roundsd_si32(__m128d, int);
extern unsigned int __cdecl _mm_cvtt_roundsd_u32(__m128d, int);
extern int       __cdecl _mm_cvtt_roundss_i32(__m128, int);
extern int       __cdecl _mm_cvtt_roundss_si32(__m128, int);
extern unsigned int __cdecl _mm_cvtt_roundss_u32(__m128, int);
extern int       __cdecl _mm_cvttsd_i32(__m128d);
extern unsigned int __cdecl _mm_cvttsd_u32(__m128d);
extern int       __cdecl _mm_cvttss_i32(__m128);
extern unsigned int __cdecl _mm_cvttss_u32(__m128);
extern __m128d   __cdecl _mm_cvtu32_sd(__m128d, unsigned int);
extern __m128    __cdecl _mm_cvtu32_ss(__m128, unsigned int);
extern __m128d   __cdecl _mm_div_round_sd(__m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_div_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_div_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128    __cdecl _mm_div_round_ss(__m128, __m128, int);
extern __m128    __cdecl _mm_mask_div_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_div_round_ss(__mmask8, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_div_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_div_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_div_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_div_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_fixupimm_round_sd(__m128d, __m128d, __m128i, const int, int);
extern __m128d   __cdecl _mm_mask_fixupimm_round_sd(__m128d, __mmask8, __m128d, __m128i, const int, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_round_sd(__mmask8, __m128d, __m128d, __m128i, const int, const int);
extern __m128    __cdecl _mm_fixupimm_round_ss(__m128, __m128, __m128i, const int, const int);
extern __m128    __cdecl _mm_mask_fixupimm_round_ss(__m128, __mmask8, __m128, __m128i, const int, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_round_ss(__mmask8, __m128, __m128, __m128i, const int, const int);
extern __m128d   __cdecl _mm_fixupimm_sd(__m128d, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_mask_fixupimm_sd(__m128d, __mmask8, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_sd(__mmask8, __m128d, __m128d, __m128i, const int);
extern __m128    __cdecl _mm_fixupimm_ss(__m128, __m128, __m128i, const int);
extern __m128    __cdecl _mm_mask_fixupimm_ss(__m128, __mmask8, __m128, __m128i, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_ss(__mmask8, __m128, __m128, __m128i, const int);
extern __m128d   __cdecl _mm_fmadd_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fmadd_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fmadd_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fmadd_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fmadd_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fmadd_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmadd_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmadd_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fmadd_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmadd_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmadd_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fmsub_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fmsub_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fmsub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fmsub_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fmsub_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fmsub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsub_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsub_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fmsub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsub_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsub_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fnmadd_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fnmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fnmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fnmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fnmadd_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fnmadd_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fnmadd_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fnmadd_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fnmadd_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmadd_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmadd_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fnmadd_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmadd_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmadd_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fnmsub_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fnmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fnmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fnmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fnmsub_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fnmsub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fnmsub_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fnmsub_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fnmsub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmsub_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmsub_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fnmsub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmsub_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmsub_ss(__mmask8, __m128, __m128, __m128);
extern __mmask8  __cdecl _mm_fpclass_sd_mask(__m128d, int);
extern __mmask8  __cdecl _mm_mask_fpclass_sd_mask(__mmask8, __m128d, int);
extern __mmask8  __cdecl _mm_fpclass_ss_mask(__m128, int);
extern __mmask8  __cdecl _mm_mask_fpclass_ss_mask(__mmask8, __m128, int);
extern __m128d   __cdecl _mm_getexp_round_sd(__m128d, __m128d, const int);
extern __m128d   __cdecl _mm_mask_getexp_round_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_getexp_round_sd(__mmask8, __m128d, __m128d, const int);
extern __m128    __cdecl _mm_getexp_round_ss(__m128, __m128, const int);
extern __m128    __cdecl _mm_mask_getexp_round_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_getexp_round_ss(__mmask8, __m128, __m128, const int);
extern __m128d   __cdecl _mm_getexp_sd(__m128d, __m128d);
extern __m128d   __cdecl _mm_mask_getexp_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_getexp_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_getexp_ss(__m128, __m128);
extern __m128    __cdecl _mm_mask_getexp_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_getexp_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_getmant_round_sd(__m128d, __m128d, int, int, int);
extern __m128d   __cdecl _mm_mask_getmant_round_sd(__m128d, __mmask8, __m128d, __m128d, int, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_round_sd(__mmask8, __m128d, __m128d, int, int, int);
extern __m128    __cdecl _mm_getmant_round_ss(__m128, __m128, int, int, int);
extern __m128    __cdecl _mm_mask_getmant_round_ss(__m128, __mmask8, __m128, __m128, int, int, int);
extern __m128    __cdecl _mm_maskz_getmant_round_ss(__mmask8, __m128, __m128, int, int, int);
extern __m128d   __cdecl _mm_getmant_sd(__m128d, __m128d, int, int);
extern __m128d   __cdecl _mm_mask_getmant_sd(__m128d, __mmask8, __m128d, __m128d, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_sd(__mmask8, __m128d, __m128d, int, int);
extern __m128    __cdecl _mm_getmant_ss(__m128, __m128, int, int);
extern __m128    __cdecl _mm_mask_getmant_ss(__m128, __mmask8, __m128, __m128, int, int);
extern __m128    __cdecl _mm_maskz_getmant_ss(__mmask8, __m128, __m128, int, int);
extern __m128d   __cdecl _mm_mask_load_sd(__m128d, __mmask8, const double*);
extern __m128d   __cdecl _mm_maskz_load_sd(__mmask8, const double*);
extern __m128    __cdecl _mm_mask_load_ss(__m128, __mmask8, const float*);
extern __m128    __cdecl _mm_maskz_load_ss(__mmask8, const float*);
extern __m128d   __cdecl _mm_mask_max_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_max_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_max_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_max_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_max_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_max_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_max_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_max_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_max_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_max_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_min_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_min_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_min_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_min_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_min_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_min_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_min_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_min_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_min_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_min_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_move_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_move_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_move_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_move_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_mul_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_mul_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mul_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_mul_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_mul_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mul_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_mul_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_mul_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_mul_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_mul_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_range_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_maskz_range_round_sd(__mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_range_round_sd(__m128d, __m128d, const int, int);
extern __m128    __cdecl _mm_mask_range_round_ss(__m128, __mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_maskz_range_round_ss(__mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_range_round_ss(__m128, __m128, const int, int);
extern __m128d   __cdecl _mm_mask_range_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_range_sd(__mmask8, __m128d, __m128d, const int);
extern __m128    __cdecl _mm_mask_range_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_range_ss(__mmask8, __m128, __m128, const int);
extern __m128d   __cdecl _mm_mask_rcp14_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp14_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rcp14_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rcp14_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rcp14_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rcp14_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_rcp28_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_rcp28_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_rcp28_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_rcp28_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_rcp28_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_rcp28_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_rcp28_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp28_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rcp28_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rcp28_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rcp28_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rcp28_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_reduce_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_maskz_reduce_round_sd(__mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_reduce_round_sd(__m128d, __m128d, const int, int);
extern __m128    __cdecl _mm_mask_reduce_round_ss(__m128, __mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_maskz_reduce_round_ss(__mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_reduce_round_ss(__m128, __m128, const int, int);
extern __m128d   __cdecl _mm_mask_reduce_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_reduce_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_reduce_sd(__m128d, __m128d, const int);
extern __m128    __cdecl _mm_mask_reduce_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_reduce_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_reduce_ss(__m128, __m128, const int);
extern __m128d   __cdecl _mm_mask_roundscale_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, const int);
extern __m128d   __cdecl _mm_maskz_roundscale_round_sd(__mmask8, __m128d, __m128d, const int, const int);
extern __m128d   __cdecl _mm_roundscale_round_sd(__m128d, __m128d, const int, const int);
extern __m128    __cdecl _mm_mask_roundscale_round_ss(__m128, __mmask8, __m128, __m128, const int, const int);
extern __m128    __cdecl _mm_maskz_roundscale_round_ss(__mmask8, __m128, __m128, const int, const int);
extern __m128    __cdecl _mm_roundscale_round_ss(__m128, __m128, const int, const int);
extern __m128d   __cdecl _mm_mask_roundscale_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_roundscale_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_roundscale_sd(__m128d, __m128d, const int);
extern __m128    __cdecl _mm_mask_roundscale_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_roundscale_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_roundscale_ss(__m128, __m128, const int);
extern __m128d   __cdecl _mm_mask_rsqrt14_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt14_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rsqrt14_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rsqrt14_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt14_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rsqrt14_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_rsqrt28_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_rsqrt28_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_rsqrt28_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_rsqrt28_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_rsqrt28_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_rsqrt28_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_rsqrt28_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt28_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rsqrt28_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rsqrt28_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt28_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rsqrt28_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_scalef_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_scalef_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_scalef_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_scalef_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_scalef_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_scalef_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_scalef_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_scalef_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_scalef_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_scalef_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_scalef_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_scalef_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_sqrt_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_sqrt_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_sqrt_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_sqrt_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_sqrt_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_sqrt_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_sqrt_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sqrt_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_sqrt_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sqrt_ss(__mmask8, __m128, __m128);
extern void      __cdecl _mm_mask_store_sd(double*, __mmask8, __m128d);
extern void      __cdecl _mm_mask_store_ss(float*, __mmask8, __m128);
extern __m128d   __cdecl _mm_mask_sub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_sub_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_sub_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_sub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_sub_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_sub_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_sub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sub_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_sub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sub_ss(__mmask8, __m128, __m128);
extern unsigned __int64 __cdecl _mm_cvtsd_u64(__m128d);
extern unsigned __int64 __cdecl _mm_cvtss_u64(__m128);
extern unsigned __int64 __cdecl _mm_cvttsd_u64(__m128d);
extern unsigned __int64 __cdecl _mm_cvttss_u64(__m128);
extern unsigned __int64 __cdecl _mm_cvt_roundsd_u64(__m128d, int);
extern unsigned __int64 __cdecl _mm_cvt_roundss_u64(__m128, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundsd_u64(__m128d, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundss_u64(__m128, int);
extern __m128d   __cdecl _mm_cvti64_sd(__m128d, __int64);
extern __m128    __cdecl _mm_cvti64_ss(__m128, __int64);
extern __int64   __cdecl _mm_cvtsd_i64(__m128d);
extern __int64   __cdecl _mm_cvtss_i64(__m128);
extern __int64   __cdecl _mm_cvttsd_i64(__m128d);
extern __int64   __cdecl _mm_cvttss_i64(__m128);
extern __int64   __cdecl _mm_cvtt_roundsd_i64(__m128d, int);
extern __int64   __cdecl _mm_cvtt_roundsd_si64(__m128d, int);
extern __int64   __cdecl _mm_cvtt_roundss_i64(__m128, int);
extern __int64   __cdecl _mm_cvtt_roundss_si64(__m128, int);
extern __m128d   __cdecl _mm_cvtu64_sd(__m128d, unsigned __int64);
extern __m128    __cdecl _mm_cvtu64_ss(__m128, unsigned __int64);
extern __m128d   __cdecl _mm_cvt_roundi64_sd(__m128d, __int64, int);
extern __m128    __cdecl _mm_cvt_roundi64_ss(__m128, __int64, int);
extern __int64   __cdecl _mm_cvt_roundsd_i64(__m128d, int);
extern __int64   __cdecl _mm_cvt_roundsd_si64(__m128d, int);
extern __m128d   __cdecl _mm_cvt_roundsi64_sd(__m128d, __int64, int);
extern __m128    __cdecl _mm_cvt_roundsi64_ss(__m128, __int64, int);
extern __int64   __cdecl _mm_cvt_roundss_i64(__m128, int);
extern __int64   __cdecl _mm_cvt_roundss_si64(__m128, int);
extern __m128d   __cdecl _mm_cvt_roundu64_sd(__m128d, unsigned __int64, int);
extern __m128    __cdecl _mm_cvt_roundu64_ss(__m128, unsigned __int64, int);
#line 5412 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\zmmintrin.h"
extern __m512d   __cdecl _mm512_zextpd128_pd512(__m128d);
extern __m512d   __cdecl _mm512_zextpd256_pd512(__m256d);
extern __m512    __cdecl _mm512_zextps128_ps512(__m128);
extern __m512    __cdecl _mm512_zextps256_ps512(__m256);
extern __m512i   __cdecl _mm512_zextsi128_si512(__m128i);
extern __m512i   __cdecl _mm512_zextsi256_si512(__m256i);
#line 5448 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\zmmintrin.h"
extern __m128i __cdecl _mm_madd52hi_epu64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_madd52hi_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_madd52hi_epu64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52hi_epu64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_madd52hi_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_madd52hi_epu64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_madd52hi_epu64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd52hi_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd52hi_epu64(__mmask8, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_madd52lo_epu64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_madd52lo_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_madd52lo_epu64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52lo_epu64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_madd52lo_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_madd52lo_epu64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_madd52lo_epu64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd52lo_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd52lo_epu64(__mmask8, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_permutexvar_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_permutexvar_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_permutexvar_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_permutexvar_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_permutexvar_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_permutexvar_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_permutexvar_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi8(__mmask64, __m512i, __m512i);
extern __m128i __cdecl _mm_permutex2var_epi8(__m128i, __m128i , __m128i);
extern __m128i __cdecl _mm_mask_permutex2var_epi8(__m128i, __mmask16, __m128i , __m128i);
extern __m128i __cdecl _mm_mask2_permutex2var_epi8(__m128i, __m128i , __mmask16, __m128i);
extern __m128i __cdecl _mm_maskz_permutex2var_epi8(__mmask16, __m128i, __m128i , __m128i);
extern __m256i __cdecl _mm256_permutex2var_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_permutex2var_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask2_permutex2var_epi8(__m256i, __m256i, __mmask32, __m256i);
extern __m256i __cdecl _mm256_maskz_permutex2var_epi8(__mmask32, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_permutex2var_epi8(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi8(__m512i, __m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi8(__mmask64, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_multishift_epi64_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_multishift_epi64_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_multishift_epi64_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_multishift_epi64_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_multishift_epi64_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_multishift_epi64_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_multishift_epi64_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_multishift_epi64_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_multishift_epi64_epi8(__mmask64, __m512i, __m512i);
extern __m128i __cdecl _mm_dpbusd_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpbusd_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpbusd_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusd_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpbusd_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpbusd_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpbusd_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpbusd_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpbusd_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_dpbusds_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpbusds_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpbusds_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusds_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpbusds_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpbusds_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpbusds_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpbusds_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpbusds_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_dpwssd_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpwssd_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpwssd_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssd_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpwssd_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpwssd_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpwssd_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpwssd_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpwssd_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_dpwssds_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpwssds_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpwssds_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssds_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpwssds_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpwssds_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpwssds_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpwssds_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpwssds_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m256i __cdecl _mm256_aesenc_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesenc_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesenclast_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesenclast_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesdec_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesdec_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesdeclast_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesdeclast_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_clmulepi64_epi128(__m256i, __m256i, const int);
extern __m512i __cdecl _mm512_clmulepi64_epi128(__m512i, __m512i, const int);
extern __m128i __cdecl _mm_popcnt_epi32(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi32(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi32(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi32(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi32(__m256i, __mmask8, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi32(__mmask8, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi32(__mmask16, __m512i);
extern __m128i __cdecl _mm_popcnt_epi64(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi64(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi64(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi64(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi64(__m256i, __mmask8, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi64(__mmask8, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi64(__mmask8, __m512i);
extern __m128i __cdecl _mm_popcnt_epi8(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi8(__m128i, __mmask16, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi8(__mmask16, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi8(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi8(__m256i, __mmask32, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi8(__mmask32, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi8(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi8(__mmask64, __m512i);
extern __m128i __cdecl _mm_popcnt_epi16(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi16(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi16(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi16(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi16(__m256i, __mmask16, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi16(__mmask16, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi16(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi16(__mmask32, __m512i);
extern __mmask16 __cdecl _mm_bitshuffle_epi64_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm_mask_bitshuffle_epi64_mask(__mmask16, __m128i, __m128i);
extern __mmask32 __cdecl _mm256_bitshuffle_epi64_mask(__m256i, __m256i);
extern __mmask32 __cdecl _mm256_mask_bitshuffle_epi64_mask(__mmask32, __m256i, __m256i);
extern __mmask64 __cdecl _mm512_bitshuffle_epi64_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_bitshuffle_epi64_mask(__mmask64, __m512i, __m512i);
extern __m128i __cdecl _mm_gf2p8affineinv_epi64_epi8(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_gf2p8affineinv_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_gf2p8affineinv_epi64_epi8(__mmask16, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_gf2p8affineinv_epi64_epi8(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_gf2p8affineinv_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_gf2p8affineinv_epi64_epi8(__mmask32, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_gf2p8affineinv_epi64_epi8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_gf2p8affineinv_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_gf2p8affineinv_epi64_epi8(__mmask64, __m512i, __m512i, int);
extern __m128i __cdecl _mm_gf2p8affine_epi64_epi8(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_gf2p8affine_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_gf2p8affine_epi64_epi8(__mmask16, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_gf2p8affine_epi64_epi8(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_gf2p8affine_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_gf2p8affine_epi64_epi8(__mmask32, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_gf2p8affine_epi64_epi8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_gf2p8affine_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_gf2p8affine_epi64_epi8(__mmask64, __m512i, __m512i, int);
extern __m128i __cdecl _mm_gf2p8mul_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_gf2p8mul_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_gf2p8mul_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_gf2p8mul_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_gf2p8mul_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_gf2p8mul_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_gf2p8mul_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_gf2p8mul_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_gf2p8mul_epi8(__mmask64, __m512i, __m512i);
extern __m128i __cdecl _mm_shldi_epi16(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi16(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi16(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi16(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi16(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi16(__mmask16, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi16(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi16(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi16(__mmask32, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldi_epi32(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi32(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi32(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi32(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi32(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi32(__mmask16, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldi_epi64(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi64(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi64(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi64(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi64(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi64(__mmask8, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldv_epi16(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi16(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi16(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi16(__mmask32, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shldv_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shldv_epi64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi64(__mmask8, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shrdi_epi16(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi16(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi16(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi16(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi16(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi16(__mmask16, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi16(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi16(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi16(__mmask32, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdi_epi32(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi32(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi32(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi32(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi32(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi32(__mmask16, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdi_epi64(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi64(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi64(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi64(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi64(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi64(__mmask8, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdv_epi16(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi16(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi16(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi16(__mmask32, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shrdv_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shrdv_epi64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi64(__mmask8, __m512i, __m512i, __m512i);
extern __m512i _mm512_div_epi8(__m512i, __m512i);
extern __m512i _mm512_div_epi16(__m512i, __m512i);
extern __m512i _mm512_div_epi32(__m512i, __m512i);
extern __m512i _mm512_div_epi64(__m512i, __m512i);
extern __m512i _mm512_div_epu8(__m512i, __m512i);
extern __m512i _mm512_div_epu16(__m512i, __m512i);
extern __m512i _mm512_div_epu32(__m512i, __m512i);
extern __m512i _mm512_div_epu64(__m512i, __m512i);
extern __m512i _mm512_mask_div_epi32(__m512i , __mmask16, __m512i, __m512i);
extern __m512i _mm512_mask_div_epu32(__m512i , __mmask16, __m512i, __m512i);
extern __m512i _mm512_rem_epi8(__m512i, __m512i);
extern __m512i _mm512_rem_epi16(__m512i, __m512i);
extern __m512i _mm512_rem_epi32(__m512i, __m512i);
extern __m512i _mm512_rem_epi64(__m512i, __m512i);
extern __m512i _mm512_rem_epu8(__m512i, __m512i);
extern __m512i _mm512_rem_epu16(__m512i, __m512i);
extern __m512i _mm512_rem_epu32(__m512i, __m512i);
extern __m512i _mm512_rem_epu64(__m512i, __m512i);
extern __m512i _mm512_mask_rem_epi32(__m512i , __mmask16, __m512i, __m512i);
extern __m512i _mm512_mask_rem_epu32(__m512i , __mmask16, __m512i, __m512i);
extern __m512  _mm512_sin_ps(__m512);
extern __m512  _mm512_mask_sin_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_sin_pd(__m512d);
extern __m512d _mm512_mask_sin_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cos_ps(__m512);
extern __m512  _mm512_mask_cos_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cos_pd(__m512d);
extern __m512d _mm512_mask_cos_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_sincos_ps(__m512  * , __m512);
extern __m512  _mm512_mask_sincos_ps(__m512  * , __m512  , __m512  , __mmask16, __m512);
extern __m512d _mm512_sincos_pd(__m512d * , __m512d);
extern __m512d _mm512_mask_sincos_pd(__m512d * , __m512d , __m512d , __mmask8, __m512d);
extern __m512  _mm512_tan_ps(__m512);
extern __m512  _mm512_mask_tan_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_tan_pd(__m512d);
extern __m512d _mm512_mask_tan_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_asin_ps(__m512);
extern __m512  _mm512_mask_asin_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_asin_pd(__m512d);
extern __m512d _mm512_mask_asin_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_acos_ps(__m512);
extern __m512  _mm512_mask_acos_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_acos_pd(__m512d);
extern __m512d _mm512_mask_acos_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_atan_ps(__m512);
extern __m512  _mm512_mask_atan_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_atan_pd(__m512d);
extern __m512d _mm512_mask_atan_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_atan2_ps(__m512, __m512);
extern __m512  _mm512_mask_atan2_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_atan2_pd(__m512d, __m512d);
extern __m512d _mm512_mask_atan2_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_sind_ps(__m512);
extern __m512  _mm512_mask_sind_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_sind_pd(__m512d);
extern __m512d _mm512_mask_sind_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cosd_ps(__m512);
extern __m512  _mm512_mask_cosd_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cosd_pd(__m512d);
extern __m512d _mm512_mask_cosd_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_tand_ps(__m512);
extern __m512  _mm512_mask_tand_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_tand_pd(__m512d);
extern __m512d _mm512_mask_tand_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_sinh_ps(__m512);
extern __m512  _mm512_mask_sinh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_sinh_pd(__m512d);
extern __m512d _mm512_mask_sinh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cosh_ps(__m512);
extern __m512  _mm512_mask_cosh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cosh_pd(__m512d);
extern __m512d _mm512_mask_cosh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_tanh_ps(__m512);
extern __m512  _mm512_mask_tanh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_tanh_pd(__m512d);
extern __m512d _mm512_mask_tanh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_asinh_ps(__m512);
extern __m512  _mm512_mask_asinh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_asinh_pd(__m512d);
extern __m512d _mm512_mask_asinh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_acosh_ps(__m512);
extern __m512  _mm512_mask_acosh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_acosh_pd(__m512d);
extern __m512d _mm512_mask_acosh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_atanh_ps(__m512);
extern __m512  _mm512_mask_atanh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_atanh_pd(__m512d);
extern __m512d _mm512_mask_atanh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log_ps(__m512);
extern __m512  _mm512_mask_log_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log_pd(__m512d);
extern __m512d _mm512_mask_log_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log1p_ps(__m512);
extern __m512  _mm512_mask_log1p_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log1p_pd(__m512d);
extern __m512d _mm512_mask_log1p_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log10_ps(__m512);
extern __m512  _mm512_mask_log10_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log10_pd(__m512d);
extern __m512d _mm512_mask_log10_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log2_ps(__m512);
extern __m512  _mm512_mask_log2_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log2_pd(__m512d);
extern __m512d _mm512_mask_log2_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_logb_ps(__m512);
extern __m512  _mm512_mask_logb_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_logb_pd(__m512d);
extern __m512d _mm512_mask_logb_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_exp_ps(__m512);
extern __m512  _mm512_mask_exp_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_exp_pd(__m512d);
extern __m512d _mm512_mask_exp_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_exp10_ps(__m512);
extern __m512  _mm512_mask_exp10_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_exp10_pd(__m512d);
extern __m512d _mm512_mask_exp10_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_exp2_ps(__m512);
extern __m512  _mm512_mask_exp2_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_exp2_pd(__m512d);
extern __m512d _mm512_mask_exp2_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_expm1_ps(__m512);
extern __m512  _mm512_mask_expm1_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_expm1_pd(__m512d);
extern __m512d _mm512_mask_expm1_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_pow_ps(__m512, __m512);
extern __m512  _mm512_mask_pow_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_pow_pd(__m512d, __m512d);
extern __m512d _mm512_mask_pow_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_trunc_ps(__m512);
extern __m512  _mm512_mask_trunc_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_trunc_pd(__m512d);
extern __m512d _mm512_mask_trunc_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_floor_ps(__m512);
extern __m512  _mm512_mask_floor_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_floor_pd(__m512d);
extern __m512d _mm512_mask_floor_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_ceil_ps(__m512);
extern __m512  _mm512_mask_ceil_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_ceil_pd(__m512d);
extern __m512d _mm512_mask_ceil_pd(__m512d , __mmask8, __m512d);
extern __m512 _mm512_svml_round_ps(__m512);
extern __m512 _mm512_mask_svml_round_ps(__m512 , __mmask16, __m512);
extern __m512d _mm512_svml_round_pd(__m512d);
extern __m512d _mm512_mask_svml_round_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_fmod_ps(__m512, __m512);
extern __m512  _mm512_mask_fmod_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_fmod_pd(__m512d, __m512d);
extern __m512d _mm512_mask_fmod_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_rint_ps(__m512);
extern __m512  _mm512_mask_rint_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_rint_pd(__m512d);
extern __m512d _mm512_mask_rint_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_invsqrt_ps(__m512);
extern __m512  _mm512_mask_invsqrt_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_invsqrt_pd(__m512d);
extern __m512d _mm512_mask_invsqrt_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cbrt_ps(__m512);
extern __m512  _mm512_mask_cbrt_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cbrt_pd(__m512d);
extern __m512d _mm512_mask_cbrt_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_invcbrt_ps(__m512);
extern __m512  _mm512_mask_invcbrt_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_invcbrt_pd(__m512d);
extern __m512d _mm512_mask_invcbrt_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_hypot_ps(__m512, __m512);
extern __m512  _mm512_mask_hypot_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_hypot_pd(__m512d, __m512d);
extern __m512d _mm512_mask_hypot_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_cdfnorm_ps(__m512);
extern __m512  _mm512_mask_cdfnorm_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cdfnorm_pd(__m512d);
extern __m512d _mm512_mask_cdfnorm_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cdfnorminv_ps(__m512);
extern __m512  _mm512_mask_cdfnorminv_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cdfnorminv_pd(__m512d);
extern __m512d _mm512_mask_cdfnorminv_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erf_ps(__m512);
extern __m512  _mm512_mask_erf_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erf_pd(__m512d);
extern __m512d _mm512_mask_erf_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erfc_ps(__m512);
extern __m512  _mm512_mask_erfc_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erfc_pd(__m512d);
extern __m512d _mm512_mask_erfc_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erfcinv_ps(__m512);
extern __m512  _mm512_mask_erfcinv_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erfcinv_pd(__m512d);
extern __m512d _mm512_mask_erfcinv_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erfinv_ps(__m512);
extern __m512  _mm512_mask_erfinv_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erfinv_pd(__m512d);
extern __m512d _mm512_mask_erfinv_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_nearbyint_ps(__m512);
extern __m512  _mm512_mask_nearbyint_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_nearbyint_pd(__m512d);
extern __m512d _mm512_mask_nearbyint_pd(__m512d , __mmask8, __m512d);
}
#line 5962 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\zmmintrin.h"
#line 5965 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\zmmintrin.h"
#line 2379 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
#line 2381 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
#line 2382 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
#line 2383 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\immintrin.h"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_common_simd.inl"
namespace glm{
namespace detail
{
	template<qualifier Q>
	struct compute_abs_vector<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& v)
		{
			vec<4, float, Q> result;
			result.data = glm_vec4_abs(v.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_abs_vector<4, int, Q, true>
	{
		 inline static vec<4, int, Q> call(vec<4, int, Q> const& v)
		{
			vec<4, int, Q> result;
			result.data = glm_ivec4_abs(v.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_floor<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& v)
		{
			vec<4, float, Q> result;
			result.data = glm_vec4_floor(v.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_ceil<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& v)
		{
			vec<4, float, Q> result;
			result.data = glm_vec4_ceil(v.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_fract<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& v)
		{
			vec<4, float, Q> result;
			result.data = glm_vec4_fract(v.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_round<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& v)
		{
			vec<4, float, Q> result;
			result.data = glm_vec4_round(v.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_mod<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& x, vec<4, float, Q> const& y)
		{
			vec<4, float, Q> result;
			result.data = glm_vec4_mod(x.data, y.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_min_vector<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& v1, vec<4, float, Q> const& v2)
		{
			vec<4, float, Q> result;
			result.data = _mm_min_ps(v1.data, v2.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_min_vector<4, int32, Q, true>
	{
		 inline static vec<4, int32, Q> call(vec<4, int32, Q> const& v1, vec<4, int32, Q> const& v2)
		{
			vec<4, int32, Q> result;
			result.data = _mm_min_epi32(v1.data, v2.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_min_vector<4, uint32, Q, true>
	{
		 inline static vec<4, int32, Q> call(vec<4, uint32, Q> const& v1, vec<4, uint32, Q> const& v2)
		{
			vec<4, uint32, Q> result;
			result.data = _mm_min_epu32(v1.data, v2.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_max_vector<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& v1, vec<4, float, Q> const& v2)
		{
			vec<4, float, Q> result;
			result.data = _mm_max_ps(v1.data, v2.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_max_vector<4, int32, Q, true>
	{
		 inline static vec<4, int32, Q> call(vec<4, int32, Q> const& v1, vec<4, int32, Q> const& v2)
		{
			vec<4, int32, Q> result;
			result.data = _mm_max_epi32(v1.data, v2.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_max_vector<4, uint32, Q, true>
	{
		 inline static vec<4, uint32, Q> call(vec<4, uint32, Q> const& v1, vec<4, uint32, Q> const& v2)
		{
			vec<4, uint32, Q> result;
			result.data = _mm_max_epu32(v1.data, v2.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_clamp_vector<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& x, vec<4, float, Q> const& minVal, vec<4, float, Q> const& maxVal)
		{
			vec<4, float, Q> result;
			result.data = _mm_min_ps(_mm_max_ps(x.data, minVal.data), maxVal.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_clamp_vector<4, int32, Q, true>
	{
		 inline static vec<4, int32, Q> call(vec<4, int32, Q> const& x, vec<4, int32, Q> const& minVal, vec<4, int32, Q> const& maxVal)
		{
			vec<4, int32, Q> result;
			result.data = _mm_min_epi32(_mm_max_epi32(x.data, minVal.data), maxVal.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_clamp_vector<4, uint32, Q, true>
	{
		 inline static vec<4, uint32, Q> call(vec<4, uint32, Q> const& x, vec<4, uint32, Q> const& minVal, vec<4, uint32, Q> const& maxVal)
		{
			vec<4, uint32, Q> result;
			result.data = _mm_min_epu32(_mm_max_epu32(x.data, minVal.data), maxVal.data);
			return result;
		}
	};
	template<qualifier Q>
	struct compute_mix_vector<4, float, bool, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& x, vec<4, float, Q> const& y, vec<4, bool, Q> const& a)
		{
			__m128i const Load = _mm_set_epi32(-static_cast<int>(a.w), -static_cast<int>(a.z), -static_cast<int>(a.y), -static_cast<int>(a.x));
			__m128 const Mask = _mm_castsi128_ps(Load);
			vec<4, float, Q> Result;
#line 201 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_common_simd.inl"
				Result.data = _mm_or_ps(_mm_and_ps(Mask, y.data), _mm_andnot_ps(Mask, x.data));
#line 203 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_common_simd.inl"
			return Result;
		}
	};
	template<qualifier Q>
	struct compute_smoothstep_vector<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& edge0, vec<4, float, Q> const& edge1, vec<4, float, Q> const& x)
		{
			vec<4, float, Q> Result;
			Result.data = glm_vec4_smoothstep(edge0.data, edge1.data, x.data);
			return Result;
		}
	};
}
}
#line 232 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_common_simd.inl"
#line 826 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
#line 827 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_common.inl"
#line 534 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../common.hpp"
#line 6 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_geometric.inl"
namespace glm{
namespace detail
{
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_length
	{
		 inline static T call(vec<L, T, Q> const& v)
		{
			return sqrt(dot(v, v));
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_distance
	{
		 inline static T call(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
		{
			return length(p1 - p0);
		}
	};
	template<typename V, typename T, bool Aligned>
	struct compute_dot{};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<1, T, Q>, T, Aligned>
	{
		 inline static T call(vec<1, T, Q> const& a, vec<1, T, Q> const& b)
		{
			return a.x * b.x;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<2, T, Q>, T, Aligned>
	{
		 inline static T call(vec<2, T, Q> const& a, vec<2, T, Q> const& b)
		{
			vec<2, T, Q> tmp(a * b);
			return tmp.x + tmp.y;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<3, T, Q>, T, Aligned>
	{
		 inline static T call(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
		{
			vec<3, T, Q> tmp(a * b);
			return tmp.x + tmp.y + tmp.z;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<4, T, Q>, T, Aligned>
	{
		 inline static T call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			vec<4, T, Q> tmp(a * b);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_cross
	{
		 inline static vec<3, T, Q> call(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'cross' accepts only floating-point inputs");
			return vec<3, T, Q>(
				x.y * y.z - y.y * x.z,
				x.z * y.x - y.z * x.x,
				x.x * y.y - y.x * x.y);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_normalize
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");
			return v * inversesqrt(dot(v, v));
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_faceforward
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");
			return dot(Nref, I) < static_cast<T>(0) ? N : -N;
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_reflect
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
		{
			return I - N * dot(N, I) * static_cast<T>(2);
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_refract
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
		{
			T const dotValue(dot(N, I));
			T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
			return (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));
		}
	};
}
	template<typename genType>
	 inline genType length(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'length' accepts only floating-point inputs");
		return abs(x);
	}
	template<length_t L, typename T, qualifier Q>
	 inline T length(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'length' accepts only floating-point inputs");
		return detail::compute_length<L, T, Q, detail::is_aligned<Q>::value>::call(v);
	}
	template<typename genType>
	 inline genType distance(genType const& p0, genType const& p1)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'distance' accepts only floating-point inputs");
		return length(p1 - p0);
	}
	template<length_t L, typename T, qualifier Q>
	 inline T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
	{
		return detail::compute_distance<L, T, Q, detail::is_aligned<Q>::value>::call(p0, p1);
	}
	template<typename T>
	 inline T dot(T x, T y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
		return x * y;
	}
	template<length_t L, typename T, qualifier Q>
	 inline T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
		return detail::compute_dot<vec<L, T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
	}
	template<typename T, qualifier Q>
	 inline vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
	{
		return detail::compute_cross<T, Q, detail::is_aligned<Q>::value>::call(x, y);
	}
	template<typename genType>
	 inline genType normalize(genType const& x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'normalize' accepts only floating-point inputs");
		return x < genType(0) ? genType(-1) : genType(1);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> normalize(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");
		return detail::compute_normalize<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
	template<typename genType>
	 inline genType faceforward(genType const& N, genType const& I, genType const& Nref)
	{
		return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> faceforward(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
	{
		return detail::compute_faceforward<L, T, Q, detail::is_aligned<Q>::value>::call(N, I, Nref);
	}
	template<typename genType>
	 inline genType reflect(genType const& I, genType const& N)
	{
		return I - N * dot(N, I) * genType(2);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> reflect(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
	{
		return detail::compute_reflect<L, T, Q, detail::is_aligned<Q>::value>::call(I, N);
	}
	template<typename genType>
	 inline genType refract(genType const& I, genType const& N, genType eta)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'refract' accepts only floating-point inputs");
		genType const dotValue(dot(N, I));
		genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
		return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> refract(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'refract' accepts only floating-point inputs");
		return detail::compute_refract<L, T, Q, detail::is_aligned<Q>::value>::call(I, N, eta);
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_geometric_simd.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/geometric.h"
#pragma once
 glm_vec4 glm_vec4_dot(glm_vec4 v1, glm_vec4 v2);
 glm_vec4 glm_vec1_dot(glm_vec4 v1, glm_vec4 v2);
 inline glm_vec4 glm_vec4_length(glm_vec4 x)
{
	glm_vec4 const dot0 = glm_vec4_dot(x, x);
	glm_vec4 const sqt0 = _mm_sqrt_ps(dot0);
	return sqt0;
}
 inline glm_vec4 glm_vec4_distance(glm_vec4 p0, glm_vec4 p1)
{
	glm_vec4 const sub0 = _mm_sub_ps(p0, p1);
	glm_vec4 const len0 = glm_vec4_length(sub0);
	return len0;
}
 inline glm_vec4 glm_vec4_dot(glm_vec4 v1, glm_vec4 v2)
{
#line 32 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/geometric.h"
#line 37 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/geometric.h"
		glm_vec4 const mul0 = _mm_mul_ps(v1, v2);
		glm_vec4 const swp0 = _mm_shuffle_ps(mul0, mul0, (((2) << 6) | ((3) << 4) | ((0) << 2) | ((1))));
		glm_vec4 const add0 = _mm_add_ps(mul0, swp0);
		glm_vec4 const swp1 = _mm_shuffle_ps(add0, add0, (((0) << 6) | ((1) << 4) | ((2) << 2) | ((3))));
		glm_vec4 const add1 = _mm_add_ps(add0, swp1);
		return add1;
#line 44 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/geometric.h"
}
 inline glm_vec4 glm_vec1_dot(glm_vec4 v1, glm_vec4 v2)
{
#line 51 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/geometric.h"
#line 56 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/geometric.h"
		glm_vec4 const mul0 = _mm_mul_ps(v1, v2);
		glm_vec4 const mov0 = _mm_movehl_ps(mul0, mul0);
		glm_vec4 const add0 = _mm_add_ps(mov0, mul0);
		glm_vec4 const swp1 = _mm_shuffle_ps(add0, add0, 1);
		glm_vec4 const add1 = _mm_add_ss(add0, swp1);
		return add1;
#line 63 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/geometric.h"
}
 inline glm_vec4 glm_vec4_cross(glm_vec4 v1, glm_vec4 v2)
{
	glm_vec4 const swp0 = _mm_shuffle_ps(v1, v1, (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
	glm_vec4 const swp1 = _mm_shuffle_ps(v1, v1, (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))));
	glm_vec4 const swp2 = _mm_shuffle_ps(v2, v2, (((3) << 6) | ((0) << 4) | ((2) << 2) | ((1))));
	glm_vec4 const swp3 = _mm_shuffle_ps(v2, v2, (((3) << 6) | ((1) << 4) | ((0) << 2) | ((2))));
	glm_vec4 const mul0 = _mm_mul_ps(swp0, swp3);
	glm_vec4 const mul1 = _mm_mul_ps(swp1, swp2);
	glm_vec4 const sub0 = _mm_sub_ps(mul0, mul1);
	return sub0;
}
 inline glm_vec4 glm_vec4_normalize(glm_vec4 v)
{
	glm_vec4 const dot0 = glm_vec4_dot(v, v);
	glm_vec4 const isr0 = _mm_rsqrt_ps(dot0);
	glm_vec4 const mul0 = _mm_mul_ps(v, isr0);
	return mul0;
}
 inline glm_vec4 glm_vec4_faceforward(glm_vec4 N, glm_vec4 I, glm_vec4 Nref)
{
	glm_vec4 const dot0 = glm_vec4_dot(Nref, I);
	glm_vec4 const sgn0 = glm_vec4_sign(dot0);
	glm_vec4 const mul0 = _mm_mul_ps(sgn0, _mm_set_ps1(-1.0f));
	glm_vec4 const mul1 = _mm_mul_ps(N, mul0);
	return mul1;
}
 inline glm_vec4 glm_vec4_reflect(glm_vec4 I, glm_vec4 N)
{
	glm_vec4 const dot0 = glm_vec4_dot(N, I);
	glm_vec4 const mul0 = _mm_mul_ps(N, dot0);
	glm_vec4 const mul1 = _mm_mul_ps(mul0, _mm_set_ps1(2.0f));
	glm_vec4 const sub0 = _mm_sub_ps(I, mul1);
	return sub0;
}
 inline __m128 glm_vec4_refract(glm_vec4 I, glm_vec4 N, glm_vec4 eta)
{
	glm_vec4 const dot0 = glm_vec4_dot(N, I);
	glm_vec4 const mul0 = _mm_mul_ps(eta, eta);
	glm_vec4 const mul1 = _mm_mul_ps(dot0, dot0);
	glm_vec4 const sub0 = _mm_sub_ps(_mm_set_ps1(1.0f), mul0);
	glm_vec4 const sub1 = _mm_sub_ps(_mm_set_ps1(1.0f), mul1);
	glm_vec4 const mul2 = _mm_mul_ps(sub0, sub1);
	if(_mm_movemask_ps(_mm_cmplt_ss(mul2, _mm_set_ps1(0.0f))) == 0)
		return _mm_set_ps1(0.0f);
	glm_vec4 const sqt0 = _mm_sqrt_ps(mul2);
	glm_vec4 const mad0 = glm_vec4_fma(eta, dot0, sqt0);
	glm_vec4 const mul4 = _mm_mul_ps(mad0, N);
	glm_vec4 const mul5 = _mm_mul_ps(eta, I);
	glm_vec4 const sub2 = _mm_sub_ps(mul5, mul4);
	return sub2;
}
#line 125 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/geometric.h"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_geometric_simd.inl"
namespace glm{
namespace detail
{
	template<qualifier Q>
	struct compute_length<4, float, Q, true>
	{
		 inline static float call(vec<4, float, Q> const& v)
		{
			return _mm_cvtss_f32(glm_vec4_length(v.data));
		}
	};
	template<qualifier Q>
	struct compute_distance<4, float, Q, true>
	{
		 inline static float call(vec<4, float, Q> const& p0, vec<4, float, Q> const& p1)
		{
			return _mm_cvtss_f32(glm_vec4_distance(p0.data, p1.data));
		}
	};
	template<qualifier Q>
	struct compute_dot<vec<4, float, Q>, float, true>
	{
		 inline static float call(vec<4, float, Q> const& x, vec<4, float, Q> const& y)
		{
			return _mm_cvtss_f32(glm_vec1_dot(x.data, y.data));
		}
	};
	template<qualifier Q>
	struct compute_cross<float, Q, true>
	{
		 inline static vec<3, float, Q> call(vec<3, float, Q> const& a, vec<3, float, Q> const& b)
		{
			__m128 const set0 = _mm_set_ps(0.0f, a.z, a.y, a.x);
			__m128 const set1 = _mm_set_ps(0.0f, b.z, b.y, b.x);
			__m128 const xpd0 = glm_vec4_cross(set0, set1);
			vec<4, float, Q> Result;
			Result.data = xpd0;
			return vec<3, float, Q>(Result);
		}
	};
	template<qualifier Q>
	struct compute_normalize<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& v)
		{
			vec<4, float, Q> Result;
			Result.data = glm_vec4_normalize(v.data);
			return Result;
		}
	};
	template<qualifier Q>
	struct compute_faceforward<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& N, vec<4, float, Q> const& I, vec<4, float, Q> const& Nref)
		{
			vec<4, float, Q> Result;
			Result.data = glm_vec4_faceforward(N.data, I.data, Nref.data);
			return Result;
		}
	};
	template<qualifier Q>
	struct compute_reflect<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& I, vec<4, float, Q> const& N)
		{
			vec<4, float, Q> Result;
			Result.data = glm_vec4_reflect(I.data, N.data);
			return Result;
		}
	};
	template<qualifier Q>
	struct compute_refract<4, float, Q, true>
	{
		 inline static vec<4, float, Q> call(vec<4, float, Q> const& I, vec<4, float, Q> const& N, float eta)
		{
			vec<4, float, Q> Result;
			Result.data = glm_vec4_refract(I.data, N.data, _mm_set_ps1(eta));
			return Result;
		}
	};
}
}
#line 100 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_geometric_simd.inl"
#line 247 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_geometric.inl"
#line 248 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_geometric.inl"
#line 117 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../geometric.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_matrix.inl"
namespace glm{
namespace detail
{
	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_matrixCompMult
	{
		 inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
		{
			mat<C, R, T, Q> Result;
			for(length_t i = 0; i < Result.length(); ++i)
				Result[i] = x[i] * y[i];
			return Result;
		}
	};
	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_transpose{};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<2, 2, T, Q, Aligned>
	{
		 inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
		{
			mat<2, 2, T, Q> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			return Result;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<2, 3, T, Q, Aligned>
	{
		 inline static mat<3, 2, T, Q> call(mat<2, 3, T, Q> const& m)
		{
			mat<3,2, T, Q> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			return Result;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<2, 4, T, Q, Aligned>
	{
		 inline static mat<4, 2, T, Q> call(mat<2, 4, T, Q> const& m)
		{
			mat<4, 2, T, Q> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			return Result;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<3, 2, T, Q, Aligned>
	{
		 inline static mat<2, 3, T, Q> call(mat<3, 2, T, Q> const& m)
		{
			mat<2, 3, T, Q> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			return Result;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<3, 3, T, Q, Aligned>
	{
		 inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
		{
			mat<3, 3, T, Q> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			return Result;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<3, 4, T, Q, Aligned>
	{
		 inline static mat<4, 3, T, Q> call(mat<3, 4, T, Q> const& m)
		{
			mat<4, 3, T, Q> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			Result[3][2] = m[2][3];
			return Result;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<4, 2, T, Q, Aligned>
	{
		 inline static mat<2, 4, T, Q> call(mat<4, 2, T, Q> const& m)
		{
			mat<2, 4, T, Q> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];
			return Result;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<4, 3, T, Q, Aligned>
	{
		 inline static mat<3, 4, T, Q> call(mat<4, 3, T, Q> const& m)
		{
			mat<3, 4, T, Q> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[2][3] = m[3][2];
			return Result;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<4, 4, T, Q, Aligned>
	{
		 inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
		{
			mat<4, 4, T, Q> Result;
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[2][3] = m[3][2];
			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			Result[3][2] = m[2][3];
			Result[3][3] = m[3][3];
			return Result;
		}
	};
	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_determinant{};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_determinant<2, 2, T, Q, Aligned>
	{
		 inline static T call(mat<2, 2, T, Q> const& m)
		{
			return m[0][0] * m[1][1] - m[1][0] * m[0][1];
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_determinant<3, 3, T, Q, Aligned>
	{
		 inline static T call(mat<3, 3, T, Q> const& m)
		{
			return
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_determinant<4, 4, T, Q, Aligned>
	{
		 inline static T call(mat<4, 4, T, Q> const& m)
		{
			T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
			vec<4, T, Q> DetCof(
				+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
				- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
				+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
				- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));
			return
				m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
				m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
		}
	};
	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_inverse{};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_inverse<2, 2, T, Q, Aligned>
	{
		 inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * m[1][1]
				- m[1][0] * m[0][1]);
			mat<2, 2, T, Q> Inverse(
				+ m[1][1] * OneOverDeterminant,
				- m[0][1] * OneOverDeterminant,
				- m[1][0] * OneOverDeterminant,
				+ m[0][0] * OneOverDeterminant);
			return Inverse;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_inverse<3, 3, T, Q, Aligned>
	{
		 inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));
			mat<3, 3, T, Q> Inverse;
			Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
			Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
			Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
			Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
			Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;
			return Inverse;
		}
	};
	template<typename T, qualifier Q, bool Aligned>
	struct compute_inverse<4, 4, T, Q, Aligned>
	{
		 inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
		{
			T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
			T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
			T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
			T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
			T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
			T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
			T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
			T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
			T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
			T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
			T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
			T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
			T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];
			vec<4, T, Q> Fac0(Coef00, Coef00, Coef02, Coef03);
			vec<4, T, Q> Fac1(Coef04, Coef04, Coef06, Coef07);
			vec<4, T, Q> Fac2(Coef08, Coef08, Coef10, Coef11);
			vec<4, T, Q> Fac3(Coef12, Coef12, Coef14, Coef15);
			vec<4, T, Q> Fac4(Coef16, Coef16, Coef18, Coef19);
			vec<4, T, Q> Fac5(Coef20, Coef20, Coef22, Coef23);
			vec<4, T, Q> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
			vec<4, T, Q> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
			vec<4, T, Q> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
			vec<4, T, Q> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);
			vec<4, T, Q> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
			vec<4, T, Q> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
			vec<4, T, Q> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
			vec<4, T, Q> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);
			vec<4, T, Q> SignA(+1, -1, +1, -1);
			vec<4, T, Q> SignB(-1, +1, -1, +1);
			mat<4, 4, T, Q> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);
			vec<4, T, Q> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);
			vec<4, T, Q> Dot0(m[0] * Row0);
			T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);
			T OneOverDeterminant = static_cast<T>(1) / Dot1;
			return Inverse * OneOverDeterminant;
		}
	};
}
	template<length_t C, length_t R, typename T, qualifier Q>
	 inline mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'matrixCompMult' only accept floating-point inputs");
		return detail::compute_matrixCompMult<C, R, T, Q, detail::is_aligned<Q>::value>::call(x, y);
	}
	template<length_t DA, length_t DB, typename T, qualifier Q>
	 inline typename detail::outerProduct_trait<DA, DB, T, Q>::type outerProduct(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'outerProduct' only accept floating-point inputs");
		typename detail::outerProduct_trait<DA, DB, T, Q>::type m;
		for(length_t i = 0; i < m.length(); ++i)
			m[i] = c * r[i];
		return m;
	}
	template<length_t C, length_t R, typename T, qualifier Q>
	 inline typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'transpose' only accept floating-point inputs");
		return detail::compute_transpose<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
	}
	template<length_t C, length_t R, typename T, qualifier Q>
	 inline T determinant(mat<C, R, T, Q> const& m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'determinant' only accept floating-point inputs");
		return detail::compute_determinant<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
	}
	template<length_t C, length_t R, typename T, qualifier Q>
	 inline mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inverse' only accept floating-point inputs");
		return detail::compute_inverse<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_matrix_simd.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/matrix.h"
#pragma once
 inline void glm_mat4_matrixCompMult(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])
{
	out[0] = _mm_mul_ps(in1[0], in2[0]);
	out[1] = _mm_mul_ps(in1[1], in2[1]);
	out[2] = _mm_mul_ps(in1[2], in2[2]);
	out[3] = _mm_mul_ps(in1[3], in2[3]);
}
 inline void glm_mat4_add(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])
{
	out[0] = _mm_add_ps(in1[0], in2[0]);
	out[1] = _mm_add_ps(in1[1], in2[1]);
	out[2] = _mm_add_ps(in1[2], in2[2]);
	out[3] = _mm_add_ps(in1[3], in2[3]);
}
 inline void glm_mat4_sub(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])
{
	out[0] = _mm_sub_ps(in1[0], in2[0]);
	out[1] = _mm_sub_ps(in1[1], in2[1]);
	out[2] = _mm_sub_ps(in1[2], in2[2]);
	out[3] = _mm_sub_ps(in1[3], in2[3]);
}
 inline glm_vec4 glm_mat4_mul_vec4(glm_vec4 const m[4], glm_vec4 v)
{
	__m128 v0 = _mm_shuffle_ps(v, v, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 v1 = _mm_shuffle_ps(v, v, (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
	__m128 v2 = _mm_shuffle_ps(v, v, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
	__m128 v3 = _mm_shuffle_ps(v, v, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
	__m128 m0 = _mm_mul_ps(m[0], v0);
	__m128 m1 = _mm_mul_ps(m[1], v1);
	__m128 m2 = _mm_mul_ps(m[2], v2);
	__m128 m3 = _mm_mul_ps(m[3], v3);
	__m128 a0 = _mm_add_ps(m0, m1);
	__m128 a1 = _mm_add_ps(m2, m3);
	__m128 a2 = _mm_add_ps(a0, a1);
	return a2;
}
 inline __m128 glm_vec4_mul_mat4(glm_vec4 v, glm_vec4 const m[4])
{
	__m128 i0 = m[0];
	__m128 i1 = m[1];
	__m128 i2 = m[2];
	__m128 i3 = m[3];
	__m128 m0 = _mm_mul_ps(v, i0);
	__m128 m1 = _mm_mul_ps(v, i1);
	__m128 m2 = _mm_mul_ps(v, i2);
	__m128 m3 = _mm_mul_ps(v, i3);
	__m128 u0 = _mm_unpacklo_ps(m0, m1);
	__m128 u1 = _mm_unpackhi_ps(m0, m1);
	__m128 a0 = _mm_add_ps(u0, u1);
	__m128 u2 = _mm_unpacklo_ps(m2, m3);
	__m128 u3 = _mm_unpackhi_ps(m2, m3);
	__m128 a1 = _mm_add_ps(u2, u3);
	__m128 f0 = _mm_movelh_ps(a0, a1);
	__m128 f1 = _mm_movehl_ps(a1, a0);
	__m128 f2 = _mm_add_ps(f0, f1);
	return f2;
}
 inline void glm_mat4_mul(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])
{
	{
		__m128 e0 = _mm_shuffle_ps(in2[0], in2[0], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 e1 = _mm_shuffle_ps(in2[0], in2[0], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 e2 = _mm_shuffle_ps(in2[0], in2[0], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 e3 = _mm_shuffle_ps(in2[0], in2[0], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 m0 = _mm_mul_ps(in1[0], e0);
		__m128 m1 = _mm_mul_ps(in1[1], e1);
		__m128 m2 = _mm_mul_ps(in1[2], e2);
		__m128 m3 = _mm_mul_ps(in1[3], e3);
		__m128 a0 = _mm_add_ps(m0, m1);
		__m128 a1 = _mm_add_ps(m2, m3);
		__m128 a2 = _mm_add_ps(a0, a1);
		out[0] = a2;
	}
	{
		__m128 e0 = _mm_shuffle_ps(in2[1], in2[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 e1 = _mm_shuffle_ps(in2[1], in2[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 e2 = _mm_shuffle_ps(in2[1], in2[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 e3 = _mm_shuffle_ps(in2[1], in2[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 m0 = _mm_mul_ps(in1[0], e0);
		__m128 m1 = _mm_mul_ps(in1[1], e1);
		__m128 m2 = _mm_mul_ps(in1[2], e2);
		__m128 m3 = _mm_mul_ps(in1[3], e3);
		__m128 a0 = _mm_add_ps(m0, m1);
		__m128 a1 = _mm_add_ps(m2, m3);
		__m128 a2 = _mm_add_ps(a0, a1);
		out[1] = a2;
	}
	{
		__m128 e0 = _mm_shuffle_ps(in2[2], in2[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 e1 = _mm_shuffle_ps(in2[2], in2[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 e2 = _mm_shuffle_ps(in2[2], in2[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 e3 = _mm_shuffle_ps(in2[2], in2[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 m0 = _mm_mul_ps(in1[0], e0);
		__m128 m1 = _mm_mul_ps(in1[1], e1);
		__m128 m2 = _mm_mul_ps(in1[2], e2);
		__m128 m3 = _mm_mul_ps(in1[3], e3);
		__m128 a0 = _mm_add_ps(m0, m1);
		__m128 a1 = _mm_add_ps(m2, m3);
		__m128 a2 = _mm_add_ps(a0, a1);
		out[2] = a2;
	}
	{
		__m128 e0 = _mm_shuffle_ps(in2[3], in2[3], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 e1 = _mm_shuffle_ps(in2[3], in2[3], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 e2 = _mm_shuffle_ps(in2[3], in2[3], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 e3 = _mm_shuffle_ps(in2[3], in2[3], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 m0 = _mm_mul_ps(in1[0], e0);
		__m128 m1 = _mm_mul_ps(in1[1], e1);
		__m128 m2 = _mm_mul_ps(in1[2], e2);
		__m128 m3 = _mm_mul_ps(in1[3], e3);
		__m128 a0 = _mm_add_ps(m0, m1);
		__m128 a1 = _mm_add_ps(m2, m3);
		__m128 a2 = _mm_add_ps(a0, a1);
		out[3] = a2;
	}
}
 inline void glm_mat4_transpose(glm_vec4 const in[4], glm_vec4 out[4])
{
	__m128 tmp0 = _mm_shuffle_ps(in[0], in[1], 0x44);
	__m128 tmp2 = _mm_shuffle_ps(in[0], in[1], 0xEE);
	__m128 tmp1 = _mm_shuffle_ps(in[2], in[3], 0x44);
	__m128 tmp3 = _mm_shuffle_ps(in[2], in[3], 0xEE);
	out[0] = _mm_shuffle_ps(tmp0, tmp1, 0x88);
	out[1] = _mm_shuffle_ps(tmp0, tmp1, 0xDD);
	out[2] = _mm_shuffle_ps(tmp2, tmp3, 0x88);
	out[3] = _mm_shuffle_ps(tmp2, tmp3, 0xDD);
}
 inline glm_vec4 glm_mat4_determinant_highp(glm_vec4 const in[4])
{
	__m128 Fac0;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac0 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac1;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac1 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac2;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac2 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac3;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac3 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac4;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac4 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac5;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac5 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 SignA = _mm_set_ps( 1.0f,-1.0f, 1.0f,-1.0f);
	__m128 SignB = _mm_set_ps(-1.0f, 1.0f,-1.0f, 1.0f);
	__m128 Temp0 = _mm_shuffle_ps(in[1], in[0], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Vec0 = _mm_shuffle_ps(Temp0, Temp0, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Temp1 = _mm_shuffle_ps(in[1], in[0], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
	__m128 Vec1 = _mm_shuffle_ps(Temp1, Temp1, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Temp2 = _mm_shuffle_ps(in[1], in[0], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
	__m128 Vec2 = _mm_shuffle_ps(Temp2, Temp2, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Temp3 = _mm_shuffle_ps(in[1], in[0], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
	__m128 Vec3 = _mm_shuffle_ps(Temp3, Temp3, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Mul00 = _mm_mul_ps(Vec1, Fac0);
	__m128 Mul01 = _mm_mul_ps(Vec2, Fac1);
	__m128 Mul02 = _mm_mul_ps(Vec3, Fac2);
	__m128 Sub00 = _mm_sub_ps(Mul00, Mul01);
	__m128 Add00 = _mm_add_ps(Sub00, Mul02);
	__m128 Inv0 = _mm_mul_ps(SignB, Add00);
	__m128 Mul03 = _mm_mul_ps(Vec0, Fac0);
	__m128 Mul04 = _mm_mul_ps(Vec2, Fac3);
	__m128 Mul05 = _mm_mul_ps(Vec3, Fac4);
	__m128 Sub01 = _mm_sub_ps(Mul03, Mul04);
	__m128 Add01 = _mm_add_ps(Sub01, Mul05);
	__m128 Inv1 = _mm_mul_ps(SignA, Add01);
	__m128 Mul06 = _mm_mul_ps(Vec0, Fac1);
	__m128 Mul07 = _mm_mul_ps(Vec1, Fac3);
	__m128 Mul08 = _mm_mul_ps(Vec3, Fac5);
	__m128 Sub02 = _mm_sub_ps(Mul06, Mul07);
	__m128 Add02 = _mm_add_ps(Sub02, Mul08);
	__m128 Inv2 = _mm_mul_ps(SignB, Add02);
	__m128 Mul09 = _mm_mul_ps(Vec0, Fac2);
	__m128 Mul10 = _mm_mul_ps(Vec1, Fac4);
	__m128 Mul11 = _mm_mul_ps(Vec2, Fac5);
	__m128 Sub03 = _mm_sub_ps(Mul09, Mul10);
	__m128 Add03 = _mm_add_ps(Sub03, Mul11);
	__m128 Inv3 = _mm_mul_ps(SignA, Add03);
	__m128 Row0 = _mm_shuffle_ps(Inv0, Inv1, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row1 = _mm_shuffle_ps(Inv2, Inv3, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row2 = _mm_shuffle_ps(Row0, Row1, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
	__m128 Det0 = glm_vec4_dot(in[0], Row2);
	return Det0;
}
 inline glm_vec4 glm_mat4_determinant_lowp(glm_vec4 const m[4])
{
 	__m128 Swp2A = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[2]), (((0) << 6) | ((1) << 4) | ((1) << 2) | ((2)))));
 	__m128 Swp3A = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[3]), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((3)))));
	__m128 MulA = _mm_mul_ps(Swp2A, Swp3A);
	__m128 Swp2B = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[2]), (((3) << 6) | ((2) << 4) | ((3) << 2) | ((3)))));
	__m128 Swp3B = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[3]), (((0) << 6) | ((1) << 4) | ((1) << 2) | ((2)))));
	__m128 MulB = _mm_mul_ps(Swp2B, Swp3B);
	__m128 SubE = _mm_sub_ps(MulA, MulB);
	__m128 Swp2C = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[2]), (((0) << 6) | ((0) << 4) | ((1) << 2) | ((2)))));
	__m128 Swp3C = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[3]), (((1) << 6) | ((2) << 4) | ((0) << 2) | ((0)))));
	__m128 MulC = _mm_mul_ps(Swp2C, Swp3C);
	__m128 SubF = _mm_sub_ps(_mm_movehl_ps(MulC, MulC), MulC);
	__m128 SubFacA = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(SubE), (((2) << 6) | ((1) << 4) | ((0) << 2) | ((0)))));
	__m128 SwpFacA = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[1]), (((0) << 6) | ((0) << 4) | ((0) << 2) | ((1)))));
	__m128 MulFacA = _mm_mul_ps(SwpFacA, SubFacA);
	__m128 SubTmpB = _mm_shuffle_ps(SubE, SubF, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((1))));
	__m128 SubFacB = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(SubTmpB), (((3) << 6) | ((1) << 4) | ((1) << 2) | ((0)))));
	__m128 SwpFacB = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[1]), (((1) << 6) | ((1) << 4) | ((2) << 2) | ((2)))));
	__m128 MulFacB = _mm_mul_ps(SwpFacB, SubFacB);
	__m128 SubRes = _mm_sub_ps(MulFacA, MulFacB);
	__m128 SubTmpC = _mm_shuffle_ps(SubE, SubF, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((2))));
	__m128 SubFacC = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(SubTmpC), (((3) << 6) | ((3) << 4) | ((2) << 2) | ((0)))));
	__m128 SwpFacC = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(m[1]), (((2) << 6) | ((3) << 4) | ((3) << 2) | ((3)))));
	__m128 MulFacC = _mm_mul_ps(SwpFacC, SubFacC);
	__m128 AddRes = _mm_add_ps(SubRes, MulFacC);
	__m128 DetCof = _mm_mul_ps(AddRes, _mm_setr_ps( 1.0f,-1.0f, 1.0f,-1.0f));
	return glm_vec4_dot(m[0], DetCof);
}
 inline glm_vec4 glm_mat4_determinant(glm_vec4 const m[4])
{
 	__m128 Swp2A = _mm_shuffle_ps(m[2], m[2], (((0) << 6) | ((1) << 4) | ((1) << 2) | ((2))));
 	__m128 Swp3A = _mm_shuffle_ps(m[3], m[3], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((3))));
	__m128 MulA = _mm_mul_ps(Swp2A, Swp3A);
	__m128 Swp2B = _mm_shuffle_ps(m[2], m[2], (((3) << 6) | ((2) << 4) | ((3) << 2) | ((3))));
	__m128 Swp3B = _mm_shuffle_ps(m[3], m[3], (((0) << 6) | ((1) << 4) | ((1) << 2) | ((2))));
	__m128 MulB = _mm_mul_ps(Swp2B, Swp3B);
	__m128 SubE = _mm_sub_ps(MulA, MulB);
	__m128 Swp2C = _mm_shuffle_ps(m[2], m[2], (((0) << 6) | ((0) << 4) | ((1) << 2) | ((2))));
	__m128 Swp3C = _mm_shuffle_ps(m[3], m[3], (((1) << 6) | ((2) << 4) | ((0) << 2) | ((0))));
	__m128 MulC = _mm_mul_ps(Swp2C, Swp3C);
	__m128 SubF = _mm_sub_ps(_mm_movehl_ps(MulC, MulC), MulC);
	__m128 SubFacA = _mm_shuffle_ps(SubE, SubE, (((2) << 6) | ((1) << 4) | ((0) << 2) | ((0))));
	__m128 SwpFacA = _mm_shuffle_ps(m[1], m[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((1))));
	__m128 MulFacA = _mm_mul_ps(SwpFacA, SubFacA);
	__m128 SubTmpB = _mm_shuffle_ps(SubE, SubF, (((0) << 6) | ((0) << 4) | ((3) << 2) | ((1))));
	__m128 SubFacB = _mm_shuffle_ps(SubTmpB, SubTmpB, (((3) << 6) | ((1) << 4) | ((1) << 2) | ((0))));
	__m128 SwpFacB = _mm_shuffle_ps(m[1], m[1], (((1) << 6) | ((1) << 4) | ((2) << 2) | ((2))));
	__m128 MulFacB = _mm_mul_ps(SwpFacB, SubFacB);
	__m128 SubRes = _mm_sub_ps(MulFacA, MulFacB);
	__m128 SubTmpC = _mm_shuffle_ps(SubE, SubF, (((1) << 6) | ((0) << 4) | ((2) << 2) | ((2))));
	__m128 SubFacC = _mm_shuffle_ps(SubTmpC, SubTmpC, (((3) << 6) | ((3) << 4) | ((2) << 2) | ((0))));
	__m128 SwpFacC = _mm_shuffle_ps(m[1], m[1], (((2) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
	__m128 MulFacC = _mm_mul_ps(SwpFacC, SubFacC);
	__m128 AddRes = _mm_add_ps(SubRes, MulFacC);
	__m128 DetCof = _mm_mul_ps(AddRes, _mm_setr_ps( 1.0f,-1.0f, 1.0f,-1.0f));
	return glm_vec4_dot(m[0], DetCof);
}
 inline void glm_mat4_inverse(glm_vec4 const in[4], glm_vec4 out[4])
{
	__m128 Fac0;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac0 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac1;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac1 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac2;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac2 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac3;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac3 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac4;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac4 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac5;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac5 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 SignA = _mm_set_ps( 1.0f,-1.0f, 1.0f,-1.0f);
	__m128 SignB = _mm_set_ps(-1.0f, 1.0f,-1.0f, 1.0f);
	__m128 Temp0 = _mm_shuffle_ps(in[1], in[0], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Vec0 = _mm_shuffle_ps(Temp0, Temp0, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Temp1 = _mm_shuffle_ps(in[1], in[0], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
	__m128 Vec1 = _mm_shuffle_ps(Temp1, Temp1, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Temp2 = _mm_shuffle_ps(in[1], in[0], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
	__m128 Vec2 = _mm_shuffle_ps(Temp2, Temp2, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Temp3 = _mm_shuffle_ps(in[1], in[0], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
	__m128 Vec3 = _mm_shuffle_ps(Temp3, Temp3, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Mul00 = _mm_mul_ps(Vec1, Fac0);
	__m128 Mul01 = _mm_mul_ps(Vec2, Fac1);
	__m128 Mul02 = _mm_mul_ps(Vec3, Fac2);
	__m128 Sub00 = _mm_sub_ps(Mul00, Mul01);
	__m128 Add00 = _mm_add_ps(Sub00, Mul02);
	__m128 Inv0 = _mm_mul_ps(SignB, Add00);
	__m128 Mul03 = _mm_mul_ps(Vec0, Fac0);
	__m128 Mul04 = _mm_mul_ps(Vec2, Fac3);
	__m128 Mul05 = _mm_mul_ps(Vec3, Fac4);
	__m128 Sub01 = _mm_sub_ps(Mul03, Mul04);
	__m128 Add01 = _mm_add_ps(Sub01, Mul05);
	__m128 Inv1 = _mm_mul_ps(SignA, Add01);
	__m128 Mul06 = _mm_mul_ps(Vec0, Fac1);
	__m128 Mul07 = _mm_mul_ps(Vec1, Fac3);
	__m128 Mul08 = _mm_mul_ps(Vec3, Fac5);
	__m128 Sub02 = _mm_sub_ps(Mul06, Mul07);
	__m128 Add02 = _mm_add_ps(Sub02, Mul08);
	__m128 Inv2 = _mm_mul_ps(SignB, Add02);
	__m128 Mul09 = _mm_mul_ps(Vec0, Fac2);
	__m128 Mul10 = _mm_mul_ps(Vec1, Fac4);
	__m128 Mul11 = _mm_mul_ps(Vec2, Fac5);
	__m128 Sub03 = _mm_sub_ps(Mul09, Mul10);
	__m128 Add03 = _mm_add_ps(Sub03, Mul11);
	__m128 Inv3 = _mm_mul_ps(SignA, Add03);
	__m128 Row0 = _mm_shuffle_ps(Inv0, Inv1, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row1 = _mm_shuffle_ps(Inv2, Inv3, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row2 = _mm_shuffle_ps(Row0, Row1, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
	__m128 Det0 = glm_vec4_dot(in[0], Row2);
	__m128 Rcp0 = _mm_div_ps(_mm_set_ps1(1.0f), Det0);
	out[0] = _mm_mul_ps(Inv0, Rcp0);
	out[1] = _mm_mul_ps(Inv1, Rcp0);
	out[2] = _mm_mul_ps(Inv2, Rcp0);
	out[3] = _mm_mul_ps(Inv3, Rcp0);
}
 inline void glm_mat4_inverse_lowp(glm_vec4 const in[4], glm_vec4 out[4])
{
	__m128 Fac0;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac0 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac1;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac1 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac2;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac2 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac3;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac3 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac4;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac4 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 Fac5;
	{
		__m128 Swp0a = _mm_shuffle_ps(in[3], in[2], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Swp0b = _mm_shuffle_ps(in[3], in[2], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp00 = _mm_shuffle_ps(in[2], in[1], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, (((2) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
		__m128 Swp03 = _mm_shuffle_ps(in[2], in[1], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
		__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
		__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
		Fac5 = _mm_sub_ps(Mul00, Mul01);
	}
	__m128 SignA = _mm_set_ps( 1.0f,-1.0f, 1.0f,-1.0f);
	__m128 SignB = _mm_set_ps(-1.0f, 1.0f,-1.0f, 1.0f);
	__m128 Temp0 = _mm_shuffle_ps(in[1], in[0], (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Vec0 = _mm_shuffle_ps(Temp0, Temp0, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Temp1 = _mm_shuffle_ps(in[1], in[0], (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1))));
	__m128 Vec1 = _mm_shuffle_ps(Temp1, Temp1, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Temp2 = _mm_shuffle_ps(in[1], in[0], (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2))));
	__m128 Vec2 = _mm_shuffle_ps(Temp2, Temp2, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Temp3 = _mm_shuffle_ps(in[1], in[0], (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3))));
	__m128 Vec3 = _mm_shuffle_ps(Temp3, Temp3, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((0))));
	__m128 Mul00 = _mm_mul_ps(Vec1, Fac0);
	__m128 Mul01 = _mm_mul_ps(Vec2, Fac1);
	__m128 Mul02 = _mm_mul_ps(Vec3, Fac2);
	__m128 Sub00 = _mm_sub_ps(Mul00, Mul01);
	__m128 Add00 = _mm_add_ps(Sub00, Mul02);
	__m128 Inv0 = _mm_mul_ps(SignB, Add00);
	__m128 Mul03 = _mm_mul_ps(Vec0, Fac0);
	__m128 Mul04 = _mm_mul_ps(Vec2, Fac3);
	__m128 Mul05 = _mm_mul_ps(Vec3, Fac4);
	__m128 Sub01 = _mm_sub_ps(Mul03, Mul04);
	__m128 Add01 = _mm_add_ps(Sub01, Mul05);
	__m128 Inv1 = _mm_mul_ps(SignA, Add01);
	__m128 Mul06 = _mm_mul_ps(Vec0, Fac1);
	__m128 Mul07 = _mm_mul_ps(Vec1, Fac3);
	__m128 Mul08 = _mm_mul_ps(Vec3, Fac5);
	__m128 Sub02 = _mm_sub_ps(Mul06, Mul07);
	__m128 Add02 = _mm_add_ps(Sub02, Mul08);
	__m128 Inv2 = _mm_mul_ps(SignB, Add02);
	__m128 Mul09 = _mm_mul_ps(Vec0, Fac2);
	__m128 Mul10 = _mm_mul_ps(Vec1, Fac4);
	__m128 Mul11 = _mm_mul_ps(Vec2, Fac5);
	__m128 Sub03 = _mm_sub_ps(Mul09, Mul10);
	__m128 Add03 = _mm_add_ps(Sub03, Mul11);
	__m128 Inv3 = _mm_mul_ps(SignA, Add03);
	__m128 Row0 = _mm_shuffle_ps(Inv0, Inv1, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row1 = _mm_shuffle_ps(Inv2, Inv3, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0))));
	__m128 Row2 = _mm_shuffle_ps(Row0, Row1, (((2) << 6) | ((0) << 4) | ((2) << 2) | ((0))));
	__m128 Det0 = glm_vec4_dot(in[0], Row2);
	__m128 Rcp0 = _mm_rcp_ps(Det0);
	out[0] = _mm_mul_ps(Inv0, Rcp0);
	out[1] = _mm_mul_ps(Inv1, Rcp0);
	out[2] = _mm_mul_ps(Inv2, Rcp0);
	out[3] = _mm_mul_ps(Inv3, Rcp0);
}
 inline void glm_mat4_outerProduct(__m128 const& c, __m128 const& r, __m128 out[4])
{
	out[0] = _mm_mul_ps(c, _mm_shuffle_ps(r, r, (((0) << 6) | ((0) << 4) | ((0) << 2) | ((0)))));
	out[1] = _mm_mul_ps(c, _mm_shuffle_ps(r, r, (((1) << 6) | ((1) << 4) | ((1) << 2) | ((1)))));
	out[2] = _mm_mul_ps(c, _mm_shuffle_ps(r, r, (((2) << 6) | ((2) << 4) | ((2) << 2) | ((2)))));
	out[3] = _mm_mul_ps(c, _mm_shuffle_ps(r, r, (((3) << 6) | ((3) << 4) | ((3) << 2) | ((3)))));
}
#line 1029 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/matrix.h"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_matrix_simd.inl"
namespace glm{
namespace detail
{
	template<qualifier Q>
	struct compute_matrixCompMult<4, 4, float, Q, true>
	{
		static_assert(detail::is_aligned<Q>::value, "Specialization requires aligned");
		 inline static mat<4, 4, float, Q> call(mat<4, 4, float, Q> const& x, mat<4, 4, float, Q> const& y)
		{
			mat<4, 4, float, Q> Result;
			glm_mat4_matrixCompMult(
				*static_cast<glm_vec4 const (*)[4]>(&x[0].data),
				*static_cast<glm_vec4 const (*)[4]>(&y[0].data),
				*static_cast<glm_vec4(*)[4]>(&Result[0].data));
			return Result;
		}
	};
	template<qualifier Q>
	struct compute_transpose<4, 4, float, Q, true>
	{
		 inline static mat<4, 4, float, Q> call(mat<4, 4, float, Q> const& m)
		{
			mat<4, 4, float, Q> Result;
			glm_mat4_transpose(
				*static_cast<glm_vec4 const (*)[4]>(&m[0].data),
				*static_cast<glm_vec4(*)[4]>(&Result[0].data));
			return Result;
		}
	};
	template<qualifier Q>
	struct compute_determinant<4, 4, float, Q, true>
	{
		 inline static float call(mat<4, 4, float, Q> const& m)
		{
			return _mm_cvtss_f32(glm_mat4_determinant(*reinterpret_cast<__m128 const(*)[4]>(&m[0].data)));
		}
	};
	template<qualifier Q>
	struct compute_inverse<4, 4, float, Q, true>
	{
		 inline static mat<4, 4, float, Q> call(mat<4, 4, float, Q> const& m)
		{
			mat<4, 4, float, Q> Result;
			glm_mat4_inverse(*reinterpret_cast<__m128 const(*)[4]>(&m[0].data), *reinterpret_cast<__m128(*)[4]>(&Result[0].data));
			return Result;
		}
	};
}
	template<>
	 inline mat<4, 4, float, aligned_lowp> outerProduct<4, 4, float, aligned_lowp>(vec<4, float, aligned_lowp> const& c, vec<4, float, aligned_lowp> const& r)
	{
		__m128 NativeResult[4];
		glm_mat4_outerProduct(c.data, r.data, NativeResult);
		mat<4, 4, float, aligned_lowp> Result;
		std::memcpy(&Result[0], &NativeResult[0], sizeof(Result));
		return Result;
	}
	template<>
	 inline mat<4, 4, float, aligned_mediump> outerProduct<4, 4, float, aligned_mediump>(vec<4, float, aligned_mediump> const& c, vec<4, float, aligned_mediump> const& r)
	{
		__m128 NativeResult[4];
		glm_mat4_outerProduct(c.data, r.data, NativeResult);
		mat<4, 4, float, aligned_mediump> Result;
		std::memcpy(&Result[0], &NativeResult[0], sizeof(Result));
		return Result;
	}
	template<>
	 inline mat<4, 4, float, aligned_highp> outerProduct<4, 4, float, aligned_highp>(vec<4, float, aligned_highp> const& c, vec<4, float, aligned_highp> const& r)
	{
		__m128 NativeResult[4];
		glm_mat4_outerProduct(c.data, r.data, NativeResult);
		mat<4, 4, float, aligned_highp> Result;
		std::memcpy(&Result[0], &NativeResult[0], sizeof(Result));
		return Result;
	}
}
#line 96 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_matrix_simd.inl"
#line 400 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_matrix.inl"
#line 401 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_matrix.inl"
#line 165 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../matrix.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x2.inl"
namespace glm
{
#line 15 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x2.inl"
#line 24 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x2.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline mat<2, 2, T, Q>::mat(mat<2, 2, T, P> const& m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat(T scalar)
	{
		this->value[0] = col_type(scalar, 0);
		this->value[1] = col_type(0, scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat 
	(
		T const& x0, T const& y0,
		T const& x1, T const& y1
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat(col_type const& v0, col_type const& v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}
	template<typename T, qualifier Q>
	template<typename X1, typename Y1, typename X2, typename Y2>
	 inline mat<2, 2, T, Q>::mat 
	(
		X1 const& x1, Y1 const& y1,
		X2 const& x2, Y2 const& y2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
	}
	template<typename T, qualifier Q>
	template<typename V1, typename V2>
	 inline mat<2, 2, T, Q>::mat(vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline mat<2, 2, T, Q>::mat(mat<2, 2, U, P> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 2, T, Q>::col_type& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x2.inl", (unsigned)(151)), 0) );
		return this->value[i];
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 2, T, Q>::col_type const& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x2.inl", (unsigned)(158)), 0) );
		return this->value[i];
	}
#line 173 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_mat2x2.inl"
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator=(mat<2, 2, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(U scalar)
	{
		this->value[0] += scalar;
		this->value[1] += scalar;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(mat<2, 2, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(U scalar)
	{
		this->value[0] -= scalar;
		this->value[1] -= scalar;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(mat<2, 2, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(U scalar)
	{
		this->value[0] *= scalar;
		this->value[1] *= scalar;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(mat<2, 2, U, Q> const& m)
	{
		return (*this = *this * m);
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(U scalar)
	{
		this->value[0] /= scalar;
		this->value[1] /= scalar;
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(mat<2, 2, U, Q> const& m)
	{
		return *this *= inverse(m);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> mat<2, 2, T, Q>::operator++(int)
	{
		mat<2, 2, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> mat<2, 2, T, Q>::operator--(int)
	{
		mat<2, 2, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m)
	{
		return m;
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			-m[0], 
			-m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 2, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] - scalar,
			m[1] - scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			scalar - m[0],
			scalar - m[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 2, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 2, T, Q>::col_type operator*
	(
		mat<2, 2, T, Q> const& m,
		typename mat<2, 2, T, Q>::row_type const& v
	)
	{
		return vec<2, T, Q>(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y);
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 2, T, Q>::row_type operator*
	(
		typename mat<2, 2, T, Q>::col_type const& v,
		mat<2, 2, T, Q> const& m
	)
	{
		return vec<2, T, Q>(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1]);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
	}
	template<typename T, qualifier Q>
	 inline mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
	}
	template<typename T, qualifier Q>
	 inline mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] / scalar,
			m[1] / scalar);
	}
	template<typename T, qualifier Q> 
	 inline mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			scalar / m[0],
			scalar / m[1]);
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v)
	{
		return inverse(m) * v;
	}
	template<typename T, qualifier Q>
	 inline typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m)
	{
		return v *  inverse(m);
	}
	template<typename T, qualifier Q>
	 inline mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{	
		mat<2, 2, T, Q> m1_copy(m1);
		return m1_copy /= m2;
	}
	template<typename T, qualifier Q>
	 inline bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}
	template<typename T, qualifier Q>
	 inline bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 182 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat2x2.hpp"
#line 183 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/type_mat2x2.hpp"
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\mat2x2.hpp"
namespace glm
{
	typedef mat<2, 2, float, lowp>		lowp_mat2;
	typedef mat<2, 2, float, mediump>		mediump_mat2;
	typedef mat<2, 2, float, highp>		highp_mat2;
	typedef mat<2, 2, float, lowp>		lowp_mat2x2;
	typedef mat<2, 2, float, mediump>		mediump_mat2x2;
	typedef mat<2, 2, float, highp>		highp_mat2x2;
}
#line 101 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\trigonometric.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 20 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\trigonometric.hpp"
namespace glm
{
	template<length_t L, typename T, qualifier Q>
	 constexpr vec<L, T, Q> radians(vec<L, T, Q> const& degrees);
	template<length_t L, typename T, qualifier Q>
	 constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& radians);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> sin(vec<L, T, Q> const& angle);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> cos(vec<L, T, Q> const& angle);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> tan(vec<L, T, Q> const& angle);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> asin(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> acos(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> atan(vec<L, T, Q> const& y_over_x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> sinh(vec<L, T, Q> const& angle);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> cosh(vec<L, T, Q> const& angle);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> tanh(vec<L, T, Q> const& angle);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> asinh(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> acosh(vec<L, T, Q> const& x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> atanh(vec<L, T, Q> const& x);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_trigonometric.inl"
namespace glm
{
	template<typename genType>
	 inline constexpr genType radians(genType degrees)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'radians' only accept floating-point input");
		return degrees * static_cast<genType>(0.01745329251994329576923690768489);
	}
	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> radians(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(radians, v);
	}
	template<typename genType>
	 inline constexpr genType degrees(genType radians)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'degrees' only accept floating-point input");
		return radians * static_cast<genType>(57.295779513082320876798154814105);
	}
	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(degrees, v);
	}
	using ::std::sin;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> sin(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(sin, v);
	}
	using std::cos;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> cos(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(cos, v);
	}
	using std::tan;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> tan(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(tan, v);
	}
	using std::asin;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> asin(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(asin, v);
	}
	using std::acos;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> acos(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(acos, v);
	}
	template<typename genType>
	 inline genType atan(genType y, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'atan' only accept floating-point input");
		return ::std::atan2(y, x);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> atan(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
	{
		return detail::functor2<L, T, Q>::call(::std::atan2, a, b);
	}
	using std::atan;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> atan(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(atan, v);
	}
	using std::sinh;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> sinh(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(sinh, v);
	}
	using std::cosh;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> cosh(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(cosh, v);
	}
	using std::tanh;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> tanh(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(tanh, v);
	}
		using std::asinh;
#line 147 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_trigonometric.inl"
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> asinh(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(asinh, v);
	}
		using std::acosh;
#line 168 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_trigonometric.inl"
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> acosh(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(acosh, v);
	}
		using std::atanh;
#line 189 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_trigonometric.inl"
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> atanh(vec<L, T, Q> const& v)
	{
		return detail::functor1<L, T, T, Q>::call(atanh, v);
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_trigonometric_simd.inl"
#line 199 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_trigonometric.inl"
#line 200 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_trigonometric.inl"
#line 209 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\trigonometric.hpp"
#line 111 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\packing.hpp"
#pragma once
namespace glm
{
	 uint packUnorm2x16(vec2 const& v);
	 uint packSnorm2x16(vec2 const& v);
	 uint packUnorm4x8(vec4 const& v);
	 uint packSnorm4x8(vec4 const& v);
	 vec2 unpackUnorm2x16(uint p);
	 vec2 unpackSnorm2x16(uint p);
	 vec4 unpackUnorm4x8(uint p);
	 vec4 unpackSnorm4x8(uint p);
	 double packDouble2x32(uvec2 const& v);
	 uvec2 unpackDouble2x32(double v);
	 uint packHalf2x16(vec2 const& v);
	 vec2 unpackHalf2x16(uint v);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_packing.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_half.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\setup.hpp"
#line 7 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_half.hpp"
namespace glm{
namespace detail
{
	typedef short hdata;
	 float toFloat32(hdata value);
	 hdata toFloat16(float const& value);
}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_half.inl"
namespace glm{
namespace detail
{
	 inline float overflow()
	{
		volatile float f = 1e10;
		for(int i = 0; i < 10; ++i)	
			f *= f; 
		return f;
	}
	union uif32
	{
		 inline uif32() :
			i(0)
		{}
		 inline uif32(float f_) :
			f(f_)
		{}
		 inline uif32(uint32 i_) :
			i(i_)
		{}
		float f;
		uint32 i;
	};
	 inline float toFloat32(hdata value)
	{
		int s = (value >> 15) & 0x00000001;
		int e = (value >> 10) & 0x0000001f;
		int m =  value        & 0x000003ff;
		if(e == 0)
		{
			if(m == 0)
			{
				detail::uif32 result;
				result.i = static_cast<unsigned int>(s << 31);
				return result.f;
			}
			else
			{
				while(!(m & 0x00000400))
				{
					m <<= 1;
					e -=  1;
				}
				e += 1;
				m &= ~0x00000400;
			}
		}
		else if(e == 31)
		{
			if(m == 0)
			{
				uif32 result;
				result.i = static_cast<unsigned int>((s << 31) | 0x7f800000);
				return result.f;
			}
			else
			{
				uif32 result;
				result.i = static_cast<unsigned int>((s << 31) | 0x7f800000 | (m << 13));
				return result.f;
			}
		}
		e = e + (127 - 15);
		m = m << 13;
		uif32 Result;
		Result.i = static_cast<unsigned int>((s << 31) | (e << 23) | m);
		return Result.f;
	}
	 inline hdata toFloat16(float const& f)
	{
		uif32 Entry;
		Entry.f = f;
		int i = static_cast<int>(Entry.i);
		int s =  (i >> 16) & 0x00008000;
		int e = ((i >> 23) & 0x000000ff) - (127 - 15);
		int m =   i        & 0x007fffff;
		if(e <= 0)
		{
			if(e < -10)
			{
				return hdata(s);
			}
			m = (m | 0x00800000) >> (1 - e);
			if(m & 0x00001000) 
				m += 0x00002000;
			return hdata(s | (m >> 13));
		}
		else if(e == 0xff - (127 - 15))
		{
			if(m == 0)
			{
				return hdata(s | 0x7c00);
			}
			else
			{
				m >>= 13;
				return hdata(s | 0x7c00 | m | (m == 0));
			}
		}
		else
		{
			if(m &  0x00001000)
			{
				m += 0x00002000;
				if(m & 0x00800000)
				{
					m =  0;     
					e += 1;     
				}
			}
			if (e > 30)
			{
				overflow();        
				return hdata(s | 0x7c00);
			}   
			return hdata(s | (e << 10) | (m >> 13));
		}
	}
}
}
#line 20 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\type_half.hpp"
#line 6 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_packing.inl"
namespace glm
{
	 inline uint packUnorm2x16(vec2 const& v)
	{
		union
		{
			u16  in[2];
			uint out;
		} u;
		u16vec2 result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));
		u.in[0] = result[0];
		u.in[1] = result[1];
		return u.out;
	}
	 inline vec2 unpackUnorm2x16(uint p)
	{
		union
		{
			uint in;
			u16  out[2];
		} u;
		u.in = p;
		return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
	}
	 inline uint packSnorm2x16(vec2 const& v)
	{
		union
		{
			i16  in[2];
			uint out;
		} u;
		i16vec2 result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));
		u.in[0] = result[0];
		u.in[1] = result[1];
		return u.out;
	}
	 inline vec2 unpackSnorm2x16(uint p)
	{
		union
		{
			uint in;
			i16  out[2];
		} u;
		u.in = p;
		return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
	}
	 inline uint packUnorm4x8(vec4 const& v)
	{
		union
		{
			u8   in[4];
			uint out;
		} u;
		u8vec4 result(round(clamp(v, 0.0f, 1.0f) * 255.0f));
		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];
		return u.out;
	}
	 inline vec4 unpackUnorm4x8(uint p)
	{
		union
		{
			uint in;
			u8   out[4];
		} u;
		u.in = p;
		return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
	}
	 inline uint packSnorm4x8(vec4 const& v)
	{
		union
		{
			i8   in[4];
			uint out;
		} u;
		i8vec4 result(round(clamp(v, -1.0f, 1.0f) * 127.0f));
		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];
		return u.out;
	}
	 inline glm::vec4 unpackSnorm4x8(uint p)
	{
		union
		{
			uint in;
			i8   out[4];
		} u;
		u.in = p;
		return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
	}
	 inline double packDouble2x32(uvec2 const& v)
	{
		union
		{
			uint   in[2];
			double out;
		} u;
		u.in[0] = v[0];
		u.in[1] = v[1];
		return u.out;
	}
	 inline uvec2 unpackDouble2x32(double v)
	{
		union
		{
			double in;
			uint   out[2];
		} u;
		u.in = v;
		return uvec2(u.out[0], u.out[1]);
	}
	 inline uint packHalf2x16(vec2 const& v)
	{
		union
		{
			i16  in[2];
			uint out;
		} u;
		u.in[0] = detail::toFloat16(v.x);
		u.in[1] = detail::toFloat16(v.y);
		return u.out;
	}
	 inline vec2 unpackHalf2x16(uint v)
	{
		union
		{
			uint in;
			i16  out[2];
		} u;
		u.in = v;
		return vec2(
			detail::toFloat32(u.out[0]),
			detail::toFloat32(u.out[1]));
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_packing_simd.inl"
namespace glm{
namespace detail
{
}
}
#line 189 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_packing.inl"
#line 190 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_packing.inl"
#line 171 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\packing.hpp"
#line 114 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\integer.hpp"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 796 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 798 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/setup.hpp"
#line 18 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\integer.hpp"
namespace glm
{
	template<length_t L, qualifier Q>
	 vec<L, uint, Q> uaddCarry(
		vec<L, uint, Q> const& x,
		vec<L, uint, Q> const& y,
		vec<L, uint, Q> & carry);
	template<length_t L, qualifier Q>
	 vec<L, uint, Q> usubBorrow(
		vec<L, uint, Q> const& x,
		vec<L, uint, Q> const& y,
		vec<L, uint, Q> & borrow);
	template<length_t L, qualifier Q>
	 void umulExtended(
		vec<L, uint, Q> const& x,
		vec<L, uint, Q> const& y,
		vec<L, uint, Q> & msb,
		vec<L, uint, Q> & lsb);
	template<length_t L, qualifier Q>
	 void imulExtended(
		vec<L, int, Q> const& x,
		vec<L, int, Q> const& y,
		vec<L, int, Q> & msb,
		vec<L, int, Q> & lsb);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> bitfieldExtract(
		vec<L, T, Q> const& Value,
		int Offset,
		int Bits);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> bitfieldInsert(
		vec<L, T, Q> const& Base,
		vec<L, T, Q> const& Insert,
		int Offset,
		int Bits);
	template<length_t L, typename T, qualifier Q>
	 vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v);
	template<typename genType>
	 int bitCount(genType v);
	template<length_t L, typename T, qualifier Q>
	 vec<L, int, Q> bitCount(vec<L, T, Q> const& v);
	template<typename genIUType>
	 int findLSB(genIUType x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, int, Q> findLSB(vec<L, T, Q> const& v);
	template<typename genIUType>
	 int findMSB(genIUType x);
	template<length_t L, typename T, qualifier Q>
	 vec<L, int, Q> findMSB(vec<L, T, Q> const& v);
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
#pragma once
#line 24 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
#line 29 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
namespace glm
{
	template<typename T, qualifier Q>
	struct vec<1, T, Q>
	{
		typedef T value_type;
		typedef vec type;
		typedef vec<1, bool, Q> bool_type;
#line 50 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
#line 54 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
#line 59 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
			union
			{
				T x;
				T r;
				T s;
			};
#line 82 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
#line 85 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
#line 92 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
		typedef length_t length_type;
		 static constexpr length_type length(){return 1;}
		 T & operator[](length_type i);
		 T const& operator[](length_type i) const;
		 constexpr vec() = default;
		 constexpr vec(vec const& v) = default;
		template<qualifier P>
		 constexpr vec(vec<1, T, P> const& v);
		 constexpr explicit vec(T scalar);
		template<typename U, qualifier P>
		 constexpr  vec(vec<2, U, P> const& v);
		template<typename U, qualifier P>
		 constexpr  vec(vec<3, U, P> const& v);
		template<typename U, qualifier P>
		 constexpr  vec(vec<4, U, P> const& v);
		template<typename U, qualifier P>
		 constexpr  vec(vec<1, U, P> const& v);
		 vec & operator=(vec const& v) = default;
		template<typename U>
		 vec & operator=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator+=(U scalar);
		template<typename U>
		 vec & operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator-=(U scalar);
		template<typename U>
		 vec & operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator*=(U scalar);
		template<typename U>
		 vec & operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator/=(U scalar);
		template<typename U>
		 vec & operator/=(vec<1, U, Q> const& v);
		 vec & operator++();
		 vec & operator--();
		 vec operator++(int);
		 vec operator--(int);
		template<typename U>
		 vec & operator%=(U scalar);
		template<typename U>
		 vec & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator&=(U scalar);
		template<typename U>
		 vec & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator|=(U scalar);
		template<typename U>
		 vec & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator^=(U scalar);
		template<typename U>
		 vec & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator<<=(U scalar);
		template<typename U>
		 vec & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		 vec & operator>>=(U scalar);
		template<typename U>
		 vec & operator>>=(vec<1, U, Q> const& v);
	};
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator+(vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator-(vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 vec<1, T, Q> operator~(vec<1, T, Q> const& v);
	template<typename T, qualifier Q>
	 bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<typename T, qualifier Q>
	 bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);
	template<qualifier Q>
	 vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);
	template<qualifier Q>
	 vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);
	typedef vec<1, float, highp>		highp_vec1;
	typedef vec<1, float, mediump>		mediump_vec1;
	typedef vec<1, float, lowp>			lowp_vec1;
	typedef vec<1, double, highp>		highp_dvec1;
	typedef vec<1, double, mediump>		mediump_dvec1;
	typedef vec<1, double, lowp>		lowp_dvec1;
	typedef vec<1, int, highp>			highp_ivec1;
	typedef vec<1, int, mediump>		mediump_ivec1;
	typedef vec<1, int, lowp>			lowp_ivec1;
	typedef vec<1, uint, highp>			highp_uvec1;
	typedef vec<1, uint, mediump>		mediump_uvec1;
	typedef vec<1, uint, lowp>			lowp_uvec1;
	typedef vec<1, bool, highp>			highp_bvec1;
	typedef vec<1, bool, mediump>		mediump_bvec1;
	typedef vec<1, bool, lowp>			lowp_bvec1;
	template <typename T, qualifier Q = defaultp> using tvec1 = vec<1, T, Q>;
#line 392 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\ext\\../detail/type_vec1.inl"
namespace glm
{
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\ext\\../detail/type_vec1.inl"
#line 20 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\ext\\../detail/type_vec1.inl"
	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<1, T, P> const& v)
		: x(v.x)
	{}
	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q>::vec(T scalar)
		: x(scalar)
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<1, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<2, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<3, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}
	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}
	template<typename T, qualifier Q>
	 inline T & vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type i)
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\ext\\../detail/type_vec1.inl", (unsigned)(65)), 0) );
		return (&x)[i];
	}
	template<typename T, qualifier Q>
	 inline T const& vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type i) const
	{
		(void)( (!!(i >= 0 && i < this->length())) || (_wassert(L"i >= 0 && i < this->length()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\ext\\../detail/type_vec1.inl", (unsigned)(72)), 0) );
		return (&x)[i];
	}
#line 86 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\ext\\../detail/type_vec1.inl"
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator=(vec<1, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> & vec<1, T, Q>::operator++()
	{
		++this->x;
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> & vec<1, T, Q>::operator--()
	{
		--this->x;
		return *this;
	}
	template<typename T, qualifier Q> 
	 inline vec<1, T, Q> vec<1, T, Q>::operator++(int)
	{
		vec<1, T, Q> Result(*this);
		++*this;
		return Result;
	}
	template<typename T, qualifier Q> 
	 inline vec<1, T, Q> vec<1, T, Q>::operator--(int)
	{
		vec<1, T, Q> Result(*this);
		--*this;
		return Result;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		this->x %= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		this->x &= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		this->x |= U(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		this->x ^= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		return *this;
	}
	template<typename T, qualifier Q>
	template<typename U> 
	 inline vec<1, T, Q> & vec<1, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		return *this;
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator+(vec<1, T, Q> const& v)
	{
		return v;
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator-(vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			-v.x);
	}
	template<typename T, qualifier Q> 
	 inline vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x + scalar);
	}
	template<typename T, qualifier Q> 
	 inline vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar + v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x + v2.x);
	}
	template<typename T, qualifier Q> 
	 inline vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x - scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar - v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x - v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x * scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar * v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x * v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x / scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar / v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x / v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x % scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar % v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x % v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x & scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar & v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x & v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x | scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar | v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x | v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x ^ scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar ^ v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x ^ v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			static_cast<T>(v.x << scalar));
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar << v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x << v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x >> scalar);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar >> v.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x >> v2.x);
	}
	template<typename T, qualifier Q>
	 inline vec<1, T, Q> operator~(vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			~v.x);
	}
	template<typename T, qualifier Q> 
	 inline bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return detail::compute_equal<T>::call(v1.x, v2.x);
	}
	template<typename T, qualifier Q> 
	 inline bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return !(v1 == v2);
	}
	template<qualifier Q>
	 inline vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
	{
		return vec<1, bool, Q>(v1.x && v2.x);
	}
	template<qualifier Q>
	 inline vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
	{
		return vec<1, bool, Q>(v1.x || v2.x);
	}
}
#line 398 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
#line 399 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../ext/vec1.hpp"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\setjmp.h"
#pragma once
__pragma(pack(push, 8)) extern "C" {
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\setjmp.h"
    typedef struct __declspec(align(16)) _SETJMP_FLOAT128
    {
        unsigned __int64 Part[2];
    } SETJMP_FLOAT128;
    typedef SETJMP_FLOAT128 _JBTYPE;
    typedef struct _JUMP_BUFFER
    {
        unsigned __int64 Frame;
        unsigned __int64 Rbx;
        unsigned __int64 Rsp;
        unsigned __int64 Rbp;
        unsigned __int64 Rsi;
        unsigned __int64 Rdi;
        unsigned __int64 R12;
        unsigned __int64 R13;
        unsigned __int64 R14;
        unsigned __int64 R15;
        unsigned __int64 Rip;
        unsigned long MxCsr;
        unsigned short FpCsr;
        unsigned short Spare;
        SETJMP_FLOAT128 Xmm6;
        SETJMP_FLOAT128 Xmm7;
        SETJMP_FLOAT128 Xmm8;
        SETJMP_FLOAT128 Xmm9;
        SETJMP_FLOAT128 Xmm10;
        SETJMP_FLOAT128 Xmm11;
        SETJMP_FLOAT128 Xmm12;
        SETJMP_FLOAT128 Xmm13;
        SETJMP_FLOAT128 Xmm14;
        SETJMP_FLOAT128 Xmm15;
    } _JUMP_BUFFER;
#line 139 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\setjmp.h"
    typedef _JBTYPE jmp_buf[16];
#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\setjmp.h"
#line 153 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\setjmp.h"
int __cdecl _setjmp(
      jmp_buf _Buf
    );
    __declspec(noreturn) void __cdecl longjmp(
          jmp_buf _Buf,
          int     _Value
        ) noexcept(false);
#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\setjmp.h"
} __pragma(pack(pop))
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
        #line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
#pragma once
#line 18 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
#line 26 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
#line 30 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
extern "C" { 
#line 34 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);
__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);
__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);
__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);
__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);
__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);
__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);
__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);
void __llwpcb(void *);
void *__slwpcb();
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);
void __lwpval64(unsigned __int64, unsigned int, unsigned int);
unsigned char __lwpins64(unsigned __int64, unsigned int, unsigned int);
#line 258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);
unsigned __int64 _bextr_u64(unsigned __int64, unsigned int, unsigned int);
unsigned __int64 _andn_u64(unsigned __int64, unsigned __int64);
unsigned __int64 _tzcnt_u64(unsigned __int64);
unsigned __int64 _lzcnt_u64(unsigned __int64);
unsigned __int64 _blsr_u64(unsigned __int64);
unsigned __int64 _blsmsk_u64(unsigned __int64);
unsigned __int64 _blsi_u64(unsigned __int64);
#line 276 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);
unsigned __int64 _bextri_u64(unsigned __int64, unsigned int);
unsigned __int64 _blcfill_u64(unsigned __int64);
unsigned __int64 _blsfill_u64(unsigned __int64);
unsigned __int64 _blcs_u64(unsigned __int64);
unsigned __int64 _tzmsk_u64(unsigned __int64);
unsigned __int64 _blcic_u64(unsigned __int64);
unsigned __int64 _blsic_u64(unsigned __int64);
unsigned __int64 _t1mskc_u64(unsigned __int64);
unsigned __int64 _blcmsk_u64(unsigned __int64);
unsigned __int64 _blci_u64(unsigned __int64);
#line 300 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);
void _mm_clzero(void const *);
}; 
#line 309 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
#line 311 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
#line 312 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
#line 313 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\ammintrin.h"
#line 31 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
    #line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
#line 36 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
#line 41 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
#line 46 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
extern "C" {
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
void * _AddressOfReturnAddress(void);
short _InterlockedAnd16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedAnd64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedAnd8_np(char volatile * _Value, char _Mask);
long _InterlockedAnd_np(long volatile * _Value, long _Mask);
unsigned char _InterlockedCompareExchange128(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);
unsigned char _InterlockedCompareExchange128_np(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);
short _InterlockedCompareExchange16_np(short volatile * _Destination, short _Exchange, short _Comparand);
__int64 _InterlockedCompareExchange64_np(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);
void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);
void * _InterlockedCompareExchangePointer_np(void * volatile * _Destination, void * _Exchange, void * _Comparand);
long _InterlockedCompareExchange_np(long volatile * _Destination, long _Exchange, long _Comparand);
short _InterlockedDecrement16(short volatile * _Addend);
__int64 _InterlockedDecrement64(__int64 volatile * _Addend);
void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);
short _InterlockedIncrement16(short volatile * _Addend);
__int64 _InterlockedIncrement64(__int64 volatile * _Addend);
short _InterlockedOr16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedOr64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedOr8_np(char volatile * _Value, char _Mask);
long _InterlockedOr_np(long volatile * _Value, long _Mask);
short _InterlockedXor16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedXor64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedXor8_np(char volatile * _Value, char _Mask);
long _InterlockedXor_np(long volatile * _Value, long _Mask);
void _ReadBarrier(void);
void * _ReturnAddress(void);
void _WriteBarrier(void);
void __addgsbyte(unsigned long, unsigned char);
void __addgsdword(unsigned long, unsigned long);
void __addgsqword(unsigned long, unsigned __int64);
void __addgsword(unsigned long, unsigned short);
void __clts(void);
void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);
__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);
void __faststorefence(void);
unsigned int __getcallerseflags(void);
void __halt(void);
unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);
void __incgsbyte(unsigned long);
void __incgsdword(unsigned long);
void __incgsqword(unsigned long);
void __incgsword(unsigned long);
unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);
void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);
void __movsq(unsigned long long *, unsigned long long const *, size_t);
void __movsw(unsigned short *, unsigned short const *, size_t);
__int64 __mulh(__int64, __int64);
void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);
unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);
unsigned __int64 __readcr0(void);
unsigned __int64 __readcr2(void);
unsigned __int64 __readcr3(void);
unsigned __int64 __readcr4(void);
unsigned __int64 __readcr8(void);
unsigned __int64 __readdr(unsigned int);
unsigned __int64 __readeflags(void);
unsigned char __readgsbyte(unsigned long);
unsigned long __readgsdword(unsigned long);
unsigned __int64 __readgsqword(unsigned long);
unsigned short __readgsword(unsigned long);
unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);
unsigned long __segmentlimit(unsigned long);
unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
void __sidt(void *);
void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);
void __stosq(unsigned __int64 *, unsigned __int64, size_t);
void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);
void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);
unsigned __int64 __umulh(unsigned __int64, unsigned __int64);
void __vmx_off(void);
unsigned char __vmx_on(unsigned __int64 *);
unsigned char __vmx_vmclear(unsigned __int64 *);
unsigned char __vmx_vmlaunch(void);
unsigned char __vmx_vmptrld(unsigned __int64 *);
void __vmx_vmptrst(unsigned __int64 *);
unsigned char __vmx_vmread(size_t, size_t *);
unsigned char __vmx_vmresume(void);
unsigned char __vmx_vmwrite(size_t, size_t);
void __wbinvd(void);
void __writecr0(unsigned __int64);
void __writecr2(unsigned __int64);
void __writecr3(unsigned __int64);
void __writecr4(unsigned __int64);
void __writecr8(unsigned __int64);
void __writedr(unsigned int, unsigned __int64);
void __writeeflags(unsigned __int64);
void __writegsbyte(unsigned long, unsigned char);
void __writegsdword(unsigned long, unsigned long);
void __writegsqword(unsigned long, unsigned __int64);
void __writegsword(unsigned long, unsigned short);
void __writemsr(unsigned long, unsigned __int64);
unsigned char _bittest64(__int64 const *, __int64);
unsigned char _bittestandcomplement(long *, long);
unsigned char _bittestandcomplement64(__int64 *, __int64);
unsigned char _bittestandreset(long *, long);
unsigned char _bittestandreset64(__int64 *, __int64);
unsigned char _bittestandset(long *, long);
unsigned char _bittestandset64(__int64 *, __int64);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64);
  unsigned long __cdecl _byteswap_ulong(  unsigned long);
  unsigned short __cdecl _byteswap_ushort(  unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);
unsigned char _interlockedbittestandreset64(__int64 volatile *, __int64);
unsigned char _interlockedbittestandset64(__int64 volatile *, __int64);
  unsigned long __cdecl _lrotl(  unsigned long,   int);
  unsigned long __cdecl _lrotr(  unsigned long,   int);
void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);
__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);
__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);
__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);
__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
void _mm_clflushopt(void const *);
void _mm_clwb(void const *);
void _mm_clzero(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);
unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64);
unsigned int _mm_crc32_u8(unsigned int, unsigned char);
__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);
__m128 _mm_cvtpd_ps(__m128d);
__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);
__int64 _mm_cvtsd_si64(__m128d);
__int64 _mm_cvtsd_si64x(__m128d);
__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);
__int64 _mm_cvtsi128_si64(__m128i);
__int64 _mm_cvtsi128_si64x(__m128i);
__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);
__m128d _mm_cvtsi64_sd(__m128d, __int64);
__m128i _mm_cvtsi64_si128(__int64);
__m128 _mm_cvtsi64_ss(__m128, __int64);
__m128d _mm_cvtsi64x_sd(__m128d, __int64);
__m128i _mm_cvtsi64x_si128(__int64);
__m128 _mm_cvtsi64x_ss(__m128, __int64);
__m128d _mm_cvtss_sd(__m128d, __m128);
__int64 _mm_cvtss_si64(__m128);
__int64 _mm_cvtss_si64x(__m128);
int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);
__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);
__int64 _mm_cvttsd_si64(__m128d);
__int64 _mm_cvttsd_si64x(__m128d);
__int64 _mm_cvttss_si64(__m128);
__int64 _mm_cvttss_si64x(__m128);
__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);
__int64 _mm_extract_epi64(__m128i, int);
int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);
__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);
__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);
__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);
__m128i _mm_insert_epi64(__m128i, __int64, int);
__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);
void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);
__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);
__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
void _mm_pause(void);
int _mm_popcnt_u32(unsigned int);
__int64 _mm_popcnt_u64(unsigned __int64);
void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);
__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);
__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);
__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);
__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);
__m128i _mm_setr_epi64x(__int64, __int64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);
__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);
void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);
__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);
__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);
#line 858 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
__m128i _mm_stream_load_si128(const __m128i *);
#line 860 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
void _mm_stream_pd(double *, __m128d);
void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);
void _mm_stream_si64x(__int64 *, __int64);
void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);
__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);
__int64 _mul128(__int64 _Multiplier, __int64 _Multiplicand, __int64 * _HighProduct);
unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);
int __cdecl _setjmpex(jmp_buf);
void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);
}
#line 941 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
#line 942 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
#line 943 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\intrin.h"
#line 12 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
#pragma intrinsic(_BitScanReverse)
#line 14 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
#line 24 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
namespace glm{
namespace detail
{
	template<typename T>
	 inline T mask(T Bits)
	{
		return Bits >= static_cast<T>(sizeof(T) * 8) ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
	}
	template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
	struct compute_bitfieldReverseStep
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
		{
			return v;
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_bitfieldReverseStep<L, T, Q, Aligned, true>
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
		{
			return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
	struct compute_bitfieldBitCountStep
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
		{
			return v;
		}
	};
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_bitfieldBitCountStep<L, T, Q, Aligned, true>
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
		{
			return (v & Mask) + ((v >> Shift) & Mask);
		}
	};
	template<typename genIUType, size_t Bits>
	struct compute_findLSB
	{
		 inline static int call(genIUType Value)
		{
			if(Value == 0)
				return -1;
			return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
		}
	};
		template<typename genIUType>
		struct compute_findLSB<genIUType, 32>
		{
			 inline static int call(genIUType Value)
			{
				unsigned long Result(0);
				unsigned char IsNotNull = _BitScanForward(&Result, *reinterpret_cast<unsigned long*>(&Value));
				return IsNotNull ? int(Result) : -1;
			}
		};
		template<typename genIUType>
		struct compute_findLSB<genIUType, 64>
		{
			 inline static int call(genIUType Value)
			{
				unsigned long Result(0);
				unsigned char IsNotNull = _BitScanForward64(&Result, *reinterpret_cast<unsigned __int64*>(&Value));
				return IsNotNull ? int(Result) : -1;
			}
		};
#line 106 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
#line 107 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
	template<length_t L, typename T, qualifier Q, bool EXEC = true>
	struct compute_findMSB_step_vec
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T Shift)
		{
			return x | (x >> Shift);
		}
	};
	template<length_t L, typename T, qualifier Q>
	struct compute_findMSB_step_vec<L, T, Q, false>
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T)
		{
			return x;
		}
	};
	template<length_t L, typename T, qualifier Q, int>
	struct compute_findMSB_vec
	{
		 inline static vec<L, int, Q> call(vec<L, T, Q> const& v)
		{
			vec<L, T, Q> x(v);
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 1));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 2));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 4));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
			return vec<L, int, Q>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
		}
	};
		template<typename genIUType>
		 inline int compute_findMSB_32(genIUType Value)
		{
			unsigned long Result(0);
			unsigned char IsNotNull = _BitScanReverse(&Result, *reinterpret_cast<unsigned long*>(&Value));
			return IsNotNull ? int(Result) : -1;
		}
		template<length_t L, typename T, qualifier Q>
		struct compute_findMSB_vec<L, T, Q, 32>
		{
			 inline static vec<L, int, Q> call(vec<L, T, Q> const& x)
			{
				return detail::functor1<L, int, T, Q>::call(compute_findMSB_32, x);
			}
		};
		template<typename genIUType>
		 inline int compute_findMSB_64(genIUType Value)
		{
			unsigned long Result(0);
			unsigned char IsNotNull = _BitScanReverse64(&Result, *reinterpret_cast<unsigned __int64*>(&Value));
			return IsNotNull ? int(Result) : -1;
		}
		template<length_t L, typename T, qualifier Q>
		struct compute_findMSB_vec<L, T, Q, 64>
		{
			 inline static vec<L, int, Q> call(vec<L, T, Q> const& x)
			{
				return detail::functor1<L, int, T, Q>::call(compute_findMSB_64, x);
			}
		};
#line 178 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
#line 179 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
}
	 inline uint uaddCarry(uint const& x, uint const& y, uint & Carry)
	{
		uint64 const Value64(static_cast<uint64>(x) + static_cast<uint64>(y));
		uint64 const Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
		Carry = Value64 > Max32 ? 1u : 0u;
		return static_cast<uint32>(Value64 % (Max32 + static_cast<uint64>(1)));
	}
	template<length_t L, qualifier Q>
	 inline vec<L, uint, Q> uaddCarry(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Carry)
	{
		vec<L, uint64, Q> Value64(vec<L, uint64, Q>(x) + vec<L, uint64, Q>(y));
		vec<L, uint64, Q> Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
		Carry = mix(vec<L, uint32, Q>(0), vec<L, uint32, Q>(1), greaterThan(Value64, Max32));
		return vec<L, uint32, Q>(Value64 % (Max32 + static_cast<uint64>(1)));
	}
	 inline uint usubBorrow(uint const& x, uint const& y, uint & Borrow)
	{
		static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");
		Borrow = x >= y ? static_cast<uint32>(0) : static_cast<uint32>(1);
		if(y >= x)
			return y - x;
		else
			return static_cast<uint32>((static_cast<int64>(1) << static_cast<int64>(32)) + (static_cast<int64>(y) - static_cast<int64>(x)));
	}
	template<length_t L, qualifier Q>
	 inline vec<L, uint, Q> usubBorrow(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Borrow)
	{
		Borrow = mix(vec<L, uint, Q>(1), vec<L, uint, Q>(0), greaterThanEqual(x, y));
		vec<L, uint, Q> const YgeX(y - x);
		vec<L, uint, Q> const XgeY(vec<L, uint32, Q>((static_cast<int64>(1) << static_cast<int64>(32)) + (vec<L, int64, Q>(y) - vec<L, int64, Q>(x))));
		return mix(XgeY, YgeX, greaterThanEqual(y, x));
	}
	 inline void umulExtended(uint const& x, uint const& y, uint & msb, uint & lsb)
	{
		static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");
		uint64 Value64 = static_cast<uint64>(x) * static_cast<uint64>(y);
		msb = static_cast<uint>(Value64 >> static_cast<uint64>(32));
		lsb = static_cast<uint>(Value64);
	}
	template<length_t L, qualifier Q>
	 inline void umulExtended(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& msb, vec<L, uint, Q>& lsb)
	{
		static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");
		vec<L, uint64, Q> Value64(vec<L, uint64, Q>(x) * vec<L, uint64, Q>(y));
		msb = vec<L, uint32, Q>(Value64 >> static_cast<uint64>(32));
		lsb = vec<L, uint32, Q>(Value64);
	}
	 inline void imulExtended(int x, int y, int& msb, int& lsb)
	{
		static_assert(sizeof(int) == sizeof(int32), "int and int32 size mismatch");
		int64 Value64 = static_cast<int64>(x) * static_cast<int64>(y);
		msb = static_cast<int>(Value64 >> static_cast<int64>(32));
		lsb = static_cast<int>(Value64);
	}
	template<length_t L, qualifier Q>
	 inline void imulExtended(vec<L, int, Q> const& x, vec<L, int, Q> const& y, vec<L, int, Q>& msb, vec<L, int, Q>& lsb)
	{
		static_assert(sizeof(int) == sizeof(int32), "int and int32 size mismatch");
		vec<L, int64, Q> Value64(vec<L, int64, Q>(x) * vec<L, int64, Q>(y));
		lsb = vec<L, int32, Q>(Value64 & static_cast<int64>(0xFFFFFFFF));
		msb = vec<L, int32, Q>((Value64 >> static_cast<int64>(32)) & static_cast<int64>(0xFFFFFFFF));
	}
	template<typename genIUType>
	 inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
	{
		return bitfieldExtract(vec<1, genIUType>(Value), Offset, Bits).x;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> bitfieldExtract(vec<L, T, Q> const& Value, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldExtract' only accept integer inputs");
		return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
	}
	template<typename genIUType>
	 inline genIUType bitfieldInsert(genIUType const& Base, genIUType const& Insert, int Offset, int Bits)
	{
		return bitfieldInsert(vec<1, genIUType>(Base), vec<1, genIUType>(Insert), Offset, Bits).x;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> bitfieldInsert(vec<L, T, Q> const& Base, vec<L, T, Q> const& Insert, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldInsert' only accept integer values");
		T const Mask = static_cast<T>(detail::mask(Bits) << Offset);
		return (Base & ~Mask) | (Insert & Mask);
	}
	template<typename genType>
	 inline genType bitfieldReverse(genType x)
	{
		return bitfieldReverse(glm::vec<1, genType, glm::defaultp>(x)).x;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v)
	{
		vec<L, T, Q> x(v);
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  2>::call(x, static_cast<T>(0x5555555555555555ull), static_cast<T>( 1));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  4>::call(x, static_cast<T>(0x3333333333333333ull), static_cast<T>( 2));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  8>::call(x, static_cast<T>(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, static_cast<T>(0x00FF00FF00FF00FFull), static_cast<T>( 8));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, static_cast<T>(0x0000FFFF0000FFFFull), static_cast<T>(16));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, static_cast<T>(0x00000000FFFFFFFFull), static_cast<T>(32));
		return x;
	}
	template<typename genType>
	 inline int bitCount(genType x)
	{
		return bitCount(glm::vec<1, genType, glm::defaultp>(x)).x;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, int, Q> bitCount(vec<L, T, Q> const& v)
	{
#pragma warning(push)
#pragma warning(disable : 4310) 
#line 325 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
		vec<L, typename detail::make_unsigned<T>::type, Q> x(*reinterpret_cast<vec<L, typename detail::make_unsigned<T>::type, Q> const *>(&v));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
		return vec<L, int, Q>(x);
#pragma warning(pop)
#line 338 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
	}
	template<typename genIUType>
	 inline int findLSB(genIUType Value)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values");
		return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, int, Q> findLSB(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'findLSB' only accept integer values");
		return detail::functor1<L, int, T, Q>::call(findLSB, x);
	}
	template<typename genIUType>
	 inline int findMSB(genIUType v)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values");
		return findMSB(vec<1, genIUType>(v)).x;
	}
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, int, Q> findMSB(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'findMSB' only accept integer values");
		return detail::compute_findMSB_vec<L, T, Q, sizeof(T) * 8>::call(v);
	}
}
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_integer_simd.inl"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/integer.h"
#pragma once
 inline glm_uvec4 glm_i128_interleave(glm_uvec4 x)
{
	glm_uvec4 const Mask4 = _mm_set1_epi32(0x0000FFFF);
	glm_uvec4 const Mask3 = _mm_set1_epi32(0x00FF00FF);
	glm_uvec4 const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
	glm_uvec4 const Mask1 = _mm_set1_epi32(0x33333333);
	glm_uvec4 const Mask0 = _mm_set1_epi32(0x55555555);
	glm_uvec4 Reg1;
	glm_uvec4 Reg2;
	Reg1 = x;
	Reg2 = _mm_slli_si128(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask4);
	Reg2 = _mm_slli_si128(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask3);
	Reg2 = _mm_slli_epi32(Reg1, 4);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask2);
	Reg2 = _mm_slli_epi32(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask1);
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask0);
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg2 = _mm_srli_si128(Reg2, 8);
	Reg1 = _mm_or_si128(Reg1, Reg2);
	return Reg1;
}
 inline glm_uvec4 glm_i128_interleave2(glm_uvec4 x, glm_uvec4 y)
{
	glm_uvec4 const Mask4 = _mm_set1_epi32(0x0000FFFF);
	glm_uvec4 const Mask3 = _mm_set1_epi32(0x00FF00FF);
	glm_uvec4 const Mask2 = _mm_set1_epi32(0x0F0F0F0F);
	glm_uvec4 const Mask1 = _mm_set1_epi32(0x33333333);
	glm_uvec4 const Mask0 = _mm_set1_epi32(0x55555555);
	glm_uvec4 Reg1;
	glm_uvec4 Reg2;
	Reg1 = _mm_unpacklo_epi64(x, y);
	Reg2 = _mm_slli_si128(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask4);
	Reg2 = _mm_slli_si128(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask3);
	Reg2 = _mm_slli_epi32(Reg1, 4);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask2);
	Reg2 = _mm_slli_epi32(Reg1, 2);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask1);
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg1 = _mm_or_si128(Reg2, Reg1);
	Reg1 = _mm_and_si128(Reg1, Mask0);
	Reg2 = _mm_slli_epi32(Reg1, 1);
	Reg2 = _mm_srli_si128(Reg2, 8);
	Reg1 = _mm_or_si128(Reg1, Reg2);
	return Reg1;
}
#line 116 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\../simd/integer.h"
#line 5 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_integer_simd.inl"
namespace glm{
namespace detail
{
	template<qualifier Q>
	struct compute_bitfieldReverseStep<4, uint32, Q, true, true>
	{
		 inline static vec<4, uint32, Q> call(vec<4, uint32, Q> const& v, uint32 Mask, uint32 Shift)
		{
			__m128i const set0 = v.data;
			__m128i const set1 = _mm_set1_epi32(static_cast<int>(Mask));
			__m128i const and1 = _mm_and_si128(set0, set1);
			__m128i const sft1 = _mm_slli_epi32(and1, Shift);
			__m128i const set2 = _mm_andnot_si128(set0, _mm_set1_epi32(-1));
			__m128i const and2 = _mm_and_si128(set0, set2);
			__m128i const sft2 = _mm_srai_epi32(and2, Shift);
			__m128i const or0 = _mm_or_si128(sft1, sft2);
			return or0;
		}
	};
	template<qualifier Q>
	struct compute_bitfieldBitCountStep<4, uint32, Q, true, true>
	{
		 inline static vec<4, uint32, Q> call(vec<4, uint32, Q> const& v, uint32 Mask, uint32 Shift)
		{
			__m128i const set0 = v.data;
			__m128i const set1 = _mm_set1_epi32(static_cast<int>(Mask));
			__m128i const and0 = _mm_and_si128(set0, set1);
			__m128i const sft0 = _mm_slli_epi32(set0, Shift);
			__m128i const and1 = _mm_and_si128(sft0, set1);
			__m128i const add0 = _mm_add_epi32(and0, and1);
			return add0;
		}
	};
}
#line 65 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_integer_simd.inl"
}
#line 69 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail\\func_integer_simd.inl"
#line 377 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
#line 378 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\detail/func_integer.inl"
#line 212 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm\\integer.hpp"
#line 118 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\glm\\0.9.9.0\\glm/glm.hpp"
#line 10 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h"
#pragma warning(disable : 4365 6313 6319 6385 6386)
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h"
__pragma(warning(push))
__pragma(warning(disable: 4244)) 
__pragma(warning(disable: 4702))  
#line 29 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h"
namespace rapidjson {
template<typename CharType = char>
struct UTF8 {
    typedef CharType Ch;
    enum { supportUnicode = 1 };
    template<typename OutputStream>
    static void Encode(OutputStream& os, unsigned codepoint) {
        if (codepoint <= 0x7F) 
            os.Put(static_cast<Ch>(codepoint & 0xFF));
        else if (codepoint <= 0x7FF) {
            os.Put(static_cast<Ch>(0xC0 | ((codepoint >> 6) & 0xFF)));
            os.Put(static_cast<Ch>(0x80 | ((codepoint & 0x3F))));
        }
        else if (codepoint <= 0xFFFF) {
            os.Put(static_cast<Ch>(0xE0 | ((codepoint >> 12) & 0xFF)));
            os.Put(static_cast<Ch>(0x80 | ((codepoint >> 6) & 0x3F)));
            os.Put(static_cast<Ch>(0x80 | (codepoint & 0x3F)));
        }
        else {
            (void)( (!!(codepoint <= 0x10FFFF)) || (_wassert(L"codepoint <= 0x10FFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(115)), 0) );
            os.Put(static_cast<Ch>(0xF0 | ((codepoint >> 18) & 0xFF)));
            os.Put(static_cast<Ch>(0x80 | ((codepoint >> 12) & 0x3F)));
            os.Put(static_cast<Ch>(0x80 | ((codepoint >> 6) & 0x3F)));
            os.Put(static_cast<Ch>(0x80 | (codepoint & 0x3F)));
        }
    }
    template<typename OutputStream>
    static void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        if (codepoint <= 0x7F) 
            PutUnsafe(os, static_cast<Ch>(codepoint & 0xFF));
        else if (codepoint <= 0x7FF) {
            PutUnsafe(os, static_cast<Ch>(0xC0 | ((codepoint >> 6) & 0xFF)));
            PutUnsafe(os, static_cast<Ch>(0x80 | ((codepoint & 0x3F))));
        }
        else if (codepoint <= 0xFFFF) {
            PutUnsafe(os, static_cast<Ch>(0xE0 | ((codepoint >> 12) & 0xFF)));
            PutUnsafe(os, static_cast<Ch>(0x80 | ((codepoint >> 6) & 0x3F)));
            PutUnsafe(os, static_cast<Ch>(0x80 | (codepoint & 0x3F)));
        }
        else {
            (void)( (!!(codepoint <= 0x10FFFF)) || (_wassert(L"codepoint <= 0x10FFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(137)), 0) );
            PutUnsafe(os, static_cast<Ch>(0xF0 | ((codepoint >> 18) & 0xFF)));
            PutUnsafe(os, static_cast<Ch>(0x80 | ((codepoint >> 12) & 0x3F)));
            PutUnsafe(os, static_cast<Ch>(0x80 | ((codepoint >> 6) & 0x3F)));
            PutUnsafe(os, static_cast<Ch>(0x80 | (codepoint & 0x3F)));
        }
    }
    template <typename InputStream>
    static bool Decode(InputStream& is, unsigned* codepoint) {
        typename InputStream::Ch c = is.Take();
        if (!(c & 0x80)) {
            *codepoint = static_cast<unsigned char>(c);
            return true;
        }
        unsigned char type = GetRange(static_cast<unsigned char>(c));
        if (type >= 32) {
            *codepoint = 0;
        } else {
            *codepoint = (0xFF >> type) & static_cast<unsigned char>(c);
        }
        bool result = true;
        switch (type) {
        case 2: c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 3: c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 4: c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x50) != 0); c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 5: c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x10) != 0); c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 6: c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 10: c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x20) != 0); c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 11: c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x60) != 0); c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); c = is.Take(); *codepoint = (*codepoint << 6) | (static_cast<unsigned char>(c) & 0x3Fu); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        default: return false;
        }
    }
    template <typename InputStream, typename OutputStream>
    static bool Validate(InputStream& is, OutputStream& os) {
        Ch c;
        os.Put(c = is.Take());
        if (!(c & 0x80))
            return true;
        bool result = true;
        switch (GetRange(static_cast<unsigned char>(c))) {
        case 2: os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 3: os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 4: os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x50) != 0); os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 5: os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x10) != 0); os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 6: os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 10: os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x20) != 0); os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        case 11: os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x60) != 0); os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); os.Put(c = is.Take()); result &= ((GetRange(static_cast<unsigned char>(c)) & 0x70) != 0); return result;
        default: return false;
        }
    }
    static unsigned char GetRange(unsigned char c) {
        static const unsigned char type[] = {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
            0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
            0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
            0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
            8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
            10,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3, 11,6,6,6,5,8,8,8,8,8,8,8,8,8,8,8,
        };
        return type[c];
    }
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef224 ;
        typename InputByteStream::Ch c = Take(is);
        if (static_cast<unsigned char>(c) != 0xEFu) return c;
        c = is.Take();
        if (static_cast<unsigned char>(c) != 0xBBu) return c;
        c = is.Take();
        if (static_cast<unsigned char>(c) != 0xBFu) return c;
        c = is.Take();
        return c;
    }
    template <typename InputByteStream>
    static Ch Take(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef237 ;
        return static_cast<Ch>(is.Take());
    }
    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef243 ;
        os.Put(static_cast<typename OutputByteStream::Ch>(0xEFu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xBBu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xBFu));
    }
    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, Ch c) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef251 ;
        os.Put(static_cast<typename OutputByteStream::Ch>(c));
    }
};
template<typename CharType = wchar_t>
struct UTF16 {
    typedef CharType Ch;
    typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(Ch) >= 2) >)> StaticAssertTypedef271 ;
    enum { supportUnicode = 1 };
    template<typename OutputStream>
    static void Encode(OutputStream& os, unsigned codepoint) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputStream::Ch) >= 2) >)> StaticAssertTypedef277 ;
        if (codepoint <= 0xFFFF) {
            (void)( (!!(codepoint < 0xD800 || codepoint > 0xDFFF)) || (_wassert(L"codepoint < 0xD800 || codepoint > 0xDFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(279)), 0) ); 
            os.Put(static_cast<typename OutputStream::Ch>(codepoint));
        }
        else {
            (void)( (!!(codepoint <= 0x10FFFF)) || (_wassert(L"codepoint <= 0x10FFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(283)), 0) );
            unsigned v = codepoint - 0x10000;
            os.Put(static_cast<typename OutputStream::Ch>((v >> 10) | 0xD800));
            os.Put((v & 0x3FF) | 0xDC00);
        }
    }
    template<typename OutputStream>
    static void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputStream::Ch) >= 2) >)> StaticAssertTypedef293 ;
        if (codepoint <= 0xFFFF) {
            (void)( (!!(codepoint < 0xD800 || codepoint > 0xDFFF)) || (_wassert(L"codepoint < 0xD800 || codepoint > 0xDFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(295)), 0) ); 
            PutUnsafe(os, static_cast<typename OutputStream::Ch>(codepoint));
        }
        else {
            (void)( (!!(codepoint <= 0x10FFFF)) || (_wassert(L"codepoint <= 0x10FFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(299)), 0) );
            unsigned v = codepoint - 0x10000;
            PutUnsafe(os, static_cast<typename OutputStream::Ch>((v >> 10) | 0xD800));
            PutUnsafe(os, (v & 0x3FF) | 0xDC00);
        }
    }
    template <typename InputStream>
    static bool Decode(InputStream& is, unsigned* codepoint) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputStream::Ch) >= 2) >)> StaticAssertTypedef308 ;
        typename InputStream::Ch c = is.Take();
        if (c < 0xD800 || c > 0xDFFF) {
            *codepoint = static_cast<unsigned>(c);
            return true;
        }
        else if (c <= 0xDBFF) {
            *codepoint = (static_cast<unsigned>(c) & 0x3FF) << 10;
            c = is.Take();
            *codepoint |= (static_cast<unsigned>(c) & 0x3FF);
            *codepoint += 0x10000;
            return c >= 0xDC00 && c <= 0xDFFF;
        }
        return false;
    }
    template <typename InputStream, typename OutputStream>
    static bool Validate(InputStream& is, OutputStream& os) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputStream::Ch) >= 2) >)> StaticAssertTypedef326 ;
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputStream::Ch) >= 2) >)> StaticAssertTypedef327 ;
        typename InputStream::Ch c;
        os.Put(static_cast<typename OutputStream::Ch>(c = is.Take()));
        if (c < 0xD800 || c > 0xDFFF)
            return true;
        else if (c <= 0xDBFF) {
            os.Put(c = is.Take());
            return c >= 0xDC00 && c <= 0xDFFF;
        }
        return false;
    }
};
template<typename CharType = wchar_t>
struct UTF16LE : UTF16<CharType> {
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef345 ;
        CharType c = Take(is);
        return static_cast<uint16_t>(c) == 0xFEFFu ? Take(is) : c;
    }
    template <typename InputByteStream>
    static CharType Take(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef352 ;
        unsigned c = static_cast<uint8_t>(is.Take());
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 8;
        return static_cast<CharType>(c);
    }
    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef360 ;
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFEu));
    }
    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, CharType c) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef367 ;
        os.Put(static_cast<typename OutputByteStream::Ch>(static_cast<unsigned>(c) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>((static_cast<unsigned>(c) >> 8) & 0xFFu));
    }
};
template<typename CharType = wchar_t>
struct UTF16BE : UTF16<CharType> {
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef378 ;
        CharType c = Take(is);
        return static_cast<uint16_t>(c) == 0xFEFFu ? Take(is) : c;
    }
    template <typename InputByteStream>
    static CharType Take(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef385 ;
        unsigned c = static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 8;
        c |= static_cast<uint8_t>(is.Take());
        return static_cast<CharType>(c);
    }
    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef393 ;
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFEu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFFu));
    }
    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, CharType c) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef400 ;
        os.Put(static_cast<typename OutputByteStream::Ch>((static_cast<unsigned>(c) >> 8) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>(static_cast<unsigned>(c) & 0xFFu));
    }
};
template<typename CharType = unsigned>
struct UTF32 {
    typedef CharType Ch;
    typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(Ch) >= 4) >)> StaticAssertTypedef420 ;
    enum { supportUnicode = 1 };
    template<typename OutputStream>
    static void Encode(OutputStream& os, unsigned codepoint) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputStream::Ch) >= 4) >)> StaticAssertTypedef426 ;
        (void)( (!!(codepoint <= 0x10FFFF)) || (_wassert(L"codepoint <= 0x10FFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(427)), 0) );
        os.Put(codepoint);
    }
    template<typename OutputStream>
    static void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputStream::Ch) >= 4) >)> StaticAssertTypedef433 ;
        (void)( (!!(codepoint <= 0x10FFFF)) || (_wassert(L"codepoint <= 0x10FFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(434)), 0) );
        PutUnsafe(os, codepoint);
    }
    template <typename InputStream>
    static bool Decode(InputStream& is, unsigned* codepoint) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputStream::Ch) >= 4) >)> StaticAssertTypedef440 ;
        Ch c = is.Take();
        *codepoint = c;
        return c <= 0x10FFFF;
    }
    template <typename InputStream, typename OutputStream>
    static bool Validate(InputStream& is, OutputStream& os) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputStream::Ch) >= 4) >)> StaticAssertTypedef448 ;
        Ch c;
        os.Put(c = is.Take());
        return c <= 0x10FFFF;
    }
};
template<typename CharType = unsigned>
struct UTF32LE : UTF32<CharType> {
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef460 ;
        CharType c = Take(is);
        return static_cast<uint32_t>(c) == 0x0000FEFFu ? Take(is) : c;
    }
    template <typename InputByteStream>
    static CharType Take(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef467 ;
        unsigned c = static_cast<uint8_t>(is.Take());
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 8;
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 16;
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 24;
        return static_cast<CharType>(c);
    }
    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef477 ;
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFEu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0x00u));
        os.Put(static_cast<typename OutputByteStream::Ch>(0x00u));
    }
    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, CharType c) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef486 ;
        os.Put(static_cast<typename OutputByteStream::Ch>(c & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>((c >> 8) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>((c >> 16) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>((c >> 24) & 0xFFu));
    }
};
template<typename CharType = unsigned>
struct UTF32BE : UTF32<CharType> {
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef499 ;
        CharType c = Take(is);
        return static_cast<uint32_t>(c) == 0x0000FEFFu ? Take(is) : c; 
    }
    template <typename InputByteStream>
    static CharType Take(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef506 ;
        unsigned c = static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 24;
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 16;
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take())) << 8;
        c |= static_cast<unsigned>(static_cast<uint8_t>(is.Take()));
        return static_cast<CharType>(c);
    }
    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef516 ;
        os.Put(static_cast<typename OutputByteStream::Ch>(0x00u));
        os.Put(static_cast<typename OutputByteStream::Ch>(0x00u));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFEu));
        os.Put(static_cast<typename OutputByteStream::Ch>(0xFFu));
    }
    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, CharType c) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef525 ;
        os.Put(static_cast<typename OutputByteStream::Ch>((c >> 24) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>((c >> 16) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>((c >> 8) & 0xFFu));
        os.Put(static_cast<typename OutputByteStream::Ch>(c & 0xFFu));
    }
};
template<typename CharType = char>
struct ASCII {
    typedef CharType Ch;
    enum { supportUnicode = 0 };
    template<typename OutputStream>
    static void Encode(OutputStream& os, unsigned codepoint) {
        (void)( (!!(codepoint <= 0x7F)) || (_wassert(L"codepoint <= 0x7F", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(549)), 0) );
        os.Put(static_cast<Ch>(codepoint & 0xFF));
    }
    template<typename OutputStream>
    static void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        (void)( (!!(codepoint <= 0x7F)) || (_wassert(L"codepoint <= 0x7F", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h", (unsigned)(555)), 0) );
        PutUnsafe(os, static_cast<Ch>(codepoint & 0xFF));
    }
    template <typename InputStream>
    static bool Decode(InputStream& is, unsigned* codepoint) {
        uint8_t c = static_cast<uint8_t>(is.Take());
        *codepoint = c;
        return c <= 0X7F;
    }
    template <typename InputStream, typename OutputStream>
    static bool Validate(InputStream& is, OutputStream& os) {
        uint8_t c = static_cast<uint8_t>(is.Take());
        os.Put(static_cast<typename OutputStream::Ch>(c));
        return c <= 0x7F;
    }
    template <typename InputByteStream>
    static CharType TakeBOM(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef575 ;
        uint8_t c = static_cast<uint8_t>(Take(is));
        return static_cast<Ch>(c);
    }
    template <typename InputByteStream>
    static Ch Take(InputByteStream& is) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef582 ;
        return static_cast<Ch>(is.Take());
    }
    template <typename OutputByteStream>
    static void PutBOM(OutputByteStream& os) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef588 ;
        (void)os;
    }
    template <typename OutputByteStream>
    static void Put(OutputByteStream& os, Ch c) {
        typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef594 ;
        os.Put(static_cast<typename OutputByteStream::Ch>(c));
    }
};
enum UTFType {
    kUTF8 = 0,      
    kUTF16LE = 1,   
    kUTF16BE = 2,   
    kUTF32LE = 3,   
    kUTF32BE = 4    
};
template<typename CharType>
struct AutoUTF {
    typedef CharType Ch;
    enum { supportUnicode = 1 };
    template<typename OutputStream>
     static void Encode(OutputStream& os, unsigned codepoint) {
        typedef void (*EncodeFunc)(OutputStream&, unsigned);
        static const EncodeFunc f[] = { UTF8<Ch>::Encode, UTF16LE<Ch>::Encode, UTF16BE<Ch>::Encode, UTF32LE<Ch>::Encode, UTF32BE<Ch>::Encode };
        (*f[os.GetType()])(os, codepoint);
    }
    template<typename OutputStream>
     static void EncodeUnsafe(OutputStream& os, unsigned codepoint) {
        typedef void (*EncodeFunc)(OutputStream&, unsigned);
        static const EncodeFunc f[] = { UTF8<Ch>::EncodeUnsafe, UTF16LE<Ch>::EncodeUnsafe, UTF16BE<Ch>::EncodeUnsafe, UTF32LE<Ch>::EncodeUnsafe, UTF32BE<Ch>::EncodeUnsafe };
        (*f[os.GetType()])(os, codepoint);
    }
    template <typename InputStream>
     static bool Decode(InputStream& is, unsigned* codepoint) {
        typedef bool (*DecodeFunc)(InputStream&, unsigned*);
        static const DecodeFunc f[] = { UTF8<Ch>::Decode, UTF16LE<Ch>::Decode, UTF16BE<Ch>::Decode, UTF32LE<Ch>::Decode, UTF32BE<Ch>::Decode };
        return (*f[is.GetType()])(is, codepoint);
    }
    template <typename InputStream, typename OutputStream>
     static bool Validate(InputStream& is, OutputStream& os) {
        typedef bool (*ValidateFunc)(InputStream&, OutputStream&);
        static const ValidateFunc f[] = { UTF8<Ch>::Validate, UTF16LE<Ch>::Validate, UTF16BE<Ch>::Validate, UTF32LE<Ch>::Validate, UTF32BE<Ch>::Validate };
        return (*f[is.GetType()])(is, os);
    }
};
template<typename SourceEncoding, typename TargetEncoding>
struct Transcoder {
    template<typename InputStream, typename OutputStream>
     static bool Transcode(InputStream& is, OutputStream& os) {
        unsigned codepoint;
        if (!SourceEncoding::Decode(is, &codepoint))
            return false;
        TargetEncoding::Encode(os, codepoint);
        return true;
    }
    template<typename InputStream, typename OutputStream>
     static bool TranscodeUnsafe(InputStream& is, OutputStream& os) {
        unsigned codepoint;
        if (!SourceEncoding::Decode(is, &codepoint))
            return false;
        TargetEncoding::EncodeUnsafe(os, codepoint);
        return true;
    }
    template<typename InputStream, typename OutputStream>
     static bool Validate(InputStream& is, OutputStream& os) {
        return Transcode(is, os);   
    }
};
template<typename Stream>
inline void PutUnsafe(Stream& stream, typename Stream::Ch c);
template<typename Encoding>
struct Transcoder<Encoding, Encoding> {
    template<typename InputStream, typename OutputStream>
     static bool Transcode(InputStream& is, OutputStream& os) {
        os.Put(is.Take());  
        return true;
    }
    template<typename InputStream, typename OutputStream>
     static bool TranscodeUnsafe(InputStream& is, OutputStream& os) {
        PutUnsafe(os, is.Take());  
        return true;
    }
    template<typename InputStream, typename OutputStream>
     static bool Validate(InputStream& is, OutputStream& os) {
        return Encoding::Validate(is, os);  
    }
};
}
__pragma(warning(pop))
#line 715 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h"
#line 717 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodings.h"
#line 21 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h"
namespace rapidjson {
template<typename Stream>
struct StreamTraits {
    enum { copyOptimization = 0 };
};
template<typename Stream>
inline void PutReserve(Stream& stream, size_t count) {
    (void)stream;
    (void)count;
}
template<typename Stream>
inline void PutUnsafe(Stream& stream, typename Stream::Ch c) {
    stream.Put(c);
}
template<typename Stream, typename Ch>
inline void PutN(Stream& stream, Ch c, size_t n) {
    PutReserve(stream, n);
    for (size_t i = 0; i < n; i++)
        PutUnsafe(stream, c);
}
template <typename Encoding>
struct GenericStringStream {
    typedef typename Encoding::Ch Ch;
    GenericStringStream(const Ch *src) : src_(src), head_(src) {}
    Ch Peek() const { return *src_; }
    Ch Take() { return *src_++; }
    size_t Tell() const { return static_cast<size_t>(src_ - head_); }
    Ch* PutBegin() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h", (unsigned)(119)), 0) ); return 0; }
    void Put(Ch) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h", (unsigned)(120)), 0) ); }
    void Flush() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h", (unsigned)(121)), 0) ); }
    size_t PutEnd(Ch*) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h", (unsigned)(122)), 0) ); return 0; }
    const Ch* src_;     
    const Ch* head_;    
};
template <typename Encoding>
struct StreamTraits<GenericStringStream<Encoding> > {
    enum { copyOptimization = 1 };
};
typedef GenericStringStream<UTF8<> > StringStream;
template <typename Encoding>
struct GenericInsituStringStream {
    typedef typename Encoding::Ch Ch;
    GenericInsituStringStream(Ch *src) : src_(src), dst_(0), head_(src) {}
    Ch Peek() { return *src_; }
    Ch Take() { return *src_++; }
    size_t Tell() { return static_cast<size_t>(src_ - head_); }
    void Put(Ch c) { (void)( (!!(dst_ != 0)) || (_wassert(L"dst_ != 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h", (unsigned)(155)), 0) ); *dst_++ = c; }
    Ch* PutBegin() { return dst_ = src_; }
    size_t PutEnd(Ch* begin) { return static_cast<size_t>(dst_ - begin); }
    void Flush() {}
    Ch* Push(size_t count) { Ch* begin = dst_; dst_ += count; return begin; }
    void Pop(size_t count) { dst_ -= count; }
    Ch* src_;
    Ch* dst_;
    Ch* head_;
};
template <typename Encoding>
struct StreamTraits<GenericInsituStringStream<Encoding> > {
    enum { copyOptimization = 1 };
};
typedef GenericInsituStringStream<UTF8<> > InsituStringStream;
}
#line 180 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h"
#line 22 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h"
#line 19 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\memorystream.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\stream.h"
#line 19 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\memorystream.h"
namespace rapidjson {
struct MemoryStream {
    typedef char Ch; 
    MemoryStream(const Ch *src, size_t size) : src_(src), begin_(src), end_(src + size), size_(size) {}
    Ch Peek() const { return (src_ == end_) ? '\0' : *src_; }
    Ch Take() { return (src_ == end_) ? '\0' : *src_++; }
    size_t Tell() const { return static_cast<size_t>(src_ - begin_); }
    Ch* PutBegin() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\memorystream.h", (unsigned)(49)), 0) ); return 0; }
    void Put(Ch) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\memorystream.h", (unsigned)(50)), 0) ); }
    void Flush() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\memorystream.h", (unsigned)(51)), 0) ); }
    size_t PutEnd(Ch*) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\memorystream.h", (unsigned)(52)), 0) ); return 0; }
    const Ch* Peek4() const {
        return Tell() + 4 <= size_ ? src_ : 0;
    }
    const Ch* src_;     
    const Ch* begin_;   
    const Ch* end_;     
    size_t size_;       
};
}
#line 72 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\memorystream.h"
#line 20 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h"
namespace rapidjson {
template <typename Encoding, typename InputByteStream>
class EncodedInputStream {
    typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef40 ;
public:
    typedef typename Encoding::Ch Ch;
    EncodedInputStream(InputByteStream& is) : is_(is) { 
        current_ = Encoding::TakeBOM(is_);
    }
    Ch Peek() const { return current_; }
    Ch Take() { Ch c = current_; current_ = Encoding::Take(is_); return c; }
    size_t Tell() const { return is_.Tell(); }
    void Put(Ch) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(53)), 0) ); }
    void Flush() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(54)), 0) ); } 
    Ch* PutBegin() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(55)), 0) ); return 0; }
    size_t PutEnd(Ch*) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(56)), 0) ); return 0; }
private:
    EncodedInputStream(const EncodedInputStream&);
    EncodedInputStream& operator=(const EncodedInputStream&);
    InputByteStream& is_;
    Ch current_;
};
template <>
class EncodedInputStream<UTF8<>, MemoryStream> {
public:
    typedef UTF8<>::Ch Ch;
    EncodedInputStream(MemoryStream& is) : is_(is) {
        if (static_cast<unsigned char>(is_.Peek()) == 0xEFu) is_.Take();
        if (static_cast<unsigned char>(is_.Peek()) == 0xBBu) is_.Take();
        if (static_cast<unsigned char>(is_.Peek()) == 0xBFu) is_.Take();
    }
    Ch Peek() const { return is_.Peek(); }
    Ch Take() { return is_.Take(); }
    size_t Tell() const { return is_.Tell(); }
    void Put(Ch) {}
    void Flush() {} 
    Ch* PutBegin() { return 0; }
    size_t PutEnd(Ch*) { return 0; }
    MemoryStream& is_;
private:
    EncodedInputStream(const EncodedInputStream&);
    EncodedInputStream& operator=(const EncodedInputStream&);
};
template <typename Encoding, typename OutputByteStream>
class EncodedOutputStream {
    typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef101 ;
public:
    typedef typename Encoding::Ch Ch;
    EncodedOutputStream(OutputByteStream& os, bool putBOM = true) : os_(os) { 
        if (putBOM)
            Encoding::PutBOM(os_);
    }
    void Put(Ch c) { Encoding::Put(os_, c);  }
    void Flush() { os_.Flush(); }
    Ch Peek() const { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(114)), 0) ); return 0;}
    Ch Take() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(115)), 0) ); return 0;}
    size_t Tell() const { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(116)), 0) );  return 0; }
    Ch* PutBegin() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(117)), 0) ); return 0; }
    size_t PutEnd(Ch*) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(118)), 0) ); return 0; }
private:
    EncodedOutputStream(const EncodedOutputStream&);
    EncodedOutputStream& operator=(const EncodedOutputStream&);
    OutputByteStream& os_;
};
template <typename CharType, typename InputByteStream>
class AutoUTFInputStream {
    typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename InputByteStream::Ch) == 1) >)> StaticAssertTypedef136 ;
public:
    typedef CharType Ch;
    AutoUTFInputStream(InputByteStream& is, UTFType type = kUTF8) : is_(&is), type_(type), hasBOM_(false) {
        (void)( (!!(type >= kUTF8 && type <= kUTF32BE)) || (_wassert(L"type >= kUTF8 && type <= kUTF32BE", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(146)), 0) );        
        DetectType();
        static const TakeFunc f[] = { UTF8<Ch>::Take, UTF16LE<Ch>::Take, UTF16BE<Ch>::Take, UTF32LE<Ch>::Take, UTF32BE<Ch>::Take };
        takeFunc_ = f[type_];
        current_ = takeFunc_(*is_);
    }
    UTFType GetType() const { return type_; }
    bool HasBOM() const { return hasBOM_; }
    Ch Peek() const { return current_; }
    Ch Take() { Ch c = current_; current_ = takeFunc_(*is_); return c; }
    size_t Tell() const { return is_->Tell(); }
    void Put(Ch) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(161)), 0) ); }
    void Flush() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(162)), 0) ); } 
    Ch* PutBegin() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(163)), 0) ); return 0; }
    size_t PutEnd(Ch*) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(164)), 0) ); return 0; }
private:
    AutoUTFInputStream(const AutoUTFInputStream&);
    AutoUTFInputStream& operator=(const AutoUTFInputStream&);
    void DetectType() {
        const unsigned char* c = reinterpret_cast<const unsigned char *>(is_->Peek4());
        if (!c)
            return;
        unsigned bom = static_cast<unsigned>(c[0] | (c[1] << 8) | (c[2] << 16) | (c[3] << 24));
        hasBOM_ = false;
        if (bom == 0xFFFE0000)                  { type_ = kUTF32BE; hasBOM_ = true; is_->Take(); is_->Take(); is_->Take(); is_->Take(); }
        else if (bom == 0x0000FEFF)             { type_ = kUTF32LE; hasBOM_ = true; is_->Take(); is_->Take(); is_->Take(); is_->Take(); }
        else if ((bom & 0xFFFF) == 0xFFFE)      { type_ = kUTF16BE; hasBOM_ = true; is_->Take(); is_->Take();                           }
        else if ((bom & 0xFFFF) == 0xFEFF)      { type_ = kUTF16LE; hasBOM_ = true; is_->Take(); is_->Take();                           }
        else if ((bom & 0xFFFFFF) == 0xBFBBEF)  { type_ = kUTF8;    hasBOM_ = true; is_->Take(); is_->Take(); is_->Take();              }
        if (!hasBOM_) {
            unsigned pattern = (c[0] ? 1 : 0) | (c[1] ? 2 : 0) | (c[2] ? 4 : 0) | (c[3] ? 8 : 0);
            switch (pattern) {
            case 0x08: type_ = kUTF32BE; break;
            case 0x0A: type_ = kUTF16BE; break;
            case 0x01: type_ = kUTF32LE; break;
            case 0x05: type_ = kUTF16LE; break;
            case 0x0F: type_ = kUTF8;    break;
            default: break; 
            }
        }
        if (type_ == kUTF16LE || type_ == kUTF16BE) (void)( (!!(sizeof(Ch) >= 2)) || (_wassert(L"sizeof(Ch) >= 2", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(215)), 0) );
        if (type_ == kUTF32LE || type_ == kUTF32BE) (void)( (!!(sizeof(Ch) >= 4)) || (_wassert(L"sizeof(Ch) >= 4", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(216)), 0) );
    }
    typedef Ch (*TakeFunc)(InputByteStream& is);
    InputByteStream* is_;
    UTFType type_;
    Ch current_;
    TakeFunc takeFunc_;
    bool hasBOM_;
};
template <typename CharType, typename OutputByteStream>
class AutoUTFOutputStream {
    typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(typename OutputByteStream::Ch) == 1) >)> StaticAssertTypedef234 ;
public:
    typedef CharType Ch;
    AutoUTFOutputStream(OutputByteStream& os, UTFType type, bool putBOM) : os_(&os), type_(type) {
        (void)( (!!(type >= kUTF8 && type <= kUTF32BE)) || (_wassert(L"type >= kUTF8 && type <= kUTF32BE", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(245)), 0) );
        if (type_ == kUTF16LE || type_ == kUTF16BE) (void)( (!!(sizeof(Ch) >= 2)) || (_wassert(L"sizeof(Ch) >= 2", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(248)), 0) );
        if (type_ == kUTF32LE || type_ == kUTF32BE) (void)( (!!(sizeof(Ch) >= 4)) || (_wassert(L"sizeof(Ch) >= 4", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(249)), 0) );
        static const PutFunc f[] = { UTF8<Ch>::Put, UTF16LE<Ch>::Put, UTF16BE<Ch>::Put, UTF32LE<Ch>::Put, UTF32BE<Ch>::Put };
        putFunc_ = f[type_];
        if (putBOM)
            PutBOM();
    }
    UTFType GetType() const { return type_; }
    void Put(Ch c) { putFunc_(*os_, c); }
    void Flush() { os_->Flush(); } 
    Ch Peek() const { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(264)), 0) ); return 0;}
    Ch Take() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(265)), 0) ); return 0;}
    size_t Tell() const { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(266)), 0) ); return 0; }
    Ch* PutBegin() { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(267)), 0) ); return 0; }
    size_t PutEnd(Ch*) { (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h", (unsigned)(268)), 0) ); return 0; }
private:
    AutoUTFOutputStream(const AutoUTFOutputStream&);
    AutoUTFOutputStream& operator=(const AutoUTFOutputStream&);
    void PutBOM() { 
        typedef void (*PutBOMFunc)(OutputByteStream&);
        static const PutBOMFunc f[] = { UTF8<Ch>::PutBOM, UTF16LE<Ch>::PutBOM, UTF16BE<Ch>::PutBOM, UTF32LE<Ch>::PutBOM, UTF32BE<Ch>::PutBOM };
        f[type_](*os_);
    }
    typedef void (*PutFunc)(OutputByteStream&, Ch);
    OutputByteStream* os_;
    UTFType type_;
    PutFunc putFunc_;
};
}
#line 300 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\encodedstream.h"
#line 23 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/meta.h"
__pragma(warning(push))
__pragma(warning(disable: 6334))
#line 28 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/meta.h"
#line 32 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/meta.h"
namespace rapidjson {
namespace internal {
template <typename T> struct Void { typedef void Type; };
template <bool Cond> struct BoolType {
    static const bool Value = Cond;
    typedef BoolType Type;
};
typedef BoolType<true> TrueType;
typedef BoolType<false> FalseType;
template <bool C> struct SelectIfImpl { template <typename T1, typename T2> struct Apply { typedef T1 Type; }; };
template <> struct SelectIfImpl<false> { template <typename T1, typename T2> struct Apply { typedef T2 Type; }; };
template <bool C, typename T1, typename T2> struct SelectIfCond : SelectIfImpl<C>::template Apply<T1,T2> {};
template <typename C, typename T1, typename T2> struct SelectIf : SelectIfCond<C::Value, T1, T2> {};
template <bool Cond1, bool Cond2> struct AndExprCond : FalseType {};
template <> struct AndExprCond<true, true> : TrueType {};
template <bool Cond1, bool Cond2> struct OrExprCond : TrueType {};
template <> struct OrExprCond<false, false> : FalseType {};
template <typename C> struct BoolExpr : SelectIf<C,TrueType,FalseType>::Type {};
template <typename C> struct NotExpr  : SelectIf<C,FalseType,TrueType>::Type {};
template <typename C1, typename C2> struct AndExpr : AndExprCond<C1::Value, C2::Value>::Type {};
template <typename C1, typename C2> struct OrExpr  : OrExprCond<C1::Value, C2::Value>::Type {};
template <typename T> struct AddConst { typedef const T Type; };
template <bool Constify, typename T> struct MaybeAddConst : SelectIfCond<Constify, const T, T> {};
template <typename T> struct RemoveConst { typedef T Type; };
template <typename T> struct RemoveConst<const T> { typedef T Type; };
template <typename T, typename U> struct IsSame : FalseType {};
template <typename T> struct IsSame<T, T> : TrueType {};
template <typename T> struct IsConst : FalseType {};
template <typename T> struct IsConst<const T> : TrueType {};
template <typename CT, typename T>
struct IsMoreConst
    : AndExpr<IsSame<typename RemoveConst<CT>::Type, typename RemoveConst<T>::Type>,
              BoolType<IsConst<CT>::Value >= IsConst<T>::Value> >::Type {};
template <typename T> struct IsPointer : FalseType {};
template <typename T> struct IsPointer<T*> : TrueType {};
#line 105 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/meta.h"
template<typename B, typename D> struct IsBaseOfImpl {
    typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(B) != 0) >)> StaticAssertTypedef107 ;
    typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool(sizeof(D) != 0) >)> StaticAssertTypedef108 ;
    typedef char (&Yes)[1];
    typedef char (&No) [2];
    template <typename T>
    static Yes Check(const D*, T);
    static No  Check(const B*, int);
    struct Host {
        operator const B*() const;
        operator const D*();
    };
    enum { Value = (sizeof(Check(Host(), 0)) == sizeof(Yes)) };
};
template <typename B, typename D> struct IsBaseOf
    : OrExpr<IsSame<B, D>, BoolExpr<IsBaseOfImpl<B, D> > >::Type {};
#line 129 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/meta.h"
template <bool Condition, typename T = void> struct EnableIfCond  { typedef T Type; };
template <typename T> struct EnableIfCond<false, T> {  };
template <bool Condition, typename T = void> struct DisableIfCond { typedef T Type; };
template <typename T> struct DisableIfCond<true, T> {  };
template <typename Condition, typename T = void>
struct EnableIf : EnableIfCond<Condition::Value, T> {};
template <typename Condition, typename T = void>
struct DisableIf : DisableIfCond<Condition::Value, T> {};
struct SfinaeTag {};
template <typename T> struct RemoveSfinaeTag;
template <typename T> struct RemoveSfinaeTag<SfinaeTag&(*)(T)> { typedef T Type; };
} 
}
__pragma(warning(pop))
#line 180 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/meta.h"
#line 182 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/meta.h"
#line 24 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\swap.h"
#line 24 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\swap.h"
namespace rapidjson {
namespace internal {
template <typename T>
inline void Swap(T& a, T& b)  {
    T tmp = a;
        a = b;
        b = tmp;
}
} 
}
#line 45 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\swap.h"
#line 47 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\swap.h"
#line 20 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h"
#line 25 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h"
namespace rapidjson {
namespace internal {
template <typename Allocator>
class Stack {
public:
    Stack(Allocator* allocator, size_t stackCapacity) : allocator_(allocator), ownAllocator_(0), stack_(0), stackTop_(0), stackEnd_(0), initialCapacity_(stackCapacity) {
    }
    Stack(Stack&& rhs)
        : allocator_(rhs.allocator_),
          ownAllocator_(rhs.ownAllocator_),
          stack_(rhs.stack_),
          stackTop_(rhs.stackTop_),
          stackEnd_(rhs.stackEnd_),
          initialCapacity_(rhs.initialCapacity_)
    {
        rhs.allocator_ = 0;
        rhs.ownAllocator_ = 0;
        rhs.stack_ = 0;
        rhs.stackTop_ = 0;
        rhs.stackEnd_ = 0;
        rhs.initialCapacity_ = 0;
    }
#line 60 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h"
    ~Stack() {
        Destroy();
    }
    Stack& operator=(Stack&& rhs) {
        if (&rhs != this)
        {
            Destroy();
            allocator_ = rhs.allocator_;
            ownAllocator_ = rhs.ownAllocator_;
            stack_ = rhs.stack_;
            stackTop_ = rhs.stackTop_;
            stackEnd_ = rhs.stackEnd_;
            initialCapacity_ = rhs.initialCapacity_;
            rhs.allocator_ = 0;
            rhs.ownAllocator_ = 0;
            rhs.stack_ = 0;
            rhs.stackTop_ = 0;
            rhs.stackEnd_ = 0;
            rhs.initialCapacity_ = 0;
        }
        return *this;
    }
#line 88 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h"
    void Swap(Stack& rhs)  {
        internal::Swap(allocator_, rhs.allocator_);
        internal::Swap(ownAllocator_, rhs.ownAllocator_);
        internal::Swap(stack_, rhs.stack_);
        internal::Swap(stackTop_, rhs.stackTop_);
        internal::Swap(stackEnd_, rhs.stackEnd_);
        internal::Swap(initialCapacity_, rhs.initialCapacity_);
    }
    void Clear() { stackTop_ = stack_; }
    void ShrinkToFit() { 
        if (Empty()) {
            Allocator::Free(stack_);
            stack_ = 0;
            stackTop_ = 0;
            stackEnd_ = 0;
        }
        else
            Resize(GetSize());
    }
    template<typename T>
     void Reserve(size_t count = 1) {
        if ((stackTop_ + sizeof(T) * count > stackEnd_))
            Expand<T>(count);
    }
    template<typename T>
     T* Push(size_t count = 1) {
        Reserve<T>(count);
        return PushUnsafe<T>(count);
    }
    template<typename T>
     T* PushUnsafe(size_t count = 1) {
        (void)( (!!(stackTop_ + sizeof(T) * count <= stackEnd_)) || (_wassert(L"stackTop_ + sizeof(T) * count <= stackEnd_", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h", (unsigned)(129)), 0) );
        T* ret = reinterpret_cast<T*>(stackTop_);
        stackTop_ += sizeof(T) * count;
        return ret;
    }
    template<typename T>
    T* Pop(size_t count) {
        (void)( (!!(GetSize() >= count * sizeof(T))) || (_wassert(L"GetSize() >= count * sizeof(T)", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h", (unsigned)(137)), 0) );
        stackTop_ -= count * sizeof(T);
        return reinterpret_cast<T*>(stackTop_);
    }
    template<typename T>
    T* Top() { 
        (void)( (!!(GetSize() >= sizeof(T))) || (_wassert(L"GetSize() >= sizeof(T)", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h", (unsigned)(144)), 0) );
        return reinterpret_cast<T*>(stackTop_ - sizeof(T));
    }
    template<typename T>
    const T* Top() const {
        (void)( (!!(GetSize() >= sizeof(T))) || (_wassert(L"GetSize() >= sizeof(T)", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h", (unsigned)(150)), 0) );
        return reinterpret_cast<T*>(stackTop_ - sizeof(T));
    }
    template<typename T>
    T* End() { return reinterpret_cast<T*>(stackTop_); }
    template<typename T>
    const T* End() const { return reinterpret_cast<T*>(stackTop_); }
    template<typename T>
    T* Bottom() { return reinterpret_cast<T*>(stack_); }
    template<typename T>
    const T* Bottom() const { return reinterpret_cast<T*>(stack_); }
    bool HasAllocator() const {
        return allocator_ != 0;
    }
    Allocator& GetAllocator() {
        (void)( (!!(allocator_)) || (_wassert(L"allocator_", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h", (unsigned)(171)), 0) );
        return *allocator_;
    }
    bool Empty() const { return stackTop_ == stack_; }
    size_t GetSize() const { return static_cast<size_t>(stackTop_ - stack_); }
    size_t GetCapacity() const { return static_cast<size_t>(stackEnd_ - stack_); }
private:
    template<typename T>
    void Expand(size_t count) {
        size_t newCapacity;
        if (stack_ == 0) {
            if (!allocator_)
                ownAllocator_ = allocator_ = new Allocator();
            newCapacity = initialCapacity_;
        } else {
            newCapacity = GetCapacity();
            newCapacity += (newCapacity + 1) / 2;
        }
        size_t newSize = GetSize() + sizeof(T) * count;
        if (newCapacity < newSize)
            newCapacity = newSize;
        Resize(newCapacity);
    }
    void Resize(size_t newCapacity) {
        const size_t size = GetSize();  
        stack_ = static_cast<char*>(allocator_->Realloc(stack_, GetCapacity(), newCapacity));
        stackTop_ = stack_ + size;
        stackEnd_ = stack_ + newCapacity;
    }
    void Destroy() {
        Allocator::Free(stack_);
        delete ownAllocator_; 
    }
    Stack(const Stack&);
    Stack& operator=(const Stack&);
    Allocator* allocator_;
    Allocator* ownAllocator_;
    char *stack_;
    char *stackTop_;
    char *stackEnd_;
    size_t initialCapacity_;
};
} 
}
#line 229 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h"
#line 231 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/stack.h"
#line 25 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strtod.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\ieee754.h"
namespace rapidjson {
namespace internal {
class Double {
public:
    Double() {}
    Double(double d) : d_(d) {}
    Double(uint64_t u) : u_(u) {}
    double Value() const { return d_; }
    uint64_t Uint64Value() const { return u_; }
    double NextPositiveDouble() const {
        (void)( (!!(!Sign())) || (_wassert(L"!Sign()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\ieee754.h", (unsigned)(33)), 0) );
        return Double(u_ + 1).Value();
    }
    bool Sign() const { return (u_ & kSignMask) != 0; }
    uint64_t Significand() const { return u_ & kSignificandMask; }
    int Exponent() const { return static_cast<int>(((u_ & kExponentMask) >> kSignificandSize) - kExponentBias); }
    bool IsNan() const { return (u_ & kExponentMask) == kExponentMask && Significand() != 0; }
    bool IsInf() const { return (u_ & kExponentMask) == kExponentMask && Significand() == 0; }
    bool IsNanOrInf() const { return (u_ & kExponentMask) == kExponentMask; }
    bool IsNormal() const { return (u_ & kExponentMask) != 0 || Significand() == 0; }
    bool IsZero() const { return (u_ & (kExponentMask | kSignificandMask)) == 0; }
    uint64_t IntegerSignificand() const { return IsNormal() ? Significand() | kHiddenBit : Significand(); }
    int IntegerExponent() const { return (IsNormal() ? Exponent() : kDenormalExponent) - kSignificandSize; }
    uint64_t ToBias() const { return (u_ & kSignMask) ? ~u_ + 1 : u_ | kSignMask; }
    static unsigned EffectiveSignificandSize(int order) {
        if (order >= -1021)
            return 53;
        else if (order <= -1074)
            return 0;
        else
            return static_cast<unsigned>(order) + 1074;
    }
private:
    static const int kSignificandSize = 52;
    static const int kExponentBias = 0x3FF;
    static const int kDenormalExponent = 1 - kExponentBias;
    static const uint64_t kSignMask = ((static_cast<uint64_t>(0x80000000) << 32) | static_cast<uint64_t>(0x00000000));
    static const uint64_t kExponentMask = ((static_cast<uint64_t>(0x7FF00000) << 32) | static_cast<uint64_t>(0x00000000));
    static const uint64_t kSignificandMask = ((static_cast<uint64_t>(0x000FFFFF) << 32) | static_cast<uint64_t>(0xFFFFFFFF));
    static const uint64_t kHiddenBit = ((static_cast<uint64_t>(0x00100000) << 32) | static_cast<uint64_t>(0x00000000));
    union {
        double d_;
        uint64_t u_;
    };
};
} 
}
#line 79 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\ieee754.h"
#line 19 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strtod.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h"
#pragma intrinsic(_umul128)
#line 24 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h"
namespace rapidjson {
namespace internal {
class BigInteger {
public:
    typedef uint64_t Type;
    BigInteger(const BigInteger& rhs) : count_(rhs.count_) {
        std::memcpy(digits_, rhs.digits_, count_ * sizeof(Type));
    }
    explicit BigInteger(uint64_t u) : count_(1) {
        digits_[0] = u;
    }
    BigInteger(const char* decimals, size_t length) : count_(1) {
        (void)( (!!(length > 0)) || (_wassert(L"length > 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h", (unsigned)(41)), 0) );
        digits_[0] = 0;
        size_t i = 0;
        const size_t kMaxDigitPerIteration = 19;  
        while (length >= kMaxDigitPerIteration) {
            AppendDecimal64(decimals + i, decimals + i + kMaxDigitPerIteration);
            length -= kMaxDigitPerIteration;
            i += kMaxDigitPerIteration;
        }
        if (length > 0)
            AppendDecimal64(decimals + i, decimals + i + length);
    }
    BigInteger& operator=(const BigInteger &rhs)
    {
        if (this != &rhs) {
            count_ = rhs.count_;
            std::memcpy(digits_, rhs.digits_, count_ * sizeof(Type));
        }
        return *this;
    }
    BigInteger& operator=(uint64_t u) {
        digits_[0] = u;            
        count_ = 1;
        return *this;
    }
    BigInteger& operator+=(uint64_t u) {
        Type backup = digits_[0];
        digits_[0] += u;
        for (size_t i = 0; i < count_ - 1; i++) {
            if (digits_[i] >= backup)
                return *this; 
            backup = digits_[i + 1];
            digits_[i + 1] += 1;
        }
        if (digits_[count_ - 1] < backup)
            PushBack(1);
        return *this;
    }
    BigInteger& operator*=(uint64_t u) {
        if (u == 0) return *this = 0;
        if (u == 1) return *this;
        if (*this == 1) return *this = u;
        uint64_t k = 0;
        for (size_t i = 0; i < count_; i++) {
            uint64_t hi;
            digits_[i] = MulAdd64(digits_[i], u, k, &hi);
            k = hi;
        }
        if (k > 0)
            PushBack(k);
        return *this;
    }
    BigInteger& operator*=(uint32_t u) {
        if (u == 0) return *this = 0;
        if (u == 1) return *this;
        if (*this == 1) return *this = u;
        uint64_t k = 0;
        for (size_t i = 0; i < count_; i++) {
            const uint64_t c = digits_[i] >> 32;
            const uint64_t d = digits_[i] & 0xFFFFFFFF;
            const uint64_t uc = u * c;
            const uint64_t ud = u * d;
            const uint64_t p0 = ud + k;
            const uint64_t p1 = uc + (p0 >> 32);
            digits_[i] = (p0 & 0xFFFFFFFF) | (p1 << 32);
            k = p1 >> 32;
        }
        if (k > 0)
            PushBack(k);
        return *this;
    }
    BigInteger& operator<<=(size_t shift) {
        if (IsZero() || shift == 0) return *this;
        size_t offset = shift / kTypeBit;
        size_t interShift = shift % kTypeBit;
        (void)( (!!(count_ + offset <= kCapacity)) || (_wassert(L"count_ + offset <= kCapacity", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h", (unsigned)(133)), 0) );
        if (interShift == 0) {
            std::memmove(&digits_[count_ - 1 + offset], &digits_[count_ - 1], count_ * sizeof(Type));
            count_ += offset;
        }
        else {
            digits_[count_] = 0;
            for (size_t i = count_; i > 0; i--)
                digits_[i + offset] = (digits_[i] << interShift) | (digits_[i - 1] >> (kTypeBit - interShift));
            digits_[offset] = digits_[0] << interShift;
            count_ += offset;
            if (digits_[count_])
                count_++;
        }
        std::memset(digits_, 0, offset * sizeof(Type));
        return *this;
    }
    bool operator==(const BigInteger& rhs) const {
        return count_ == rhs.count_ && std::memcmp(digits_, rhs.digits_, count_ * sizeof(Type)) == 0;
    }
    bool operator==(const Type rhs) const {
        return count_ == 1 && digits_[0] == rhs;
    }
    BigInteger& MultiplyPow5(unsigned exp) {
        static const uint32_t kPow5[12] = {
            5,
            5 * 5,
            5 * 5 * 5,
            5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5
        };
        if (exp == 0) return *this;
        for (; exp >= 27; exp -= 27) *this *= ((static_cast<uint64_t>(0X6765C793) << 32) | static_cast<uint64_t>(0XFA10079D)); 
        for (; exp >= 13; exp -= 13) *this *= static_cast<uint32_t>(1220703125u); 
        if (exp > 0)                 *this *= kPow5[exp - 1];
        return *this;
    }
    bool Difference(const BigInteger& rhs, BigInteger* out) const {
        int cmp = Compare(rhs);
        (void)( (!!(cmp != 0)) || (_wassert(L"cmp != 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h", (unsigned)(188)), 0) );
        const BigInteger *a, *b;  
        bool ret;
        if (cmp < 0) { a = &rhs; b = this; ret = true; }
        else         { a = this; b = &rhs; ret = false; }
        Type borrow = 0;
        for (size_t i = 0; i < a->count_; i++) {
            Type d = a->digits_[i] - borrow;
            if (i < b->count_)
                d -= b->digits_[i];
            borrow = (d > a->digits_[i]) ? 1 : 0;
            out->digits_[i] = d;
            if (d != 0)
                out->count_ = i + 1;
        }
        return ret;
    }
    int Compare(const BigInteger& rhs) const {
        if (count_ != rhs.count_)
            return count_ < rhs.count_ ? -1 : 1;
        for (size_t i = count_; i-- > 0;)
            if (digits_[i] != rhs.digits_[i])
                return digits_[i] < rhs.digits_[i] ? -1 : 1;
        return 0;
    }
    size_t GetCount() const { return count_; }
    Type GetDigit(size_t index) const { (void)( (!!(index < count_)) || (_wassert(L"index < count_", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h", (unsigned)(220)), 0) ); return digits_[index]; }
    bool IsZero() const { return count_ == 1 && digits_[0] == 0; }
private:
    void AppendDecimal64(const char* begin, const char* end) {
        uint64_t u = ParseUint64(begin, end);
        if (IsZero())
            *this = u;
        else {
            unsigned exp = static_cast<unsigned>(end - begin);
            (MultiplyPow5(exp) <<= exp) += u;   
        }
    }
    void PushBack(Type digit) {
        (void)( (!!(count_ < kCapacity)) || (_wassert(L"count_ < kCapacity", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h", (unsigned)(235)), 0) );
        digits_[count_++] = digit;
    }
    static uint64_t ParseUint64(const char* begin, const char* end) {
        uint64_t r = 0;
        for (const char* p = begin; p != end; ++p) {
            (void)( (!!(*p >= '0' && *p <= '9')) || (_wassert(L"*p >= '0' && *p <= '9'", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h", (unsigned)(242)), 0) );
            r = r * 10u + static_cast<unsigned>(*p - '0');
        }
        return r;
    }
    static uint64_t MulAdd64(uint64_t a, uint64_t b, uint64_t k, uint64_t* outHigh) {
        uint64_t low = _umul128(a, b, outHigh) + k;
        if (low < k)
            (*outHigh)++;
        return low;
#line 277 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h"
    }
    static const size_t kBitCount = 3328;  
    static const size_t kCapacity = kBitCount / sizeof(Type);
    static const size_t kTypeBit = sizeof(Type) * 8;
    Type digits_[kCapacity];
    size_t count_;
};
} 
}
#line 291 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\biginteger.h"
#line 20 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strtod.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\diyfp.h"
#pragma intrinsic(_BitScanReverse64)
#pragma intrinsic(_umul128)
#line 29 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\diyfp.h"
namespace rapidjson {
namespace internal {
struct DiyFp {
    DiyFp() : f(), e() {}
    DiyFp(uint64_t fp, int exp) : f(fp), e(exp) {}
    explicit DiyFp(double d) {
        union {
            double d;
            uint64_t u64;
        } u = { d };
        int biased_e = static_cast<int>((u.u64 & kDpExponentMask) >> kDpSignificandSize);
        uint64_t significand = (u.u64 & kDpSignificandMask);
        if (biased_e != 0) {
            f = significand + kDpHiddenBit;
            e = biased_e - kDpExponentBias;
        } 
        else {
            f = significand;
            e = kDpMinExponent + 1;
        }
    }
    DiyFp operator-(const DiyFp& rhs) const {
        return DiyFp(f - rhs.f, e);
    }
    DiyFp operator*(const DiyFp& rhs) const {
        uint64_t h;
        uint64_t l = _umul128(f, rhs.f, &h);
        if (l & (uint64_t(1) << 63)) 
            h++;
        return DiyFp(h, e + rhs.e + 64);
#line 99 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\diyfp.h"
    }
    DiyFp Normalize() const {
        unsigned long index;
        _BitScanReverse64(&index, f);
        return DiyFp(f << (63 - index), e - (63 - index));
#line 117 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\diyfp.h"
    }
    DiyFp NormalizeBoundary() const {
        DiyFp res = *this;
        while (!(res.f & (kDpHiddenBit << 1))) {
            res.f <<= 1;
            res.e--;
        }
        res.f <<= (kDiySignificandSize - kDpSignificandSize - 2);
        res.e = res.e - (kDiySignificandSize - kDpSignificandSize - 2);
        return res;
    }
    void NormalizedBoundaries(DiyFp* minus, DiyFp* plus) const {
        DiyFp pl = DiyFp((f << 1) + 1, e - 1).NormalizeBoundary();
        DiyFp mi = (f == kDpHiddenBit) ? DiyFp((f << 2) - 1, e - 2) : DiyFp((f << 1) - 1, e - 1);
        mi.f <<= mi.e - pl.e;
        mi.e = pl.e;
        *plus = pl;
        *minus = mi;
    }
    double ToDouble() const {
        union {
            double d;
            uint64_t u64;
        }u;
        const uint64_t be = (e == kDpDenormalExponent && (f & kDpHiddenBit) == 0) ? 0 : 
            static_cast<uint64_t>(e + kDpExponentBias);
        u.u64 = (f & kDpSignificandMask) | (be << kDpSignificandSize);
        return u.d;
    }
    static const int kDiySignificandSize = 64;
    static const int kDpSignificandSize = 52;
    static const int kDpExponentBias = 0x3FF + kDpSignificandSize;
    static const int kDpMaxExponent = 0x7FF - kDpExponentBias;
    static const int kDpMinExponent = -kDpExponentBias;
    static const int kDpDenormalExponent = -kDpExponentBias + 1;
    static const uint64_t kDpExponentMask = ((static_cast<uint64_t>(0x7FF00000) << 32) | static_cast<uint64_t>(0x00000000));
    static const uint64_t kDpSignificandMask = ((static_cast<uint64_t>(0x000FFFFF) << 32) | static_cast<uint64_t>(0xFFFFFFFF));
    static const uint64_t kDpHiddenBit = ((static_cast<uint64_t>(0x00100000) << 32) | static_cast<uint64_t>(0x00000000));
    uint64_t f;
    int e;
};
inline DiyFp GetCachedPowerByIndex(size_t index) {
    static const uint64_t kCachedPowers_F[] = {
        ((static_cast<uint64_t>(0xfa8fd5a0) << 32) | static_cast<uint64_t>(0x081c0288)), ((static_cast<uint64_t>(0xbaaee17f) << 32) | static_cast<uint64_t>(0xa23ebf76)),
        ((static_cast<uint64_t>(0x8b16fb20) << 32) | static_cast<uint64_t>(0x3055ac76)), ((static_cast<uint64_t>(0xcf42894a) << 32) | static_cast<uint64_t>(0x5dce35ea)),
        ((static_cast<uint64_t>(0x9a6bb0aa) << 32) | static_cast<uint64_t>(0x55653b2d)), ((static_cast<uint64_t>(0xe61acf03) << 32) | static_cast<uint64_t>(0x3d1a45df)),
        ((static_cast<uint64_t>(0xab70fe17) << 32) | static_cast<uint64_t>(0xc79ac6ca)), ((static_cast<uint64_t>(0xff77b1fc) << 32) | static_cast<uint64_t>(0xbebcdc4f)),
        ((static_cast<uint64_t>(0xbe5691ef) << 32) | static_cast<uint64_t>(0x416bd60c)), ((static_cast<uint64_t>(0x8dd01fad) << 32) | static_cast<uint64_t>(0x907ffc3c)),
        ((static_cast<uint64_t>(0xd3515c28) << 32) | static_cast<uint64_t>(0x31559a83)), ((static_cast<uint64_t>(0x9d71ac8f) << 32) | static_cast<uint64_t>(0xada6c9b5)),
        ((static_cast<uint64_t>(0xea9c2277) << 32) | static_cast<uint64_t>(0x23ee8bcb)), ((static_cast<uint64_t>(0xaecc4991) << 32) | static_cast<uint64_t>(0x4078536d)),
        ((static_cast<uint64_t>(0x823c1279) << 32) | static_cast<uint64_t>(0x5db6ce57)), ((static_cast<uint64_t>(0xc2109436) << 32) | static_cast<uint64_t>(0x4dfb5637)),
        ((static_cast<uint64_t>(0x9096ea6f) << 32) | static_cast<uint64_t>(0x3848984f)), ((static_cast<uint64_t>(0xd77485cb) << 32) | static_cast<uint64_t>(0x25823ac7)),
        ((static_cast<uint64_t>(0xa086cfcd) << 32) | static_cast<uint64_t>(0x97bf97f4)), ((static_cast<uint64_t>(0xef340a98) << 32) | static_cast<uint64_t>(0x172aace5)),
        ((static_cast<uint64_t>(0xb23867fb) << 32) | static_cast<uint64_t>(0x2a35b28e)), ((static_cast<uint64_t>(0x84c8d4df) << 32) | static_cast<uint64_t>(0xd2c63f3b)),
        ((static_cast<uint64_t>(0xc5dd4427) << 32) | static_cast<uint64_t>(0x1ad3cdba)), ((static_cast<uint64_t>(0x936b9fce) << 32) | static_cast<uint64_t>(0xbb25c996)),
        ((static_cast<uint64_t>(0xdbac6c24) << 32) | static_cast<uint64_t>(0x7d62a584)), ((static_cast<uint64_t>(0xa3ab6658) << 32) | static_cast<uint64_t>(0x0d5fdaf6)),
        ((static_cast<uint64_t>(0xf3e2f893) << 32) | static_cast<uint64_t>(0xdec3f126)), ((static_cast<uint64_t>(0xb5b5ada8) << 32) | static_cast<uint64_t>(0xaaff80b8)),
        ((static_cast<uint64_t>(0x87625f05) << 32) | static_cast<uint64_t>(0x6c7c4a8b)), ((static_cast<uint64_t>(0xc9bcff60) << 32) | static_cast<uint64_t>(0x34c13053)),
        ((static_cast<uint64_t>(0x964e858c) << 32) | static_cast<uint64_t>(0x91ba2655)), ((static_cast<uint64_t>(0xdff97724) << 32) | static_cast<uint64_t>(0x70297ebd)),
        ((static_cast<uint64_t>(0xa6dfbd9f) << 32) | static_cast<uint64_t>(0xb8e5b88f)), ((static_cast<uint64_t>(0xf8a95fcf) << 32) | static_cast<uint64_t>(0x88747d94)),
        ((static_cast<uint64_t>(0xb9447093) << 32) | static_cast<uint64_t>(0x8fa89bcf)), ((static_cast<uint64_t>(0x8a08f0f8) << 32) | static_cast<uint64_t>(0xbf0f156b)),
        ((static_cast<uint64_t>(0xcdb02555) << 32) | static_cast<uint64_t>(0x653131b6)), ((static_cast<uint64_t>(0x993fe2c6) << 32) | static_cast<uint64_t>(0xd07b7fac)),
        ((static_cast<uint64_t>(0xe45c10c4) << 32) | static_cast<uint64_t>(0x2a2b3b06)), ((static_cast<uint64_t>(0xaa242499) << 32) | static_cast<uint64_t>(0x697392d3)),
        ((static_cast<uint64_t>(0xfd87b5f2) << 32) | static_cast<uint64_t>(0x8300ca0e)), ((static_cast<uint64_t>(0xbce50864) << 32) | static_cast<uint64_t>(0x92111aeb)),
        ((static_cast<uint64_t>(0x8cbccc09) << 32) | static_cast<uint64_t>(0x6f5088cc)), ((static_cast<uint64_t>(0xd1b71758) << 32) | static_cast<uint64_t>(0xe219652c)),
        ((static_cast<uint64_t>(0x9c400000) << 32) | static_cast<uint64_t>(0x00000000)), ((static_cast<uint64_t>(0xe8d4a510) << 32) | static_cast<uint64_t>(0x00000000)),
        ((static_cast<uint64_t>(0xad78ebc5) << 32) | static_cast<uint64_t>(0xac620000)), ((static_cast<uint64_t>(0x813f3978) << 32) | static_cast<uint64_t>(0xf8940984)),
        ((static_cast<uint64_t>(0xc097ce7b) << 32) | static_cast<uint64_t>(0xc90715b3)), ((static_cast<uint64_t>(0x8f7e32ce) << 32) | static_cast<uint64_t>(0x7bea5c70)),
        ((static_cast<uint64_t>(0xd5d238a4) << 32) | static_cast<uint64_t>(0xabe98068)), ((static_cast<uint64_t>(0x9f4f2726) << 32) | static_cast<uint64_t>(0x179a2245)),
        ((static_cast<uint64_t>(0xed63a231) << 32) | static_cast<uint64_t>(0xd4c4fb27)), ((static_cast<uint64_t>(0xb0de6538) << 32) | static_cast<uint64_t>(0x8cc8ada8)),
        ((static_cast<uint64_t>(0x83c7088e) << 32) | static_cast<uint64_t>(0x1aab65db)), ((static_cast<uint64_t>(0xc45d1df9) << 32) | static_cast<uint64_t>(0x42711d9a)),
        ((static_cast<uint64_t>(0x924d692c) << 32) | static_cast<uint64_t>(0xa61be758)), ((static_cast<uint64_t>(0xda01ee64) << 32) | static_cast<uint64_t>(0x1a708dea)),
        ((static_cast<uint64_t>(0xa26da399) << 32) | static_cast<uint64_t>(0x9aef774a)), ((static_cast<uint64_t>(0xf209787b) << 32) | static_cast<uint64_t>(0xb47d6b85)),
        ((static_cast<uint64_t>(0xb454e4a1) << 32) | static_cast<uint64_t>(0x79dd1877)), ((static_cast<uint64_t>(0x865b8692) << 32) | static_cast<uint64_t>(0x5b9bc5c2)),
        ((static_cast<uint64_t>(0xc83553c5) << 32) | static_cast<uint64_t>(0xc8965d3d)), ((static_cast<uint64_t>(0x952ab45c) << 32) | static_cast<uint64_t>(0xfa97a0b3)),
        ((static_cast<uint64_t>(0xde469fbd) << 32) | static_cast<uint64_t>(0x99a05fe3)), ((static_cast<uint64_t>(0xa59bc234) << 32) | static_cast<uint64_t>(0xdb398c25)),
        ((static_cast<uint64_t>(0xf6c69a72) << 32) | static_cast<uint64_t>(0xa3989f5c)), ((static_cast<uint64_t>(0xb7dcbf53) << 32) | static_cast<uint64_t>(0x54e9bece)),
        ((static_cast<uint64_t>(0x88fcf317) << 32) | static_cast<uint64_t>(0xf22241e2)), ((static_cast<uint64_t>(0xcc20ce9b) << 32) | static_cast<uint64_t>(0xd35c78a5)),
        ((static_cast<uint64_t>(0x98165af3) << 32) | static_cast<uint64_t>(0x7b2153df)), ((static_cast<uint64_t>(0xe2a0b5dc) << 32) | static_cast<uint64_t>(0x971f303a)),
        ((static_cast<uint64_t>(0xa8d9d153) << 32) | static_cast<uint64_t>(0x5ce3b396)), ((static_cast<uint64_t>(0xfb9b7cd9) << 32) | static_cast<uint64_t>(0xa4a7443c)),
        ((static_cast<uint64_t>(0xbb764c4c) << 32) | static_cast<uint64_t>(0xa7a44410)), ((static_cast<uint64_t>(0x8bab8eef) << 32) | static_cast<uint64_t>(0xb6409c1a)),
        ((static_cast<uint64_t>(0xd01fef10) << 32) | static_cast<uint64_t>(0xa657842c)), ((static_cast<uint64_t>(0x9b10a4e5) << 32) | static_cast<uint64_t>(0xe9913129)),
        ((static_cast<uint64_t>(0xe7109bfb) << 32) | static_cast<uint64_t>(0xa19c0c9d)), ((static_cast<uint64_t>(0xac2820d9) << 32) | static_cast<uint64_t>(0x623bf429)),
        ((static_cast<uint64_t>(0x80444b5e) << 32) | static_cast<uint64_t>(0x7aa7cf85)), ((static_cast<uint64_t>(0xbf21e440) << 32) | static_cast<uint64_t>(0x03acdd2d)),
        ((static_cast<uint64_t>(0x8e679c2f) << 32) | static_cast<uint64_t>(0x5e44ff8f)), ((static_cast<uint64_t>(0xd433179d) << 32) | static_cast<uint64_t>(0x9c8cb841)),
        ((static_cast<uint64_t>(0x9e19db92) << 32) | static_cast<uint64_t>(0xb4e31ba9)), ((static_cast<uint64_t>(0xeb96bf6e) << 32) | static_cast<uint64_t>(0xbadf77d9)),
        ((static_cast<uint64_t>(0xaf87023b) << 32) | static_cast<uint64_t>(0x9bf0ee6b))
    };
    static const int16_t kCachedPowers_E[] = {
        -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,
        -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,
        -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,
        -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,
        -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,
        109,   136,   162,   189,   216,   242,   269,   295,   322,   348,
        375,   402,   428,   455,   481,   508,   534,   561,   588,   614,
        641,   667,   694,   720,   747,   774,   800,   827,   853,   880,
        907,   933,   960,   986,  1013,  1039,  1066
    };
    return DiyFp(kCachedPowers_F[index], kCachedPowers_E[index]);
}
inline DiyFp GetCachedPower(int e, int* K) {
    double dk = (-61 - e) * 0.30102999566398114 + 347;  
    int k = static_cast<int>(dk);
    if (dk - k > 0.0)
        k++;
    unsigned index = static_cast<unsigned>((k >> 3) + 1);
    *K = -(-348 + static_cast<int>(index << 3));    
    return GetCachedPowerByIndex(index);
}
inline DiyFp GetCachedPower10(int exp, int *outExp) {
     unsigned index = (static_cast<unsigned>(exp) + 348u) / 8u;
     *outExp = -348 + static_cast<int>(index) * 8;
     return GetCachedPowerByIndex(index);
 }
} 
}
#line 259 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\diyfp.h"
#line 21 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strtod.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\pow10.h"
namespace rapidjson {
namespace internal {
inline double Pow10(int n) {
    static const double e[] = { 
        1e+0,  
        1e+1,  1e+2,  1e+3,  1e+4,  1e+5,  1e+6,  1e+7,  1e+8,  1e+9,  1e+10, 1e+11, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20, 
        1e+21, 1e+22, 1e+23, 1e+24, 1e+25, 1e+26, 1e+27, 1e+28, 1e+29, 1e+30, 1e+31, 1e+32, 1e+33, 1e+34, 1e+35, 1e+36, 1e+37, 1e+38, 1e+39, 1e+40,
        1e+41, 1e+42, 1e+43, 1e+44, 1e+45, 1e+46, 1e+47, 1e+48, 1e+49, 1e+50, 1e+51, 1e+52, 1e+53, 1e+54, 1e+55, 1e+56, 1e+57, 1e+58, 1e+59, 1e+60,
        1e+61, 1e+62, 1e+63, 1e+64, 1e+65, 1e+66, 1e+67, 1e+68, 1e+69, 1e+70, 1e+71, 1e+72, 1e+73, 1e+74, 1e+75, 1e+76, 1e+77, 1e+78, 1e+79, 1e+80,
        1e+81, 1e+82, 1e+83, 1e+84, 1e+85, 1e+86, 1e+87, 1e+88, 1e+89, 1e+90, 1e+91, 1e+92, 1e+93, 1e+94, 1e+95, 1e+96, 1e+97, 1e+98, 1e+99, 1e+100,
        1e+101,1e+102,1e+103,1e+104,1e+105,1e+106,1e+107,1e+108,1e+109,1e+110,1e+111,1e+112,1e+113,1e+114,1e+115,1e+116,1e+117,1e+118,1e+119,1e+120,
        1e+121,1e+122,1e+123,1e+124,1e+125,1e+126,1e+127,1e+128,1e+129,1e+130,1e+131,1e+132,1e+133,1e+134,1e+135,1e+136,1e+137,1e+138,1e+139,1e+140,
        1e+141,1e+142,1e+143,1e+144,1e+145,1e+146,1e+147,1e+148,1e+149,1e+150,1e+151,1e+152,1e+153,1e+154,1e+155,1e+156,1e+157,1e+158,1e+159,1e+160,
        1e+161,1e+162,1e+163,1e+164,1e+165,1e+166,1e+167,1e+168,1e+169,1e+170,1e+171,1e+172,1e+173,1e+174,1e+175,1e+176,1e+177,1e+178,1e+179,1e+180,
        1e+181,1e+182,1e+183,1e+184,1e+185,1e+186,1e+187,1e+188,1e+189,1e+190,1e+191,1e+192,1e+193,1e+194,1e+195,1e+196,1e+197,1e+198,1e+199,1e+200,
        1e+201,1e+202,1e+203,1e+204,1e+205,1e+206,1e+207,1e+208,1e+209,1e+210,1e+211,1e+212,1e+213,1e+214,1e+215,1e+216,1e+217,1e+218,1e+219,1e+220,
        1e+221,1e+222,1e+223,1e+224,1e+225,1e+226,1e+227,1e+228,1e+229,1e+230,1e+231,1e+232,1e+233,1e+234,1e+235,1e+236,1e+237,1e+238,1e+239,1e+240,
        1e+241,1e+242,1e+243,1e+244,1e+245,1e+246,1e+247,1e+248,1e+249,1e+250,1e+251,1e+252,1e+253,1e+254,1e+255,1e+256,1e+257,1e+258,1e+259,1e+260,
        1e+261,1e+262,1e+263,1e+264,1e+265,1e+266,1e+267,1e+268,1e+269,1e+270,1e+271,1e+272,1e+273,1e+274,1e+275,1e+276,1e+277,1e+278,1e+279,1e+280,
        1e+281,1e+282,1e+283,1e+284,1e+285,1e+286,1e+287,1e+288,1e+289,1e+290,1e+291,1e+292,1e+293,1e+294,1e+295,1e+296,1e+297,1e+298,1e+299,1e+300,
        1e+301,1e+302,1e+303,1e+304,1e+305,1e+306,1e+307,1e+308
    };
    (void)( (!!(n >= 0 && n <= 308)) || (_wassert(L"n >= 0 && n <= 308", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\pow10.h", (unsigned)(48)), 0) );
    return e[n];
}
} 
}
#line 56 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\pow10.h"
#line 22 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strtod.h"
namespace rapidjson {
namespace internal {
inline double FastPath(double significand, int exp) {
    if (exp < -308)
        return 0.0;
    else if (exp >= 0)
        return significand * internal::Pow10(exp);
    else
        return significand / internal::Pow10(-exp);
}
inline double StrtodNormalPrecision(double d, int p) {
    if (p < -308) {
        d = FastPath(d, -308);
        d = FastPath(d, p + 308);
    }
    else
        d = FastPath(d, p);
    return d;
}
template <typename T>
inline T Min3(T a, T b, T c) {
    T m = a;
    if (m > b) m = b;
    if (m > c) m = c;
    return m;
}
inline int CheckWithinHalfULP(double b, const BigInteger& d, int dExp) {
    const Double db(b);
    const uint64_t bInt = db.IntegerSignificand();
    const int bExp = db.IntegerExponent();
    const int hExp = bExp - 1;
    int dS_Exp2 = 0, dS_Exp5 = 0, bS_Exp2 = 0, bS_Exp5 = 0, hS_Exp2 = 0, hS_Exp5 = 0;
    if (dExp >= 0) {
        dS_Exp2 += dExp;
        dS_Exp5 += dExp;
    }
    else {
        bS_Exp2 -= dExp;
        bS_Exp5 -= dExp;
        hS_Exp2 -= dExp;
        hS_Exp5 -= dExp;
    }
    if (bExp >= 0)
        bS_Exp2 += bExp;
    else {
        dS_Exp2 -= bExp;
        hS_Exp2 -= bExp;
    }
    if (hExp >= 0)
        hS_Exp2 += hExp;
    else {
        dS_Exp2 -= hExp;
        bS_Exp2 -= hExp;
    }
    int common_Exp2 = Min3(dS_Exp2, bS_Exp2, hS_Exp2);
    dS_Exp2 -= common_Exp2;
    bS_Exp2 -= common_Exp2;
    hS_Exp2 -= common_Exp2;
    BigInteger dS = d;
    dS.MultiplyPow5(static_cast<unsigned>(dS_Exp5)) <<= static_cast<unsigned>(dS_Exp2);
    BigInteger bS(bInt);
    bS.MultiplyPow5(static_cast<unsigned>(bS_Exp5)) <<= static_cast<unsigned>(bS_Exp2);
    BigInteger hS(1);
    hS.MultiplyPow5(static_cast<unsigned>(hS_Exp5)) <<= static_cast<unsigned>(hS_Exp2);
    BigInteger delta(0);
    dS.Difference(bS, &delta);
    return delta.Compare(hS);
}
inline bool StrtodFast(double d, int p, double* result) {
    if (p > 22  && p < 22 + 16) {
        d *= internal::Pow10(p - 22);
        p = 22;
    }
    if (p >= -22 && p <= 22 && d <= 9007199254740991.0) { 
        *result = FastPath(d, p);
        return true;
    }
    else
        return false;
}
inline bool StrtodDiyFp(const char* decimals, size_t length, size_t decimalPosition, int exp, double* result) {
    uint64_t significand = 0;
    size_t i = 0;   
    for (; i < length; i++) {
        if (significand  >  ((static_cast<uint64_t>(0x19999999) << 32) | static_cast<uint64_t>(0x99999999)) ||
            (significand == ((static_cast<uint64_t>(0x19999999) << 32) | static_cast<uint64_t>(0x99999999)) && decimals[i] > '5'))
            break;
        significand = significand * 10u + static_cast<unsigned>(decimals[i] - '0');
    }
    if (i < length && decimals[i] >= '5') 
        significand++;
    size_t remaining = length - i;
    const unsigned kUlpShift = 3;
    const unsigned kUlp = 1 << kUlpShift;
    int64_t error = (remaining == 0) ? 0 : kUlp / 2;
    DiyFp v(significand, 0);
    v = v.Normalize();
    error <<= -v.e;
    const int dExp = static_cast<int>(decimalPosition) - static_cast<int>(i) + exp;
    int actualExp;
    DiyFp cachedPower = GetCachedPower10(dExp, &actualExp);
    if (actualExp != dExp) {
        static const DiyFp kPow10[] = {
            DiyFp(((static_cast<uint64_t>(0xa0000000) << 32) | static_cast<uint64_t>(00000000)), -60),  
            DiyFp(((static_cast<uint64_t>(0xc8000000) << 32) | static_cast<uint64_t>(00000000)), -57),  
            DiyFp(((static_cast<uint64_t>(0xfa000000) << 32) | static_cast<uint64_t>(00000000)), -54),  
            DiyFp(((static_cast<uint64_t>(0x9c400000) << 32) | static_cast<uint64_t>(00000000)), -50),  
            DiyFp(((static_cast<uint64_t>(0xc3500000) << 32) | static_cast<uint64_t>(00000000)), -47),  
            DiyFp(((static_cast<uint64_t>(0xf4240000) << 32) | static_cast<uint64_t>(00000000)), -44),  
            DiyFp(((static_cast<uint64_t>(0x98968000) << 32) | static_cast<uint64_t>(00000000)), -40)   
        };
        int  adjustment = dExp - actualExp - 1;
        (void)( (!!(adjustment >= 0 && adjustment < 7)) || (_wassert(L"adjustment >= 0 && adjustment < 7", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strtod.h", (unsigned)(166)), 0) );
        v = v * kPow10[adjustment];
        if (length + static_cast<unsigned>(adjustment)> 19u) 
            error += kUlp / 2;
    }
    v = v * cachedPower;
    error += kUlp + (error == 0 ? 0 : 1);
    const int oldExp = v.e;
    v = v.Normalize();
    error <<= oldExp - v.e;
    const unsigned effectiveSignificandSize = Double::EffectiveSignificandSize(64 + v.e);
    unsigned precisionSize = 64 - effectiveSignificandSize;
    if (precisionSize + kUlpShift >= 64) {
        unsigned scaleExp = (precisionSize + kUlpShift) - 63;
        v.f >>= scaleExp;
        v.e += scaleExp; 
        error = (error >> scaleExp) + 1 + static_cast<int>(kUlp);
        precisionSize -= scaleExp;
    }
    DiyFp rounded(v.f >> precisionSize, v.e + static_cast<int>(precisionSize));
    const uint64_t precisionBits = (v.f & ((uint64_t(1) << precisionSize) - 1)) * kUlp;
    const uint64_t halfWay = (uint64_t(1) << (precisionSize - 1)) * kUlp;
    if (precisionBits >= halfWay + static_cast<unsigned>(error)) {
        rounded.f++;
        if (rounded.f & (DiyFp::kDpHiddenBit << 1)) { 
            rounded.f >>= 1;
            rounded.e++;
        }
    }
    *result = rounded.ToDouble();
    return halfWay - static_cast<unsigned>(error) >= precisionBits || precisionBits >= halfWay + static_cast<unsigned>(error);
}
inline double StrtodBigInteger(double approx, const char* decimals, size_t length, size_t decimalPosition, int exp) {
    const BigInteger dInt(decimals, length);
    const int dExp = static_cast<int>(decimalPosition) - static_cast<int>(length) + exp;
    Double a(approx);
    int cmp = CheckWithinHalfULP(a.Value(), dInt, dExp);
    if (cmp < 0)
        return a.Value();  
    else if (cmp == 0) {
        if (a.Significand() & 1)
            return a.NextPositiveDouble();
        else
            return a.Value();
    }
    else 
        return a.NextPositiveDouble();
}
inline double StrtodFullPrecision(double d, int p, const char* decimals, size_t length, size_t decimalPosition, int exp) {
    (void)( (!!(d >= 0.0)) || (_wassert(L"d >= 0.0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strtod.h", (unsigned)(225)), 0) );
    (void)( (!!(length >= 1)) || (_wassert(L"length >= 1", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strtod.h", (unsigned)(226)), 0) );
    double result;
    if (StrtodFast(d, p, &result))
        return result;
    while (*decimals == '0' && length > 1) {
        length--;
        decimals++;
        decimalPosition--;
    }
    while (decimals[length - 1] == '0' && length > 1) {
        length--;
        decimalPosition--;
        exp++;
    }
    const int kMaxDecimalDigit = 780;
    if (static_cast<int>(length) > kMaxDecimalDigit) {
        int delta = (static_cast<int>(length) - kMaxDecimalDigit);
        exp += delta;
        decimalPosition -= static_cast<unsigned>(delta);
        length = kMaxDecimalDigit;
    }
    if (int(length) + exp < -324)
        return 0.0;
    if (StrtodDiyFp(decimals, length, decimalPosition, exp, &result))
        return result;
    return StrtodBigInteger(result, decimals, length, decimalPosition, exp);
}
} 
}
#line 270 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strtod.h"
#line 26 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 32 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 37 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
__pragma(warning(push))
__pragma(warning(disable: 4127))  
__pragma(warning(disable: 4702))  
#line 43 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 64 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 105 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 124 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\error/error.h"
#line 41 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\error/error.h"
#line 54 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\error/error.h"
namespace rapidjson {
enum ParseErrorCode {
    kParseErrorNone = 0,                        
    kParseErrorDocumentEmpty,                   
    kParseErrorDocumentRootNotSingular,         
    kParseErrorValueInvalid,                    
    kParseErrorObjectMissName,                  
    kParseErrorObjectMissColon,                 
    kParseErrorObjectMissCommaOrCurlyBracket,   
    kParseErrorArrayMissCommaOrSquareBracket,   
    kParseErrorStringUnicodeEscapeInvalidHex,   
    kParseErrorStringUnicodeSurrogateInvalid,   
    kParseErrorStringEscapeInvalid,             
    kParseErrorStringMissQuotationMark,         
    kParseErrorStringInvalidEncoding,           
    kParseErrorNumberTooBig,                    
    kParseErrorNumberMissFraction,              
    kParseErrorNumberMissExponent,              
    kParseErrorTermination,                     
    kParseErrorUnspecificSyntaxError            
};
struct ParseResult {
public:
    ParseResult() : code_(kParseErrorNone), offset_(0) {}
    ParseResult(ParseErrorCode code, size_t offset) : code_(code), offset_(offset) {}
    ParseErrorCode Code() const { return code_; }
    size_t Offset() const { return offset_; }
    operator bool() const { return !IsError(); }
    bool IsError() const { return code_ != kParseErrorNone; }
    bool operator==(const ParseResult& that) const { return code_ == that.code_; }
    bool operator==(ParseErrorCode code) const { return code_ == code; }
    friend bool operator==(ParseErrorCode code, const ParseResult & err) { return code == err.code_; }
    void Clear() { Set(kParseErrorNone); }
    void Set(ParseErrorCode code, size_t offset = 0) { code_ = code; offset_ = offset; }
private:
    ParseErrorCode code_;
    size_t offset_;
};
typedef const char* (*GetParseErrorFunc)(ParseErrorCode);
}
#line 156 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\error/error.h"
#line 126 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
namespace rapidjson {
#line 141 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
enum ParseFlag {
    kParseNoFlags = 0,              
    kParseInsituFlag = 1,           
    kParseValidateEncodingFlag = 2, 
    kParseIterativeFlag = 4,        
    kParseStopWhenDoneFlag = 8,     
    kParseFullPrecisionFlag = 16,   
    kParseCommentsFlag = 32,        
    kParseNumbersAsStringsFlag = 64,    
    kParseTrailingCommasFlag = 128, 
    kParseNanAndInfFlag = 256,      
    kParseDefaultFlags = kParseNoFlags  
};
template<typename Encoding = UTF8<>, typename Derived = void>
struct BaseReaderHandler {
    typedef typename Encoding::Ch Ch;
    typedef typename internal::SelectIf<internal::IsSame<Derived, void>, BaseReaderHandler, Derived>::Type Override;
    bool Default() { return true; }
    bool Null() { return static_cast<Override&>(*this).Default(); }
    bool Bool(bool) { return static_cast<Override&>(*this).Default(); }
    bool Int(int) { return static_cast<Override&>(*this).Default(); }
    bool Uint(unsigned) { return static_cast<Override&>(*this).Default(); }
    bool Int64(int64_t) { return static_cast<Override&>(*this).Default(); }
    bool Uint64(uint64_t) { return static_cast<Override&>(*this).Default(); }
    bool Double(double) { return static_cast<Override&>(*this).Default(); }
    bool RawNumber(const Ch* str, SizeType len, bool copy) { return static_cast<Override&>(*this).String(str, len, copy); }
    bool String(const Ch*, SizeType, bool) { return static_cast<Override&>(*this).Default(); }
    bool StartObject() { return static_cast<Override&>(*this).Default(); }
    bool Key(const Ch* str, SizeType len, bool copy) { return static_cast<Override&>(*this).String(str, len, copy); }
    bool EndObject(SizeType) { return static_cast<Override&>(*this).Default(); }
    bool StartArray() { return static_cast<Override&>(*this).Default(); }
    bool EndArray(SizeType) { return static_cast<Override&>(*this).Default(); }
};
namespace internal {
template<typename Stream, int = StreamTraits<Stream>::copyOptimization>
class StreamLocalCopy;
template<typename Stream>
class StreamLocalCopy<Stream, 1> {
public:
    StreamLocalCopy(Stream& original) : s(original), original_(original) {}
    ~StreamLocalCopy() { original_ = s; }
    Stream s;
private:
    StreamLocalCopy& operator=(const StreamLocalCopy&) ;
    Stream& original_;
};
template<typename Stream>
class StreamLocalCopy<Stream, 0> {
public:
    StreamLocalCopy(Stream& original) : s(original) {}
    Stream& s;
private:
    StreamLocalCopy& operator=(const StreamLocalCopy&) ;
};
} 
template<typename InputStream>
void SkipWhitespace(InputStream& is) {
    internal::StreamLocalCopy<InputStream> copy(is);
    InputStream& s(copy.s);
    typename InputStream::Ch c;
    while ((c = s.Peek()) == ' ' || c == '\n' || c == '\r' || c == '\t')
        s.Take();
}
inline const char* SkipWhitespace(const char* p, const char* end) {
    while (p != end && (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t'))
        ++p;
    return p;
}
#line 429 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
template <typename SourceEncoding, typename TargetEncoding, typename StackAllocator = CrtAllocator>
class GenericReader {
public:
    typedef typename SourceEncoding::Ch Ch; 
    GenericReader(StackAllocator* stackAllocator = 0, size_t stackCapacity = kDefaultStackCapacity) : stack_(stackAllocator, stackCapacity), parseResult_() {}
    template <unsigned parseFlags, typename InputStream, typename Handler>
    ParseResult Parse(InputStream& is, Handler& handler) {
        if (parseFlags & kParseIterativeFlag)
            return IterativeParse<parseFlags>(is, handler);
        parseResult_.Clear();
        ClearStackOnExit scope(*this);
        SkipWhitespaceAndComments<parseFlags>(is);
        do { if ((HasParseError())) { return parseResult_; } } while((void)0, 0);
        if ((is.Peek() == '\0')) {
            do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(497)), 0) ); SetParseError(kParseErrorDocumentEmpty, is.Tell()); } while((void)0, 0);
            do { if ((HasParseError())) { return parseResult_; } } while((void)0, 0);
        }
        else {
            ParseValue<parseFlags>(is, handler);
            do { if ((HasParseError())) { return parseResult_; } } while((void)0, 0);
            if (!(parseFlags & kParseStopWhenDoneFlag)) {
                SkipWhitespaceAndComments<parseFlags>(is);
                do { if ((HasParseError())) { return parseResult_; } } while((void)0, 0);
                if ((is.Peek() != '\0')) {
                    do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(509)), 0) ); SetParseError(kParseErrorDocumentRootNotSingular, is.Tell()); } while((void)0, 0);
                    do { if ((HasParseError())) { return parseResult_; } } while((void)0, 0);
                }
            }
        }
        return parseResult_;
    }
    template <typename InputStream, typename Handler>
    ParseResult Parse(InputStream& is, Handler& handler) {
        return Parse<kParseDefaultFlags>(is, handler);
    }
    bool HasParseError() const { return parseResult_.IsError(); }
    ParseErrorCode GetParseErrorCode() const { return parseResult_.Code(); }
    size_t GetErrorOffset() const { return parseResult_.Offset(); }
protected:
    void SetParseError(ParseErrorCode code, size_t offset) { parseResult_.Set(code, offset); }
private:
    GenericReader(const GenericReader&);
    GenericReader& operator=(const GenericReader&);
    void ClearStack() { stack_.Clear(); }
    struct ClearStackOnExit {
        explicit ClearStackOnExit(GenericReader& r) : r_(r) {}
        ~ClearStackOnExit() { r_.ClearStack(); }
    private:
        GenericReader& r_;
        ClearStackOnExit(const ClearStackOnExit&);
        ClearStackOnExit& operator=(const ClearStackOnExit&);
    };
    template<unsigned parseFlags, typename InputStream>
    void SkipWhitespaceAndComments(InputStream& is) {
        SkipWhitespace(is);
        if (parseFlags & kParseCommentsFlag) {
            while ((Consume(is, '/'))) {
                if (Consume(is, '*')) {
                    while (true) {
                        if ((is.Peek() == '\0'))
                            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(568)), 0) ); SetParseError(kParseErrorUnspecificSyntaxError, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                        else if (Consume(is, '*')) {
                            if (Consume(is, '/'))
                                break;
                        }
                        else
                            is.Take();
                    }
                }
                else if ((Consume(is, '/')))
                    while (is.Peek() != '\0' && is.Take() != '\n');
                else
                    do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(580)), 0) ); SetParseError(kParseErrorUnspecificSyntaxError, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                SkipWhitespace(is);
            }
        }
    }
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseObject(InputStream& is, Handler& handler) {
        (void)( (!!(is.Peek() == '{')) || (_wassert(L"is.Peek() == '{'", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(590)), 0) );
        is.Take();  
        if ((!handler.StartObject()))
            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(594)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
        SkipWhitespaceAndComments<parseFlags>(is);
        do { if ((HasParseError())) { return ; } } while((void)0, 0);
        if (Consume(is, '}')) {
            if ((!handler.EndObject(0)))  
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(601)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            return;
        }
        for (SizeType memberCount = 0;;) {
            if ((is.Peek() != '"'))
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(607)), 0) ); SetParseError(kParseErrorObjectMissName, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            ParseString<parseFlags>(is, handler, true);
            do { if ((HasParseError())) { return ; } } while((void)0, 0);
            SkipWhitespaceAndComments<parseFlags>(is);
            do { if ((HasParseError())) { return ; } } while((void)0, 0);
            if ((!Consume(is, ':')))
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(616)), 0) ); SetParseError(kParseErrorObjectMissColon, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            SkipWhitespaceAndComments<parseFlags>(is);
            do { if ((HasParseError())) { return ; } } while((void)0, 0);
            ParseValue<parseFlags>(is, handler);
            do { if ((HasParseError())) { return ; } } while((void)0, 0);
            SkipWhitespaceAndComments<parseFlags>(is);
            do { if ((HasParseError())) { return ; } } while((void)0, 0);
            ++memberCount;
            switch (is.Peek()) {
                case ',':
                    is.Take();
                    SkipWhitespaceAndComments<parseFlags>(is);
                    do { if ((HasParseError())) { return ; } } while((void)0, 0);
                    break;
                case '}':
                    is.Take();
                    if ((!handler.EndObject(memberCount)))
                        do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(638)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                    return;
                default:
                    do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(641)), 0) ); SetParseError(kParseErrorObjectMissCommaOrCurlyBracket, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0); break; 
            }
            if (parseFlags & kParseTrailingCommasFlag) {
                if (is.Peek() == '}') {
                    if ((!handler.EndObject(memberCount)))
                        do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(647)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                    is.Take();
                    return;
                }
            }
        }
    }
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseArray(InputStream& is, Handler& handler) {
        (void)( (!!(is.Peek() == '[')) || (_wassert(L"is.Peek() == '['", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(658)), 0) );
        is.Take();  
        if ((!handler.StartArray()))
            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(662)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
        SkipWhitespaceAndComments<parseFlags>(is);
        do { if ((HasParseError())) { return ; } } while((void)0, 0);
        if (Consume(is, ']')) {
            if ((!handler.EndArray(0))) 
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(669)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            return;
        }
        for (SizeType elementCount = 0;;) {
            ParseValue<parseFlags>(is, handler);
            do { if ((HasParseError())) { return ; } } while((void)0, 0);
            ++elementCount;
            SkipWhitespaceAndComments<parseFlags>(is);
            do { if ((HasParseError())) { return ; } } while((void)0, 0);
            if (Consume(is, ',')) {
                SkipWhitespaceAndComments<parseFlags>(is);
                do { if ((HasParseError())) { return ; } } while((void)0, 0);
            }
            else if (Consume(is, ']')) {
                if ((!handler.EndArray(elementCount)))
                    do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(687)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                return;
            }
            else
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(691)), 0) ); SetParseError(kParseErrorArrayMissCommaOrSquareBracket, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            if (parseFlags & kParseTrailingCommasFlag) {
                if (is.Peek() == ']') {
                    if ((!handler.EndArray(elementCount)))
                        do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(696)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                    is.Take();
                    return;
                }
            }
        }
    }
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseNull(InputStream& is, Handler& handler) {
        (void)( (!!(is.Peek() == 'n')) || (_wassert(L"is.Peek() == 'n'", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(706)), 0) );
        is.Take();
        if ((Consume(is, 'u') && Consume(is, 'l') && Consume(is, 'l'))) {
            if ((!handler.Null()))
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(711)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
        }
        else
            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(714)), 0) ); SetParseError(kParseErrorValueInvalid, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
    }
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseTrue(InputStream& is, Handler& handler) {
        (void)( (!!(is.Peek() == 't')) || (_wassert(L"is.Peek() == 't'", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(719)), 0) );
        is.Take();
        if ((Consume(is, 'r') && Consume(is, 'u') && Consume(is, 'e'))) {
            if ((!handler.Bool(true)))
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(724)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
        }
        else
            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(727)), 0) ); SetParseError(kParseErrorValueInvalid, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
    }
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseFalse(InputStream& is, Handler& handler) {
        (void)( (!!(is.Peek() == 'f')) || (_wassert(L"is.Peek() == 'f'", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(732)), 0) );
        is.Take();
        if ((Consume(is, 'a') && Consume(is, 'l') && Consume(is, 's') && Consume(is, 'e'))) {
            if ((!handler.Bool(false)))
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(737)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
        }
        else
            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(740)), 0) ); SetParseError(kParseErrorValueInvalid, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
    }
    template<typename InputStream>
     static bool Consume(InputStream& is, typename InputStream::Ch expect) {
        if ((is.Peek() == expect)) {
            is.Take();
            return true;
        }
        else
            return false;
    }
    template<typename InputStream>
    unsigned ParseHex4(InputStream& is, size_t escapeOffset) {
        unsigned codepoint = 0;
        for (int i = 0; i < 4; i++) {
            Ch c = is.Peek();
            codepoint <<= 4;
            codepoint += static_cast<unsigned>(c);
            if (c >= '0' && c <= '9')
                codepoint -= '0';
            else if (c >= 'A' && c <= 'F')
                codepoint -= 'A' - 10;
            else if (c >= 'a' && c <= 'f')
                codepoint -= 'a' - 10;
            else {
                do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(768)), 0) ); SetParseError(kParseErrorStringUnicodeEscapeInvalidHex, escapeOffset); } while((void)0, 0);
                do { if ((HasParseError())) { return 0; } } while((void)0, 0);
            }
            is.Take();
        }
        return codepoint;
    }
    template <typename CharType>
    class StackStream {
    public:
        typedef CharType Ch;
        StackStream(internal::Stack<StackAllocator>& stack) : stack_(stack), length_(0) {}
         void Put(Ch c) {
            *stack_.template Push<Ch>() = c;
            ++length_;
        }
         void* Push(SizeType count) {
            length_ += count;
            return stack_.template Push<Ch>(count);
        }
        size_t Length() const { return length_; }
        Ch* Pop() {
            return stack_.template Pop<Ch>(length_);
        }
    private:
        StackStream(const StackStream&);
        StackStream& operator=(const StackStream&);
        internal::Stack<StackAllocator>& stack_;
        SizeType length_;
    };
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseString(InputStream& is, Handler& handler, bool isKey = false) {
        internal::StreamLocalCopy<InputStream> copy(is);
        InputStream& s(copy.s);
        (void)( (!!(s.Peek() == '\"')) || (_wassert(L"s.Peek() == '\\\"'", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(812)), 0) );
        s.Take();  
        bool success = false;
        if (parseFlags & kParseInsituFlag) {
            typename InputStream::Ch *head = s.PutBegin();
            ParseStringToStream<parseFlags, SourceEncoding, SourceEncoding>(s, s);
            do { if ((HasParseError())) { return ; } } while((void)0, 0);
            size_t length = s.PutEnd(head) - 1;
            (void)( (!!(length <= 0xFFFFFFFF)) || (_wassert(L"length <= 0xFFFFFFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(821)), 0) );
            const typename TargetEncoding::Ch* const str = reinterpret_cast<typename TargetEncoding::Ch*>(head);
            success = (isKey ? handler.Key(str, SizeType(length), false) : handler.String(str, SizeType(length), false));
        }
        else {
            StackStream<typename TargetEncoding::Ch> stackStream(stack_);
            ParseStringToStream<parseFlags, SourceEncoding, TargetEncoding>(s, stackStream);
            do { if ((HasParseError())) { return ; } } while((void)0, 0);
            SizeType length = static_cast<SizeType>(stackStream.Length()) - 1;
            const typename TargetEncoding::Ch* const str = stackStream.Pop();
            success = (isKey ? handler.Key(str, length, true) : handler.String(str, length, true));
        }
        if ((!success))
            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(834)), 0) ); SetParseError(kParseErrorTermination, s.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
    }
    template<unsigned parseFlags, typename SEncoding, typename TEncoding, typename InputStream, typename OutputStream>
     void ParseStringToStream(InputStream& is, OutputStream& os) {
        static const char escape[256] = {
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,'\"', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'/',
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\', 0, 0, 0,
            0, 0,'\b', 0, 0, 0,'\f', 0, 0, 0, 0, 0, 0, 0,'\n', 0,
            0, 0,'\r', 0,'\t', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        };
        for (;;) {
            if (!(parseFlags & kParseValidateEncodingFlag))
                ScanCopyUnescapedString(is, os);
            Ch c = is.Peek();
            if ((c == '\\')) {    
                size_t escapeOffset = is.Tell();    
                is.Take();
                Ch e = is.Peek();
                if ((sizeof(Ch) == 1 || unsigned(e) < 256) && (escape[static_cast<unsigned char>(e)])) {
                    is.Take();
                    os.Put(static_cast<typename TEncoding::Ch>(escape[static_cast<unsigned char>(e)]));
                }
                else if ((e == 'u')) {    
                    is.Take();
                    unsigned codepoint = ParseHex4(is, escapeOffset);
                    do { if ((HasParseError())) { return ; } } while((void)0, 0);
                    if ((codepoint >= 0xD800 && codepoint <= 0xDBFF)) {
                        if ((!Consume(is, '\\') || !Consume(is, 'u')))
                            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(874)), 0) ); SetParseError(kParseErrorStringUnicodeSurrogateInvalid, escapeOffset); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                        unsigned codepoint2 = ParseHex4(is, escapeOffset);
                        do { if ((HasParseError())) { return ; } } while((void)0, 0);
                        if ((codepoint2 < 0xDC00 || codepoint2 > 0xDFFF))
                            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(878)), 0) ); SetParseError(kParseErrorStringUnicodeSurrogateInvalid, escapeOffset); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                        codepoint = (((codepoint - 0xD800) << 10) | (codepoint2 - 0xDC00)) + 0x10000;
                    }
                    TEncoding::Encode(os, codepoint);
                }
                else
                    do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(884)), 0) ); SetParseError(kParseErrorStringEscapeInvalid, escapeOffset); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            }
            else if ((c == '"')) {    
                is.Take();
                os.Put('\0');   
                return;
            }
            else if ((static_cast<unsigned>(c) < 0x20)) { 
                if (c == '\0')
                    do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(893)), 0) ); SetParseError(kParseErrorStringMissQuotationMark, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                else
                    do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(895)), 0) ); SetParseError(kParseErrorStringEscapeInvalid, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            }
            else {
                size_t offset = is.Tell();
                if (((parseFlags & kParseValidateEncodingFlag ? !Transcoder<SEncoding, TEncoding>::Validate(is, os) : !Transcoder<SEncoding, TEncoding>::Transcode(is, os))))
#line 902 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
                    do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(902)), 0) ); SetParseError(kParseErrorStringInvalidEncoding, offset); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            }
        }
    }
    template<typename InputStream, typename OutputStream>
    static  void ScanCopyUnescapedString(InputStream&, OutputStream&) {
    }
#line 1068 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
    template<typename InputStream, bool backup, bool pushOnTake>
    class NumberStream;
    template<typename InputStream>
    class NumberStream<InputStream, false, false> {
    public:
        typedef typename InputStream::Ch Ch;
        NumberStream(GenericReader& reader, InputStream& s) : is(s) { (void)reader;  }
        ~NumberStream() {}
         Ch Peek() const { return is.Peek(); }
         Ch TakePush() { return is.Take(); }
         Ch Take() { return is.Take(); }
		   void Push(char) {}
        size_t Tell() { return is.Tell(); }
        size_t Length() { return 0; }
        const char* Pop() { return 0; }
    protected:
        NumberStream& operator=(const NumberStream&);
        InputStream& is;
    };
    template<typename InputStream>
    class NumberStream<InputStream, true, false> : public NumberStream<InputStream, false, false> {
        typedef NumberStream<InputStream, false, false> Base;
    public:
        NumberStream(GenericReader& reader, InputStream& is) : Base(reader, is), stackStream(reader.stack_) {}
        ~NumberStream() {}
         Ch TakePush() {
            stackStream.Put(static_cast<char>(Base::is.Peek()));
            return Base::is.Take();
        }
         void Push(char c) {
            stackStream.Put(c);
        }
        size_t Length() { return stackStream.Length(); }
        const char* Pop() {
            stackStream.Put('\0');
            return stackStream.Pop();
        }
    private:
        StackStream<char> stackStream;
    };
    template<typename InputStream>
    class NumberStream<InputStream, true, true> : public NumberStream<InputStream, true, false> {
        typedef NumberStream<InputStream, true, false> Base;
    public:
        NumberStream(GenericReader& reader, InputStream& is) : Base(reader, is) {}
        ~NumberStream() {}
         Ch Take() { return Base::TakePush(); }
    };
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseNumber(InputStream& is, Handler& handler) {
        internal::StreamLocalCopy<InputStream> copy(is);
        NumberStream<InputStream,
            ((parseFlags & kParseNumbersAsStringsFlag) != 0) ?
                ((parseFlags & kParseInsituFlag) == 0) :
                ((parseFlags & kParseFullPrecisionFlag) != 0),
            (parseFlags & kParseNumbersAsStringsFlag) != 0 &&
                (parseFlags & kParseInsituFlag) == 0> s(*this, copy.s);
        size_t startOffset = s.Tell();
        double d = 0.0;
        bool useNanOrInf = false;
        bool minus = Consume(s, '-');
        unsigned i = 0;
        uint64_t i64 = 0;
        bool use64bit = false;
        int significandDigit = 0;
        if ((s.Peek() == '0')) {
            i = 0;
            s.TakePush();
        }
        else if ((s.Peek() >= '1' && s.Peek() <= '9')) {
            i = static_cast<unsigned>(s.TakePush() - '0');
            if (minus)
                while ((s.Peek() >= '0' && s.Peek() <= '9')) {
                    if ((i >= 214748364)) { 
                        if ((i != 214748364 || s.Peek() > '8')) {
                            i64 = i;
                            use64bit = true;
                            break;
                        }
                    }
                    i = i * 10 + static_cast<unsigned>(s.TakePush() - '0');
                    significandDigit++;
                }
            else
                while ((s.Peek() >= '0' && s.Peek() <= '9')) {
                    if ((i >= 429496729)) { 
                        if ((i != 429496729 || s.Peek() > '5')) {
                            i64 = i;
                            use64bit = true;
                            break;
                        }
                    }
                    i = i * 10 + static_cast<unsigned>(s.TakePush() - '0');
                    significandDigit++;
                }
        }
        else if ((parseFlags & kParseNanAndInfFlag) && ((s.Peek() == 'I' || s.Peek() == 'N'))) {
            useNanOrInf = true;
            if ((Consume(s, 'N') && Consume(s, 'a') && Consume(s, 'N'))) {
                d = std::numeric_limits<double>::quiet_NaN();
            }
            else if ((Consume(s, 'I') && Consume(s, 'n') && Consume(s, 'f'))) {
                d = (minus ? -std::numeric_limits<double>::infinity() : std::numeric_limits<double>::infinity());
                if ((s.Peek() == 'i' && !(Consume(s, 'i') && Consume(s, 'n') && Consume(s, 'i') && Consume(s, 't') && Consume(s, 'y'))))
#line 1196 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
                    do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1196)), 0) ); SetParseError(kParseErrorValueInvalid, s.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            }
            else
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1199)), 0) ); SetParseError(kParseErrorValueInvalid, s.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
        }
        else
            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1202)), 0) ); SetParseError(kParseErrorValueInvalid, s.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
        bool useDouble = false;
        if (use64bit) {
            if (minus)
                while ((s.Peek() >= '0' && s.Peek() <= '9')) {
                     if ((i64 >= ((static_cast<uint64_t>(0x0CCCCCCC) << 32) | static_cast<uint64_t>(0xCCCCCCCC)))) 
                        if ((i64 != ((static_cast<uint64_t>(0x0CCCCCCC) << 32) | static_cast<uint64_t>(0xCCCCCCCC)) || s.Peek() > '8')) {
                            d = static_cast<double>(i64);
                            useDouble = true;
                            break;
                        }
                    i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');
                    significandDigit++;
                }
            else
                while ((s.Peek() >= '0' && s.Peek() <= '9')) {
                    if ((i64 >= ((static_cast<uint64_t>(0x19999999) << 32) | static_cast<uint64_t>(0x99999999)))) 
                        if ((i64 != ((static_cast<uint64_t>(0x19999999) << 32) | static_cast<uint64_t>(0x99999999)) || s.Peek() > '5')) {
                            d = static_cast<double>(i64);
                            useDouble = true;
                            break;
                        }
                    i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');
                    significandDigit++;
                }
        }
        if (useDouble) {
            while ((s.Peek() >= '0' && s.Peek() <= '9')) {
                if ((d >= 1.7976931348623157e307)) 
                    do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1235)), 0) ); SetParseError(kParseErrorNumberTooBig, startOffset); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                d = d * 10 + (s.TakePush() - '0');
            }
        }
        int expFrac = 0;
        size_t decimalPosition;
        if (Consume(s, '.')) {
            decimalPosition = s.Length();
            if ((!(s.Peek() >= '0' && s.Peek() <= '9')))
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1247)), 0) ); SetParseError(kParseErrorNumberMissFraction, s.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            if (!useDouble) {
                if (!use64bit)
                    i64 = i;
                while ((s.Peek() >= '0' && s.Peek() <= '9')) {
                    if (i64 > ((static_cast<uint64_t>(0x1FFFFF) << 32) | static_cast<uint64_t>(0xFFFFFFFF))) 
                        break;
                    else {
                        i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');
                        --expFrac;
                        if (i64 != 0)
                            significandDigit++;
                    }
                }
                d = static_cast<double>(i64);
#line 1271 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
                useDouble = true;
            }
            while ((s.Peek() >= '0' && s.Peek() <= '9')) {
                if (significandDigit < 17) {
                    d = d * 10.0 + (s.TakePush() - '0');
                    --expFrac;
                    if ((d > 0.0))
                        significandDigit++;
                }
                else
                    s.TakePush();
            }
        }
        else
            decimalPosition = s.Length(); 
        int exp = 0;
        if (Consume(s, 'e') || Consume(s, 'E')) {
            if (!useDouble) {
                d = static_cast<double>(use64bit ? i64 : i);
                useDouble = true;
            }
            bool expMinus = false;
            if (Consume(s, '+'))
                ;
            else if (Consume(s, '-'))
                expMinus = true;
            if ((s.Peek() >= '0' && s.Peek() <= '9')) {
                exp = static_cast<int>(s.Take() - '0');
                if (expMinus) {
                    while ((s.Peek() >= '0' && s.Peek() <= '9')) {
                        exp = exp * 10 + static_cast<int>(s.Take() - '0');
                        if (exp >= 214748364) {                         
                            while ((s.Peek() >= '0' && s.Peek() <= '9'))  
                                s.Take();
                        }
                    }
                }
                else {  
                    int maxExp = 308 - expFrac;
                    while ((s.Peek() >= '0' && s.Peek() <= '9')) {
                        exp = exp * 10 + static_cast<int>(s.Take() - '0');
                        if ((exp > maxExp))
                            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1318)), 0) ); SetParseError(kParseErrorNumberTooBig, startOffset); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
                    }
                }
            }
            else
                do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1323)), 0) ); SetParseError(kParseErrorNumberMissExponent, s.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
            if (expMinus)
                exp = -exp;
        }
        bool cont = true;
        if (parseFlags & kParseNumbersAsStringsFlag) {
            if (parseFlags & kParseInsituFlag) {
                s.Pop();  
                typename InputStream::Ch* head = is.PutBegin();
                const size_t length = s.Tell() - startOffset;
                (void)( (!!(length <= 0xFFFFFFFF)) || (_wassert(L"length <= 0xFFFFFFFF", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1337)), 0) );
                const typename TargetEncoding::Ch* const str = reinterpret_cast<typename TargetEncoding::Ch*>(head);
                cont = handler.RawNumber(str, SizeType(length), false);
            }
            else {
                SizeType numCharsToCopy = static_cast<SizeType>(s.Length());
                StringStream srcStream(s.Pop());
                StackStream<typename TargetEncoding::Ch> dstStream(stack_);
                while (numCharsToCopy--) {
                    Transcoder<UTF8<>, TargetEncoding>::Transcode(srcStream, dstStream);
                }
                dstStream.Put('\0');
                const typename TargetEncoding::Ch* str = dstStream.Pop();
                const SizeType length = static_cast<SizeType>(dstStream.Length()) - 1;
                cont = handler.RawNumber(str, SizeType(length), true);
            }
        }
        else {
           size_t length = s.Length();
           const char* decimal = s.Pop();  
           if (useDouble) {
               int p = exp + expFrac;
               if (parseFlags & kParseFullPrecisionFlag)
                   d = internal::StrtodFullPrecision(d, p, decimal, length, decimalPosition, exp);
               else
                   d = internal::StrtodNormalPrecision(d, p);
               cont = handler.Double(minus ? -d : d);
           }
           else if (useNanOrInf) {
               cont = handler.Double(d);
           }
           else {
               if (use64bit) {
                   if (minus)
                       cont = handler.Int64(static_cast<int64_t>(~i64 + 1));
                   else
                       cont = handler.Uint64(i64);
               }
               else {
                   if (minus)
                       cont = handler.Int(static_cast<int32_t>(~i + 1));
                   else
                       cont = handler.Uint(i);
               }
           }
        }
        if ((!cont))
            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1387)), 0) ); SetParseError(kParseErrorTermination, startOffset); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0);
    }
    template<unsigned parseFlags, typename InputStream, typename Handler>
    void ParseValue(InputStream& is, Handler& handler) {
        switch (is.Peek()) {
            case 'n': ParseNull  <parseFlags>(is, handler); break;
            case 't': ParseTrue  <parseFlags>(is, handler); break;
            case 'f': ParseFalse <parseFlags>(is, handler); break;
            case '"': ParseString<parseFlags>(is, handler); break;
            case '{': ParseObject<parseFlags>(is, handler); break;
            case '[': ParseArray <parseFlags>(is, handler); break;
            default :
                      ParseNumber<parseFlags>(is, handler);
                      break;
        }
    }
    enum IterativeParsingState {
        IterativeParsingStartState = 0,
        IterativeParsingFinishState,
        IterativeParsingErrorState,
        IterativeParsingObjectInitialState,
        IterativeParsingMemberKeyState,
        IterativeParsingKeyValueDelimiterState,
        IterativeParsingMemberValueState,
        IterativeParsingMemberDelimiterState,
        IterativeParsingObjectFinishState,
        IterativeParsingArrayInitialState,
        IterativeParsingElementState,
        IterativeParsingElementDelimiterState,
        IterativeParsingArrayFinishState,
        IterativeParsingValueState
    };
    enum { cIterativeParsingStateCount = IterativeParsingValueState + 1 };
    enum Token {
        LeftBracketToken = 0,
        RightBracketToken,
        LeftCurlyBracketToken,
        RightCurlyBracketToken,
        CommaToken,
        ColonToken,
        StringToken,
        FalseToken,
        TrueToken,
        NullToken,
        NumberToken,
        kTokenCount
    };
     Token Tokenize(Ch c) {
        static const unsigned char tokenMap[256] = {
            NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, 
            NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, 
            NumberToken, NumberToken, StringToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, CommaToken, NumberToken, NumberToken, NumberToken, 
            NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, ColonToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, 
            NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, 
            NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, LeftBracketToken, NumberToken, RightBracketToken, NumberToken, NumberToken, 
            NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, FalseToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NullToken, NumberToken, 
            NumberToken, NumberToken, NumberToken, NumberToken, TrueToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, NumberToken, LeftCurlyBracketToken, NumberToken, RightCurlyBracketToken, NumberToken, NumberToken, 
            NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken, NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken,NumberToken 
        };
        if (sizeof(Ch) == 1 || static_cast<unsigned>(c) < 256)
            return static_cast<Token>(tokenMap[static_cast<unsigned char>(c)]);
        else
            return NumberToken;
    }
     IterativeParsingState Predict(IterativeParsingState state, Token token) {
        static const char G[cIterativeParsingStateCount][kTokenCount] = {
            {
                IterativeParsingArrayInitialState,  
                IterativeParsingErrorState,         
                IterativeParsingObjectInitialState, 
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingValueState,         
                IterativeParsingValueState,         
                IterativeParsingValueState,         
                IterativeParsingValueState,         
                IterativeParsingValueState          
            },
            {
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState
            },
            {
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState
            },
            {
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingObjectFinishState,  
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingMemberKeyState,     
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingErrorState          
            },
            {
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingKeyValueDelimiterState, 
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState              
            },
            {
                IterativeParsingArrayInitialState,      
                IterativeParsingErrorState,             
                IterativeParsingObjectInitialState,     
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingMemberValueState,       
                IterativeParsingMemberValueState,       
                IterativeParsingMemberValueState,       
                IterativeParsingMemberValueState,       
                IterativeParsingMemberValueState        
            },
            {
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingObjectFinishState,      
                IterativeParsingMemberDelimiterState,   
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState              
            },
            {
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingObjectFinishState,  
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingMemberKeyState,     
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingErrorState,         
                IterativeParsingErrorState          
            },
            {
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState
            },
            {
                IterativeParsingArrayInitialState,      
                IterativeParsingArrayFinishState,       
                IterativeParsingObjectInitialState,     
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingElementState,           
                IterativeParsingElementState,           
                IterativeParsingElementState,           
                IterativeParsingElementState,           
                IterativeParsingElementState            
            },
            {
                IterativeParsingErrorState,             
                IterativeParsingArrayFinishState,       
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingElementDelimiterState,  
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState              
            },
            {
                IterativeParsingArrayInitialState,      
                IterativeParsingArrayFinishState,       
                IterativeParsingObjectInitialState,     
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingErrorState,             
                IterativeParsingElementState,           
                IterativeParsingElementState,           
                IterativeParsingElementState,           
                IterativeParsingElementState,           
                IterativeParsingElementState            
            },
            {
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState
            },
            {
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
                IterativeParsingErrorState
            }
        }; 
        return static_cast<IterativeParsingState>(G[state][token]);
    }
    template <unsigned parseFlags, typename InputStream, typename Handler>
     IterativeParsingState Transit(IterativeParsingState src, Token token, IterativeParsingState dst, InputStream& is, Handler& handler) {
        (void)token;
        switch (dst) {
        case IterativeParsingErrorState:
            return dst;
        case IterativeParsingObjectInitialState:
        case IterativeParsingArrayInitialState:
        {
            IterativeParsingState n = src;
            if (src == IterativeParsingArrayInitialState || src == IterativeParsingElementDelimiterState)
                n = IterativeParsingElementState;
            else if (src == IterativeParsingKeyValueDelimiterState)
                n = IterativeParsingMemberValueState;
            *stack_.template Push<SizeType>(1) = n;
            *stack_.template Push<SizeType>(1) = 0;
            bool hr = (dst == IterativeParsingObjectInitialState) ? handler.StartObject() : handler.StartArray();
            if (!hr) {
                do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1674)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0);
                return IterativeParsingErrorState;
            }
            else {
                is.Take();
                return dst;
            }
        }
        case IterativeParsingMemberKeyState:
            ParseString<parseFlags>(is, handler, true);
            if (HasParseError())
                return IterativeParsingErrorState;
            else
                return dst;
        case IterativeParsingKeyValueDelimiterState:
            (void)( (!!(token == ColonToken)) || (_wassert(L"token == ColonToken", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1691)), 0) );
            is.Take();
            return dst;
        case IterativeParsingMemberValueState:
            ParseValue<parseFlags>(is, handler);
            if (HasParseError()) {
                return IterativeParsingErrorState;
            }
            return dst;
        case IterativeParsingElementState:
            ParseValue<parseFlags>(is, handler);
            if (HasParseError()) {
                return IterativeParsingErrorState;
            }
            return dst;
        case IterativeParsingMemberDelimiterState:
        case IterativeParsingElementDelimiterState:
            is.Take();
            *stack_.template Top<SizeType>() = *stack_.template Top<SizeType>() + 1;
            return dst;
        case IterativeParsingObjectFinishState:
        {
            if (!(parseFlags & kParseTrailingCommasFlag) && src == IterativeParsingMemberDelimiterState) {
                do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1722)), 0) ); SetParseError(kParseErrorObjectMissName, is.Tell()); } while((void)0, 0);
                return IterativeParsingErrorState;
            }
            SizeType c = *stack_.template Pop<SizeType>(1);
            if (src == IterativeParsingMemberValueState)
                ++c;
            IterativeParsingState n = static_cast<IterativeParsingState>(*stack_.template Pop<SizeType>(1));
            if (n == IterativeParsingStartState)
                n = IterativeParsingFinishState;
            bool hr = handler.EndObject(c);
            if (!hr) {
                do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1739)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0);
                return IterativeParsingErrorState;
            }
            else {
                is.Take();
                return n;
            }
        }
        case IterativeParsingArrayFinishState:
        {
            if (!(parseFlags & kParseTrailingCommasFlag) && src == IterativeParsingElementDelimiterState) {
                do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1752)), 0) ); SetParseError(kParseErrorValueInvalid, is.Tell()); } while((void)0, 0);
                return IterativeParsingErrorState;
            }
            SizeType c = *stack_.template Pop<SizeType>(1);
            if (src == IterativeParsingElementState)
                ++c;
            IterativeParsingState n = static_cast<IterativeParsingState>(*stack_.template Pop<SizeType>(1));
            if (n == IterativeParsingStartState)
                n = IterativeParsingFinishState;
            bool hr = handler.EndArray(c);
            if (!hr) {
                do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1769)), 0) ); SetParseError(kParseErrorTermination, is.Tell()); } while((void)0, 0);
                return IterativeParsingErrorState;
            }
            else {
                is.Take();
                return n;
            }
        }
        default:
            (void)( (!!(dst == IterativeParsingValueState)) || (_wassert(L"dst == IterativeParsingValueState", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1789)), 0) );
            ParseValue<parseFlags>(is, handler);
            if (HasParseError()) {
                return IterativeParsingErrorState;
            }
            return IterativeParsingFinishState;
        }
    }
    template <typename InputStream>
    void HandleError(IterativeParsingState src, InputStream& is) {
        if (HasParseError()) {
            return;
        }
        switch (src) {
        case IterativeParsingStartState:            do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1808)), 0) ); SetParseError(kParseErrorDocumentEmpty, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0); return;
        case IterativeParsingFinishState:           do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1809)), 0) ); SetParseError(kParseErrorDocumentRootNotSingular, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0); return;
        case IterativeParsingObjectInitialState:
        case IterativeParsingMemberDelimiterState:  do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1811)), 0) ); SetParseError(kParseErrorObjectMissName, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0); return;
        case IterativeParsingMemberKeyState:        do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1812)), 0) ); SetParseError(kParseErrorObjectMissColon, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0); return;
        case IterativeParsingMemberValueState:      do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1813)), 0) ); SetParseError(kParseErrorObjectMissCommaOrCurlyBracket, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0); return;
        case IterativeParsingKeyValueDelimiterState:
        case IterativeParsingArrayInitialState:
        case IterativeParsingElementDelimiterState: do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1816)), 0) ); SetParseError(kParseErrorValueInvalid, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0); return;
        default: (void)( (!!(src == IterativeParsingElementState)) || (_wassert(L"src == IterativeParsingElementState", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1817)), 0) ); do { do { (void)( (!!(!HasParseError())) || (_wassert(L"!HasParseError()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h", (unsigned)(1817)), 0) ); SetParseError(kParseErrorArrayMissCommaOrSquareBracket, is.Tell()); } while((void)0, 0); do { if ((HasParseError())) { return ; } } while((void)0, 0); } while((void)0, 0); return;
        }
    }
    template <unsigned parseFlags, typename InputStream, typename Handler>
    ParseResult IterativeParse(InputStream& is, Handler& handler) {
        parseResult_.Clear();
        ClearStackOnExit scope(*this);
        IterativeParsingState state = IterativeParsingStartState;
        SkipWhitespaceAndComments<parseFlags>(is);
        do { if ((HasParseError())) { return parseResult_; } } while((void)0, 0);
        while (is.Peek() != '\0') {
            Token t = Tokenize(is.Peek());
            IterativeParsingState n = Predict(state, t);
            IterativeParsingState d = Transit<parseFlags>(state, t, n, is, handler);
            if (d == IterativeParsingErrorState) {
                HandleError(state, is);
                break;
            }
            state = d;
            if ((parseFlags & kParseStopWhenDoneFlag) && state == IterativeParsingFinishState)
                break;
            SkipWhitespaceAndComments<parseFlags>(is);
            do { if ((HasParseError())) { return parseResult_; } } while((void)0, 0);
        }
        if (state != IterativeParsingFinishState)
            HandleError(state, is);
        return parseResult_;
    }
    static const size_t kDefaultStackCapacity = 256;    
    internal::Stack<StackAllocator> stack_;  
    ParseResult parseResult_;
}; 
typedef GenericReader<UTF8<>, UTF8<> > Reader;
}
__pragma(warning(pop))
#line 1878 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 1880 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\reader.h"
#line 21 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strfunc.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal\\../stream.h"
#line 19 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strfunc.h"
namespace rapidjson {
namespace internal {
template <typename Ch>
inline SizeType StrLen(const Ch* s) {
    const Ch* p = s;
    while (*p) ++p;
    return SizeType(p - s);
}
template<typename Encoding>
bool CountStringCodePoint(const typename Encoding::Ch* s, SizeType length, SizeType* outCount) {
    GenericStringStream<Encoding> is(s);
    const typename Encoding::Ch* end = s + length;
    SizeType count = 0;
    while (is.src_ < end) {
        unsigned codepoint;
        if (!Encoding::Decode(is, &codepoint))
            return false;
        count++;
    }
    *outCount = count;
    return true;
}
} 
}
#line 56 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson\\internal/strfunc.h"
#line 23 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
__pragma(warning(push))
__pragma(warning(disable: 4127)) 
__pragma(warning(disable: 4244)) 
#line 33 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
#line 50 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
#line 54 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
namespace rapidjson {
template <typename Encoding, typename Allocator>
class GenericValue;
template <typename Encoding, typename Allocator, typename StackAllocator>
class GenericDocument;
template <typename Encoding, typename Allocator> 
struct GenericMember { 
    GenericValue<Encoding, Allocator> name;     
    GenericValue<Encoding, Allocator> value;    
};
template <bool Const, typename Encoding, typename Allocator>
class GenericMemberIterator
    : public std::iterator<std::random_access_iterator_tag
        , typename internal::MaybeAddConst<Const,GenericMember<Encoding,Allocator> >::Type> {
    friend class GenericValue<Encoding,Allocator>;
    template <bool, typename, typename> friend class GenericMemberIterator;
    typedef GenericMember<Encoding,Allocator> PlainType;
    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
    typedef std::iterator<std::random_access_iterator_tag,ValueType> BaseType;
public:
    typedef GenericMemberIterator Iterator;
    typedef GenericMemberIterator<true,Encoding,Allocator>  ConstIterator;
    typedef GenericMemberIterator<false,Encoding,Allocator> NonConstIterator;
    typedef typename BaseType::pointer         Pointer;
    typedef typename BaseType::reference       Reference;
    typedef typename BaseType::difference_type DifferenceType;
    GenericMemberIterator() : ptr_() {}
    GenericMemberIterator(const NonConstIterator & it) : ptr_(it.ptr_) {}
    Iterator& operator=(const NonConstIterator & it) { ptr_ = it.ptr_; return *this; }
    Iterator& operator++(){ ++ptr_; return *this; }
    Iterator& operator--(){ --ptr_; return *this; }
    Iterator  operator++(int){ Iterator old(*this); ++ptr_; return old; }
    Iterator  operator--(int){ Iterator old(*this); --ptr_; return old; }
    Iterator operator+(DifferenceType n) const { return Iterator(ptr_+n); }
    Iterator operator-(DifferenceType n) const { return Iterator(ptr_-n); }
    Iterator& operator+=(DifferenceType n) { ptr_+=n; return *this; }
    Iterator& operator-=(DifferenceType n) { ptr_-=n; return *this; }
    bool operator==(ConstIterator that) const { return ptr_ == that.ptr_; }
    bool operator!=(ConstIterator that) const { return ptr_ != that.ptr_; }
    bool operator<=(ConstIterator that) const { return ptr_ <= that.ptr_; }
    bool operator>=(ConstIterator that) const { return ptr_ >= that.ptr_; }
    bool operator< (ConstIterator that) const { return ptr_ < that.ptr_; }
    bool operator> (ConstIterator that) const { return ptr_ > that.ptr_; }
    Reference operator*() const { return *ptr_; }
    Pointer   operator->() const { return ptr_; }
    Reference operator[](DifferenceType n) const { return ptr_[n]; }
    DifferenceType operator-(ConstIterator that) const { return ptr_-that.ptr_; }
private:
    explicit GenericMemberIterator(Pointer p) : ptr_(p) {}
    Pointer ptr_; 
};
#line 217 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
template<typename CharType>
struct GenericStringRef {
    typedef CharType Ch; 
#line 277 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template<SizeType N>
    GenericStringRef(const CharType (&str)[N]) 
        : s(str), length(N-1) {}
#line 302 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    explicit GenericStringRef(const CharType* str)
        : s(str), length(internal::StrLen(str)){ (void)( (!!(s != 0)) || (_wassert(L"s != 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(303)), 0) ); }
#line 314 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericStringRef(const CharType* str, SizeType len)
        : s(str), length(len) { (void)( (!!(s != 0)) || (_wassert(L"s != 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(315)), 0) ); }
    GenericStringRef(const GenericStringRef& rhs) : s(rhs.s), length(rhs.length) {}
    GenericStringRef& operator=(const GenericStringRef& rhs) { s = rhs.s; length = rhs.length; }
    operator const Ch *() const { return s; }
    const Ch* const s; 
    const SizeType length; 
private:
    template<SizeType N>
    GenericStringRef(CharType (&str)[N]) ;
};
template<typename CharType>
inline GenericStringRef<CharType> StringRef(const CharType* str) {
    return GenericStringRef<CharType>(str, internal::StrLen(str));
}
template<typename CharType>
inline GenericStringRef<CharType> StringRef(const CharType* str, size_t length) {
    return GenericStringRef<CharType>(str, SizeType(length));
}
#line 388 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
namespace internal {
template <typename T, typename Encoding = void, typename Allocator = void>
struct IsGenericValueImpl : FalseType {};
template <typename T> struct IsGenericValueImpl<T, typename Void<typename T::EncodingType>::Type, typename Void<typename T::AllocatorType>::Type>
    : IsBaseOf<GenericValue<typename T::EncodingType, typename T::AllocatorType>, T>::Type {};
template <typename T> struct IsGenericValue : IsGenericValueImpl<T>::Type {};
} 
namespace internal {
template <typename ValueType, typename T>
struct TypeHelper {};
template<typename ValueType> 
struct TypeHelper<ValueType, bool> {
    static bool Is(const ValueType& v) { return v.IsBool(); }
    static bool Get(const ValueType& v) { return v.GetBool(); }
    static ValueType& Set(ValueType& v, bool data) { return v.SetBool(data); }
    static ValueType& Set(ValueType& v, bool data, typename ValueType::AllocatorType&) { return v.SetBool(data); }
};
template<typename ValueType> 
struct TypeHelper<ValueType, int> {
    static bool Is(const ValueType& v) { return v.IsInt(); }
    static int Get(const ValueType& v) { return v.GetInt(); }
    static ValueType& Set(ValueType& v, int data) { return v.SetInt(data); }
    static ValueType& Set(ValueType& v, int data, typename ValueType::AllocatorType&) { return v.SetInt(data); }
};
template<typename ValueType> 
struct TypeHelper<ValueType, unsigned> {
    static bool Is(const ValueType& v) { return v.IsUint(); }
    static unsigned Get(const ValueType& v) { return v.GetUint(); }
    static ValueType& Set(ValueType& v, unsigned data) { return v.SetUint(data); }
    static ValueType& Set(ValueType& v, unsigned data, typename ValueType::AllocatorType&) { return v.SetUint(data); }
};
template<typename ValueType> 
struct TypeHelper<ValueType, int64_t> {
    static bool Is(const ValueType& v) { return v.IsInt64(); }
    static int64_t Get(const ValueType& v) { return v.GetInt64(); }
    static ValueType& Set(ValueType& v, int64_t data) { return v.SetInt64(data); }
    static ValueType& Set(ValueType& v, int64_t data, typename ValueType::AllocatorType&) { return v.SetInt64(data); }
};
template<typename ValueType> 
struct TypeHelper<ValueType, uint64_t> {
    static bool Is(const ValueType& v) { return v.IsUint64(); }
    static uint64_t Get(const ValueType& v) { return v.GetUint64(); }
    static ValueType& Set(ValueType& v, uint64_t data) { return v.SetUint64(data); }
    static ValueType& Set(ValueType& v, uint64_t data, typename ValueType::AllocatorType&) { return v.SetUint64(data); }
};
template<typename ValueType> 
struct TypeHelper<ValueType, double> {
    static bool Is(const ValueType& v) { return v.IsDouble(); }
    static double Get(const ValueType& v) { return v.GetDouble(); }
    static ValueType& Set(ValueType& v, double data) { return v.SetDouble(data); }
    static ValueType& Set(ValueType& v, double data, typename ValueType::AllocatorType&) { return v.SetDouble(data); }
};
template<typename ValueType> 
struct TypeHelper<ValueType, float> {
    static bool Is(const ValueType& v) { return v.IsFloat(); }
    static float Get(const ValueType& v) { return v.GetFloat(); }
    static ValueType& Set(ValueType& v, float data) { return v.SetFloat(data); }
    static ValueType& Set(ValueType& v, float data, typename ValueType::AllocatorType&) { return v.SetFloat(data); }
};
template<typename ValueType> 
struct TypeHelper<ValueType, const typename ValueType::Ch*> {
    typedef const typename ValueType::Ch* StringType;
    static bool Is(const ValueType& v) { return v.IsString(); }
    static StringType Get(const ValueType& v) { return v.GetString(); }
    static ValueType& Set(ValueType& v, const StringType data) { return v.SetString(typename ValueType::StringRefType(data)); }
    static ValueType& Set(ValueType& v, const StringType data, typename ValueType::AllocatorType& a) { return v.SetString(data, a); }
};
#line 487 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
template<typename ValueType> 
struct TypeHelper<ValueType, typename ValueType::Array> {
    typedef typename ValueType::Array ArrayType;
    static bool Is(const ValueType& v) { return v.IsArray(); }
    static ArrayType Get(ValueType& v) { return v.GetArray(); }
    static ValueType& Set(ValueType& v, ArrayType data) { return v = data; }
    static ValueType& Set(ValueType& v, ArrayType data, typename ValueType::AllocatorType&) { return v = data; }
};
template<typename ValueType> 
struct TypeHelper<ValueType, typename ValueType::ConstArray> {
    typedef typename ValueType::ConstArray ArrayType;
    static bool Is(const ValueType& v) { return v.IsArray(); }
    static ArrayType Get(const ValueType& v) { return v.GetArray(); }
};
template<typename ValueType> 
struct TypeHelper<ValueType, typename ValueType::Object> {
    typedef typename ValueType::Object ObjectType;
    static bool Is(const ValueType& v) { return v.IsObject(); }
    static ObjectType Get(ValueType& v) { return v.GetObject(); }
    static ValueType& Set(ValueType& v, ObjectType data) { return v = data; }
    static ValueType& Set(ValueType& v, ObjectType data, typename ValueType::AllocatorType&) { v = data; }
};
template<typename ValueType> 
struct TypeHelper<ValueType, typename ValueType::ConstObject> {
    typedef typename ValueType::ConstObject ObjectType;
    static bool Is(const ValueType& v) { return v.IsObject(); }
    static ObjectType Get(const ValueType& v) { return v.GetObject(); }
};
} 
template <bool, typename> class GenericArray;
template <bool, typename> class GenericObject;
template <typename Encoding, typename Allocator = MemoryPoolAllocator<> > 
class GenericValue {
public:
    typedef GenericMember<Encoding, Allocator> Member;
    typedef Encoding EncodingType;                  
    typedef Allocator AllocatorType;                
    typedef typename Encoding::Ch Ch;               
    typedef GenericStringRef<Ch> StringRefType;     
    typedef typename GenericMemberIterator<false,Encoding,Allocator>::Iterator MemberIterator;  
    typedef typename GenericMemberIterator<true,Encoding,Allocator>::Iterator ConstMemberIterator;  
    typedef GenericValue* ValueIterator;            
    typedef const GenericValue* ConstValueIterator; 
    typedef GenericValue<Encoding, Allocator> ValueType;    
    typedef GenericArray<false, ValueType> Array;
    typedef GenericArray<true, ValueType> ConstArray;
    typedef GenericObject<false, ValueType> Object;
    typedef GenericObject<true, ValueType> ConstObject;
    GenericValue()  : data_() { data_.f.flags = kNullFlag; }
    GenericValue(GenericValue&& rhs)  : data_(rhs.data_) {
        rhs.data_.f.flags = kNullFlag; 
    }
#line 570 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
private:
    GenericValue(const GenericValue& rhs);
    template <typename StackAllocator>
    GenericValue(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);
    template <typename StackAllocator>
    GenericValue& operator=(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);
#line 584 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
public:
    explicit GenericValue(Type type)  : data_() {
        static const uint16_t defaultFlags[7] = {
            kNullFlag, kFalseFlag, kTrueFlag, kObjectFlag, kArrayFlag, kShortStringFlag,
            kNumberAnyFlag
        };
        (void)( (!!(type <= kNumberType)) || (_wassert(L"type <= kNumberType", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(597)), 0) );
        data_.f.flags = defaultFlags[type];
        if (type == kStringType)
            data_.ss.SetLength(0);
    }
    template< typename SourceAllocator >
    GenericValue(const GenericValue<Encoding, SourceAllocator>& rhs, Allocator & allocator);
    template <typename T>
    explicit GenericValue(T b, typename ::rapidjson::internal::EnableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::IsSame<bool, T>)>::Type>::Type * = 0)   
#line 627 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
        : data_() {
            typedef ::rapidjson::StaticAssertTest< sizeof(::rapidjson::STATIC_ASSERTION_FAILURE<bool((internal::IsSame<bool,T>::Value)) >)> StaticAssertTypedef629 ;
            data_.f.flags = b ? kTrueFlag : kFalseFlag;
    }
    explicit GenericValue(int i)  : data_() {
        data_.n.i64 = i;
        data_.f.flags = (i >= 0) ? (kNumberIntFlag | kUintFlag | kUint64Flag) : kNumberIntFlag;
    }
    explicit GenericValue(unsigned u)  : data_() {
        data_.n.u64 = u; 
        data_.f.flags = (u & 0x80000000) ? kNumberUintFlag : (kNumberUintFlag | kIntFlag | kInt64Flag);
    }
    explicit GenericValue(int64_t i64)  : data_() {
        data_.n.i64 = i64;
        data_.f.flags = kNumberInt64Flag;
        if (i64 >= 0) {
            data_.f.flags |= kNumberUint64Flag;
            if (!(static_cast<uint64_t>(i64) & ((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x00000000))))
                data_.f.flags |= kUintFlag;
            if (!(static_cast<uint64_t>(i64) & ((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x80000000))))
                data_.f.flags |= kIntFlag;
        }
        else if (i64 >= static_cast<int64_t>(((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x80000000))))
            data_.f.flags |= kIntFlag;
    }
    explicit GenericValue(uint64_t u64)  : data_() {
        data_.n.u64 = u64;
        data_.f.flags = kNumberUint64Flag;
        if (!(u64 & ((static_cast<uint64_t>(0x80000000) << 32) | static_cast<uint64_t>(0x00000000))))
            data_.f.flags |= kInt64Flag;
        if (!(u64 & ((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x00000000))))
            data_.f.flags |= kUintFlag;
        if (!(u64 & ((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x80000000))))
            data_.f.flags |= kIntFlag;
    }
    explicit GenericValue(double d)  : data_() { data_.n.d = d; data_.f.flags = kNumberDoubleFlag; }
    GenericValue(const Ch* s, SizeType length)  : data_() { SetStringRaw(StringRef(s, length)); }
    explicit GenericValue(StringRefType s)  : data_() { SetStringRaw(s); }
    GenericValue(const Ch* s, SizeType length, Allocator& allocator) : data_() { SetStringRaw(StringRef(s, length), allocator); }
    GenericValue(const Ch*s, Allocator& allocator) : data_() { SetStringRaw(StringRef(s), allocator); }
#line 693 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericValue(Array a)  : data_(a.value_.data_) {
        a.value_.data_ = Data();
        a.value_.data_.f.flags = kArrayFlag;
    }
    GenericValue(Object o)  : data_(o.value_.data_) {
        o.value_.data_ = Data();
        o.value_.data_.f.flags = kObjectFlag;
    }
    ~GenericValue() {
        if (Allocator::kNeedFree) { 
            switch(data_.f.flags) {
            case kArrayFlag:
                {
                    GenericValue* e = GetElementsPointer();
                    for (GenericValue* v = e; v != e + data_.a.size; ++v)
                        v->~GenericValue();
                    Allocator::Free(e);
                }
                break;
            case kObjectFlag:
                for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
                    m->~Member();
                Allocator::Free(GetMembersPointer());
                break;
            case kCopyStringFlag:
                Allocator::Free(const_cast<Ch*>(GetStringPointer()));
                break;
            default:
                break;  
            }
        }
    }
    GenericValue& operator=(GenericValue& rhs)  {
        (void)( (!!(this != &rhs)) || (_wassert(L"this != &rhs", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(756)), 0) );
        this->~GenericValue();
        RawAssign(rhs);
        return *this;
    }
    GenericValue& operator=(GenericValue&& rhs)  {
        return *this = rhs.Move();
    }
#line 768 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericValue& operator=(StringRefType str)  {
        GenericValue s(str);
        return *this = s;
    }
    template <typename T>
    typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::IsPointer<T>)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (GenericValue&)>::Type>::Type
    operator=(T value) {
        GenericValue v(value);
        return *this = v;
    }
    template <typename SourceAllocator>
    GenericValue& CopyFrom(const GenericValue<Encoding, SourceAllocator>& rhs, Allocator& allocator) {
        (void)( (!!(static_cast<void*>(this) != static_cast<void const*>(&rhs))) || (_wassert(L"static_cast<void*>(this) != static_cast<void const*>(&rhs)", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(806)), 0) );
        this->~GenericValue();
        new (this) GenericValue(rhs, allocator);
        return *this;
    }
    GenericValue& Swap(GenericValue& other)  {
        GenericValue temp;
        temp.RawAssign(*this);
        RawAssign(other);
        other.RawAssign(temp);
        return *this;
    }
    friend inline void swap(GenericValue& a, GenericValue& b)  { a.Swap(b); }
    GenericValue& Move()  { return *this; }
    template <typename SourceAllocator>
    bool operator==(const GenericValue<Encoding, SourceAllocator>& rhs) const {
        typedef GenericValue<Encoding, SourceAllocator> RhsType;
        if (GetType() != rhs.GetType())
            return false;
        switch (GetType()) {
        case kObjectType: 
            if (data_.o.size != rhs.data_.o.size)
                return false;           
            for (ConstMemberIterator lhsMemberItr = MemberBegin(); lhsMemberItr != MemberEnd(); ++lhsMemberItr) {
                typename RhsType::ConstMemberIterator rhsMemberItr = rhs.FindMember(lhsMemberItr->name);
                if (rhsMemberItr == rhs.MemberEnd() || lhsMemberItr->value != rhsMemberItr->value)
                    return false;
            }
            return true;
        case kArrayType:
            if (data_.a.size != rhs.data_.a.size)
                return false;
            for (SizeType i = 0; i < data_.a.size; i++)
                if ((*this)[i] != rhs[i])
                    return false;
            return true;
        case kStringType:
            return StringEqual(rhs);
        case kNumberType:
            if (IsDouble() || rhs.IsDouble()) {
                double a = GetDouble();     
                double b = rhs.GetDouble(); 
                return a >= b && a <= b;    
            }
            else
                return data_.n.u64 == rhs.data_.n.u64;
        default:
            return true;
        }
    }
    bool operator==(const Ch* rhs) const { return *this == GenericValue(StringRef(rhs)); }
#line 902 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename T> typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::OrExpr<internal::IsPointer<T>,internal::IsGenericValue<T> >)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (bool)>::Type>::Type operator==(const T& rhs) const { return *this == GenericValue(rhs); }
    template <typename SourceAllocator>
    bool operator!=(const GenericValue<Encoding, SourceAllocator>& rhs) const { return !(*this == rhs); }
    bool operator!=(const Ch* rhs) const { return !(*this == rhs); }
    template <typename T> typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::IsGenericValue<T>)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (bool)>::Type>::Type operator!=(const T& rhs) const { return !(*this == rhs); }
    template <typename T> friend typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::IsGenericValue<T>)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (bool)>::Type>::Type operator==(const T& lhs, const GenericValue& rhs) { return rhs == lhs; }
    template <typename T> friend typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::IsGenericValue<T>)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (bool)>::Type>::Type operator!=(const T& lhs, const GenericValue& rhs) { return !(rhs == lhs); }
    Type GetType()  const { return static_cast<Type>(data_.f.flags & kTypeMask); }
    bool IsNull()   const { return data_.f.flags == kNullFlag; }
    bool IsFalse()  const { return data_.f.flags == kFalseFlag; }
    bool IsTrue()   const { return data_.f.flags == kTrueFlag; }
    bool IsBool()   const { return (data_.f.flags & kBoolFlag) != 0; }
    bool IsObject() const { return data_.f.flags == kObjectFlag; }
    bool IsArray()  const { return data_.f.flags == kArrayFlag; }
    bool IsNumber() const { return (data_.f.flags & kNumberFlag) != 0; }
    bool IsInt()    const { return (data_.f.flags & kIntFlag) != 0; }
    bool IsUint()   const { return (data_.f.flags & kUintFlag) != 0; }
    bool IsInt64()  const { return (data_.f.flags & kInt64Flag) != 0; }
    bool IsUint64() const { return (data_.f.flags & kUint64Flag) != 0; }
    bool IsDouble() const { return (data_.f.flags & kDoubleFlag) != 0; }
    bool IsString() const { return (data_.f.flags & kStringFlag) != 0; }
    bool IsLosslessDouble() const {
        if (!IsNumber()) return false;
        if (IsUint64()) {
            uint64_t u = GetUint64();
            volatile double d = static_cast<double>(u);
            return (d >= 0.0)
                && (d < static_cast<double>(std::numeric_limits<uint64_t>::max()))
                && (u == static_cast<uint64_t>(d));
        }
        if (IsInt64()) {
            int64_t i = GetInt64();
            volatile double d = static_cast<double>(i);
            return (d >= static_cast<double>(std::numeric_limits<int64_t>::min()))
                && (d < static_cast<double>(std::numeric_limits<int64_t>::max()))
                && (i == static_cast<int64_t>(d));
        }
        return true; 
    }
    bool IsFloat() const  {
        if ((data_.f.flags & kDoubleFlag) == 0)
            return false;
        double d = GetDouble();
        return d >= -3.4028234e38 && d <= 3.4028234e38;
    }
    bool IsLosslessFloat() const {
        if (!IsNumber()) return false;
        double a = GetDouble();
        if (a < static_cast<double>(-std::numeric_limits<float>::max())
                || a > static_cast<double>(std::numeric_limits<float>::max()))
            return false;
        double b = static_cast<double>(static_cast<float>(a));
        return a >= b && a <= b;    
    }
    GenericValue& SetNull() { this->~GenericValue(); new (this) GenericValue(); return *this; }
    bool GetBool() const { (void)( (!!(IsBool())) || (_wassert(L"IsBool()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1001)), 0) ); return data_.f.flags == kTrueFlag; }
    GenericValue& SetBool(bool b) { this->~GenericValue(); new (this) GenericValue(b); return *this; }
    GenericValue& SetObject() { this->~GenericValue(); new (this) GenericValue(kObjectType); return *this; }
    SizeType MemberCount() const { (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1016)), 0) ); return data_.o.size; }
    bool ObjectEmpty() const { (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1019)), 0) ); return data_.o.size == 0; }
    template <typename T>
    typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (GenericValue&)>::Type>::Type operator[](T* name) {
        GenericValue n(StringRef(name));
        return (*this)[n];
    }
    template <typename T>
    typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (const GenericValue&)>::Type>::Type operator[](T* name) const { return const_cast<GenericValue&>(*this)[name]; }
    template <typename SourceAllocator>
    GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) {
        MemberIterator member = FindMember(name);
        if (member != MemberEnd())
            return member->value;
        else {
            (void)( (!!(false)) || (_wassert(L"false", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1053)), 0) );    
            static char buffer[sizeof(GenericValue)];
            return *new (buffer) GenericValue();
        }
    }
    template <typename SourceAllocator>
    const GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this)[name]; }
#line 1072 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    ConstMemberIterator MemberBegin() const { (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1075)), 0) ); return ConstMemberIterator(GetMembersPointer()); }
    ConstMemberIterator MemberEnd() const   { (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1078)), 0) ); return ConstMemberIterator(GetMembersPointer() + data_.o.size); }
    MemberIterator MemberBegin()            { (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1081)), 0) ); return MemberIterator(GetMembersPointer()); }
    MemberIterator MemberEnd()              { (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1084)), 0) ); return MemberIterator(GetMembersPointer() + data_.o.size); }
    bool HasMember(const Ch* name) const { return FindMember(name) != MemberEnd(); }
#line 1107 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename SourceAllocator>
    bool HasMember(const GenericValue<Encoding, SourceAllocator>& name) const { return FindMember(name) != MemberEnd(); }
    MemberIterator FindMember(const Ch* name) {
        GenericValue n(StringRef(name));
        return FindMember(n);
    }
    ConstMemberIterator FindMember(const Ch* name) const { return const_cast<GenericValue&>(*this).FindMember(name); }
    template <typename SourceAllocator>
    MemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) {
        (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1154)), 0) );
        (void)( (!!(name.IsString())) || (_wassert(L"name.IsString()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1155)), 0) );
        MemberIterator member = MemberBegin();
        for ( ; member != MemberEnd(); ++member)
            if (name.StringEqual(member->name))
                break;
        return member;
    }
    template <typename SourceAllocator> ConstMemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this).FindMember(name); }
#line 1175 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericValue& AddMember(GenericValue& name, GenericValue& value, Allocator& allocator) {
        (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1187)), 0) );
        (void)( (!!(name.IsString())) || (_wassert(L"name.IsString()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1188)), 0) );
        ObjectData& o = data_.o;
        if (o.size >= o.capacity) {
            if (o.capacity == 0) {
                o.capacity = kDefaultObjectCapacity;
                SetMembersPointer(reinterpret_cast<Member*>(allocator.Malloc(o.capacity * sizeof(Member))));
            }
            else {
                SizeType oldCapacity = o.capacity;
                o.capacity += (oldCapacity + 1) / 2; 
                SetMembersPointer(reinterpret_cast<Member*>(allocator.Realloc(GetMembersPointer(), oldCapacity * sizeof(Member), o.capacity * sizeof(Member))));
            }
        }
        Member* members = GetMembersPointer();
        members[o.size].name.RawAssign(name);
        members[o.size].value.RawAssign(value);
        o.size++;
        return *this;
    }
    GenericValue& AddMember(GenericValue& name, StringRefType value, Allocator& allocator) {
        GenericValue v(value);
        return AddMember(name, v, allocator);
    }
#line 1238 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename T>
    typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (GenericValue&)>::Type>::Type
    AddMember(GenericValue& name, T value, Allocator& allocator) {
        GenericValue v(value);
        return AddMember(name, v, allocator);
    }
    GenericValue& AddMember(GenericValue&& name, GenericValue&& value, Allocator& allocator) {
        return AddMember(name, value, allocator);
    }
    GenericValue& AddMember(GenericValue&& name, GenericValue& value, Allocator& allocator) {
        return AddMember(name, value, allocator);
    }
    GenericValue& AddMember(GenericValue& name, GenericValue&& value, Allocator& allocator) {
        return AddMember(name, value, allocator);
    }
    GenericValue& AddMember(StringRefType name, GenericValue&& value, Allocator& allocator) {
        GenericValue n(name);
        return AddMember(n, value, allocator);
    }
#line 1278 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericValue& AddMember(StringRefType name, GenericValue& value, Allocator& allocator) {
        GenericValue n(name);
        return AddMember(n, value, allocator);
    }
    GenericValue& AddMember(StringRefType name, StringRefType value, Allocator& allocator) {
        GenericValue v(value);
        return AddMember(name, v, allocator);
    }
    template <typename T>
    typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (GenericValue&)>::Type>::Type
    AddMember(StringRefType name, T value, Allocator& allocator) {
        GenericValue n(name);
        return AddMember(n, value, allocator);
    }
    void RemoveAllMembers() {
        (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1338)), 0) ); 
        for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
            m->~Member();
        data_.o.size = 0;
    }
    bool RemoveMember(const Ch* name) {
        GenericValue n(StringRef(name));
        return RemoveMember(n);
    }
#line 1360 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename SourceAllocator>
    bool RemoveMember(const GenericValue<Encoding, SourceAllocator>& name) {
        MemberIterator m = FindMember(name);
        if (m != MemberEnd()) {
            RemoveMember(m);
            return true;
        }
        else
            return false;
    }
    MemberIterator RemoveMember(MemberIterator m) {
        (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1381)), 0) );
        (void)( (!!(data_.o.size > 0)) || (_wassert(L"data_.o.size > 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1382)), 0) );
        (void)( (!!(GetMembersPointer() != 0)) || (_wassert(L"GetMembersPointer() != 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1383)), 0) );
        (void)( (!!(m >= MemberBegin() && m < MemberEnd())) || (_wassert(L"m >= MemberBegin() && m < MemberEnd()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1384)), 0) );
        MemberIterator last(GetMembersPointer() + (data_.o.size - 1));
        if (data_.o.size > 1 && m != last)
            *m = *last; 
        else
            m->~Member(); 
        --data_.o.size;
        return m;
    }
    MemberIterator EraseMember(ConstMemberIterator pos) {
        return EraseMember(pos, pos +1);
    }
    MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) {
        (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1418)), 0) );
        (void)( (!!(data_.o.size > 0)) || (_wassert(L"data_.o.size > 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1419)), 0) );
        (void)( (!!(GetMembersPointer() != 0)) || (_wassert(L"GetMembersPointer() != 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1420)), 0) );
        (void)( (!!(first >= MemberBegin())) || (_wassert(L"first >= MemberBegin()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1421)), 0) );
        (void)( (!!(first <= last)) || (_wassert(L"first <= last", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1422)), 0) );
        (void)( (!!(last <= MemberEnd())) || (_wassert(L"last <= MemberEnd()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1423)), 0) );
        MemberIterator pos = MemberBegin() + (first - MemberBegin());
        for (MemberIterator itr = pos; itr != last; ++itr)
            itr->~Member();
        std::memmove(&*pos, &*last, static_cast<size_t>(MemberEnd() - last) * sizeof(Member));
        data_.o.size -= static_cast<SizeType>(last - first);
        return pos;
    }
    bool EraseMember(const Ch* name) {
        GenericValue n(StringRef(name));
        return EraseMember(n);
    }
#line 1446 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename SourceAllocator>
    bool EraseMember(const GenericValue<Encoding, SourceAllocator>& name) {
        MemberIterator m = FindMember(name);
        if (m != MemberEnd()) {
            EraseMember(m);
            return true;
        }
        else
            return false;
    }
    Object GetObject() { (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1458)), 0) ); return Object(*this); }
    ConstObject GetObject() const { (void)( (!!(IsObject())) || (_wassert(L"IsObject()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1459)), 0) ); return ConstObject(*this); }
    GenericValue& SetArray() { this->~GenericValue(); new (this) GenericValue(kArrayType); return *this; }
    SizeType Size() const { (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1471)), 0) ); return data_.a.size; }
    SizeType Capacity() const { (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1474)), 0) ); return data_.a.capacity; }
    bool Empty() const { (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1477)), 0) ); return data_.a.size == 0; }
    void Clear() {
        (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1484)), 0) ); 
        GenericValue* e = GetElementsPointer();
        for (GenericValue* v = e; v != e + data_.a.size; ++v)
            v->~GenericValue();
        data_.a.size = 0;
    }
    GenericValue& operator[](SizeType index) {
        (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1497)), 0) );
        (void)( (!!(index < data_.a.size)) || (_wassert(L"index < data_.a.size", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1498)), 0) );
        return GetElementsPointer()[index];
    }
    const GenericValue& operator[](SizeType index) const { return const_cast<GenericValue&>(*this)[index]; }
    ValueIterator Begin() { (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1505)), 0) ); return GetElementsPointer(); }
    ValueIterator End() { (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1508)), 0) ); return GetElementsPointer() + data_.a.size; }
    ConstValueIterator Begin() const { return const_cast<GenericValue&>(*this).Begin(); }
    ConstValueIterator End() const { return const_cast<GenericValue&>(*this).End(); }
    GenericValue& Reserve(SizeType newCapacity, Allocator &allocator) {
        (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1523)), 0) );
        if (newCapacity > data_.a.capacity) {
            SetElementsPointer(reinterpret_cast<GenericValue*>(allocator.Realloc(GetElementsPointer(), data_.a.capacity * sizeof(GenericValue), newCapacity * sizeof(GenericValue))));
            data_.a.capacity = newCapacity;
        }
        return *this;
    }
    GenericValue& PushBack(GenericValue& value, Allocator& allocator) {
        (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1542)), 0) );
        if (data_.a.size >= data_.a.capacity)
            Reserve(data_.a.capacity == 0 ? kDefaultArrayCapacity : (data_.a.capacity + (data_.a.capacity + 1) / 2), allocator);
        GetElementsPointer()[data_.a.size++].RawAssign(value);
        return *this;
    }
    GenericValue& PushBack(GenericValue&& value, Allocator& allocator) {
        return PushBack(value, allocator);
    }
#line 1554 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericValue& PushBack(StringRefType value, Allocator& allocator) {
        return (*this).template PushBack<StringRefType>(value, allocator);
    }
    template <typename T>
    typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (GenericValue&)>::Type>::Type
    PushBack(T value, Allocator& allocator) {
        GenericValue v(value);
        return PushBack(v, allocator);
    }
    GenericValue& PopBack() {
        (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1597)), 0) );
        (void)( (!!(!Empty())) || (_wassert(L"!Empty()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1598)), 0) );
        GetElementsPointer()[--data_.a.size].~GenericValue();
        return *this;
    }
    ValueIterator Erase(ConstValueIterator pos) {
        return Erase(pos, pos + 1);
    }
    ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) {
        (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1623)), 0) );
        (void)( (!!(data_.a.size > 0)) || (_wassert(L"data_.a.size > 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1624)), 0) );
        (void)( (!!(GetElementsPointer() != 0)) || (_wassert(L"GetElementsPointer() != 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1625)), 0) );
        (void)( (!!(first >= Begin())) || (_wassert(L"first >= Begin()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1626)), 0) );
        (void)( (!!(first <= last)) || (_wassert(L"first <= last", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1627)), 0) );
        (void)( (!!(last <= End())) || (_wassert(L"last <= End()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1628)), 0) );
        ValueIterator pos = Begin() + (first - Begin());
        for (ValueIterator itr = pos; itr != last; ++itr)
            itr->~GenericValue();       
        std::memmove(pos, last, static_cast<size_t>(End() - last) * sizeof(GenericValue));
        data_.a.size -= static_cast<SizeType>(last - first);
        return pos;
    }
    Array GetArray() { (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1637)), 0) ); return Array(*this); }
    ConstArray GetArray() const { (void)( (!!(IsArray())) || (_wassert(L"IsArray()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1638)), 0) ); return ConstArray(*this); }
    int GetInt() const          { (void)( (!!(data_.f.flags & kIntFlag)) || (_wassert(L"data_.f.flags & kIntFlag", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1645)), 0) );   return data_.n.i.i;   }
    unsigned GetUint() const    { (void)( (!!(data_.f.flags & kUintFlag)) || (_wassert(L"data_.f.flags & kUintFlag", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1646)), 0) );  return data_.n.u.u;   }
    int64_t GetInt64() const    { (void)( (!!(data_.f.flags & kInt64Flag)) || (_wassert(L"data_.f.flags & kInt64Flag", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1647)), 0) ); return data_.n.i64; }
    uint64_t GetUint64() const  { (void)( (!!(data_.f.flags & kUint64Flag)) || (_wassert(L"data_.f.flags & kUint64Flag", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1648)), 0) ); return data_.n.u64; }
    double GetDouble() const {
        (void)( (!!(IsNumber())) || (_wassert(L"IsNumber()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1654)), 0) );
        if ((data_.f.flags & kDoubleFlag) != 0)                return data_.n.d;   
        if ((data_.f.flags & kIntFlag) != 0)                   return data_.n.i.i; 
        if ((data_.f.flags & kUintFlag) != 0)                  return data_.n.u.u; 
        if ((data_.f.flags & kInt64Flag) != 0)                 return static_cast<double>(data_.n.i64); 
        (void)( (!!((data_.f.flags & kUint64Flag) != 0)) || (_wassert(L"(data_.f.flags & kUint64Flag) != 0", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1659)), 0) );  return static_cast<double>(data_.n.u64); 
    }
    float GetFloat() const {
        return static_cast<float>(GetDouble());
    }
    GenericValue& SetInt(int i)             { this->~GenericValue(); new (this) GenericValue(i);    return *this; }
    GenericValue& SetUint(unsigned u)       { this->~GenericValue(); new (this) GenericValue(u);    return *this; }
    GenericValue& SetInt64(int64_t i64)     { this->~GenericValue(); new (this) GenericValue(i64);  return *this; }
    GenericValue& SetUint64(uint64_t u64)   { this->~GenericValue(); new (this) GenericValue(u64);  return *this; }
    GenericValue& SetDouble(double d)       { this->~GenericValue(); new (this) GenericValue(d);    return *this; }
    GenericValue& SetFloat(float f)         { this->~GenericValue(); new (this) GenericValue(f);    return *this; }
    const Ch* GetString() const { (void)( (!!(IsString())) || (_wassert(L"IsString()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1681)), 0) ); return (data_.f.flags & kInlineStrFlag) ? data_.ss.str : GetStringPointer(); }
    SizeType GetStringLength() const { (void)( (!!(IsString())) || (_wassert(L"IsString()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1686)), 0) ); return ((data_.f.flags & kInlineStrFlag) ? (data_.ss.GetLength()) : data_.s.length); }
    GenericValue& SetString(const Ch* s, SizeType length) { return SetString(StringRef(s, length)); }
    GenericValue& SetString(StringRefType s) { this->~GenericValue(); SetStringRaw(s); return *this; }
    GenericValue& SetString(const Ch* s, SizeType length, Allocator& allocator) { this->~GenericValue(); SetStringRaw(StringRef(s, length), allocator); return *this; }
    GenericValue& SetString(const Ch* s, Allocator& allocator) { return SetString(s, internal::StrLen(s), allocator); }
#line 1733 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename T>
    bool Is() const { return internal::TypeHelper<ValueType, T>::Is(*this); }
    template <typename T>
    T Get() const { return internal::TypeHelper<ValueType, T>::Get(*this); }
    template <typename T>
    T Get() { return internal::TypeHelper<ValueType, T>::Get(*this); }
    template<typename T>
    ValueType& Set(const T& data) { return internal::TypeHelper<ValueType, T>::Set(*this, data); }
    template<typename T>
    ValueType& Set(const T& data, AllocatorType& allocator) { return internal::TypeHelper<ValueType, T>::Set(*this, data, allocator); }
    template <typename Handler>
    bool Accept(Handler& handler) const {
        switch(GetType()) {
        case kNullType:     return handler.Null();
        case kFalseType:    return handler.Bool(false);
        case kTrueType:     return handler.Bool(true);
        case kObjectType:
            if ((!handler.StartObject()))
                return false;
            for (ConstMemberIterator m = MemberBegin(); m != MemberEnd(); ++m) {
                (void)( (!!(m->name.IsString())) || (_wassert(L"m->name.IsString()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1778)), 0) ); 
                if ((!handler.Key(m->name.GetString(), m->name.GetStringLength(), (m->name.data_.f.flags & kCopyFlag) != 0)))
                    return false;
                if ((!m->value.Accept(handler)))
                    return false;
            }
            return handler.EndObject(data_.o.size);
        case kArrayType:
            if ((!handler.StartArray()))
                return false;
            for (const GenericValue* v = Begin(); v != End(); ++v)
                if ((!v->Accept(handler)))
                    return false;
            return handler.EndArray(data_.a.size);
        case kStringType:
            return handler.String(GetString(), GetStringLength(), (data_.f.flags & kCopyFlag) != 0);
        default:
            (void)( (!!(GetType() == kNumberType)) || (_wassert(L"GetType() == kNumberType", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1798)), 0) );
            if (IsDouble())         return handler.Double(data_.n.d);
            else if (IsInt())       return handler.Int(data_.n.i.i);
            else if (IsUint())      return handler.Uint(data_.n.u.u);
            else if (IsInt64())     return handler.Int64(data_.n.i64);
            else                    return handler.Uint64(data_.n.u64);
        }
    }
private:
    template <typename, typename> friend class GenericValue;
    template <typename, typename, typename> friend class GenericDocument;
    enum {
        kBoolFlag       = 0x0008,
        kNumberFlag     = 0x0010,
        kIntFlag        = 0x0020,
        kUintFlag       = 0x0040,
        kInt64Flag      = 0x0080,
        kUint64Flag     = 0x0100,
        kDoubleFlag     = 0x0200,
        kStringFlag     = 0x0400,
        kCopyFlag       = 0x0800,
        kInlineStrFlag  = 0x1000,
        kNullFlag = kNullType,
        kTrueFlag = kTrueType | kBoolFlag,
        kFalseFlag = kFalseType | kBoolFlag,
        kNumberIntFlag = kNumberType | kNumberFlag | kIntFlag | kInt64Flag,
        kNumberUintFlag = kNumberType | kNumberFlag | kUintFlag | kUint64Flag | kInt64Flag,
        kNumberInt64Flag = kNumberType | kNumberFlag | kInt64Flag,
        kNumberUint64Flag = kNumberType | kNumberFlag | kUint64Flag,
        kNumberDoubleFlag = kNumberType | kNumberFlag | kDoubleFlag,
        kNumberAnyFlag = kNumberType | kNumberFlag | kIntFlag | kInt64Flag | kUintFlag | kUint64Flag | kDoubleFlag,
        kConstStringFlag = kStringType | kStringFlag,
        kCopyStringFlag = kStringType | kStringFlag | kCopyFlag,
        kShortStringFlag = kStringType | kStringFlag | kCopyFlag | kInlineStrFlag,
        kObjectFlag = kObjectType,
        kArrayFlag = kArrayType,
        kTypeMask = 0x07
    };
    static const SizeType kDefaultArrayCapacity = 16;
    static const SizeType kDefaultObjectCapacity = 16;
    struct Flag {
        char payload[sizeof(SizeType) * 2 + 6];     
#line 1853 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
        uint16_t flags;
    };
    struct String {
        SizeType length;
        SizeType hashcode;  
        const Ch* str;
    };  
    struct ShortString {
        enum { MaxChars = sizeof(static_cast<Flag*>(0)->payload) / sizeof(Ch), MaxSize = MaxChars - 1, LenPos = MaxSize };
        Ch str[MaxChars];
        inline static bool Usable(SizeType len) { return                       (MaxSize >= len); }
        inline void     SetLength(SizeType len) { str[LenPos] = static_cast<Ch>(MaxSize -  len); }
        inline SizeType GetLength() const       { return  static_cast<SizeType>(MaxSize -  str[LenPos]); }
    };  
    union Number {
        struct I {
            int i;
            char padding[4];
        }i;
        struct U {
            unsigned u;
            char padding2[4];
        }u;
#line 1900 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
        int64_t i64;
        uint64_t u64;
        double d;
    };  
    struct ObjectData {
        SizeType size;
        SizeType capacity;
        Member* members;
    };  
    struct ArrayData {
        SizeType size;
        SizeType capacity;
        GenericValue* elements;
    };  
    union Data {
        String s;
        ShortString ss;
        Number n;
        ObjectData o;
        ArrayData a;
        Flag f;
    };  
     const Ch* GetStringPointer() const { return (reinterpret_cast<Ch *>(reinterpret_cast<uintptr_t>(data_.s.str) & static_cast<uintptr_t>(((static_cast<uint64_t>(0x0000FFFF) << 32) | static_cast<uint64_t>(0xFFFFFFFF))))); }
     const Ch* SetStringPointer(const Ch* str) { return (data_.s.str = reinterpret_cast<Ch *>((reinterpret_cast<uintptr_t>(data_.s.str) & static_cast<uintptr_t>(((static_cast<uint64_t>(0xFFFF0000) << 32) | static_cast<uint64_t>(0x00000000)))) | reinterpret_cast<uintptr_t>(reinterpret_cast<const void*>(str)))); }
     GenericValue* GetElementsPointer() const { return (reinterpret_cast<GenericValue *>(reinterpret_cast<uintptr_t>(data_.a.elements) & static_cast<uintptr_t>(((static_cast<uint64_t>(0x0000FFFF) << 32) | static_cast<uint64_t>(0xFFFFFFFF))))); }
     GenericValue* SetElementsPointer(GenericValue* elements) { return (data_.a.elements = reinterpret_cast<GenericValue *>((reinterpret_cast<uintptr_t>(data_.a.elements) & static_cast<uintptr_t>(((static_cast<uint64_t>(0xFFFF0000) << 32) | static_cast<uint64_t>(0x00000000)))) | reinterpret_cast<uintptr_t>(reinterpret_cast<const void*>(elements)))); }
     Member* GetMembersPointer() const { return (reinterpret_cast<Member *>(reinterpret_cast<uintptr_t>(data_.o.members) & static_cast<uintptr_t>(((static_cast<uint64_t>(0x0000FFFF) << 32) | static_cast<uint64_t>(0xFFFFFFFF))))); }
     Member* SetMembersPointer(Member* members) { return (data_.o.members = reinterpret_cast<Member *>((reinterpret_cast<uintptr_t>(data_.o.members) & static_cast<uintptr_t>(((static_cast<uint64_t>(0xFFFF0000) << 32) | static_cast<uint64_t>(0x00000000)))) | reinterpret_cast<uintptr_t>(reinterpret_cast<const void*>(members)))); }
    void SetArrayRaw(GenericValue* values, SizeType count, Allocator& allocator) {
        data_.f.flags = kArrayFlag;
        if (count) {
            GenericValue* e = static_cast<GenericValue*>(allocator.Malloc(count * sizeof(GenericValue)));
            SetElementsPointer(e);
            std::memcpy(e, values, count * sizeof(GenericValue));
        }
        else
            SetElementsPointer(0);
        data_.a.size = data_.a.capacity = count;
    }
    void SetObjectRaw(Member* members, SizeType count, Allocator& allocator) {
        data_.f.flags = kObjectFlag;
        if (count) {
            Member* m = static_cast<Member*>(allocator.Malloc(count * sizeof(Member)));
            SetMembersPointer(m);
            std::memcpy(m, members, count * sizeof(Member));
        }
        else
            SetMembersPointer(0);
        data_.o.size = data_.o.capacity = count;
    }
    void SetStringRaw(StringRefType s)  {
        data_.f.flags = kConstStringFlag;
        SetStringPointer(s);
        data_.s.length = s.length;
    }
    void SetStringRaw(StringRefType s, Allocator& allocator) {
        Ch* str = 0;
        if (ShortString::Usable(s.length)) {
            data_.f.flags = kShortStringFlag;
            data_.ss.SetLength(s.length);
            str = data_.ss.str;
        } else {
            data_.f.flags = kCopyStringFlag;
            data_.s.length = s.length;
            str = static_cast<Ch *>(allocator.Malloc((s.length + 1) * sizeof(Ch)));
            SetStringPointer(str);
        }
        std::memcpy(str, s, s.length * sizeof(Ch));
        str[s.length] = '\0';
    }
    void RawAssign(GenericValue& rhs)  {
        data_ = rhs.data_;
        rhs.data_.f.flags = kNullFlag;
    }
    template <typename SourceAllocator>
    bool StringEqual(const GenericValue<Encoding, SourceAllocator>& rhs) const {
        (void)( (!!(IsString())) || (_wassert(L"IsString()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1992)), 0) );
        (void)( (!!(rhs.IsString())) || (_wassert(L"rhs.IsString()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(1993)), 0) );
        const SizeType len1 = GetStringLength();
        const SizeType len2 = rhs.GetStringLength();
        if(len1 != len2) { return false; }
        const Ch* const str1 = GetString();
        const Ch* const str2 = rhs.GetString();
        if(str1 == str2) { return true; } 
        return (std::memcmp(str1, str2, sizeof(Ch) * len1) == 0);
    }
    Data data_;
};
typedef GenericValue<UTF8<> > Value;
template <typename Encoding, typename Allocator = MemoryPoolAllocator<>, typename StackAllocator = CrtAllocator>
class GenericDocument : public GenericValue<Encoding, Allocator> {
public:
    typedef typename Encoding::Ch Ch;                       
    typedef GenericValue<Encoding, Allocator> ValueType;    
    typedef Allocator AllocatorType;                        
    explicit GenericDocument(Type type, Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :
        GenericValue<Encoding, Allocator>(type),  allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
    {
        if (!allocator_)
            ownAllocator_ = allocator_ = new Allocator();
    }
    GenericDocument(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) : 
        allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
    {
        if (!allocator_)
            ownAllocator_ = allocator_ = new Allocator();
    }
    GenericDocument(GenericDocument&& rhs) 
        : ValueType(std::forward<ValueType>(rhs)), 
          allocator_(rhs.allocator_),
          ownAllocator_(rhs.ownAllocator_),
          stack_(std::move(rhs.stack_)),
          parseResult_(rhs.parseResult_)
    {
        rhs.allocator_ = 0;
        rhs.ownAllocator_ = 0;
        rhs.parseResult_ = ParseResult();
    }
#line 2071 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    ~GenericDocument() {
        Destroy();
    }
    GenericDocument& operator=(GenericDocument&& rhs) 
    {
        ValueType::operator=(std::forward<ValueType>(rhs));
        Destroy();
        allocator_ = rhs.allocator_;
        ownAllocator_ = rhs.ownAllocator_;
        stack_ = std::move(rhs.stack_);
        parseResult_ = rhs.parseResult_;
        rhs.allocator_ = 0;
        rhs.ownAllocator_ = 0;
        rhs.parseResult_ = ParseResult();
        return *this;
    }
#line 2099 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericDocument& Swap(GenericDocument& rhs)  {
        ValueType::Swap(rhs);
        stack_.Swap(rhs.stack_);
        internal::Swap(allocator_, rhs.allocator_);
        internal::Swap(ownAllocator_, rhs.ownAllocator_);
        internal::Swap(parseResult_, rhs.parseResult_);
        return *this;
    }
    friend inline void swap(GenericDocument& a, GenericDocument& b)  { a.Swap(b); }
    template <typename Generator>
    GenericDocument& Populate(Generator& g) {
        ClearStackOnExit scope(*this);
        if (g(*this)) {
            (void)( (!!(stack_.GetSize() == sizeof(ValueType))) || (_wassert(L"stack_.GetSize() == sizeof(ValueType)", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(2138)), 0) ); 
            ValueType::operator=(*stack_.template Pop<ValueType>(1));
        }
        return *this;
    }
    template <unsigned parseFlags, typename SourceEncoding, typename InputStream>
    GenericDocument& ParseStream(InputStream& is) {
        GenericReader<SourceEncoding, Encoding, StackAllocator> reader(
            stack_.HasAllocator() ? &stack_.GetAllocator() : 0);
        ClearStackOnExit scope(*this);
        parseResult_ = reader.template Parse<parseFlags>(is, *this);
        if (parseResult_) {
            (void)( (!!(stack_.GetSize() == sizeof(ValueType))) || (_wassert(L"stack_.GetSize() == sizeof(ValueType)", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(2161)), 0) ); 
            ValueType::operator=(*stack_.template Pop<ValueType>(1));
        }
        return *this;
    }
    template <unsigned parseFlags, typename InputStream>
    GenericDocument& ParseStream(InputStream& is) {
        return ParseStream<parseFlags, Encoding, InputStream>(is);
    }
    template <typename InputStream>
    GenericDocument& ParseStream(InputStream& is) {
        return ParseStream<kParseDefaultFlags, Encoding, InputStream>(is);
    }
    template <unsigned parseFlags>
    GenericDocument& ParseInsitu(Ch* str) {
        GenericInsituStringStream<Encoding> s(str);
        return ParseStream<parseFlags | kParseInsituFlag>(s);
    }
    GenericDocument& ParseInsitu(Ch* str) {
        return ParseInsitu<kParseDefaultFlags>(str);
    }
    template <unsigned parseFlags, typename SourceEncoding>
    GenericDocument& Parse(const typename SourceEncoding::Ch* str) {
        (void)( (!!(!(parseFlags & kParseInsituFlag))) || (_wassert(L"!(parseFlags & kParseInsituFlag)", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(2222)), 0) );
        GenericStringStream<SourceEncoding> s(str);
        return ParseStream<parseFlags, SourceEncoding>(s);
    }
    template <unsigned parseFlags>
    GenericDocument& Parse(const Ch* str) {
        return Parse<parseFlags, Encoding>(str);
    }
    GenericDocument& Parse(const Ch* str) {
        return Parse<kParseDefaultFlags>(str);
    }
    template <unsigned parseFlags, typename SourceEncoding>
    GenericDocument& Parse(const typename SourceEncoding::Ch* str, size_t length) {
        (void)( (!!(!(parseFlags & kParseInsituFlag))) || (_wassert(L"!(parseFlags & kParseInsituFlag)", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(2245)), 0) );
        MemoryStream ms(static_cast<const char*>(str), length * sizeof(typename SourceEncoding::Ch));
        EncodedInputStream<SourceEncoding, MemoryStream> is(ms);
        ParseStream<parseFlags, SourceEncoding>(is);
        return *this;
    }
    template <unsigned parseFlags>
    GenericDocument& Parse(const Ch* str, size_t length) {
        return Parse<parseFlags, Encoding>(str, length);
    }
    GenericDocument& Parse(const Ch* str, size_t length) {
        return Parse<kParseDefaultFlags>(str, length);
    }
#line 2277 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    bool HasParseError() const { return parseResult_.IsError(); }
    ParseErrorCode GetParseError() const { return parseResult_.Code(); }
    size_t GetErrorOffset() const { return parseResult_.Offset(); }
#line 2304 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    operator ParseResult() const { return parseResult_; }
    Allocator& GetAllocator() {
        (void)( (!!(allocator_)) || (_wassert(L"allocator_", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h", (unsigned)(2309)), 0) );
        return *allocator_;
    }
    size_t GetStackCapacity() const { return stack_.GetCapacity(); }
private:
    struct ClearStackOnExit {
        explicit ClearStackOnExit(GenericDocument& d) : d_(d) {}
        ~ClearStackOnExit() { d_.ClearStack(); }
    private:
        ClearStackOnExit(const ClearStackOnExit&);
        ClearStackOnExit& operator=(const ClearStackOnExit&);
        GenericDocument& d_;
    };
    template <typename, typename> friend class GenericValue; 
public:
    bool Null() { new (stack_.template Push<ValueType>()) ValueType(); return true; }
    bool Bool(bool b) { new (stack_.template Push<ValueType>()) ValueType(b); return true; }
    bool Int(int i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
    bool Uint(unsigned i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
    bool Int64(int64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
    bool Uint64(uint64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }
    bool Double(double d) { new (stack_.template Push<ValueType>()) ValueType(d); return true; }
    bool RawNumber(const Ch* str, SizeType length, bool copy) { 
        if (copy) 
            new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());
        else
            new (stack_.template Push<ValueType>()) ValueType(str, length);
        return true;
    }
    bool String(const Ch* str, SizeType length, bool copy) { 
        if (copy) 
            new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());
        else
            new (stack_.template Push<ValueType>()) ValueType(str, length);
        return true;
    }
    bool StartObject() { new (stack_.template Push<ValueType>()) ValueType(kObjectType); return true; }
    bool Key(const Ch* str, SizeType length, bool copy) { return String(str, length, copy); }
    bool EndObject(SizeType memberCount) {
        typename ValueType::Member* members = stack_.template Pop<typename ValueType::Member>(memberCount);
        stack_.template Top<ValueType>()->SetObjectRaw(members, memberCount, GetAllocator());
        return true;
    }
    bool StartArray() { new (stack_.template Push<ValueType>()) ValueType(kArrayType); return true; }
    bool EndArray(SizeType elementCount) {
        ValueType* elements = stack_.template Pop<ValueType>(elementCount);
        stack_.template Top<ValueType>()->SetArrayRaw(elements, elementCount, GetAllocator());
        return true;
    }
private:
    GenericDocument(const GenericDocument&);
    GenericDocument& operator=(const GenericDocument&);
    void ClearStack() {
        if (Allocator::kNeedFree)
            while (stack_.GetSize() > 0)    
                (stack_.template Pop<ValueType>(1))->~ValueType();
        else
            stack_.Clear();
        stack_.ShrinkToFit();
    }
    void Destroy() {
        delete ownAllocator_;
    }
    static const size_t kDefaultStackCapacity = 1024;
    Allocator* allocator_;
    Allocator* ownAllocator_;
    internal::Stack<StackAllocator> stack_;
    ParseResult parseResult_;
};
typedef GenericDocument<UTF8<> > Document;
template <typename Encoding, typename Allocator>
template <typename SourceAllocator>
inline
GenericValue<Encoding,Allocator>::GenericValue(const GenericValue<Encoding,SourceAllocator>& rhs, Allocator& allocator)
{
    switch (rhs.GetType()) {
    case kObjectType:
    case kArrayType: { 
            GenericDocument<Encoding,Allocator> d(&allocator);
            rhs.Accept(d);
            RawAssign(*d.stack_.template Pop<GenericValue>(1));
        }
        break;
    case kStringType:
        if (rhs.data_.f.flags == kConstStringFlag) {
            data_.f.flags = rhs.data_.f.flags;
            data_  = *reinterpret_cast<const Data*>(&rhs.data_);
        } else {
            SetStringRaw(StringRef(rhs.GetString(), rhs.GetStringLength()), allocator);
        }
        break;
    default:
        data_.f.flags = rhs.data_.f.flags;
        data_  = *reinterpret_cast<const Data*>(&rhs.data_);
        break;
    }
}
template <bool Const, typename ValueT>
class GenericArray {
public:
    typedef GenericArray<true, ValueT> ConstArray;
    typedef GenericArray<false, ValueT> Array;
    typedef ValueT PlainType;
    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
    typedef ValueType* ValueIterator;  
    typedef const ValueT* ConstValueIterator;
    typedef typename ValueType::AllocatorType AllocatorType;
    typedef typename ValueType::StringRefType StringRefType;
    template <typename, typename>
    friend class GenericValue;
    GenericArray(const GenericArray& rhs) : value_(rhs.value_) {}
    GenericArray& operator=(const GenericArray& rhs) { value_ = rhs.value_; return *this; }
    ~GenericArray() {}
    SizeType Size() const { return value_.Size(); }
    SizeType Capacity() const { return value_.Capacity(); }
    bool Empty() const { return value_.Empty(); }
    void Clear() const { value_.Clear(); }
    ValueType& operator[](SizeType index) const {  return value_[index]; }
    ValueIterator Begin() const { return value_.Begin(); }
    ValueIterator End() const { return value_.End(); }
    GenericArray Reserve(SizeType newCapacity, AllocatorType &allocator) const { value_.Reserve(newCapacity, allocator); return *this; }
    GenericArray PushBack(ValueType& value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
    GenericArray PushBack(ValueType&& value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
#line 2469 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericArray PushBack(StringRefType value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
    template <typename T> typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (const GenericArray&)>::Type>::Type PushBack(T value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }
    GenericArray PopBack() const { value_.PopBack(); return *this; }
    ValueIterator Erase(ConstValueIterator pos) const { return value_.Erase(pos); }
    ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) const { return value_.Erase(first, last); }
    ValueIterator begin() const { return value_.Begin(); }
    ValueIterator end() const { return value_.End(); }
#line 2479 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
private:
    GenericArray();
    GenericArray(ValueType& value) : value_(value) {}
    ValueType& value_;
};
template <bool Const, typename ValueT>
class GenericObject {
public:
    typedef GenericObject<true, ValueT> ConstObject;
    typedef GenericObject<false, ValueT> Object;
    typedef ValueT PlainType;
    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;
    typedef GenericMemberIterator<Const, typename ValueT::EncodingType, typename ValueT::AllocatorType> MemberIterator;  
    typedef GenericMemberIterator<true, typename ValueT::EncodingType, typename ValueT::AllocatorType> ConstMemberIterator;
    typedef typename ValueType::AllocatorType AllocatorType;
    typedef typename ValueType::StringRefType StringRefType;
    typedef typename ValueType::EncodingType EncodingType;
    typedef typename ValueType::Ch Ch;
    template <typename, typename>
    friend class GenericValue;
    GenericObject(const GenericObject& rhs) : value_(rhs.value_) {}
    GenericObject& operator=(const GenericObject& rhs) { value_ = rhs.value_; return *this; }
    ~GenericObject() {}
    SizeType MemberCount() const { return value_.MemberCount(); }
    bool ObjectEmpty() const { return value_.ObjectEmpty(); }
    template <typename T> ValueType& operator[](T* name) const { return value_[name]; }
    template <typename SourceAllocator> ValueType& operator[](const GenericValue<EncodingType, SourceAllocator>& name) const { return value_[name]; }
#line 2519 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    MemberIterator MemberBegin() const { return value_.MemberBegin(); }
    MemberIterator MemberEnd() const { return value_.MemberEnd(); }
    bool HasMember(const Ch* name) const { return value_.HasMember(name); }
#line 2525 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename SourceAllocator> bool HasMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.HasMember(name); }
    MemberIterator FindMember(const Ch* name) const { return value_.FindMember(name); }
    template <typename SourceAllocator> MemberIterator FindMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.FindMember(name); }
#line 2531 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericObject AddMember(ValueType& name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    GenericObject AddMember(ValueType& name, StringRefType value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
#line 2536 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename T> typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (ValueType&)>::Type>::Type AddMember(ValueType& name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    GenericObject AddMember(ValueType&& name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    GenericObject AddMember(ValueType&& name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    GenericObject AddMember(ValueType& name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    GenericObject AddMember(StringRefType name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
#line 2543 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    GenericObject AddMember(StringRefType name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    GenericObject AddMember(StringRefType name, StringRefType value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    template <typename T> typename ::rapidjson::internal::DisableIf <typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >)>::Type, typename ::rapidjson::internal::RemoveSfinaeTag < ::rapidjson::internal::SfinaeTag&(*) (GenericObject)>::Type>::Type AddMember(StringRefType name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }
    void RemoveAllMembers() { return value_.RemoveAllMembers(); }
    bool RemoveMember(const Ch* name) const { return value_.RemoveMember(name); }
#line 2551 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename SourceAllocator> bool RemoveMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.RemoveMember(name); }
    MemberIterator RemoveMember(MemberIterator m) const { return value_.RemoveMember(m); }
    MemberIterator EraseMember(ConstMemberIterator pos) const { return value_.EraseMember(pos); }
    MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) const { return value_.EraseMember(first, last); }
    bool EraseMember(const Ch* name) const { return value_.EraseMember(name); }
#line 2559 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
    template <typename SourceAllocator> bool EraseMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.EraseMember(name); }
    MemberIterator begin() const { return value_.MemberBegin(); }
    MemberIterator end() const { return value_.MemberEnd(); }
#line 2565 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
private:
    GenericObject();
    GenericObject(ValueType& value) : value_(value) {}
    ValueType& value_;
};
}
__pragma(warning(pop))
#line 2576 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\dependencies\\rapidjson\\1.1.0\\rapidjson/document.h"
#line 12 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h"
#pragma warning(default : 4365 6313 6319 6385 6386)
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns/Maybe.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
__pragma(pack(push, 8)) extern "C" {
     void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
} __pragma(pack(pop))
#line 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 6 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns/Maybe.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns\\Either.h"
#pragma once
namespace CubeWorld
{
template<typename L, typename R>
class Either
{
public:
   using LeftType = typename std::conditional<std::is_void<L>::value, std::nullptr_t, L>::type;
   using RightType = typename std::conditional<std::is_void<R>::value, std::nullptr_t, R>::type;
public:
   constexpr Either(const LeftType& left) : leftVal(left), isLeft(true) {};
   constexpr Either(LeftType&& left) : leftVal(std::move(left)), isLeft(true) {};
   constexpr Either(const RightType& right) : rightVal(right), isLeft(false) {};
   constexpr Either(RightType&& right) : rightVal(std::move(right)), isLeft(false) {};
   constexpr Either(Either<L, R>&& other) : isLeft(other.isLeft)
   {
      if (isLeft)
      {
         leftVal = std::move(other.leftVal);
      }
      else
      {
         rightVal = std::move(other.rightVal);
      }
   };
   ~Either()
   {
      if (isLeft)
      {
         leftVal.~LeftType();
      }
      else
      {
         rightVal.~RightType();
      }
   }
   constexpr bool IsLeft() const { return isLeft; }
   constexpr bool IsRight() const { return !isLeft; }
   LeftType& Left() { return leftVal; }
   RightType& Right() { return rightVal; }
   constexpr Either& operator=(LeftType&& left) { leftVal = std::move(left); isLeft = true; return *this; }
   constexpr Either& operator=(RightType&& right) { rightVal = std::move(right); isLeft = false; return *this; }
   constexpr Either& operator=(const LeftType& left) { leftVal = left; isLeft = true; return *this; }
   constexpr Either& operator=(const RightType& right) { rightVal = right; isLeft = false; return *this; }
   constexpr Either& operator=(Either&& other)
   {
      if (isLeft)
      {
         leftVal.~LeftType();
      }
      else
      {
         rightVal.~RightType();
      }
      isLeft = other.isLeft;
      if (isLeft)
      {
         leftVal = std::move(other.leftVal);
      }
      else
      {
         rightVal = std::move(other.rightVal);
      }
      return *this;
   }
   constexpr Either& operator=(const Either& other)
   {
      if (isLeft)
      {
         leftVal.~LeftType();
      }
      else
      {
         rightVal.~RightType();
      }
      isLeft = other.isLeft;
      if (isLeft)
      {
         leftVal = other.leftVal;
      }
      else
      {
         rightVal = other.rightVal;
      }
      return *this;
   }
protected:
   union {
      LeftType leftVal;
      RightType rightVal;
   };
   bool isLeft;
};
template<typename T>
class Pointer
{
public:
   constexpr Pointer(T* left) : leftVal(left), side(Left) {};
   constexpr Pointer(const std::unique_ptr<T> right) : rightVal(std::move(right)), side(Right) {};
   constexpr Pointer() : leftVal(nullptr), side(Empty) {};
   Pointer(Pointer&& other) : leftVal(nullptr)
   {
      if (other.side == Left)
      {
         this->leftVal = other.leftVal;
         other.leftVal = nullptr;
      }
      else if (other.side == Right)
      {
         this->rightVal = std::move(other.rightVal);
      }
      this->side = other.side;
      other.side = Empty;
   }
   ~Pointer()
   {
   };
   constexpr T* get()
   {
      if (side == Empty)
      {
         return nullptr;
      }
      else if (side == Left)
      {
         return leftVal;
      }
      return rightVal.get();
   }
   constexpr Pointer& operator=(T* left)
   {
      leftVal = left;
      side = Left;
      return *this;
   }
   constexpr Pointer& operator=(std::unique_ptr<T> right)
   {
      rightVal = std::move(right);
      this->side = Right;
      return *this;
   }
   constexpr Pointer& operator=(Pointer<T> other)
   {
      if (other.side == Left)
      {
         this->leftVal = other.leftVal;
         other.leftVal = nullptr;
      }
      else
      {
         this->rightVal = std::move(other.rightVal);
      }
      this->side = other.side;
      other.side = Empty;
      return *this;
   }
   constexpr operator bool() const { return get() != nullptr; }
   constexpr bool operator==(const Pointer& other) { return get() == other.get(); }
   constexpr bool operator==(const T* other) { return get() == other; }
   constexpr bool operator!=(const T* other) { return get() != other; }
   constexpr T* operator->() { return get(); }
private:
   union {
      T* leftVal;
      std::unique_ptr<T> rightVal;
   };
   enum { Left, Right, Empty } side;
};
}; 
#line 9 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns/Maybe.h"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns\\Failure.h"
#pragma once
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBText/Format.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
__pragma(pack(push, 8)) extern "C" {
     void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\assert.h"
} __pragma(pack(pop))
#line 6 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\cassert"
#line 6 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBText/Format.h"
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\string_view"
#pragma once
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\string_view"
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\string_view"
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\string_view"
#line 10 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBText/Format.h"
namespace CubeWorld
{
namespace Format
{
namespace impl
{
enum type
{
   none_type, name_arg_type,
   int32_type, uint32_type, int64_type, uint64_type, bool_type, char_type,
   last_integer_type = char_type,
   double_type, long_double_type, last_numeric_type = long_double_type,
   cstring_type, string_type, pointer_type, custom_type
};
constexpr bool is_integral(type t) {
   (void)( (!!(t != type::name_arg_type)) || (_wassert(L"t != type::name_arg_type", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBText/Format.h", (unsigned)(32)), 0) );
   return t > type::none_type && t <= type::last_integer_type;
}
constexpr bool is_arithmetic(type t) {
   (void)( (!!(t != type::name_arg_type)) || (_wassert(L"t != type::name_arg_type", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBText/Format.h", (unsigned)(37)), 0) );
   return t > type::none_type && t <= type::last_numeric_type;
}
template <typename Char>
struct string_value
{
   const Char *value;
   std::size_t size;
};
struct custom_value {
   const void *value;
   void(*format)(const void *arg);
};
class value
{
public:
   union {
      int32_t int32_value;
      int64_t int64_value;
      uint32_t uint32_value;
      uint64_t uint64_value;
      double double_value;
      long double long_double_value;
      const void *pointer;
      string_value<char> string;
      string_value<signed char> sstring;
      string_value<unsigned char> ustring;
      custom_value custom;
   };
   constexpr value(int32_t val = 0) : int32_value(val) {}
   value(int64_t val) { int64_value = val; }
   value(uint32_t val) { uint32_value = val; }
   value(uint64_t val) { uint64_value = val; }
   value(double val) { double_value = val; }
   value(long double val) { long_double_value = val; }
   value(const void *val) { pointer = val; }
   value(const signed char *val) { sstring.value = val; }
   value(const unsigned char *val) { ustring.value = val; }
   value(std::basic_string_view<char> val)
   {
      string.value = val.data();
      string.size = val.size();
   }
private:
   template <typename T>
   static void format_custom_arg(const void *arg)
   {
   }
};
template <type TYPE>
struct typed_value : value {
   static const type type_tag = TYPE;
   template <typename T>
   constexpr typed_value(const T &val) : value(val) {}
};
struct format_specs
{
   uint32_t precision = 0xffffffffui32;
};
class basic_arg
{
private:
   value value_;
   type type_;
   template <typename T>
   friend constexpr basic_arg make_arg(const T &value);
   friend std::string FormatArg(const basic_arg& argument, const format_specs& precision);
   friend class basic_format_args;
public:
   constexpr basic_arg() : type_(type::none_type) {}
   explicit operator bool() const noexcept
   {
      return type_ != type::none_type;
   }
   type type() const { return type_; }
   bool is_integral() const { return impl::is_integral(type_); }
   bool is_arithmetic() const { return impl::is_arithmetic(type_); }
   bool is_pointer() const { return type_ == type::pointer_type; }
};
constexpr typed_value<type::int32_type> make_value(signed char val) { return static_cast<int32_t>(val); };
constexpr typed_value<type::int32_type> make_value(short val) { return static_cast<int32_t>(val); };
constexpr typed_value<type::int32_type> make_value(int val) { return static_cast<int32_t>(val); };
constexpr typed_value<type::uint32_type> make_value(unsigned char val) { return static_cast<uint32_t>(val); };
constexpr typed_value<type::uint32_type> make_value(unsigned short val) { return static_cast<uint32_t>(val); };
constexpr typed_value<type::uint32_type> make_value(unsigned int val) { return static_cast<uint32_t>(val); };
constexpr typed_value<type::int64_type> make_value(long long val) { return static_cast<int64_t>(val); };
constexpr typed_value<type::uint64_type> make_value(unsigned long long val) { return static_cast<uint64_t>(val); };
constexpr typed_value<type::bool_type> make_value(bool val) { return static_cast<int32_t>(val); };
constexpr typed_value<type::char_type> make_value(char val) { return static_cast<int32_t>(val); };
typedef std::conditional<sizeof(long) == sizeof(int), int, long long>::type long_type;
constexpr typed_value<(sizeof(long) == sizeof(int) ? type::int32_type : type::int64_type)> make_value(long val) { return static_cast<long_type>(val); };
typedef std::conditional<sizeof(unsigned long) == sizeof(unsigned int), unsigned int, unsigned long long>::type ulong_type;
constexpr typed_value<(sizeof(unsigned long) == sizeof(unsigned int) ? type::uint32_type : type::uint64_type)> make_value(unsigned long val) { return static_cast<ulong_type>(val); };
constexpr typed_value<type::double_type> make_value(float val) { return static_cast<double>(val); };
constexpr typed_value<type::double_type> make_value(double val) { return static_cast<double>(val); };
constexpr typed_value<type::long_double_type> make_value(long double val) { return static_cast<long double>(val); };
constexpr typed_value<type::cstring_type> make_value(char* val) { return static_cast<const char*>(val); };
constexpr typed_value<type::cstring_type> make_value(const char* val) { return static_cast<const char*>(val); };
constexpr typed_value<type::cstring_type> make_value(signed char* val) { return static_cast<const signed char*>(val); };
constexpr typed_value<type::cstring_type> make_value(const signed char* val) { return static_cast<const signed char*>(val); };
constexpr typed_value<type::cstring_type> make_value(unsigned char* val) { return static_cast<const unsigned char*>(val); };
constexpr typed_value<type::cstring_type> make_value(const unsigned char* val) { return static_cast<const unsigned char*>(val); };
constexpr typed_value<type::string_type> make_value(std::basic_string_view<char> val) { return static_cast<std::basic_string_view<char>>(val); };
constexpr typed_value<type::string_type> make_value(const std::basic_string<char>& val) { return static_cast<std::basic_string_view<char>>(val); };
constexpr typed_value<type::pointer_type> make_value(void* val) { return static_cast<const void*>(val); };
constexpr typed_value<type::pointer_type> make_value(const void* val) { return static_cast<const void*>(val); };
constexpr typed_value<type::pointer_type> make_value(std::nullptr_t val) { return static_cast<const void*>(val); };
template <typename T>
void make_value(const T *) {
   static_assert(!sizeof(T), "formatting of non-void pointers is disallowed");
}
enum { MAX_PACKED_ARGS = 15 };
template <typename T>
class get_type
{
public:
   typedef decltype(make_value(
      std::declval<typename std::decay<T>::type>())) value_type;
   static const type value = value_type::type_tag;
};
template <typename T>
constexpr basic_arg make_arg(const T &value)
{
   basic_arg arg;
   arg.type_ = get_type<T>::value;
   arg.value_ = make_value(value);
   return arg;
}
template <typename ...Args>
class arg_store;
class basic_format_args
{
public:
   typedef unsigned size_type;
private:
   size_t size_;
   const basic_arg *args_;
   void set_data(const basic_arg *args) { args_ = args; }
   basic_arg get(uint32_t index) const
   {
      return index < size_ ? args_[index] : basic_arg{};
   }
public:
   basic_format_args() : size_(0), args_(nullptr) {}
   template<typename... Args>
   basic_format_args(const arg_store<Args...> &store) : size_(store.NUM_ARGS), args_(store.data()) {}
   basic_arg operator[](uint32_t index) const
   {
      basic_arg arg = get(index);
      return arg;
   }
   size_t max_size() const {
      return size_;
   }
};
template <typename ...Args>
class arg_store {
public:
   static const size_t NUM_ARGS = sizeof...(Args);
   static const uint64_t TYPES;
private:
   static const bool IS_PACKED = NUM_ARGS < MAX_PACKED_ARGS;
   typedef class basic_arg value_type;
   basic_arg data_[NUM_ARGS + 1];
public:
   arg_store(const Args&... args) : data_{ impl::make_arg(args)... } {}
   basic_format_args operator*() const { return *this; }
   const value_type *data() const { return data_; }
};
template <typename ...Args>
const uint64_t arg_store<Args...>::TYPES = -static_cast<int64_t>(NUM_ARGS);
template <typename ...Args>
inline arg_store<Args...> make_args(const Args & ... args)
{
   return arg_store<Args...>(args...);
}
}; 
std::string FormatString(std::string_view fmt, impl::basic_format_args args);
template <typename... Args>
std::string FormatString(std::string_view fmt, const Args& ... args)
{
   return FormatString(fmt, *impl::arg_store<Args...>(args...));
}
}; 
}; 
#line 8 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns\\Failure.h"
#line 13 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns\\Failure.h"
namespace CubeWorld
{
class Failure {
public:
   Failure() {};
   Failure(const Failure& other) : message(other.message), failureCode(other.failureCode) {};
   Failure(const std::string& message, int failureCode = NO_FAILURE_CODE_SPECIFIED) : message(message), failureCode(failureCode) {};
   template <typename ...Args>
   Failure(const std::string& fmt, const Args& ... args) : message(Format::FormatString(fmt, args...)) {};
   template <typename ...Args>
   Failure(int failureCode, const std::string& fmt, const Args& ... args) 
      : message(Format::FormatString(fmt, args...))
      , failureCode(failureCode)
   {};
   const std::string GetMessage() const { return message; }
   int GetFailureCode() const { return failureCode; }
public:
   Failure WithContext(const std::string& context)
   {
      return Failure(context + ": " + message);
   }
   template <typename ...Args>
   Failure WithContext(const std::string& fmt, const Args& ... args)
   {
      return WithContext(Format::FormatString(fmt, args...));
   }
   static const int NO_FAILURE_CODE_SPECIFIED = -1;
private:
   std::string message;
   int failureCode;  
};
}; 
#line 10 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns/Maybe.h"
namespace CubeWorld
{
template <typename T, typename FailureType>
class MaybeType : protected Either<
   typename std::conditional<std::is_void<T>::value, std::nullptr_t, T>::type,
   FailureType
>
{
public:
   using ValueType = typename std::conditional<std::is_void<T>::value, std::nullptr_t, T>::type;
   using Either = Either<
      ValueType,
      FailureType
   >;
   constexpr MaybeType() : Either(FailureType{}) {};
   constexpr MaybeType(const ValueType& value) : Either(value) {};
   constexpr MaybeType(ValueType&& value) : Either(std::move(value)) {};
   constexpr MaybeType(const FailureType& failure) : Either(failure) {};
   constexpr MaybeType(FailureType&& failure) : Either(std::move(failure)) {};
public:
   bool Succeeded() const { return this->IsLeft(); }
   bool Failed() const { return this->IsRight(); }
   constexpr bool operator !() const { return Failed(); }
   constexpr operator bool() const { return Succeeded(); }
   const FailureType& Failure() const { return this->Right(); }
   FailureType& Failure() { return this->Right(); }
   const ValueType& Result() const { return this->Left(); }
   ValueType& Result() { return this->Left(); }
   constexpr ValueType& operator*() { (void)( (!!(Succeeded())) || (_wassert(L"Succeeded()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns/Maybe.h", (unsigned)(50)), 0) ); return Result(); }
   constexpr T* operator->() { (void)( (!!(Succeeded())) || (_wassert(L"Succeeded()", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBDesignPatterns/Maybe.h", (unsigned)(51)), 0) ); return &this->leftVal; }
};
template <typename T>
using Maybe = MaybeType<T, Failure>;
const std::nullptr_t Success = nullptr;
}; 
#line 15 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h"
namespace CubeWorld
{
class BindingProperty
{
public:
   const static BindingProperty Null;
   static BindingProperty _;
public:
   enum Type {
      kNullType = 0,
      kTrueType = 1,
      kFalseType = 2,
      kNumberType = 3,
      kStringType = 4,
      kObjectType = 5,
      kArrayType = 6,
   };
public:
   struct KeyVal;
   template<typename Property> class IteratorType;
   template<typename Property> class PairIteratorType;
   typedef IteratorType<BindingProperty> Iterator;
   typedef IteratorType<const BindingProperty> ConstIterator;
   typedef PairIteratorType<BindingProperty> PairIterator;
   typedef PairIteratorType<const BindingProperty> ConstPairIterator;
   template<typename Property, typename It> class ArrayType;
   template <typename Property> class ArrayIteratorType;
   template<typename Property, typename It> class ObjectType;
   template <typename Property, typename KeyVal> class ObjectIteratorType;
   typedef ArrayIteratorType<BindingProperty> ArrayIterator;
   typedef ArrayType<BindingProperty, ArrayIterator> Array;
   typedef ArrayIteratorType<const BindingProperty> ConstArrayIterator;
   typedef ArrayType<const BindingProperty, ConstArrayIterator> ConstArray;
   typedef ObjectIteratorType<BindingProperty, KeyVal> ObjectIterator;
   typedef ObjectType<BindingProperty, ObjectIterator> Object;
   typedef ObjectIteratorType<const BindingProperty, const KeyVal> ConstObjectIterator;
   typedef ObjectType<const BindingProperty, ConstObjectIterator> ConstObject;
public:
   BindingProperty() : flags(kNullFlag) { data.numVal.i64 = 0; };
   BindingProperty(const Type& type);
   BindingProperty(const BindingProperty& other);
   BindingProperty(BindingProperty&& other);
   ~BindingProperty();
   BindingProperty(bool value);
   BindingProperty(int32_t i);
   BindingProperty(int64_t i64);
   BindingProperty(uint32_t u);
   BindingProperty(uint64_t u64);
   BindingProperty(double d);
   BindingProperty(float f);
   BindingProperty(const char* s);
   BindingProperty(const std::string& s);
   BindingProperty(std::string&& s);
   BindingProperty(const glm::vec3& vec3);
   BindingProperty(const glm::vec4& vec4);
   BindingProperty& operator=(const BindingProperty& other);
   BindingProperty& operator=(BindingProperty&& other);
   BindingProperty& operator[](const int& index);
   BindingProperty& operator[](const size_t& index);
   BindingProperty& operator[](const std::string& key);
   BindingProperty& operator[](const char* key);
   const BindingProperty& operator[](const int& index) const;
   const BindingProperty& operator[](const size_t& index) const;
   const BindingProperty& operator[](const std::string& key) const;
   const BindingProperty& operator[](const char* key) const;
   bool operator==(const BindingProperty& other) const;
   inline bool operator!=(const BindingProperty& other) const { return !(*this == other); }
public:
   bool IsNull() const { return flags == uint16_t(kNullFlag); }
   bool IsBool() const { return (flags & kBoolFlag) != 0; }
   bool IsObject() const { return flags == uint16_t(kObjectFlag); }
   bool IsArray() const { return flags == uint16_t(kArrayFlag); }
   bool IsNumber() const { return (flags & kNumberFlag) != 0; }
   bool IsInt() const { return (flags & kIntFlag) != 0; }
   bool IsUint() const { return (flags & kUintFlag) != 0; }
   bool IsInt64() const { return (flags & kInt64Flag) != 0; }
   bool IsUint64() const { return (flags & kUint64Flag) != 0; }
   bool IsDouble() const { return (flags & kDoubleFlag) != 0; }
   bool IsString() const { return flags == uint16_t(kStringFlag); }
   bool IsVec3() const;
   bool IsVec4() const;
   const bool GetBooleanValue(const bool& defaultValue = false) const;
   const int32_t GetIntValue(const int32_t& defaultValue = 0) const;
   const uint32_t GetUintValue(const uint32_t& defaultValue = 0) const;
   const int64_t GetInt64Value(const int64_t& defaultValue = 0) const;
   const uint64_t GetUint64Value(const uint64_t& defaultValue = 0) const;
   const double GetDoubleValue(const double& defaultValue = 0) const;
   const float GetFloatValue(const float& defaultValue = 0) const;
   const std::string GetStringValue(const std::string& defaultValue = "") const;
   glm::vec3 GetVec3(const glm::vec3& defaultValue = {0, 0, 0}) const;
   glm::vec4 GetVec4(const glm::vec4& defaultValue = {0, 0, 0, 0}) const;
   inline operator std::string() const { return GetStringValue(); }
   Array AsArray();
   ConstArray AsArray() const;
   Object AsObject();
   ConstObject AsObject() const;
   bool Has(const std::string& key);
   ObjectIterator Find(const std::string& key);
   ConstObjectIterator Find(const std::string& key) const;
   Iterator begin();
   Iterator end();
   ConstIterator begin() const;
   ConstIterator end() const;
   PairIterator begin_pairs();
   PairIterator end_pairs();
   ConstPairIterator begin_pairs() const;
   ConstPairIterator end_pairs() const;
   template <typename Property, typename Iterator>
   struct PairMaker {
      PairMaker(Property& obj_) : obj(obj_) {};
      Iterator begin() const { return obj.begin_pairs(); }
      Iterator end() const { return obj.end_pairs(); }
      Property& obj;
   };
   PairMaker<BindingProperty, PairIterator> pairs()
   {
      return PairMaker<BindingProperty, PairIterator>{*this};
   }
   PairMaker<const BindingProperty, ConstPairIterator> pairs() const
   {
      return PairMaker<const BindingProperty, ConstPairIterator>{*this};
   }
public:
   BindingProperty& SetNull()                { this->~BindingProperty(); new (this) BindingProperty();    return *this; }
   BindingProperty& SetBool(bool val)        { this->~BindingProperty(); new (this) BindingProperty(val); return *this; }
   BindingProperty& SetInt(int i)            { this->~BindingProperty(); new (this) BindingProperty(i);   return *this; }
   BindingProperty& SetUint(unsigned u)      { this->~BindingProperty(); new (this) BindingProperty(u);   return *this; }
   BindingProperty& SetInt64(int64_t i64)    { this->~BindingProperty(); new (this) BindingProperty(i64); return *this; }
   BindingProperty& SetUint64(uint64_t u64)  { this->~BindingProperty(); new (this) BindingProperty(u64); return *this; }
   BindingProperty& SetDouble(double d)      { this->~BindingProperty(); new (this) BindingProperty(d);   return *this; }
   BindingProperty& SetFloat(float f)        { this->~BindingProperty(); new (this) BindingProperty(f);   return *this; }
   BindingProperty& SetString(const std::string& s) { this->~BindingProperty(); new (this) BindingProperty(s);            return *this; }
   BindingProperty& SetString(std::string&& s)      { this->~BindingProperty(); new (this) BindingProperty(std::move(s)); return *this; }
   BindingProperty& SetArray()  { this->~BindingProperty(); new (this) BindingProperty(kArrayType);  return *this; }
   BindingProperty& PushBack(BindingProperty val);
   inline BindingProperty& push_back(BindingProperty val) { return PushBack(val); }
   void PopBack();
   inline void pop_back() { return PopBack(); }
   BindingProperty& SetObject() { this->~BindingProperty(); new (this) BindingProperty(kObjectType); return *this; }
   BindingProperty& Set(const std::string& key, const BindingProperty& value);
   BindingProperty& Set(const std::string& key, BindingProperty&& value);
public:
   template <typename Handler>
   Maybe<void> Write(Handler& handler) const
   {
      ConstArrayIterator it(this, 0), end(this, 0);
      switch (flags & kTypeMask)
      {
      case kNullType:
         if (!handler.Null()) { return Failure{"Failed to write null value"}; };
         break;
      case kTrueType:
      case kFalseType:
         if (!handler.Bool(GetBooleanValue())) { return Failure{"Failed to write boolean value"}; };
         break;
      case kNumberType:
         if (IsDouble()) { if (!handler.Double(data.numVal.d)) { return Failure{"Failed to write double value"}; }; }
         else if (IsInt()) { if (!handler.Int(data.numVal.i.i)) { return Failure{"Failed to write int value"}; }; }
         else if (IsUint()) { if (!handler.Uint(data.numVal.u.u)) { return Failure{"Failed to write unsigned int value"}; }; }
         else if (IsInt64()) { if (!handler.Int64(data.numVal.i64)) { return Failure{"Failed to write 64-bit int value"}; }; }
         else if (IsUint64()) { if (!handler.Uint64(data.numVal.u64)) { return Failure{"Failed to write unsigned 64-bit int value"}; }; }
         else { return Failure{"Unhandled number type: %1", flags}; }
         break;
      case kStringType:
         if (!handler.String(data.stringVal.c_str(), data.stringVal.size(), false)) { return Failure{"Failed to write string value"}; };
         break;
      case kObjectType:
         if (!handler.StartObject()) { return Failure{"Failed to start object"}; };
         for (const KeyVal& kv : data.objectVal)
         {
            if (!handler.Key(kv.key.c_str(), kv.key.size(), false))
            {
               return Failure{"Failed to write key %1", kv.key};
            }
            if (Maybe<void> result = kv.value.Write(handler); !result)
            {
               return result.Failure().WithContext("Failed to write value for %1", kv.key);
            }
         }
         if (!handler.EndObject(data.objectVal.size())) { return Failure{"Failed to end object"}; };
         break;
      case kArrayType:
         if (!handler.StartArray()) { return Failure{"Failed to start array"}; };
         end = AsArray().end();
         for (it = AsArray().begin(); it != end; ++it)
         {
            if (Maybe<void> result = it->Write(handler); !result)
            {
               return result.Failure().WithContext("Failed to write index %1", it.mIndex);
            }
         }
         if (!handler.EndArray(data.arrayVal.size())) { return Failure{"Failed to end array"}; };
         break;
      default:
         return Failure{"Unhandled type flag: %1", flags & kTypeMask};
      }
      return Success;
   }
public:
   template<typename Property>
   class IteratorType : public std::iterator<std::input_iterator_tag, Property> {
   public:
      IteratorType& operator++()
      {
         switch (mObject->flags)
         {
         case kArrayFlag:
            if (mIndex < mObject->data.arrayVal.size()) { ++mIndex; }
            break;
         case kObjectFlag:
            if (mIndex < mObject->data.objectVal.size()) { ++mIndex; }
            break;
         default:
            (void)( (!!(false && "Dereferencing iterator on a property that is not an object or an array")) || (_wassert(L"false && \"Dereferencing iterator on a property that is not an object or an array\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h", (unsigned)(293)), 0) );
         }
         return *this;
      }
      bool operator==(const IteratorType& rhs) const
      {
         return mObject == rhs.mObject && mIndex == rhs.mIndex;
      }
      bool operator!=(const IteratorType& rhs) const
      {
         return !(*this == rhs);
      }
      Property& operator*() const
      {
         switch (mObject->flags)
         {
         case kArrayFlag:
            return mObject->data.arrayVal[mIndex];
         case kObjectFlag:
            return mObject->data.objectVal[mIndex].value;
         default:
            (void)( (!!(false && "Dereferencing iterator on a property that is not an object or an array")) || (_wassert(L"false && \"Dereferencing iterator on a property that is not an object or an array\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h", (unsigned)(317)), 0) );
         }
         return *mObject;
      }
      Property* operator->() const
      {
         return &(this->operator*());
      }
      IteratorType& operator=(const IteratorType& other)
      {
         mObject = other.mObject;
         mIndex = other.mIndex;
         return *this;
      }
   private:
      friend class BindingProperty;
      IteratorType(Property* object, size_t index)
         : mObject(object)
         , mIndex(index)
      {};
   private:
      Property* mObject;
      size_t mIndex;
   };
   template<typename Property>
   class PairIteratorType : public std::iterator<std::input_iterator_tag, std::pair<BindingProperty, Property&>> {
   public:
      PairIteratorType& operator++() 
      {
         switch (mObject->flags)
         {
         case kArrayFlag:
            if (mIndex < mObject->data.arrayVal.size()) { ++mIndex; }
            break;
         case kObjectFlag:
            if (mIndex < mObject->data.objectVal.size()) { ++mIndex; }
            break;
         default:
            (void)( (!!(false && "Dereferencing iterator on a property that is not an object or an array")) || (_wassert(L"false && \"Dereferencing iterator on a property that is not an object or an array\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h", (unsigned)(361)), 0) );
         }
         return *this;
      }
      bool operator==(const PairIteratorType& rhs) const
      {
         return mObject == rhs.mObject && mIndex == rhs.mIndex;
      }
      bool operator!=(const PairIteratorType& rhs) const
      {
         return !(*this == rhs);
      }
      std::pair<BindingProperty, Property&> operator*() const
      {
         if (mObject->IsArray())
         {
            return {
               BindingProperty(mIndex),
               mObject->data.arrayVal[mIndex]
            };
         }
         else if (mObject->IsObject())
         {
            return {
               BindingProperty(mObject->data.objectVal[mIndex].key),
               mObject->data.objectVal[mIndex].value
            };
         }
         (void)( (!!(false && "Dereferencing iterator on a property that is not an object or an array")) || (_wassert(L"false && \"Dereferencing iterator on a property that is not an object or an array\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h", (unsigned)(392)), 0) );
         return std::pair<BindingProperty, Property&>{BindingProperty{}, _};
      }
      PairIteratorType& operator=(const PairIteratorType& other)
      {
         mObject = other.mObject;
         mIndex = other.mIndex;
         return *this;
      }
   private:
      friend class BindingProperty;
      PairIteratorType(Property* object, size_t index)
         : mObject(object)
         , mIndex(index)
      {}
   private:
      Property* mObject;
      size_t mIndex;
   };
   template <typename Property>
   class ArrayIteratorType : public std::iterator<std::input_iterator_tag, BindingProperty> {
   public:
      ArrayIteratorType& operator++() 
      {
         if (mIndex < mObject->data.arrayVal.size()) { ++mIndex; }
         return *this;
      }
      bool operator==(const ArrayIteratorType& rhs) const
      {
         return mObject == rhs.mObject && mIndex == rhs.mIndex;
      }
      bool operator!=(const ArrayIteratorType& rhs) const
      {
         return !(*this == rhs);
      }
      Property& operator*() const
      {
         return mObject->data.arrayVal[mIndex];
      }
      Property* operator->() const
      {
         return &mObject->data.arrayVal[mIndex];
      }
   private:
      friend class BindingProperty;
      ArrayIteratorType(Property* object, uint32_t index)
         : mObject(object)
         , mIndex(index)
      {};
   public:
      ArrayIteratorType & operator=(const ArrayIteratorType& other)
      {
         mObject = other.mObject;
         mIndex = other.mIndex;
         return *this;
      }
   private:
      Property * mObject;
      uint32_t mIndex;
   };
   template<typename Property, typename It>
   class ArrayType {
   public:
      ArrayType(Property* object) : mObject(object) {};
      It begin() { return It(mObject, 0); }
      It end() { return It(mObject, mObject->data.arrayVal.size()); }
   private:
      Property* mObject;
   };
   template <typename Property, typename KV>
   class ObjectIteratorType : public std::iterator<std::input_iterator_tag, KV> {
   public:
      ObjectIteratorType& operator++() 
      {
         if (mIndex < mObject->data.objectVal.size()) { ++mIndex; }
         return *this;
      }
      bool operator==(const ObjectIteratorType& rhs) const
      {
         return mObject == rhs.mObject && mIndex == rhs.mIndex;
      }
      bool operator!=(const ObjectIteratorType& rhs) const
      {
         return !(*this == rhs);
      }
      KV& operator*() const
      {
         return mObject->data.objectVal[mIndex];
      }
      KV* operator->() const
      {
         return &(this->operator*());
      }
   private:
      friend class BindingProperty;
      ObjectIteratorType(Property* object, size_t index)
         : mObject(object)
         , mIndex(index)
      {};
   public:
      ObjectIteratorType& operator=(const ObjectIteratorType& other)
      {
         mObject = other.mObject;
         mIndex = other.mIndex;
         return *this;
      }
   private:
      Property* mObject;
      size_t mIndex;
   };
   template<typename Property, typename It>
   class ObjectType {
   public:
      ObjectType(Property* object) : mObject(object) {};
      It begin() { return It(mObject, 0); }
      It end() { return It(mObject, mObject->data.objectVal.size()); }
   private:
      Property* mObject;
   };
private:
   union Number {
      struct I {
         int i;
         char padding[4];
      }i;
      struct U {
         unsigned u;
         char padding2[4];
      }u;
#line 566 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.h"
      int64_t i64;
      uint64_t u64;
      double d;
   };  
   union Data {
#pragma warning(disable : 4582) 
      Data() { numVal.i64 = 0; }
#pragma warning(default : 4582) 
#pragma warning(disable : 4583) 
      ~Data() {  }
#pragma warning(default : 4583) 
      Number numVal;
      std::string stringVal;
      RGBBinding::Array<BindingProperty> arrayVal;
      RGBBinding::Array<KeyVal> objectVal;
   };
private:
   enum Flags {
      kBoolFlag = 0x0008,
      kNumberFlag = 0x0010,
      kIntFlag = 0x0020,
      kUintFlag = 0x0040,
      kInt64Flag = 0x0080,
      kUint64Flag = 0x0100,
      kDoubleFlag = 0x0200,
      kNullFlag = kNullType,
      kTrueFlag = kTrueType | kBoolFlag,
      kFalseFlag = kFalseType | kBoolFlag,
      kNumberIntFlag = kNumberType | kNumberFlag | kIntFlag | kInt64Flag,
      kNumberUintFlag = kNumberType | kNumberFlag | kUintFlag | kUint64Flag | kInt64Flag,
      kNumberInt64Flag = kNumberType | kNumberFlag | kInt64Flag,
      kNumberUint64Flag = kNumberType | kNumberFlag | kUint64Flag,
      kNumberDoubleFlag = kNumberType | kNumberFlag | kDoubleFlag,
      kNumberAnyFlag = kNumberType | kNumberFlag | kIntFlag | kInt64Flag | kUintFlag | kUint64Flag | kDoubleFlag,
      kStringFlag = kStringType,
      kObjectFlag = kObjectType,
      kArrayFlag = kArrayType,
      kTypeMask = 0x07
   };
private:
   Data data;
   uint16_t flags = kNullFlag;
};
struct BindingProperty::KeyVal {
   inline bool operator==(const KeyVal& other) const
   {
      return key == other.key && value == other.value;
   }
   inline bool operator!=(const KeyVal& other) const { return !(*this == other); }
   std::string key;
   BindingProperty value;
};
template<typename T,
typename std::enable_if<!std::is_same<T, BindingProperty>::value, int>::type = 0>
inline bool operator==(const BindingProperty& prop, const T& other)
{
   return prop == BindingProperty(other);
}
template<typename T,
typename std::enable_if<!std::is_same<T, BindingProperty>::value, int>::type = 0>
inline bool operator==(const T& other, const BindingProperty& prop)
{
   return BindingProperty(other) == prop;
}
template<typename T, typename std::enable_if<!std::is_same<T, BindingProperty>::value, int>::type = 0>
inline bool operator!=(const BindingProperty& prop, const T& other)
{
   return prop != BindingProperty(other);
}
template<typename T,
typename std::enable_if<!std::is_same<T, BindingProperty>::value, int>::type = 0>
inline bool operator!=(const T& other, const BindingProperty& prop) { return !(other == prop); }
}; 
#line 4 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp"
namespace CubeWorld
{
const BindingProperty BindingProperty::Null = BindingProperty{};
BindingProperty BindingProperty::_ = BindingProperty{};
BindingProperty::BindingProperty(const Type& type)
{
   static const uint16_t defaultFlags[7] = {
      kNullFlag, kFalseFlag, kTrueFlag, kNumberAnyFlag,
      kStringFlag, kObjectFlag, kArrayFlag,
   };
   (void)( (!!(type <= kArrayType && "Invalid type provided")) || (_wassert(L"type <= kArrayType && \"Invalid type provided\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(20)), 0) );
   flags = defaultFlags[type];
   if (type == kStringType) { data.stringVal.clear(); }
   else if (type == kObjectType) { new (&data.objectVal) RGBBinding::Array<KeyVal>(); }
   else if (type == kArrayType) { new (&data.arrayVal) RGBBinding::Array<BindingProperty>(); }
   else { data.numVal.i64 = 0; }
}
BindingProperty::BindingProperty(const BindingProperty& other)
   : flags(other.flags)
{
   if (IsNumber()) { data.numVal = other.data.numVal; }
   else if (IsString()) { new (&data.stringVal) std::string(other.data.stringVal); }
   else if (IsObject()) { new (&data.objectVal) RGBBinding::Array<KeyVal>(other.data.objectVal); }
   else if (IsArray()) { new (&data.arrayVal) RGBBinding::Array<BindingProperty>(other.data.arrayVal); }
}
BindingProperty::BindingProperty(BindingProperty&& other)
   : flags(other.flags)
{
   if (IsNumber()) { data.numVal = other.data.numVal; }
   else if (IsString()) { new (&data.stringVal) std::string(std::move(other.data.stringVal)); }
   else if (IsObject()) { new (&data.objectVal) RGBBinding::Array<KeyVal>(std::move(other.data.objectVal)); }
   else if (IsArray()) { new (&data.arrayVal) RGBBinding::Array<BindingProperty>(std::move(other.data.arrayVal)); }
}
BindingProperty::~BindingProperty()
{
   if (IsNull())
   {
      return;
   }
   else if (IsString())
   {
      data.stringVal.~basic_string();
   }
   else if (IsObject())
   {
      data.objectVal.~Array();
   }
   else if (IsArray())
   {
      data.arrayVal.~Array();
   }
}
BindingProperty::BindingProperty(bool value)
{
   data.numVal.i64 = 0;
   flags = value ? uint16_t(kTrueFlag) : uint16_t(kFalseFlag);
}
BindingProperty::BindingProperty(int32_t i)
{
   data.numVal.i64 = i;
   flags = uint16_t((i >= 0) ? (kNumberIntFlag | kUintFlag | kUint64Flag) : kNumberIntFlag);
}
BindingProperty::BindingProperty(int64_t i64)
{
   data.numVal.i64 = i64;
   flags = kNumberInt64Flag;
   if (i64 >= 0) {
      flags |= kNumberUint64Flag;
      if (!(static_cast<uint64_t>(i64) & ((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x00000000))))
         flags |= kUintFlag;
      if (!(static_cast<uint64_t>(i64) & ((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x80000000))))
         flags |= kIntFlag;
   }
   else if (i64 >= static_cast<int64_t>(((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x80000000))))
      flags |= kIntFlag;
}
BindingProperty::BindingProperty(uint32_t u)
{
   data.numVal.u64 = u;
   flags = uint16_t((u & 0x80000000) ? kNumberUintFlag : (kNumberUintFlag | kIntFlag | kInt64Flag));
}
BindingProperty::BindingProperty(uint64_t u64)
{
   data.numVal.u64 = u64;
   flags = kNumberUint64Flag;
   if (!(u64 & ((static_cast<uint64_t>(0x80000000) << 32) | static_cast<uint64_t>(0x00000000))))
      flags |= kInt64Flag;
   if (!(u64 & ((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x00000000))))
      flags |= kUintFlag;
   if (!(u64 & ((static_cast<uint64_t>(0xFFFFFFFF) << 32) | static_cast<uint64_t>(0x80000000))))
      flags |= kIntFlag;
}
BindingProperty::BindingProperty(double d)
{
   data.numVal.d = d;
   flags = kNumberDoubleFlag;
}
BindingProperty::BindingProperty(float f)
{
   data.numVal.d = f;
   flags = kNumberDoubleFlag;
}
BindingProperty::BindingProperty(const char* s)
{
   new (&data.stringVal) std::string(s);
   flags = kStringFlag;
}
BindingProperty::BindingProperty(const std::string& s)
{
   new (&data.stringVal) std::string(s);
   flags = kStringFlag;
}
BindingProperty::BindingProperty(std::string&& s)
{
   new (&data.stringVal) std::string(std::move(s));
   flags = kStringFlag;
}
BindingProperty::BindingProperty(const glm::vec3& vec3) : BindingProperty(kArrayType)
{
   push_back(vec3[0]);
   push_back(vec3[1]);
   push_back(vec3[2]);
}
BindingProperty::BindingProperty(const glm::vec4& vec4) : BindingProperty(kArrayType)
{
   push_back(vec4[0]);
   push_back(vec4[1]);
   push_back(vec4[2]);
   push_back(vec4[3]);
}
BindingProperty& BindingProperty::operator=(const BindingProperty& other)
{
   this->~BindingProperty();
   new (this) BindingProperty(other);
   return *this;
}
BindingProperty& BindingProperty::operator=(BindingProperty&& other)
{
   this->~BindingProperty();
   new (this) BindingProperty(other);
   return *this;
}
BindingProperty& BindingProperty::operator[](const int& index)
{
   (void)( (!!(index >= 0 && "Negative index is invalid")) || (_wassert(L"index >= 0 && \"Negative index is invalid\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(179)), 0) );
   return this->operator[](size_t(index));
}
BindingProperty& BindingProperty::operator[](const size_t& index)
{
   (void)( (!!((IsArray() || IsNull()) && "index operator only valid on null or arrays")) || (_wassert(L"(IsArray() || IsNull()) && \"index operator only valid on null or arrays\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(185)), 0) );
   if (IsNull()) { SetArray(); }
   if (index >= data.arrayVal.size())
   {
      data.arrayVal.resize(index + 1);
   }
   return data.arrayVal[index];
}
BindingProperty& BindingProperty::operator[](const std::string& key)
{
   (void)( (!!((IsObject() || IsNull()) && "key operator only valid on null or objects")) || (_wassert(L"(IsObject() || IsNull()) && \"key operator only valid on null or objects\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(196)), 0) );
   if (IsNull()) { SetObject(); }
   ObjectIterator it = Find(key);
   if (it == AsObject().end())
   {
      data.objectVal.push_back(KeyVal{key, BindingProperty{}});
   }
   return it->value;
}
BindingProperty& BindingProperty::operator[](const char* key)
{
   return this->operator[](std::string{key});
}
const BindingProperty& BindingProperty::operator[](const int& index) const
{
   (void)( (!!(index >= 0 && "Negative index is invalid")) || (_wassert(L"index >= 0 && \"Negative index is invalid\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(213)), 0) );
   return this->operator[](size_t(index));
}
const BindingProperty& BindingProperty::operator[](const size_t& index) const
{
   (void)( (!!((IsArray() || IsNull()) && "index operator only valid on null or arrays")) || (_wassert(L"(IsArray() || IsNull()) && \"index operator only valid on null or arrays\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(219)), 0) );
   if (index < data.arrayVal.size())
   {
      return data.arrayVal[index];
   }
   return Null;
}
const BindingProperty& BindingProperty::operator[](const std::string& key) const
{
   (void)( (!!((IsObject() || IsNull()) && "key operator only valid on null or objects")) || (_wassert(L"(IsObject() || IsNull()) && \"key operator only valid on null or objects\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(229)), 0) );
   ConstObjectIterator it = Find(key);
   if (it != AsObject().end())
   {
      return it->value;
   }
   return Null;
}
const BindingProperty& BindingProperty::operator[](const char* key) const
{
   return this->operator[](std::string{key});
}
bool BindingProperty::operator==(const BindingProperty& other) const
{
   if (flags != other.flags)
   {
      return false;
   }
   if (IsNumber()) { return data.numVal.u64 == other.data.numVal.u64; }
   else if (IsString()) { return data.stringVal == other.data.stringVal; }
   else if (IsObject()) { return data.objectVal == other.data.objectVal; }
   else if (IsArray()) { return data.arrayVal == other.data.arrayVal; }
   return true;
}
bool BindingProperty::IsVec3() const
{
   return IsArray()
      && data.arrayVal.size() == 3
      && data.arrayVal[0].IsNumber()
      && data.arrayVal[1].IsNumber()
      && data.arrayVal[2].IsNumber();
}
bool BindingProperty::IsVec4() const
{
   return IsArray()
      && data.arrayVal.size() == 4
      && data.arrayVal[0].IsNumber()
      && data.arrayVal[1].IsNumber()
      && data.arrayVal[2].IsNumber()
      && data.arrayVal[3].IsNumber();
}
const bool BindingProperty::GetBooleanValue(const bool& defaultValue) const
{
   return (flags & kBoolFlag) != 0 ? flags == uint16_t(kTrueFlag) : defaultValue;
}
const int32_t BindingProperty::GetIntValue(const int32_t& defaultValue) const
{
   return (flags & kIntFlag) != 0 ? data.numVal.i.i : defaultValue;
}
const uint32_t BindingProperty::GetUintValue(const uint32_t& defaultValue) const
{
   return (flags & kUintFlag) != 0 ? data.numVal.u.u : defaultValue;
}
const int64_t BindingProperty::GetInt64Value(const int64_t& defaultValue) const
{
   return (flags & kInt64Flag) != 0 ? data.numVal.i64 : defaultValue;
}
const uint64_t BindingProperty::GetUint64Value(const uint64_t& defaultValue) const
{
   return (flags & kUint64Flag) != 0 ? data.numVal.u64 : defaultValue;
}
const double BindingProperty::GetDoubleValue(const double& defaultValue) const
{
   if ((flags & kNumberFlag) == 0) return defaultValue;
   if ((flags & kDoubleFlag) != 0) return data.numVal.d;
   if ((flags & kIntFlag) != 0)    return data.numVal.i.i;
   if ((flags & kUintFlag) != 0)   return data.numVal.u.u;
   if ((flags & kInt64Flag) != 0)  return static_cast<double>(data.numVal.i64);
   if ((flags & kUint64Flag) != 0) return static_cast<double>(data.numVal.u64);
   return defaultValue;
}
const float BindingProperty::GetFloatValue(const float& defaultValue) const
{
   if ((flags & kNumberFlag) == 0) return defaultValue;
   if ((flags & kDoubleFlag) != 0) return static_cast<float>(data.numVal.d);
   if ((flags & kIntFlag) != 0)    return static_cast<float>(data.numVal.i.i);
   if ((flags & kUintFlag) != 0)   return static_cast<float>(data.numVal.u.u);
   if ((flags & kInt64Flag) != 0)  return static_cast<float>(data.numVal.i64);
   if ((flags & kUint64Flag) != 0) return static_cast<float>(data.numVal.u64);
   return defaultValue;
}
const std::string BindingProperty::GetStringValue(const std::string& defaultValue) const
{
   return flags == uint16_t(kStringFlag) ? data.stringVal : defaultValue;
}
glm::vec3 BindingProperty::GetVec3(const glm::vec3& defaultValue) const
{
   return IsVec3() ? glm::vec3{
      data.arrayVal[0].GetDoubleValue(),
      data.arrayVal[1].GetDoubleValue(),
      data.arrayVal[2].GetDoubleValue()
   } : defaultValue;
}
glm::vec4 BindingProperty::GetVec4(const glm::vec4& defaultValue) const
{
   return IsVec4() ? glm::vec4{
      data.arrayVal[0].GetDoubleValue(),
      data.arrayVal[1].GetDoubleValue(),
      data.arrayVal[2].GetDoubleValue(),
      data.arrayVal[3].GetDoubleValue()
   } : defaultValue;
}
BindingProperty::Object BindingProperty::AsObject()
{
   (void)( (!!(IsObject() && "GetObject only works on an object")) || (_wassert(L"IsObject() && \"GetObject only works on an object\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(355)), 0) );
   return Object(this);
}
BindingProperty::ConstObject BindingProperty::AsObject() const
{
   (void)( (!!(IsObject() && "GetObject only works on an object")) || (_wassert(L"IsObject() && \"GetObject only works on an object\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(361)), 0) );
   return ConstObject(this);
}
BindingProperty::Array BindingProperty::AsArray()
{
   (void)( (!!(IsArray() && "GetArray only works on an array")) || (_wassert(L"IsArray() && \"GetArray only works on an array\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(367)), 0) );
   return Array(this);
}
BindingProperty::ConstArray BindingProperty::AsArray() const
{
   (void)( (!!(IsArray() && "GetArray only works on an array")) || (_wassert(L"IsArray() && \"GetArray only works on an array\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(373)), 0) );
   return ConstArray(this);
}
BindingProperty& BindingProperty::PushBack(BindingProperty val)
{
   if (IsNull())
   {
      SetArray();
   }
   (void)( (!!(IsArray() && "PushBack is only valid on an array")) || (_wassert(L"IsArray() && \"PushBack is only valid on an array\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(386)), 0) );
   data.arrayVal.push_back(val);
   return data.arrayVal[data.arrayVal.size() - 1];
}
void BindingProperty::PopBack()
{
   (void)( (!!(IsArray() && "PopBack is only valid on an array")) || (_wassert(L"IsArray() && \"PopBack is only valid on an array\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(393)), 0) );
   data.arrayVal.pop_back();
}
bool BindingProperty::Has(const std::string& key)
{
   (void)( (!!(IsObject() && "Has is only valid on an object")) || (_wassert(L"IsObject() && \"Has is only valid on an object\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(402)), 0) );
   Object me = AsObject();
   ObjectIterator it = me.begin();
   ObjectIterator end = me.end();
   for (; it != end; ++it)
   {
      if (it->key == key)
      {
         return true;
      }
   }
   return false;
}
BindingProperty::ObjectIterator BindingProperty::Find(const std::string& key)
{
   (void)( (!!(IsObject() && "Find is only valid on an object")) || (_wassert(L"IsObject() && \"Find is only valid on an object\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(418)), 0) );
   Object me = AsObject();
   ObjectIterator it = me.begin();
   ObjectIterator end = me.end();
   for (; it != end; ++it)
   {
      if (it->key == key)
      {
         break;
      }
   }
   return it;
}
BindingProperty::ConstObjectIterator BindingProperty::Find(const std::string& key) const
{
   (void)( (!!(IsObject() && "Find is only valid on an object")) || (_wassert(L"IsObject() && \"Find is only valid on an object\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(434)), 0) );
   ConstObject me = AsObject();
   ConstObjectIterator it = me.begin();
   ConstObjectIterator end = me.end();
   for (; it != end; ++it)
   {
      if (it->key == key)
      {
         break;
      }
   }
   return it;
}
BindingProperty& BindingProperty::Set(const std::string& key, const BindingProperty& value)
{
   return Set(key, BindingProperty(value));
}
BindingProperty& BindingProperty::Set(const std::string& key, BindingProperty&& value)
{
   (void)( (!!(IsObject() && "Set is only valid on an object")) || (_wassert(L"IsObject() && \"Set is only valid on an object\"", L"C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingProperty.cpp", (unsigned)(455)), 0) );
   ObjectIterator it = Find(key);
   if (it == AsObject().end())
   {
      data.objectVal.push_back(KeyVal{key, std::move(value)});
   }
   return it->value;
}
BindingProperty::Iterator BindingProperty::begin()
{
   return Iterator(this, 0);
}
BindingProperty::Iterator BindingProperty::end()
{
   switch (flags)
   {
   case kArrayFlag:
      return Iterator(this, data.arrayVal.size());
   case kObjectFlag:
      return Iterator(this, data.objectVal.size());
   default:
      return Iterator(this, 0);
   }
}
BindingProperty::ConstIterator BindingProperty::begin() const
{
   return ConstIterator(this, 0);
}
BindingProperty::ConstIterator BindingProperty::end() const
{
   switch (flags)
   {
   case kArrayFlag:
      return ConstIterator(this, data.arrayVal.size());
   case kObjectFlag:
      return ConstIterator(this, data.objectVal.size());
   default:
      return ConstIterator(this, 0);
   }
}
BindingProperty::PairIterator BindingProperty::begin_pairs()
{
   return PairIterator(this, 0);
}
BindingProperty::PairIterator BindingProperty::end_pairs()
{
   switch (flags)
   {
   case kArrayFlag:
      return PairIterator(this, data.arrayVal.size());
   case kObjectFlag:
      return PairIterator(this, data.objectVal.size());
   default:
      return PairIterator(this, 0);
   }
}
BindingProperty::ConstPairIterator BindingProperty::begin_pairs() const
{
   return ConstPairIterator(this, 0);
}
BindingProperty::ConstPairIterator BindingProperty::end_pairs() const
{
   switch (flags)
   {
   case kArrayFlag:
      return ConstPairIterator(this, data.arrayVal.size());
   case kObjectFlag:
      return ConstPairIterator(this, data.objectVal.size());
   default:
      return ConstPairIterator(this, 0);
   }
}
}; 
#line 8 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\tmp\\x64-Debug\\RGBBinding\\Unity1.cpp"
#pragma message( "C:/Users/Thomas/Code/CubeWorldC++/source/Library/RGBBinding/BindingPropertyReader.cpp" )
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingPropertyReader.cpp"
#line 1 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingPropertyReader.h"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stack"
#pragma once
#line 1 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
#pragma once
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Mydeque>
class _Deque_unchecked_const_iterator { 
private:
    using _Size_type = typename _Mydeque::size_type;
public:
    using iterator_category = random_access_iterator_tag;
    using value_type      = typename _Mydeque::value_type;
    using difference_type = typename _Mydeque::difference_type;
    using pointer         = typename _Mydeque::const_pointer;
    using reference       = const value_type&;
    _Deque_unchecked_const_iterator() : _Mycont(), _Myoff(0) { 
    }
    _Deque_unchecked_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque)
        : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) { 
    }
    [[nodiscard]] reference operator*() const { 
        _Size_type _Block = _Mycont->_Getblock(_Myoff);
        _Size_type _Off   = _Myoff % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1);
        return _Mycont->_Map[_Block][_Off];
    }
    [[nodiscard]] pointer operator->() const { 
        return pointer_traits<pointer>::pointer_to(**this);
    }
    _Deque_unchecked_const_iterator& operator++() { 
        ++_Myoff;
        return *this;
    }
    _Deque_unchecked_const_iterator operator++(int) { 
        _Deque_unchecked_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _Deque_unchecked_const_iterator& operator--() { 
        --_Myoff;
        return *this;
    }
    _Deque_unchecked_const_iterator operator--(int) { 
        _Deque_unchecked_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    _Deque_unchecked_const_iterator& operator+=(const difference_type _Off) { 
        _Myoff += _Off;
        return *this;
    }
    [[nodiscard]] _Deque_unchecked_const_iterator operator+(const difference_type _Off) const { 
        _Deque_unchecked_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _Deque_unchecked_const_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _Deque_unchecked_const_iterator operator-(const difference_type _Off) const { 
        _Deque_unchecked_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(
        const _Deque_unchecked_const_iterator& _Right) const { 
        return static_cast<difference_type>(_Myoff - _Right._Myoff);
    }
    [[nodiscard]] reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    [[nodiscard]] bool operator==(const _Deque_unchecked_const_iterator& _Right) const { 
        return _Myoff == _Right._Myoff;
    }
    [[nodiscard]] bool operator!=(const _Deque_unchecked_const_iterator& _Right) const { 
        return !(*this == _Right);
    }
    [[nodiscard]] bool operator<(const _Deque_unchecked_const_iterator& _Right) const { 
        return _Myoff < _Right._Myoff;
    }
    [[nodiscard]] bool operator>(const _Deque_unchecked_const_iterator& _Right) const { 
        return _Right < *this;
    }
    [[nodiscard]] bool operator<=(const _Deque_unchecked_const_iterator& _Right) const { 
        return !(_Right < *this);
    }
    [[nodiscard]] bool operator>=(const _Deque_unchecked_const_iterator& _Right) const { 
        return !(*this < _Right);
    }
    const _Container_base12* _Getcont() const { 
        return _Mycont;
    }
    const _Mydeque* _Mycont; 
    _Size_type _Myoff; 
};
template <class _Mydeque>
[[nodiscard]] inline _Deque_unchecked_const_iterator<_Mydeque> operator+(
    typename _Deque_unchecked_const_iterator<_Mydeque>::difference_type _Off,
    _Deque_unchecked_const_iterator<_Mydeque> _Next) { 
    return _Next += _Off;
}
template <class _Mydeque>
class _Deque_unchecked_iterator : public _Deque_unchecked_const_iterator<_Mydeque> { 
private:
    using _Size_type = typename _Mydeque::size_type;
    using _Mybase    = _Deque_unchecked_const_iterator<_Mydeque>;
public:
    using iterator_category = random_access_iterator_tag;
    using value_type      = typename _Mydeque::value_type;
    using difference_type = typename _Mydeque::difference_type;
    using pointer         = typename _Mydeque::pointer;
    using reference       = value_type&;
    _Deque_unchecked_iterator() { 
    }
    _Deque_unchecked_iterator(_Size_type _Off, const _Container_base12* _Pdeque)
        : _Mybase(_Off, _Pdeque) { 
    }
    [[nodiscard]] reference operator*() const { 
        return (reference) * *(_Mybase*) this;
    }
    [[nodiscard]] pointer operator->() const { 
        return pointer_traits<pointer>::pointer_to(**this);
    }
    _Deque_unchecked_iterator& operator++() { 
        ++*(_Mybase*) this;
        return *this;
    }
    _Deque_unchecked_iterator operator++(int) { 
        _Deque_unchecked_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _Deque_unchecked_iterator& operator--() { 
        --*(_Mybase*) this;
        return *this;
    }
    _Deque_unchecked_iterator operator--(int) { 
        _Deque_unchecked_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    _Deque_unchecked_iterator& operator+=(const difference_type _Off) { 
        *(_Mybase*) this += _Off;
        return *this;
    }
    [[nodiscard]] _Deque_unchecked_iterator operator+(const difference_type _Off) const { 
        _Deque_unchecked_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _Deque_unchecked_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _Deque_unchecked_iterator operator-(const difference_type _Off) const { 
        _Deque_unchecked_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(const _Mybase& _Right) const { 
        return *(_Mybase*) this - _Right;
    }
    [[nodiscard]] reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
};
template <class _Mydeque>
[[nodiscard]] inline _Deque_unchecked_iterator<_Mydeque> operator+(
    typename _Deque_unchecked_iterator<_Mydeque>::difference_type _Off,
    _Deque_unchecked_iterator<_Mydeque> _Next) { 
    return _Next += _Off;
}
template <class _Mydeque>
class _Deque_const_iterator : public _Iterator_base12 { 
private:
    using _Size_type = typename _Mydeque::size_type;
public:
    using iterator_category = random_access_iterator_tag;
    using value_type      = typename _Mydeque::value_type;
    using difference_type = typename _Mydeque::difference_type;
    using pointer         = typename _Mydeque::const_pointer;
    using reference       = const value_type&;
    using _Mydeque_t = _Mydeque; 
    enum { _EEN_DS = (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) }; 
    _Deque_const_iterator() : _Myoff(0) { 
        _Setcont(nullptr);
    }
    _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque)
        : _Myoff(_Off) { 
        _Setcont((_Mydeque*) _Pdeque);
    }
    [[nodiscard]] reference operator*() const { 
        const auto _Mycont = static_cast<const _Mydeque*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 265, 0, "%s", "cannot dereference value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 265, 0); } while (false); } ; } while (false);
        do { if (_Mycont->_Myoff <= this->_Myoff && this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 267, 0, "%s", "cannot deference out of range deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot deference out of range deque iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 267, 0); } while (false); } ; } while (false);
#line 268 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
#line 269 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        _Size_type _Block = _Mycont->_Getblock(_Myoff);
        _Size_type _Off   = _Myoff % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1);
        return _Mycont->_Map[_Block][_Off];
    }
    [[nodiscard]] pointer operator->() const { 
        return pointer_traits<pointer>::pointer_to(**this);
    }
    _Deque_const_iterator& operator++() { 
        const auto _Mycont = static_cast<const _Mydeque*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 282, 0, "%s", "cannot increment value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 282, 0); } while (false); } ; } while (false);
        do { if (this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 283, 0, "%s", "cannot increment deque iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment deque iterator past end\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 283, 0); } while (false); } ; } while (false);
#line 285 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        ++_Myoff;
        return *this;
    }
    _Deque_const_iterator operator++(int) { 
        _Deque_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _Deque_const_iterator& operator--() { 
        const auto _Mycont = static_cast<const _Mydeque*>(this->_Getcont());
        do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 299, 0, "%s", "cannot decrement value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 299, 0); } while (false); } ; } while (false);
        do { if (_Mycont->_Myoff < this->_Myoff) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 300, 0, "%s", "cannot decrement deque iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement deque iterator before begin\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 300, 0); } while (false); } ; } while (false);
#line 302 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        --_Myoff;
        return *this;
    }
    _Deque_const_iterator operator--(int) { 
        _Deque_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    _Deque_const_iterator& operator+=(const difference_type _Off) { 
        if (_Off != 0) {
            const auto _Mycont = static_cast<const _Mydeque*>(this->_Getcont());
            do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 317, 0, "%s", "cannot seek value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 317, 0); } while (false); } ; } while (false);
            do { if (_Mycont->_Myoff <= this->_Myoff + _Off && this->_Myoff + _Off <= _Mycont->_Myoff + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 320, 0, "%s", "cannot seek deque iterator out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek deque iterator out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 320, 0); } while (false); } ; } while (false);
#line 321 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        }
#line 323 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        _Myoff += _Off;
        return *this;
    }
    [[nodiscard]] _Deque_const_iterator operator+(const difference_type _Off) const { 
        _Deque_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _Deque_const_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _Deque_const_iterator operator-(const difference_type _Off) const { 
        _Deque_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(const _Deque_const_iterator& _Right) const { 
        _Compat(_Right);
        return static_cast<difference_type>(this->_Myoff - _Right._Myoff);
    }
    [[nodiscard]] reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    [[nodiscard]] bool operator==(const _Deque_const_iterator& _Right) const { 
        _Compat(_Right);
        return this->_Myoff == _Right._Myoff;
    }
    [[nodiscard]] bool operator!=(const _Deque_const_iterator& _Right) const { 
        return !(*this == _Right);
    }
    [[nodiscard]] bool operator<(const _Deque_const_iterator& _Right) const { 
        _Compat(_Right);
        return this->_Myoff < _Right._Myoff;
    }
    [[nodiscard]] bool operator>(const _Deque_const_iterator& _Right) const { 
        return _Right < *this;
    }
    [[nodiscard]] bool operator<=(const _Deque_const_iterator& _Right) const { 
        return !(_Right < *this);
    }
    [[nodiscard]] bool operator>=(const _Deque_const_iterator& _Right) const { 
        return !(*this < _Right);
    }
    void _Compat(const _Deque_const_iterator& _Right) const { 
#line 381 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 381, 0, "%s", "deque iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque iterators incompatible\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 381, 0); } while (false); } ; } while (false);
#line 383 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
    }
    void _Setcont(const _Mydeque* _Pdeque) { 
        this->_Adopt(_Pdeque);
    }
    using _Prevent_inheriting_unwrap = _Deque_const_iterator;
    [[nodiscard]] _Deque_unchecked_const_iterator<_Mydeque> _Unwrapped() const {
        return {this->_Myoff, this->_Getcont()};
    }
    void _Verify_offset(const difference_type _Off) const noexcept {
#line 399 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        if (_Off != 0) {
            const auto _Mycont = static_cast<const _Mydeque*>(this->_Getcont());
            do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 401, 0, "%s", "cannot use value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot use value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 401, 0); } while (false); } ; } while (false);
            do { if (_Mycont->_Myoff <= this->_Myoff + _Off && this->_Myoff + _Off <= _Mycont->_Myoff + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 404, 0, "%s", "cannot seek deque iterator out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek deque iterator out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 404, 0); } while (false); } ; } while (false);
#line 405 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        }
#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
    }
    friend void _Verify_range(const _Deque_const_iterator& _First, const _Deque_const_iterator& _Last) {
        do { if (_First <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 412, 0, "%s", "deque iterators transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque iterators transposed\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 412, 0); } while (false); } ; } while (false);
    }
#line 415 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
    void _Seek_to(const _Deque_unchecked_const_iterator<_Mydeque>& _UIt) {
        _Myoff = _UIt._Myoff;
    }
    _Size_type _Myoff; 
};
template <class _Mydeque>
[[nodiscard]] inline _Deque_const_iterator<_Mydeque> operator+(
    typename _Deque_const_iterator<_Mydeque>::difference_type _Off,
    _Deque_const_iterator<_Mydeque> _Next) { 
    return _Next += _Off;
}
template <class _Mydeque>
class _Deque_iterator : public _Deque_const_iterator<_Mydeque> { 
private:
    using _Size_type = typename _Mydeque::size_type;
    using _Mybase    = _Deque_const_iterator<_Mydeque>;
public:
    using _Deque_unchecked_type = _Deque_unchecked_iterator<_Mydeque>;
    using iterator_category     = random_access_iterator_tag;
    using value_type      = typename _Mydeque::value_type;
    using difference_type = typename _Mydeque::difference_type;
    using pointer         = typename _Mydeque::pointer;
    using reference       = value_type&;
    _Deque_iterator() { 
    }
    _Deque_iterator(_Size_type _Off, const _Container_base12* _Pdeque)
        : _Mybase(_Off, _Pdeque) { 
    }
    [[nodiscard]] reference operator*() const { 
        return (reference) * *(_Mybase*) this;
    }
    [[nodiscard]] pointer operator->() const { 
        return pointer_traits<pointer>::pointer_to(**this);
    }
    _Deque_iterator& operator++() { 
        ++*(_Mybase*) this;
        return *this;
    }
    _Deque_iterator operator++(int) { 
        _Deque_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }
    _Deque_iterator& operator--() { 
        --*(_Mybase*) this;
        return *this;
    }
    _Deque_iterator operator--(int) { 
        _Deque_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }
    _Deque_iterator& operator+=(const difference_type _Off) { 
        this->_Myoff += _Off;
        return *this;
    }
    [[nodiscard]] _Deque_iterator operator+(const difference_type _Off) const { 
        _Deque_iterator _Tmp = *this;
        return _Tmp += _Off;
    }
    _Deque_iterator& operator-=(const difference_type _Off) { 
        return *this += -_Off;
    }
    [[nodiscard]] _Deque_iterator operator-(const difference_type _Off) const { 
        _Deque_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }
    [[nodiscard]] difference_type operator-(const _Mybase& _Right) const { 
        return *(_Mybase*) this - _Right;
    }
    [[nodiscard]] reference operator[](const difference_type _Off) const { 
        return *(*this + _Off);
    }
    using _Prevent_inheriting_unwrap = _Deque_iterator;
    [[nodiscard]] _Deque_unchecked_iterator<_Mydeque> _Unwrapped() const {
        return {this->_Myoff, this->_Getcont()};
    }
};
template <class _Mydeque>
[[nodiscard]] inline _Deque_iterator<_Mydeque> operator+(typename _Deque_iterator<_Mydeque>::difference_type _Off,
    _Deque_iterator<_Mydeque> _Next) { 
    return _Next += _Off;
}
template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference,
    class _Mapptr_type>
struct _Deque_iter_types { 
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
    using _Mapptr         = _Mapptr_type;
};
template <class _Ty>
struct _Deque_simple_types : public _Simple_types<_Ty> { 
    using _Mapptr = _Ty**;
};
template <class _Val_types>
class _Deque_val : public _Container_base12 { 
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;
    using _Mapptr         = typename _Val_types::_Mapptr;
    _Deque_val() : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) { 
    }
    size_type _Getblock(size_type _Off) const { 
        return (_Off / (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) & (_Mapsize - 1);
    }
    _Mapptr _Map; 
    size_type _Mapsize; 
    size_type _Myoff; 
    size_type _Mysize; 
};
template <class _Ty,
    class _Alloc = allocator<_Ty>>
class deque { 
private:
    friend _Tidy_guard<deque>;
    static_assert(!1 || is_same_v<_Ty, typename _Alloc::value_type>,
        "deque<T, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");
    using _Alty           = _Rebind_alloc_t<_Alloc, _Ty>;
    using _Alty_traits    = allocator_traits<_Alty>;
    using _Alpty          = _Rebind_alloc_t<_Alloc, typename _Alty_traits::pointer>;
    using _Alpty_traits   = allocator_traits<_Alpty>;
    using _Mapptr         = typename _Alpty_traits::pointer;
    using _Alproxy_ty     = _Rebind_alloc_t<_Alty, _Container_proxy>;
    using _Alproxy_traits = allocator_traits<_Alproxy_ty>;
    using _Scary_val = _Deque_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Deque_simple_types<_Ty>,
        _Deque_iter_types<_Ty, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Ty&, const _Ty&, _Mapptr>>>;
public:
    using allocator_type  = _Alloc;
    using value_type      = _Ty;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = _Ty&;
    using const_reference = const _Ty&;
    using iterator                  = _Deque_iterator<_Scary_val>;
    using const_iterator            = _Deque_const_iterator<_Scary_val>;
    using _Unchecked_iterator       = _Deque_unchecked_iterator<_Scary_val>;
    using _Unchecked_const_iterator = _Deque_unchecked_const_iterator<_Scary_val>;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
    enum { _EEN_DS = (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) }; 
    deque() : _Mypair(_Zero_then_variadic_args_t()) { 
        _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));
    }
    explicit deque(const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));
    }
    explicit deque( size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        resize(_Count);
        _Proxy._Release();
    }
    deque( size_type _Count, const _Ty& _Val)
        : _Mypair(_Zero_then_variadic_args_t()) { 
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct_n(_Count, _Val);
        _Proxy._Release();
    }
    deque( size_type _Count, const _Ty& _Val, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct_n(_Count, _Val);
        _Proxy._Release();
    }
    deque(const deque& _Right)
        : _Mypair(_One_then_variadic_args_t(),
              _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { 
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_Right._Unchecked_begin(), _Right._Unchecked_end());
        _Proxy._Release();
    }
    deque(const deque& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_Right._Unchecked_begin(), _Right._Unchecked_end());
        _Proxy._Release();
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    deque(_Iter _First, _Iter _Last) : _Mypair(_Zero_then_variadic_args_t()) { 
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_First, _Last);
        _Proxy._Release();
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    deque(_Iter _First, _Iter _Last, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_First, _Last);
        _Proxy._Release();
    }
private:
    template <class _Iter>
    void _Construct(_Iter _First, _Iter _Last) { 
        _Tidy_guard<deque> _Guard{this};
        for (; _First != _Last; ++_First) {
            emplace_back(*_First);
        }
        _Guard._Target = nullptr;
    }
    void _Construct_n(size_type _Count, const _Ty& _Val) { 
        _Tidy_guard<deque> _Guard{this};
        for (; 0 < _Count; --_Count) {
            _Push_back_internal(_Val);
        }
        _Guard._Target = nullptr;
    }
public:
    deque(deque&& _Right)
        : _Mypair(_One_then_variadic_args_t(), ::std:: move(_Right._Getal())) { 
        _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));
        _Take_contents(_Right);
    }
    deque(deque&& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Alproxy_ty _Alproxy(_Getal());
        if
            constexpr(!_Alty_traits::is_always_equal::value) {
                if (_Getal() != _Right._Getal()) {
                    _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
                    _Construct(::std:: make_move_iterator(_Right._Unchecked_begin()),
                        ::std:: make_move_iterator(_Right._Unchecked_end()));
                    _Proxy._Release();
                    return;
                }
            }
        _Get_data()._Alloc_proxy(_Alproxy);
        _Take_contents(_Right);
    }
private:
    void _Move_assign(deque& _Right, _Equal_allocators) noexcept {
        _Tidy();
        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right);
    }
    void _Move_assign(deque& _Right, _Propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            _Alproxy_ty _Alproxy(_Getal());
            _Alproxy_ty _Alproxy_right(_Right._Getal());
            _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy_right, _Leave_proxy_unbound{});
            _Tidy();
            _Pocma(_Getal(), _Right._Getal());
            _Proxy._Bind(_Alproxy, ::std:: addressof(_Get_data()));
            _Take_contents(_Right);
        }
    }
    void _Move_assign(deque& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            assign(
                ::std:: make_move_iterator(_Right._Unchecked_begin()), ::std:: make_move_iterator(_Right._Unchecked_end()));
        }
    }
public:
    deque& operator=(deque&& _Right) noexcept(_Alty_traits::is_always_equal::value) {
        if (this != ::std:: addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma<_Alty>{});
        }
        return *this;
    }
private:
    void _Take_contents(deque& _Right) noexcept {
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        _My_data._Swap_proxy_and_iterators(_Right_data);
        _My_data._Map     = _Right_data._Map;
        _My_data._Mapsize = _Right_data._Mapsize;
        _My_data._Myoff   = _Right_data._Myoff;
        _My_data._Mysize  = _Right_data._Mysize;
        _Right_data._Map     = nullptr;
        _Right_data._Mapsize = 0;
        _Right_data._Myoff   = 0;
        _Right_data._Mysize  = 0;
    }
public:
    void push_front(_Ty&& _Val) { 
        _Orphan_all();
        if (_Myoff() % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) == 0 && _Mapsize() <= (_Mysize() + (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) / (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) { _Growmap(1); } _Myoff() &= _Mapsize() * (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = _Myoff() != 0 ? _Myoff() : _Mapsize() * (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1); size_type _Block = _Getblock(--_Newoff); if (_Map()[_Block] == pointer()) { _Map()[_Block] = _Getal().allocate((sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)); };
        _Alty_traits::construct(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)), ::std:: move(_Val));
        _Myoff() = _Newoff; ++_Mysize();
    }
private:
    void _Push_back_internal(_Ty&& _Val) { 
        if ((_Myoff() + _Mysize()) % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) == 0 && _Mapsize() <= (_Mysize() + (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) / (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) { _Growmap(1); } _Myoff() &= _Mapsize() * (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = _Myoff() + _Mysize(); size_type _Block = _Getblock(_Newoff); if (_Map()[_Block] == pointer()) { _Map()[_Block] = _Getal().allocate((sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)); };
        _Alty_traits::construct(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)), ::std:: move(_Val));
        ++_Mysize();
    }
public:
    void push_back(_Ty&& _Val) { 
        _Orphan_all();
        _Push_back_internal(::std:: move(_Val));
    }
    iterator insert(const_iterator _Where, _Ty&& _Val) { 
        return emplace(_Where, ::std:: move(_Val));
    }
    template <class... _Valty>
    decltype(auto) emplace_front(_Valty&&... _Val) { 
        _Orphan_all();
        if (_Myoff() % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) == 0 && _Mapsize() <= (_Mysize() + (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) / (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) { _Growmap(1); } _Myoff() &= _Mapsize() * (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = _Myoff() != 0 ? _Myoff() : _Mapsize() * (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1); size_type _Block = _Getblock(--_Newoff); if (_Map()[_Block] == pointer()) { _Map()[_Block] = _Getal().allocate((sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)); };
        _Alty_traits::construct(
            _Getal(), _Unfancy(_Map()[_Block] + _Newoff % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)), ::std:: forward<_Valty>(_Val)...);
        _Myoff() = _Newoff; ++_Mysize();
        return front();
#line 840 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
    }
    template <class... _Valty>
    decltype(auto) emplace_back(_Valty&&... _Val) { 
        _Orphan_all();
        if ((_Myoff() + _Mysize()) % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) == 0 && _Mapsize() <= (_Mysize() + (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) / (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) { _Growmap(1); } _Myoff() &= _Mapsize() * (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = _Myoff() + _Mysize(); size_type _Block = _Getblock(_Newoff); if (_Map()[_Block] == pointer()) { _Map()[_Block] = _Getal().allocate((sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)); };
        _Alty_traits::construct(
            _Getal(), _Unfancy(_Map()[_Block] + _Newoff % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)), ::std:: forward<_Valty>(_Val)...);
        ++_Mysize();
        return back();
#line 853 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
    }
    template <class... _Valty>
    iterator emplace(const_iterator _Where, _Valty&&... _Val) { 
        const auto _Off = static_cast<size_type>(_Where - begin());
        do { if (_Off <= _Mysize()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 860, 0, "%s", "deque emplace iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque emplace iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 860, 0); } while (false); } ; } while (false);
#line 862 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        if (_Off <= _Mysize() / 2) { 
            emplace_front(::std:: forward<_Valty>(_Val)...);
            ::std:: rotate(begin(), begin() + 1, begin() + static_cast<difference_type>(1 + _Off));
        } else { 
            emplace_back(::std:: forward<_Valty>(_Val)...);
            ::std:: rotate(begin() + static_cast<difference_type>(_Off), end() - 1, end());
        }
        return begin() + static_cast<difference_type>(_Off);
    }
    deque(initializer_list<_Ty> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t(), _Al) { 
        _Alproxy_ty _Alproxy(_Getal());
        _Container_proxy_ptr12<_Alproxy_ty> _Proxy(_Alproxy, _Get_data());
        _Construct(_Ilist.begin(), _Ilist.end());
        _Proxy._Release();
    }
    deque& operator=(initializer_list<_Ty> _Ilist) { 
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }
    void assign(initializer_list<_Ty> _Ilist) { 
        assign(_Ilist.begin(), _Ilist.end());
    }
    iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) { 
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }
    ~deque() noexcept { 
        _Tidy();
        _Alproxy_ty _Proxy_allocator(_Getal());
        _Delete_plain(_Proxy_allocator, ::std:: exchange(_Get_data()._Myproxy, nullptr));
    }
    void _Copy_assign(const deque& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        assign(_Right._Unchecked_begin(), _Right._Unchecked_end());
    }
    void _Copy_assign(const deque& _Right, true_type) {
        if (_Getal() != _Right._Getal()) {
            _Tidy();
            _Get_data()._Reload_proxy(static_cast<_Alproxy_ty>(_Getal()), static_cast<_Alproxy_ty>(_Right._Getal()));
        }
        _Copy_assign(_Right, false_type{});
    }
    deque& operator=(const deque& _Right) { 
        if (this != ::std:: addressof(_Right)) { 
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }
        return *this;
    }
    [[nodiscard]] iterator begin() noexcept { 
        return iterator(_Myoff(), ::std:: addressof(_Get_data()));
    }
    [[nodiscard]] const_iterator begin() const noexcept { 
        return const_iterator(_Myoff(), ::std:: addressof(_Get_data()));
    }
    [[nodiscard]] iterator end() noexcept { 
        return iterator(_Myoff() + _Mysize(), ::std:: addressof(_Get_data()));
    }
    [[nodiscard]] const_iterator end() const noexcept { 
        return const_iterator(_Myoff() + _Mysize(), ::std:: addressof(_Get_data()));
    }
    _Unchecked_iterator _Unchecked_begin() noexcept { 
        return _Unchecked_iterator(_Myoff(), ::std:: addressof(_Get_data()));
    }
    _Unchecked_const_iterator _Unchecked_begin() const
        noexcept { 
        return _Unchecked_const_iterator(_Myoff(), ::std:: addressof(_Get_data()));
    }
    _Unchecked_iterator _Unchecked_end() noexcept { 
        return _Unchecked_iterator(_Myoff() + _Mysize(), ::std:: addressof(_Get_data()));
    }
    _Unchecked_const_iterator _Unchecked_end() const
        noexcept { 
        return _Unchecked_const_iterator(_Myoff() + _Mysize(), ::std:: addressof(_Get_data()));
    }
    iterator _Make_iter(const_iterator _Where) const { 
        return iterator(_Where._Myoff, ::std:: addressof(_Get_data()));
    }
    [[nodiscard]] reverse_iterator rbegin() noexcept { 
        return reverse_iterator(end());
    }
    [[nodiscard]] const_reverse_iterator rbegin() const
        noexcept { 
        return const_reverse_iterator(end());
    }
    [[nodiscard]] reverse_iterator rend() noexcept { 
        return reverse_iterator(begin());
    }
    [[nodiscard]] const_reverse_iterator rend() const noexcept { 
        return const_reverse_iterator(begin());
    }
    [[nodiscard]] const_iterator cbegin() const noexcept { 
        return begin();
    }
    [[nodiscard]] const_iterator cend() const noexcept { 
        return end();
    }
    [[nodiscard]] const_reverse_iterator crbegin() const
        noexcept { 
        return rbegin();
    }
    [[nodiscard]] const_reverse_iterator crend() const
        noexcept { 
        return rend();
    }
    void shrink_to_fit() { 
        size_type _Oldcapacity = (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) * _Mapsize();
        size_type _Newcapacity = _Oldcapacity / 2;
        if (_Newcapacity < (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) * 8)
            _Newcapacity = (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) * 8;
        if ((empty() && 0 < _Mapsize())
            || (!empty() && size() <= _Newcapacity && _Newcapacity < _Oldcapacity)) { 
            deque _Tmp(::std:: make_move_iterator(begin()), ::std:: make_move_iterator(end()));
            swap(_Tmp);
        }
    }
    void resize( size_type _Newsize) { 
        while (_Mysize() < _Newsize) {
            emplace_back();
        }
        while (_Newsize < _Mysize()) {
            pop_back();
        }
    }
    void resize( size_type _Newsize,
        const _Ty& _Val) { 
        _Orphan_all();
        while (_Mysize() < _Newsize) {
            _Push_back_internal(_Val);
        }
        while (_Newsize < _Mysize()) {
            pop_back();
        }
    }
    [[nodiscard]] size_type size() const noexcept { 
        return _Mysize();
    }
    [[nodiscard]] size_type max_size() const noexcept { 
        return _Alty_traits::max_size(_Getal());
    }
    [[nodiscard]] bool empty() const noexcept { 
        return _Mysize() == 0;
    }
    [[nodiscard]] allocator_type get_allocator() const noexcept { 
        return static_cast<allocator_type>(_Getal());
    }
    [[nodiscard]] const_reference at(size_type _Pos) const { 
        if (_Mysize() <= _Pos)
            _Xran();
        return *(begin() + static_cast<difference_type>(_Pos));
    }
    [[nodiscard]] reference at(size_type _Pos) { 
        if (_Mysize() <= _Pos) {
            _Xran();
        }
        return *(begin() + static_cast<difference_type>(_Pos));
    }
    [[nodiscard]] const_reference operator[](size_type _Pos) const { 
        do { if (_Pos < _Mysize()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1063, 0, "%s", "deque subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque subscript out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1063, 0); } while (false); } ; } while (false);
#line 1065 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        return *(begin() + static_cast<difference_type>(_Pos));
    }
    [[nodiscard]] reference operator[](size_type _Pos) { 
        do { if (_Pos < _Mysize()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1071, 0, "%s", "deque subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque subscript out of range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1071, 0); } while (false); } ; } while (false);
#line 1073 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        return *(begin() + static_cast<difference_type>(_Pos));
    }
    [[nodiscard]] reference front() { 
        return *begin();
    }
    [[nodiscard]] const_reference front() const { 
        return *begin();
    }
    [[nodiscard]] reference back() { 
        return *(end() - 1);
    }
    [[nodiscard]] const_reference back() const { 
        return *(end() - 1);
    }
    void push_front(const _Ty& _Val) { 
        _Orphan_all();
        if (_Myoff() % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) == 0 && _Mapsize() <= (_Mysize() + (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) / (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) { _Growmap(1); } _Myoff() &= _Mapsize() * (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = _Myoff() != 0 ? _Myoff() : _Mapsize() * (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1); size_type _Block = _Getblock(--_Newoff); if (_Map()[_Block] == pointer()) { _Map()[_Block] = _Getal().allocate((sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)); };
        _Alty_traits::construct(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)), _Val);
        _Myoff() = _Newoff; ++_Mysize();
    }
    void pop_front() { 
        if (empty()) {
            do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1103, 0, "%s", "deque empty before pop")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque empty before pop\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1103, 0); } while (false);
        } else { 
            _Orphan_off(_Myoff());
            size_type _Block = _Getblock(_Myoff());
            _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Myoff() % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)));
            if (--_Mysize() == 0) {
                _Myoff() = 0;
            } else {
                ++_Myoff();
            }
        }
#line 1124 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
    }
private:
    void _Push_back_internal(const _Ty& _Val) {
        if ((_Myoff() + _Mysize()) % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) == 0 && _Mapsize() <= (_Mysize() + (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) / (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)) { _Growmap(1); } _Myoff() &= _Mapsize() * (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = _Myoff() + _Mysize(); size_type _Block = _Getblock(_Newoff); if (_Map()[_Block] == pointer()) { _Map()[_Block] = _Getal().allocate((sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)); };
        _Alty_traits::construct(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)), _Val);
        ++_Mysize();
    }
public:
    void push_back(const _Ty& _Val) { 
        _Orphan_all();
        _Push_back_internal(_Val);
    }
    void pop_back() { 
        if (empty()) {
            do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1142, 0, "%s", "deque empty before pop")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque empty before pop\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1142, 0); } while (false);
        } else { 
            size_type _Newoff = _Myoff() + _Mysize() - 1;
            _Orphan_off(_Newoff);
            size_type _Block = _Getblock(_Newoff);
            _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1)));
            if (--_Mysize() == 0) {
                _Myoff() = 0;
            }
        }
#line 1161 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    void assign(_Iter _First, _Iter _Last) { 
        _Orphan_all();
        _Adl_verify_range(_First, _Last);
        auto _UFirst       = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        auto _Myfirst      = _Unchecked_begin();
        const auto _Mylast = _Unchecked_end();
        for (; _UFirst != _ULast; ++_UFirst) { 
            if (_Myfirst == _Mylast) { 
                do {
                    emplace_back(*_UFirst);
                    ++_UFirst;
                } while (_UFirst != _ULast);
                return;
            }
            *_Myfirst = *_UFirst;
            ++_Myfirst;
        }
        _Erase_last_n(static_cast<size_type>(_Mylast - _Myfirst));
    }
    void assign( size_type _Count, const _Ty& _Val) { 
        _Orphan_all();
        auto _Myfirst       = _Unchecked_begin();
        const auto _Oldsize = _Mysize();
        auto _Assign_count  = _Min_value(_Count, _Oldsize);
        for (; 0 < _Assign_count; --_Assign_count) {
            *_Myfirst = _Val;
            ++_Myfirst;
        }
        const auto _Shrink_by = _Oldsize - _Assign_count;
        auto _Extend_by       = _Count - _Assign_count;
        _Erase_last_n(_Shrink_by);
        for (; 0 < _Extend_by; --_Extend_by) {
            _Push_back_internal(_Val);
        }
    }
    iterator insert(const_iterator _Where,
        const _Ty& _Val) { 
        size_type _Off = static_cast<size_type>(_Where - begin());
        do { if (_Off <= _Mysize()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1210, 0, "%s", "deque insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1210, 0); } while (false); } ; } while (false);
#line 1212 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        if (_Off <= _Mysize() / 2) { 
            push_front(_Val);
            ::std:: rotate(begin(), begin() + 1, begin() + static_cast<difference_type>(1 + _Off));
        } else { 
            push_back(_Val);
            ::std:: rotate(begin() + static_cast<difference_type>(_Off), end() - 1, end());
        }
        return begin() + static_cast<difference_type>(_Off);
    }
    iterator insert(const_iterator _Where,  size_type _Count,
        const _Ty& _Val) { 
        size_type _Off = static_cast<size_type>(_Where - begin());
        _Insert_n(_Where, _Count, _Val);
        return begin() + static_cast<difference_type>(_Off);
    }
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    iterator insert(
        const_iterator _Where, _Iter _First, _Iter _Last) { 
        size_type _Off = static_cast<size_type>(_Where - begin());
        do { if (_Mysize() >= _Off) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1237, 0, "%s", "deque insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1237, 0); } while (false); } ; } while (false);
#line 1239 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        _Adl_verify_range(_First, _Last);
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        size_type _Oldsize = _Mysize();
        if (_UFirst != _ULast) {
            if (_Off <= _Mysize() / 2) { 
                try {
                for (; _UFirst != _ULast; ++_UFirst) {
                    push_front(*_UFirst); 
                }
                } catch (...) {
                while (_Oldsize < _Mysize()) {
                    pop_front(); 
                }
                throw;
                }
                size_type _Num = _Mysize() - _Oldsize;
                ::std:: reverse(begin(), begin() + static_cast<difference_type>(_Num)); 
                ::std:: rotate(begin(), begin() + static_cast<difference_type>(_Num),
                    begin() + static_cast<difference_type>(_Num + _Off));
            } else { 
                try {
                _Orphan_all();
                for (; _UFirst != _ULast; ++_UFirst) {
                    _Push_back_internal(*_UFirst);
                }
                } catch (...) {
                while (_Oldsize < _Mysize()) {
                    pop_back(); 
                }
                throw;
                }
                ::std:: rotate(begin() + static_cast<difference_type>(_Off),
                    begin() + static_cast<difference_type>(_Oldsize), end());
            }
        }
        return begin() + static_cast<difference_type>(_Off);
    }
    iterator erase(const_iterator _Where) { 
        return erase(_Where, _Where + 1);
    }
    iterator erase(const_iterator _First_arg, const_iterator _Last_arg) { 
        iterator _First = _Make_iter(_First_arg);
        iterator _Last  = _Make_iter(_Last_arg);
        do { if (_First <= _Last && begin() <= _First && _Last <= end()) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1297, 0, "%s", "deque erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1297, 0); } while (false); } ; } while (false);
        _Adl_verify_range(_First, _Last);
        auto _Off   = static_cast<size_type>(_First - begin());
        auto _Count = static_cast<size_type>(_Last - _First);
        bool _Moved = 0 < _Off && _Off + _Count < _Mysize();
#line 1308 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        if (_Off < static_cast<size_type>(end() - _Last)) { 
            ::std:: move_backward(begin(), _First, _Last); 
            for (; 0 < _Count; --_Count) {
                pop_front(); 
            }
        } else { 
            ::std:: move(_Last, end(), _First); 
            for (; 0 < _Count; --_Count) {
                pop_back(); 
            }
        }
        if (_Moved) {
            _Orphan_all();
        }
#line 1326 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        return begin() + static_cast<difference_type>(_Off);
    }
private:
    void _Erase_last_n(size_type _Count) noexcept {
        for (; 0 < _Count; --_Count) {
            pop_back();
        }
    }
public:
    void clear() noexcept { 
        _Tidy();
    }
    void swap(deque& _Right) noexcept { 
        if (this != ::std:: addressof(_Right)) { 
            _Pocs(_Getal(), _Right._Getal());
            auto& _My_data    = _Get_data();
            auto& _Right_data = _Right._Get_data();
            _My_data._Swap_proxy_and_iterators(_Right_data);
            _Swap_adl(_My_data._Map, _Right_data._Map);
            ::std:: swap(_My_data._Mapsize, _Right_data._Mapsize);
            ::std:: swap(_My_data._Myoff, _Right_data._Myoff);
            ::std:: swap(_My_data._Mysize, _Right_data._Mysize);
        }
    }
private:
    void _Insert_n(const_iterator _Where, size_type _Count, const _Ty& _Val) { 
        iterator _Mid;
        size_type _Num;
        size_type _Off     = static_cast<size_type>(_Where - begin());
        size_type _Oldsize = _Mysize();
        size_type _Rem     = _Oldsize - _Off;
        do { if (_Off <= _Oldsize) { } else { do { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1365, 0, "%s", "deque insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque", 1365, 0); } while (false); } ; } while (false);
#line 1367 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
        if (_Off < _Rem) { 
            try {
            if (_Off < _Count) { 
                for (_Num = _Count - _Off; 0 < _Num; --_Num) {
                    push_front(_Val); 
                }
                for (_Num = _Off; 0 < _Num; --_Num) {
                    push_front(begin()[static_cast<difference_type>(_Count - 1)]); 
                }
                _Mid = begin() + static_cast<difference_type>(_Count);
                ::std:: fill(_Mid, _Mid + static_cast<difference_type>(_Off), _Val); 
            } else { 
                for (_Num = _Count; 0 < _Num; --_Num) {
                    push_front(begin()[static_cast<difference_type>(_Count - 1)]); 
                }
                _Mid     = begin() + static_cast<difference_type>(_Count);
                _Ty _Tmp = _Val; 
                ::std:: move(_Mid + static_cast<difference_type>(_Count), _Mid + static_cast<difference_type>(_Off),
                    _Mid); 
                ::std:: fill(begin() + static_cast<difference_type>(_Off), _Mid + static_cast<difference_type>(_Off),
                    _Tmp); 
            }
            } catch (...) {
            while (_Oldsize < _Mysize()) {
                pop_front(); 
            }
            throw;
            }
        } else { 
            try {
            if (_Rem < _Count) { 
                _Orphan_all();
                for (_Num = _Count - _Rem; 0 < _Num; --_Num) {
                    _Push_back_internal(_Val); 
                }
                for (_Num = 0; _Num < _Rem; ++_Num) {
                    _Push_back_internal(begin()[static_cast<difference_type>(_Off + _Num)]); 
                }
                _Mid = begin() + static_cast<difference_type>(_Off);
                ::std:: fill(_Mid, _Mid + static_cast<difference_type>(_Rem), _Val); 
            } else { 
                for (_Num = 0; _Num < _Count; ++_Num) {
                    _Push_back_internal(
                        begin()[static_cast<difference_type>(_Off + _Rem - _Count + _Num)]); 
                }
                _Mid     = begin() + static_cast<difference_type>(_Off);
                _Ty _Tmp = _Val; 
                ::std:: move_backward(_Mid, _Mid + static_cast<difference_type>(_Rem - _Count),
                    _Mid + static_cast<difference_type>(_Rem)); 
                ::std:: fill(_Mid, _Mid + static_cast<difference_type>(_Count), _Tmp); 
            }
            } catch (...) {
            _Erase_last_n(_Mysize() - _Oldsize);
            throw;
            }
        }
    }
    [[noreturn]] void _Xlen() const { 
        _Xlength_error("deque<T> too long");
    }
    [[noreturn]] void _Xran() const { 
        _Xout_of_range("invalid deque<T> subscript");
    }
    void _Growmap(size_type _Count) { 
        static_assert(1 < 8, "The _Xlen() test should always be performed.");
        _Alpty _Almap(_Getal());
        size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;
        while (
            _Newsize - _Mapsize() < _Count || _Newsize < 8) { 
            if (max_size() / (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1) - _Newsize < _Newsize) {
                _Xlen(); 
            }
            _Newsize *= 2;
        }
        _Count = _Newsize - _Mapsize();
        size_type _Myboff = _Myoff() / (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1);
        _Mapptr _Newmap   = _Almap.allocate(_Mapsize() + _Count);
        _Mapptr _Myptr    = _Newmap + _Myboff;
        _Myptr = _Uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr, _Almap); 
        if (_Myboff <= _Count) { 
            _Myptr = _Uninitialized_copy(_Map(), _Map() + _Myboff, _Myptr, _Almap); 
            _Uninitialized_value_construct_n(_Myptr, _Count - _Myboff,
                _Almap); 
            _Uninitialized_value_construct_n(_Newmap, _Myboff,
                _Almap); 
        } else { 
            _Uninitialized_copy(_Map(), _Map() + _Count, _Myptr, _Almap); 
            _Myptr = _Uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap, _Almap); 
            _Uninitialized_value_construct_n(_Myptr, _Count,
                _Almap); 
        }
        _Destroy_range(_Map() + _Myboff, _Map() + _Mapsize(), _Almap);
        if (_Map() != _Mapptr()) {
            _Almap.deallocate(_Map(), _Mapsize()); 
        }
        _Map() = _Newmap; 
        _Mapsize() += _Count;
    }
    void _Tidy() noexcept { 
        _Alpty _Almap(_Getal());
        while (!empty()) {
            pop_back();
        }
        for (size_type _Block = _Mapsize(); 0 < _Block;) { 
            if (_Map()[--_Block] != pointer()) { 
                _Getal().deallocate(_Map()[_Block], (sizeof(value_type) <= 1 ? 16 : sizeof(value_type) <= 2 ? 8 : sizeof(value_type) <= 4 ? 4 : sizeof(value_type) <= 8 ? 2 : 1));
                _Alpty_traits::destroy(_Almap, ::std:: addressof(_Map()[_Block]));
            }
        }
        if (_Map() != _Mapptr()) {
            _Almap.deallocate(_Map(), _Mapsize()); 
        }
        _Mapsize() = 0;
        _Map()     = _Mapptr();
    }
    void _Orphan_off(size_type _Offlo) const { 
        size_type _Offhigh = _Myoff() + _Mysize() <= _Offlo + 1 ? (size_type)(-1) : _Offlo;
        if (_Offlo == _Myoff()) {
            _Offlo = 0;
        }
        _Lockit _Lock(3);
        const_iterator** _Pnext = (const_iterator**) _Getpfirst();
        if (_Pnext != nullptr) {
            while (*_Pnext != nullptr) {
                if ((*_Pnext)->_Myoff < _Offlo || _Offhigh < (*_Pnext)->_Myoff) {
                    _Pnext = (const_iterator**) (*_Pnext)->_Getpnext();
                } else { 
                    (*_Pnext)->_Clrcont();
                    *_Pnext = *(const_iterator**) (*_Pnext)->_Getpnext();
                }
            }
        }
    }
#line 1523 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
    size_type _Getblock(size_type _Off) const { 
        return _Get_data()._Getblock(_Off);
    }
    _Iterator_base12** _Getpfirst() const { 
        return _Get_data()._Getpfirst();
    }
    void _Orphan_all() { 
        _Get_data()._Orphan_all();
    }
    _Alty& _Getal() noexcept { 
        return _Mypair._Get_first();
    }
    const _Alty& _Getal() const noexcept { 
        return _Mypair._Get_first();
    }
    _Scary_val& _Get_data() noexcept { 
        return _Mypair._Get_second();
    }
    const _Scary_val& _Get_data() const noexcept { 
        return _Mypair._Get_second();
    }
    _Mapptr& _Map() noexcept { 
        return _Get_data()._Map;
    }
    const _Mapptr& _Map() const noexcept { 
        return _Get_data()._Map;
    }
    size_type& _Mapsize() noexcept { 
        return _Get_data()._Mapsize;
    }
    const size_type& _Mapsize() const noexcept { 
        return _Get_data()._Mapsize;
    }
    size_type& _Myoff() noexcept { 
        return _Get_data()._Myoff;
    }
    const size_type& _Myoff() const noexcept { 
        return _Get_data()._Myoff;
    }
    size_type& _Mysize() noexcept { 
        return _Get_data()._Mysize;
    }
    const size_type& _Mysize() const noexcept { 
        return _Get_data()._Mysize;
    }
    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};
template <class _Iter, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
deque(_Iter, _Iter, _Alloc = _Alloc())->deque<_Iter_value_t<_Iter>, _Alloc>;
#line 1592 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
template <class _Ty, class _Alloc>
inline void swap(deque<_Ty, _Alloc>& _Left, deque<_Ty, _Alloc>& _Right) noexcept { 
    _Left.swap(_Right);
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator==(
    const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) { 
    return _Left.size() == _Right.size()
           && ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin());
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator!=(
    const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) { 
    return !(_Left == _Right);
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<(
    const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) { 
    return ::std:: lexicographical_compare(
        _Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin(), _Right._Unchecked_end());
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<=(
    const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) { 
    return !(_Right < _Left);
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>(
    const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) { 
    return _Right < _Left;
}
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>=(
    const deque<_Ty, _Alloc>& _Left, const deque<_Ty, _Alloc>& _Right) { 
    return !(_Left < _Right);
}
namespace pmr {
    template <class _Ty>
    using deque = ::std:: deque<_Ty, polymorphic_allocator<_Ty>>;
} 
#line 1643 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
}
#pragma warning(pop)
#pragma pack(pop)
#line 1650 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
#line 1651 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\deque"
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stack"
#pragma pack(push, 8)
#pragma warning(push, 4)
#pragma warning(disable : 4455 4494 4583 4619 4643 4702 4793 4988   )
namespace std {
template <class _Ty,
    class _Container = deque<_Ty>>
class stack { 
public:
    using container_type  = _Container;
    using value_type      = typename _Container::value_type;
    using size_type       = typename _Container::size_type;
    using reference       = typename _Container::reference;
    using const_reference = typename _Container::const_reference;
    static_assert(is_same_v<_Ty, value_type>, "container adaptors require consistent types");
    stack() noexcept(is_nothrow_default_constructible_v<_Container>) 
        : c() { 
    }
    explicit stack(const _Container& _Cont) : c(_Cont) { 
    }
    template <class _Alloc, class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
    explicit stack(const _Alloc& _Al)
        noexcept(is_nothrow_constructible_v<_Container, const _Alloc&>) 
        : c(_Al) { 
    }
    template <class _Alloc, class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
    stack(const stack& _Right, const _Alloc& _Al) : c(_Right.c, _Al) { 
    }
    template <class _Alloc, class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
    stack(const _Container& _Cont, const _Alloc& _Al) : c(_Cont, _Al) { 
    }
    explicit stack(_Container&& _Cont) noexcept(is_nothrow_move_constructible_v<_Container>) 
        : c(::std:: move(_Cont)) { 
    }
    template <class _Alloc, class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
    stack(stack&& _Right, const _Alloc& _Al)
        noexcept(is_nothrow_constructible_v<_Container, _Container, const _Alloc&>) 
        : c(::std:: move(_Right.c), _Al) { 
    }
    template <class _Alloc, class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
    stack(_Container&& _Cont, const _Alloc& _Al)
        noexcept(is_nothrow_constructible_v<_Container, _Container, const _Alloc&>) 
        : c(::std:: move(_Cont), _Al) { 
    }
    void push(value_type&& _Val) { 
        c.push_back(::std:: move(_Val));
    }
    template <class... _Valty>
    decltype(auto) emplace(_Valty&&... _Val) { 
        return c.emplace_back(::std:: forward<_Valty>(_Val)...);
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stack"
    }
    [[nodiscard]] bool empty() const { 
        return c.empty();
    }
    [[nodiscard]] size_type size() const { 
        return c.size();
    }
    [[nodiscard]] reference top() { 
        return c.back();
    }
    [[nodiscard]] const_reference top() const { 
        return c.back();
    }
    void push(const value_type& _Val) { 
        c.push_back(_Val);
    }
    void pop() { 
        c.pop_back();
    }
    const _Container& _Get_container() const { 
        return c;
    }
    void swap(stack& _Right) noexcept(_Is_nothrow_swappable<_Container>::value) { 
        _Swap_adl(c, _Right.c);
    }
protected:
    _Container c; 
};
template <class _Container, enable_if_t<!_Is_allocator<_Container>::value, int> = 0>
stack(_Container)->stack<typename _Container::value_type, _Container>;
template <class _Container, class _Alloc,
    enable_if_t<
        conjunction_v<negation<_Is_allocator<_Container>>, _Is_allocator<_Alloc>, uses_allocator<_Container, _Alloc>>,
        int> = 0>
stack(_Container, _Alloc)->stack<typename _Container::value_type, _Container>;
#line 124 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stack"
template <class _Ty, class _Container, class = enable_if_t<_Is_swappable<_Container>::value>>
inline void swap(stack<_Ty, _Container>& _Left, stack<_Ty, _Container>& _Right)
    noexcept(noexcept(_Left.swap(_Right))) { 
    _Left.swap(_Right);
}
template <class _Ty, class _Container>
[[nodiscard]] inline bool operator==(
    const stack<_Ty, _Container>& _Left, const stack<_Ty, _Container>& _Right) { 
    return _Left._Get_container() == _Right._Get_container();
}
template <class _Ty, class _Container>
[[nodiscard]] inline bool operator!=(
    const stack<_Ty, _Container>& _Left, const stack<_Ty, _Container>& _Right) { 
    return !(_Left == _Right);
}
template <class _Ty, class _Container>
[[nodiscard]] inline bool operator<(
    const stack<_Ty, _Container>& _Left, const stack<_Ty, _Container>& _Right) { 
    return _Left._Get_container() < _Right._Get_container();
}
template <class _Ty, class _Container>
[[nodiscard]] inline bool operator>(
    const stack<_Ty, _Container>& _Left, const stack<_Ty, _Container>& _Right) { 
    return _Right < _Left;
}
template <class _Ty, class _Container>
[[nodiscard]] inline bool operator<=(
    const stack<_Ty, _Container>& _Left, const stack<_Ty, _Container>& _Right) { 
    return !(_Right < _Left);
}
template <class _Ty, class _Container>
[[nodiscard]] inline bool operator>=(
    const stack<_Ty, _Container>& _Left, const stack<_Ty, _Container>& _Right) { 
    return !(_Left < _Right);
}
}
namespace std {
    template <class _Ty, class _Container, class _Alloc>
    struct uses_allocator<stack<_Ty, _Container>, _Alloc>
        : uses_allocator<_Container, _Alloc>::type { 
    };
} 
#pragma warning(pop)
#pragma pack(pop)
#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stack"
#line 181 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.20.27508\\include\\stack"
#line 6 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingPropertyReader.h"
namespace CubeWorld
{
class BindingPropertyReader
{
public:
   BindingPropertyReader();
   const BindingProperty Read(const std::string& buffer);
   const BindingProperty GetResult() const { return data; }
public:
   typedef char Ch;
   typedef rapidjson::SizeType SizeType;
   bool Null();
   bool Bool(bool b);
   bool Int(int i);
   bool Uint(unsigned i);
   bool Int64(int64_t i);
   bool Uint64(uint64_t i);
   bool Double(double d);
   bool RawNumber(const Ch* , SizeType , bool ) { return false; }
   bool String(const Ch* str, SizeType length, bool copy);
   bool StartObject();
   bool Key(const Ch* str, SizeType length, bool copy);
   bool EndObject(SizeType memberCount = 0);
   bool StartArray();
   bool EndArray(SizeType elementCount = 0);
   bool CurrentIsObject();
private:
   BindingProperty data;
   std::vector<BindingProperty*> cursor;
};
}; 
#line 4 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\source\\Library\\RGBBinding\\BindingPropertyReader.cpp"
namespace CubeWorld
{
BindingPropertyReader::BindingPropertyReader()
{
   data.SetNull();
   cursor.clear();
   cursor.push_back(&data);
}
const BindingProperty BindingPropertyReader::Read(const std::string& buffer)
{
   rapidjson::GenericStringStream<rapidjson::UTF8<>> stream(buffer.c_str());
   rapidjson::GenericReader<rapidjson::UTF8<>, rapidjson::UTF8<>> reader;
   reader.Parse(stream, *this);
   return data;
}
bool BindingPropertyReader::Null()
{
   if (cursor.empty()) { return false; }
   BindingProperty* prop = cursor.back();
   if (prop->IsArray())
   {
      prop->PushBack(BindingProperty());
   }
   else
   {
      cursor.back()->SetNull();
      cursor.pop_back();
   }
   return true;
}
bool BindingPropertyReader::Bool(bool b)
{
   if (cursor.empty()) { return false; }
   BindingProperty* prop = cursor.back();
   if (prop->IsArray())
   {
      prop->PushBack(BindingProperty(b));
   }
   else
   {
      cursor.back()->SetBool(b);
      cursor.pop_back();
   }
   return true;
}
bool BindingPropertyReader::Int(int i)
{
   if (cursor.empty()) { return false; }
   BindingProperty* prop = cursor.back();
   if (prop->IsArray())
   {
      prop->PushBack(BindingProperty(i));
   }
   else
   {
      cursor.back()->SetInt(i);
      cursor.pop_back();
   }
   return true;
}
bool BindingPropertyReader::Uint(unsigned i)
{
   if (cursor.empty()) { return false; }
   BindingProperty* prop = cursor.back();
   if (prop->IsArray())
   {
      prop->PushBack(BindingProperty(i));
   }
   else
   {
      cursor.back()->SetUint(i);
      cursor.pop_back();
   }
   return true;
}
bool BindingPropertyReader::Int64(int64_t i)
{
   if (cursor.empty()) { return false; }
   BindingProperty* prop = cursor.back();
   if (prop->IsArray())
   {
      prop->PushBack(BindingProperty(i));
   }
   else
   {
      cursor.back()->SetInt64(i);
      cursor.pop_back();
   }
   return true;
}
bool BindingPropertyReader::Uint64(uint64_t i)
{
   if (cursor.empty()) { return false; }
   BindingProperty* prop = cursor.back();
   if (prop->IsArray())
   {
      prop->PushBack(BindingProperty(i));
   }
   else
   {
      cursor.back()->SetUint64(i);
      cursor.pop_back();
   }
   return true;
}
bool BindingPropertyReader::Double(double d)
{
   if (cursor.empty()) { return false; }
   BindingProperty* prop = cursor.back();
   if (prop->IsArray())
   {
      prop->PushBack(BindingProperty(d));
   }
   else
   {
      cursor.back()->SetDouble(d);
      cursor.pop_back();
   }
   return true;
}
bool BindingPropertyReader::String(const Ch* str, SizeType length, bool )
{
   if (cursor.empty()) { return false; }
   BindingProperty* prop = cursor.back();
   if (prop->IsArray())
   {
      prop->PushBack(BindingProperty({str, length}));
   }
   else
   {
      cursor.back()->SetString({str, length});
      cursor.pop_back();
   }
   return true;
}
bool BindingPropertyReader::StartObject()
{
   if (cursor.empty()) { return false; }
   BindingProperty* prop = cursor.back();
   if (prop->IsArray())
   {
      cursor.push_back(&prop->push_back(BindingProperty(BindingProperty::kObjectType)));
   }
   else
   {
      cursor.back()->SetObject();
   }
   return true;
}
bool BindingPropertyReader::Key(const Ch* str, SizeType length, bool )
{
   if (cursor.empty()) { return false; }
   if (!cursor.back()->IsObject()) { return false; }
   BindingProperty* obj = cursor.back();
   cursor.push_back(&obj->Set({str, length}, BindingProperty{}));
   return true;
}
bool BindingPropertyReader::EndObject(SizeType )
{
   if (cursor.empty()) { return false; }
   if (!cursor.back()->IsObject()) { return false; }
   cursor.pop_back();
   return true;
}
bool BindingPropertyReader::CurrentIsObject()
{
   return cursor.back()->IsObject();
}
bool BindingPropertyReader::StartArray()
{
   if (cursor.empty()) { return false; }
   cursor.back()->SetArray();
   return true;
}
bool BindingPropertyReader::EndArray(SizeType )
{
   if (cursor.empty()) { return false; }
   if (!cursor.back()->IsArray()) { return false; }
   cursor.pop_back();
   return true;
}
}; 
#line 11 "C:\\Users\\Thomas\\Code\\CubeWorldC++\\tmp\\x64-Debug\\RGBBinding\\Unity1.cpp"
