#version 460

layout(local_size_x = 8, local_size_y = 16, local_size_z = 8) in;
layout(std140, binding = 0) buffer inColorsT
{
    vec4 Colors[];
} inColors;

uniform uvec3 uChunkSize;

layout(binding = 1, offset = 0) uniform atomic_uint aVertices;
layout(binding = 1, offset = 4) uniform atomic_uint aIndices;
layout(std140, binding = 2) buffer outPositionsT
{
    vec4 Pos[];
} outPositions;
layout(std140, binding = 3) buffer outColorsT
{
    vec4 Color[];
} outColors;
layout(std140, binding = 4) buffer outNormalsT
{
    vec4 Norm[];
} outNormals;
layout(std140, binding = 5) buffer outIndicesT
{
    ivec4 Index[];
} outIndices;

vec4 getBlock(ivec3 coords)
{
    if (coords.x < 0 || coords.x >= uChunkSize.x ||
        coords.z < 0 || coords.z >= uChunkSize.z ||
        coords.y < 0 || coords.y >= uChunkSize.y) {
        return vec4(0);
    }

    uint offset = (coords.y * uChunkSize.z + coords.z) * uChunkSize.x + coords.x;
    return inColors.Colors[offset];
}

bool occupied(ivec3 coords)
{
    return getBlock(coords).a > 0.5;
}

float occVal(ivec3 coords)
{
    return occupied(coords) ? 0.2 : 0;
}

float occlusion(ivec3 coords, ivec3 normal, vec3 bias, int expand, float weight)
{
    int kExpand = expand;
    float fExpand = float(kExpand);
    float kOcclude = 0.6;
    float minDist = 100.0;

    // Rotate the normal to get the other two normals.
    // di: (0, 1, 0) -> (1, 0, 0)
    // dj: (0, 1, 0) -> (0, 0, 1)
    ivec3 di = normal.yzx;
    ivec3 dj = normal.zxy;

    minDist = 100.0;
    for (int i = -kExpand - 2; i <= kExpand + 2; i++)
    {
        ivec3 ci = di * i;
        for (int j = -kExpand - 2; j <= kExpand + 2; j++)
        {
            ivec3 cj = dj * j;
            if (occupied(coords + normal + ci + cj))
            {
                float dist = length(abs(ci + cj - bias));

                minDist = min(minDist, dist);
            }
        }
    }

    float result = smoothstep(0.0, fExpand * 1.5, minDist);
    result = smoothstep(0.0, 1.0, 1 - result) / (1.0 + 4.0 * pow(1.0 - weight, 3));

    return max(1.0 - result, 0.0);
}

vec4 occlusionVector(
    int expand,
    float weight,
    ivec3 coords,
    ivec3 normal,
    vec3 bias1,
    vec3 bias2,
    vec3 bias3,
    vec3 bias4
)
{
    vec4 occ = vec4(
        occlusion(coords, normal, bias1, expand, weight),
        occlusion(coords, normal, bias2, expand, weight),
        occlusion(coords, normal, bias3, expand, weight),
        occlusion(coords, normal, bias4, expand, weight)
    );

    occ = clamp(occ, 0.0, 1.0);

    return occ;
}

void main()
{
    ivec3 coords = ivec3(gl_GlobalInvocationID.xyz);
    vec3 color = max(vec3(gl_WorkGroupID) / 2.0, vec3(0.1));

    vec4 thisBlock = getBlock(coords);
    if (thisBlock.a < 0.5) {
        return;
    }

    color = thisBlock.rgb;

    ivec3 d = ivec3(1,   0, -1);
    vec3 d2 = vec3(0.5, 0, -0.5);

    float o = 1.0;
    float ow = 0.3;
    float o000 = occupied(coords + ivec3(-1, -1, -1)) ? o : 0;
    float o100 = occupied(coords + ivec3( 0, -1, -1)) ? o : 0;
    float o200 = occupied(coords + ivec3( 1, -1, -1)) ? o : 0;
    float o010 = occupied(coords + ivec3(-1,  0, -1)) ? o : 0;
    float o110 = occupied(coords + ivec3( 0,  0, -1)) ? o : 0;
    float o210 = occupied(coords + ivec3( 1,  0, -1)) ? o : 0;
    float o020 = occupied(coords + ivec3(-1,  1, -1)) ? o : 0;
    float o120 = occupied(coords + ivec3( 0,  1, -1)) ? o : 0;
    float o220 = occupied(coords + ivec3( 1,  1, -1)) ? o : 0;
    float o001 = occupied(coords + ivec3(-1, -1,  0)) ? o : 0;
    float o101 = occupied(coords + ivec3( 0, -1,  0)) ? o : 0;
    float o201 = occupied(coords + ivec3( 1, -1,  0)) ? o : 0;
    float o011 = occupied(coords + ivec3(-1,  0,  0)) ? o : 0;
    //float o111 = occupied(coords + ivec3( 0,  0,  0)) ? o : 0;
    float o211 = occupied(coords + ivec3( 1,  0,  0)) ? o : 0;
    float o021 = occupied(coords + ivec3(-1,  1,  0)) ? o : 0;
    float o121 = occupied(coords + ivec3( 0,  1,  0)) ? o : 0;
    float o221 = occupied(coords + ivec3( 1,  1,  0)) ? o : 0;
    float o002 = occupied(coords + ivec3(-1, -1,  1)) ? o : 0;
    float o102 = occupied(coords + ivec3( 0, -1,  1)) ? o : 0;
    float o202 = occupied(coords + ivec3( 1, -1,  1)) ? o : 0;
    float o012 = occupied(coords + ivec3(-1,  0,  1)) ? o : 0;
    float o112 = occupied(coords + ivec3( 0,  0,  1)) ? o : 0;
    float o212 = occupied(coords + ivec3( 1,  0,  1)) ? o : 0;
    float o022 = occupied(coords + ivec3(-1,  1,  1)) ? o : 0;
    float o122 = occupied(coords + ivec3( 0,  1,  1)) ? o : 0;
    float o222 = occupied(coords + ivec3( 1,  1,  1)) ? o : 0;

    // Top
    if (!occupied(coords + ivec3(0, 1, 0)))
    {
        vec3 base = coords + d2.yxy;
        vec4 n = vec4(0, 1, 0, 0);

        vec4 occ = occlusionVector(
            3,
            0.45,
            coords,
            ivec3(n.xyz),
            d2.zyz,
            d2.zyx,
            d2.xyx,
            d2.xyz
        );

        uint ndx = atomicCounterAdd(aVertices, 5);
        uint indexNdx = atomicCounterAdd(aIndices, 2);

        outIndices.Index[indexNdx]      = ivec4(ndx, ndx + 1, ndx + 2, ndx + 3);
        outIndices.Index[indexNdx + 1]  = ivec4(ndx + 4, ndx + 1, -1, -1);

        outPositions.Pos[ndx  ] = vec4(base, 1);
        outColors.Color [ndx  ] = vec4(color, (occ.x + occ.y + occ.z + occ.w) / 4.0);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.zyz, 1);
        outColors.Color [ndx  ] = vec4(color, occ.x);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.zyx, 1);
        outColors.Color [ndx  ] = vec4(color, occ.y);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.xyx, 1);
        outColors.Color [ndx  ] = vec4(color, occ.z);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.xyz, 1);
        outColors.Color [ndx  ] = vec4(color, occ.w);
        outNormals.Norm [ndx++] = n;
    }

    // Bottom
    if (!occupied(coords + ivec3(0, -1, 0)))
    {
        vec3 base = coords + d2.yzy;
        vec4 n = vec4(0, -1, 0, 1);

        uint ndx = atomicCounterAdd(aVertices, 5);
        uint indexNdx = atomicCounterAdd(aIndices, 2);

        outIndices.Index[indexNdx]      = ivec4(ndx, ndx + 1, ndx + 2, ndx + 3);
        outIndices.Index[indexNdx + 1]  = ivec4(ndx + 4, ndx + 1, -1, -1);

        outPositions.Pos[ndx  ] = vec4(base, 1);
        outColors.Color [ndx  ] = vec4(color, 1);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.xyz, 1);
        outColors.Color [ndx  ] = vec4(color, 1);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.xyx, 1);
        outColors.Color [ndx  ] = vec4(color, 1);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.zyx, 1);
        outColors.Color [ndx  ] = vec4(color, 1);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.zyz, 1);
        outColors.Color [ndx  ] = vec4(color, 1);
        outNormals.Norm [ndx++] = n;
    }

    // Right
    if (!occupied(coords + ivec3(1, 0, 0)))
    {
        vec3 base = coords + d2.xyy;
        vec4 n = vec4(1, 0, 0, 1);
        uint ndx = atomicCounterAdd(aVertices, 5);
        uint indexNdx = atomicCounterAdd(aIndices, 2);

        vec4 occ = occlusionVector(
            1,
            0.01,
            coords,
            ivec3(n.xyz),
            d2.yxz,
            d2.yxx,
            d2.yzx,
            d2.yzz
        );

        outIndices.Index[indexNdx]      = ivec4(ndx, ndx + 1, ndx + 2, ndx + 3);
        outIndices.Index[indexNdx + 1]  = ivec4(ndx + 4, ndx + 1, -1, -1);

        outPositions.Pos[ndx  ] = vec4(base, 1);
        outColors.Color [ndx  ] = vec4(color, (occ.x + occ.y + occ.z + occ.w) / 4.0);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.yxz, 1);
        outColors.Color [ndx  ] = vec4(color, occ.x);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.yxx, 1);
        outColors.Color [ndx  ] = vec4(color, occ.y);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.yzx, 1);
        outColors.Color [ndx  ] = vec4(color, occ.z);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.yzz, 1);
        outColors.Color [ndx  ] = vec4(color, occ.w);
        outNormals.Norm [ndx++] = n;
    }

    // Left
    if (!occupied(coords + ivec3(-1, 0, 0)))
    {
        vec3 base = coords + d2.zyy;
        vec4 n = vec4(-1, 0, 0, 1);
        uint ndx = atomicCounterAdd(aVertices, 5);
        uint indexNdx = atomicCounterAdd(aIndices, 2);

        vec4 occ = occlusionVector(
            2,
            0.01,
            coords,
            ivec3(n.xyz),
            d2.yxz,
            d2.yxx,
            d2.yzx,
            d2.yzz
        );

        outIndices.Index[indexNdx]      = ivec4(ndx, ndx + 1, ndx + 2, ndx + 3);
        outIndices.Index[indexNdx + 1]  = ivec4(ndx + 4, ndx + 1, -1, -1);

        outPositions.Pos[ndx  ] = vec4(base, 1);
        outColors.Color [ndx  ] = vec4(color, (occ.x + occ.y + occ.z + occ.w) / 4.0);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.yxz, 1);
        outColors.Color [ndx  ] = vec4(color, occ.x);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.yzz, 1);
        outColors.Color [ndx  ] = vec4(color, occ.y);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.yzx, 1);
        outColors.Color [ndx  ] = vec4(color, occ.z);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.yxx, 1);
        outColors.Color [ndx  ] = vec4(color, occ.w);
        outNormals.Norm [ndx++] = n;
    }

    // Front
    if (!occupied(coords + ivec3(0, 0, 1)))
    {
        vec3 base = coords + d2.yyx;
        vec4 n = vec4(0, 0, 1, 1);
        uint ndx = atomicCounterAdd(aVertices, 5);
        uint indexNdx = atomicCounterAdd(aIndices, 2);

        vec4 occ = occlusionVector(
            2,
            0.01,
            coords,
            ivec3(n.xyz),
            d2.zxy,
            d2.zzy,
            d2.xzy,
            d2.xxy
        );

        outIndices.Index[indexNdx]      = ivec4(ndx, ndx + 1, ndx + 2, ndx + 3);
        outIndices.Index[indexNdx + 1]  = ivec4(ndx + 4, ndx + 1, -1, -1);

        outPositions.Pos[ndx  ] = vec4(base, 1);
        outColors.Color [ndx  ] = vec4(color, (occ.x + occ.y + occ.z + occ.w) / 4.0);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.zxy, 1);
        outColors.Color [ndx  ] = vec4(color, occ.x);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.zzy, 1);
        outColors.Color [ndx  ] = vec4(color, occ.y);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.xzy, 1);
        outColors.Color [ndx  ] = vec4(color, occ.z);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.xxy, 1);
        outColors.Color [ndx  ] = vec4(color, occ.w);
        outNormals.Norm [ndx++] = n;
    }

    // Back
    if (!occupied(coords + ivec3(0, 0, -1)))
    {
        vec3 base = coords + d2.yyz;
        vec4 n = vec4(0, 0, -1, 1);
        uint ndx = atomicCounterAdd(aVertices, 5);
        uint indexNdx = atomicCounterAdd(aIndices, 2);

        vec4 occ = occlusionVector(
            2,
            0.01,
            coords,
            ivec3(n.xyz),
            d2.zxy,
            d2.xxy,
            d2.xzy,
            d2.zzy
        );

        outIndices.Index[indexNdx]      = ivec4(ndx, ndx + 1, ndx + 2, ndx + 3);
        outIndices.Index[indexNdx + 1]  = ivec4(ndx + 4, ndx + 1, -1, -1);

        outPositions.Pos[ndx  ] = vec4(base, 1);
        outColors.Color [ndx  ] = vec4(color, (occ.x + occ.y + occ.z + occ.w) / 4.0);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.zxy, 1);
        outColors.Color [ndx  ] = vec4(color, occ.x);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.xxy, 1);
        outColors.Color [ndx  ] = vec4(color, occ.y);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.xzy, 1);
        outColors.Color [ndx  ] = vec4(color, occ.z);
        outNormals.Norm [ndx++] = n;

        outPositions.Pos[ndx  ] = vec4(base + d2.zzy, 1);
        outColors.Color [ndx  ] = vec4(color, occ.w);
        outNormals.Norm [ndx++] = n;
    }
}
